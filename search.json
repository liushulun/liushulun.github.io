[{"title":"Billboard","url":"/post/billboard/","content":"<ul style=\"text-align:center; display:flex; padding:0px; margin:0px; font-size:1.5em;\">\n    <li style=\"display:inline-block; flex:1; list-style:none;\"><a href=\"/about/\" style=\"margin:5px 15px; font-weight:bold; border-bottom:none!important;\">Welcome</a></li>\n</ul>\n"},{"title":"Hexo-初始化静态网站","url":"/post/hexodiy/hexodiy-init/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Hexo-初始化静态网站\"><a href=\"#Hexo-初始化静态网站\" class=\"headerlink\" title=\"Hexo-初始化静态网站\"></a>Hexo-初始化静态网站</h1><h2 id=\"1-建立静态网站仓库\"><a href=\"#1-建立静态网站仓库\" class=\"headerlink\" title=\"1. 建立静态网站仓库\"></a>1. 建立静态网站仓库</h2><p>首先在 GitHub 上用账号名新建一个仓库，名称为 <code>[username].github.io</code>，要注意是用户名而不是昵称。创建好了之后就已经可以通过 <code>[username].github.io</code> 访问。需要注意的是，这个仓库仅用来存储最终部署后的文件，而非平时写的文章。</p>\n<blockquote>\n<p>假设在 <code>本地仓库</code> 存储博客配置和文章，Hexo 在部署时会生成 HTML 静态网页并 Push 到 <code>Page 仓库</code>，开启了 Page 服务的仓库会在每次收到 Push 后自动把 HTML 部署并发布成公网网页。</p>\n</blockquote>\n<p>实际上 GitHub 限制的是每个账号只能拥有一个 <strong>账号 Page</strong>（<code>[username].github.io</code>），但一个账号可以拥有多个 <strong>项目 Page</strong>，不过开启项目 Page 的前提是必须先开启账号 Page。</p>\n<hr>\n<h2 id=\"2-远程连接\"><a href=\"#2-远程连接\" class=\"headerlink\" title=\"2. 远程连接\"></a>2. 远程连接</h2><h3 id=\"2-1-SSH鉴权\"><a href=\"#2-1-SSH鉴权\" class=\"headerlink\" title=\"2.1 SSH鉴权\"></a>2.1 SSH鉴权</h3><p>自 2021/07/31 开始，GitHub 将逐步弃用 HTTP + 密码鉴权，全面转向 SSH / GPG 鉴权。</p>\n<ul>\n<li>GPG 面向密钥持有者，需要自行维护一个仅可下发一次的随机、无规则的密钥，为了避免被盗用通常存放在设备的环境变量中，比较适合构建机、跳板机等。</li>\n<li>SSH 则面向信任设备，只要在设备生成本地 SSH，并将公钥绑定在目标平台，即可在通信时自动鉴权。</li>\n</ul>\n<p>SSH 和 GPG 各有优劣，以 SSH 为例。</p>\n<ul>\n<li>查看本地是否存在目录 <code>~/.ssh</code>，若存在则可跳过该步骤。<ul>\n<li>执行命令生成密钥：<code>ssh-keygen -t rsa -C &quot;[comments]&quot;</code>，其中 <code>[comments]</code> 只是一段注释说明，通常会用邮箱。</li>\n<li>回车执行后根据提示输入 SSH 密钥的密码，可以不加密。</li>\n<li>根据提示选择保存密钥的路径和文件名，默认为 <code>id_rsa</code>，如果需要生成多个，可以指定不同文件名。</li>\n<li>目录下将生成对应的私钥 <code>[keyname]</code> 和公钥 <code>[keyname].pub</code>。</li>\n</ul>\n</li>\n<li>在 <code>GitHub -&gt; Settings -&gt; SSH and GPG keys</code> 中点击 <code>New SSH key</code> 新建一个部署密钥，把公钥的内容复制到 Key栏并保存，Title 可随意输入。</li>\n<li>本地终端验证密钥，执行命令：<code>ssh -T git@github.com</code>，若显示 <code>Hi XXX! You&#39;ve successfully authenticated...</code> 则连接成功。</li>\n</ul>\n<p>在 Hexo 站点配置文件中指定 Push 仓库使用 SSH 鉴权方式：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"comment\">## HTTP 鉴权已弃用</span></span><br><span class=\"line\">    <span class=\"comment\"># repository: https://github.com/[username]/[username].github.io.git</span></span><br><span class=\"line\">    <span class=\"comment\">## SSH 鉴权</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">git@github.com:[username]/[username].github.io.git</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">main</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-SSH访问服务器\"><a href=\"#2-2-SSH访问服务器\" class=\"headerlink\" title=\"2.2 SSH访问服务器\"></a>2.2 SSH访问服务器</h3><p>SSH 访问的基本命令：<code>ssh [username]@[hostname]</code>。通常 Linux 都会包含一个 root 用户，但是主流云服务平台基本都禁用了远程以 root 身份登录，如果云服务平台没有默认创建一个非 root 用户，就需要先在云服务控制台自带的终端上登录服务器并新增一个非 root 用户，之后才能通过本地或其他工具远程登录。</p>\n<blockquote>\n<p>常见的远程连接工具：</p>\n<p>（1）Mac 下有：</p>\n<ul>\n<li>原生 Terminal.app</li>\n<li><a href=\"https://www.ssh.com/ssh/cyberduck\" title=\"@LINK\">CyberDuck</a></li>\n<li><a href=\"http://www.openssh.com/portable.html\" title=\"@LINK\">OpenSSH</a></li>\n</ul>\n<p>（2）Win 下有：</p>\n<ul>\n<li>原生 CMD 或 PowerShell</li>\n<li><a href=\"https://www.netsarang.com/zh/xshell/\" title=\"@LINK\">XShell</a></li>\n<li><a href=\"https://www.ssh.com/ssh/winscp/\" title=\"@LINK\">WinSCP</a></li>\n</ul>\n<p>（3）跨平台的有：</p>\n<ul>\n<li><a href=\"https://www.vandyke.com/products/securecrt/\" title=\"@LINK\">SecureCRT</a></li>\n<li><a href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/\" title=\"@LINK\">PuTTY</a></li>\n<li><a href=\"https://www.ssh.com/products/tectia-ssh/\" title=\"@LINK\">Tectia</a></li>\n</ul>\n</blockquote>\n<p>当通过远程连接至服务器时，如果要在本地与服务器之间传输文件，可以使用 <code>scp</code> 命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 本地文件复制到服务器：</span></span><br><span class=\"line\">scp [本地文件路径] [服务器登录用户名]@[服务器地址]:[服务器文件存储路径]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例如将本地用户目录下的 test.txt 复制到服务器 root 用户目录下并重命名为 db.txt：</span></span><br><span class=\"line\">scp /Users/user/test.txt root@127.0.0.1:/root/db.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 若需要复制的是文件夹，则将命令 scp 改为 scp -r：</span></span><br><span class=\"line\">scp -r /Users/user/test root@127.0.0.1:/root/db</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 服务器复制到本地：</span></span><br><span class=\"line\">scp [服务器登录用户名]@[服务器地址]:[服务器文件存储路径] [本地文件路径]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 例如将服务器 root 用户目录下的 db.txt复制到本地用户目录下并重命名为 test.txt ：</span></span><br><span class=\"line\">scp root@127.0.0.1:/root/db.txt /Users/user/test.txt</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 若需要复制的是文件夹，则将命令 scp 改为 scp -r：</span></span><br><span class=\"line\">scp -r root@127.0.0.1:/root/db /Users/user/test</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-安装必要环境\"><a href=\"#3-安装必要环境\" class=\"headerlink\" title=\"3. 安装必要环境\"></a>3. 安装必要环境</h2><p>通常，基于 Hexo 驱动的静态博客，只需要这三个环境就够了：<code>Git</code>、<code>Hexo</code>、<code>Node.JS</code>，其中 Node.JS 主要是使用其内含的包管理器 <code>npm</code>。</p>\n<blockquote>\n<p>npm 国内速度太慢有 3 个解决方案（可先通过 <code>npm config list</code> 查看是否已有相关设置）：</p>\n<ul>\n<li>安装 <code>cnpm</code>，后续命令都替换为 <code>cnpm</code>；</li>\n<li>设置 npm 代理（例如：<code>npm config set proxy=&quot;http://127.0.0.1:8080&quot;</code>）；</li>\n<li>设置国内镜像源（例如淘宝源：<code>npm config set registry https://registry.npm.taobao.org</code>），可通过 <code>npm config get registry</code> 查询所有源地址；</li>\n</ul>\n</blockquote>\n<ol>\n<li><p>Git 下载地址：<a href=\"https://git-scm.com/downloads\" title=\"@LINK\">Git 下载</a></p>\n</li>\n<li><p>Node.JS下载地址：<a href=\"https://nodejs.org/en/download/\" title=\"@LINK\">Node.JS 下载</a></p>\n</li>\n<li><p>终端安装 Hexo 命令（在安装完 Node.JS 之后）：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p> 如果安装结果出现红字报错无权限的情况，可以尝试以下两个命令其中一个：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 尝试1：</span></span><br><span class=\"line\">sudo npm install -g hexo-cli</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 尝试2：</span></span><br><span class=\"line\">sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>检查环境安装情况：</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Git 环境检查：</span></span><br><span class=\"line\">git --version</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Node.JS 环境检查：</span></span><br><span class=\"line\">node -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Hexo 环境检查：</span></span><br><span class=\"line\">hexo --Version</span><br></pre></td></tr></table></figure>\n\n<p> 如果均能输出对应版本号即表示环境配置成功。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-初始化本地静态博客页\"><a href=\"#4-初始化本地静态博客页\" class=\"headerlink\" title=\"4. 初始化本地静态博客页\"></a>4. 初始化本地静态博客页</h2><p>Hexo 环境安装完以后，就可以在本地建立管理目录了。在终端进入想要作为博客维护目录的路径，并执行以下命令初始化：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n\n<p>执行完之后，目录下应该会出现几个文件及文件夹：</p>\n<ul>\n<li>node_modules: 模块目录，包含了博客基础和自定义功能所需的组件。</li>\n<li>public: 生成的最终部署到网页上所需的 HTML 文件。</li>\n<li>scaffolds: 网站页面模板，用于在新建不同类型文件时，自动应用模板。</li>\n<li>source: 网站内所有页面读取的根目录，包括文章、分类、标签、资源等等。</li>\n<li>themes: 网站的主题，目录内可以包括各种不同的主题，并且可以在网站配置文件内随时更换。</li>\n</ul>\n<p>Hexo 目录初始化完毕后，通过命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<p>可以一键式安装所有必须的组件，为了能通过 Hexo 部署到 GitHub 上去，还要再额外安装 Git Deploy 组件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>另附几个常用组件（可能已预装，可以通过 <code>npm list</code> 先查看已安装列表）：</p>\n<ul>\n<li>SiteMap 生成器：<code>npm install hexo-generator-sitemap --save</code></li>\n<li>本地搜索：<code>npm install hexo-generator-searchdb --save</code></li>\n<li>字数及阅读时间统计：<code>npm install hexo-word-counter --save</code></li>\n</ul>\n<hr>\n<h2 id=\"5-常用Hexo命令\"><a href=\"#5-常用Hexo命令\" class=\"headerlink\" title=\"5. 常用Hexo命令\"></a>5. 常用Hexo命令</h2><p>常用的 Hexo 命令大致有如下数条：</p>\n<ul>\n<li><code>hexo init [folder]</code>: 初始化本地项目，可指定路径 folder，或默认为当前目录。</li>\n<li><code>hexo generate</code> / <code>hexo g</code>: 生成本地静态文件。</li>\n<li><code>hexo server</code> / <code>hexo s</code>: 启动本地服务器，启动后可在 <code>localhost:4000</code> 查看页面效果（如果 4000 端口被占用，可以通过修改 Hexo 的 Server 端口更换）。</li>\n<li><code>hexo deploy</code> / <code>hexo d</code>: 部署到 Github（或其他代码托管网站），由根目录下的 <code>_config.yml</code> 文件设定。</li>\n<li><code>hexo clean</code>: 清理缓存文件。</li>\n<li><code>hexo new [layout] &lt;title&gt;</code>: 新建文件（夹），可指定文件类型 layout，或默认由 <code>_config.yml</code> 中的 default_layout 决定。必填项 title 用于指定文章标题，若参数值中含有空格，需使用英文双引号包括。</li>\n<li><code>hexo --safe</code>: 安全模式，禁用加载插件和脚本，可在安装新插件遇到问题时启用。</li>\n<li><code>hexo --debug</code>: 调试模式，用于将消息详细记录到终端和 debug.log 文件。</li>\n<li><code>hexo --silent</code>: 静默模式，用于静默输出到终端。</li>\n<li><code>hexo g -d</code> / <code>hexo d -g</code>: 表示自动按顺序执行 <code>hexo g</code> 和 <code>hexo d</code>。</li>\n</ul>\n<hr>\n<h2 id=\"6-部署博客基本功能\"><a href=\"#6-部署博客基本功能\" class=\"headerlink\" title=\"6. 部署博客基本功能\"></a>6. 部署博客基本功能</h2><p>到上一步为止，博客是已经建立完基础功能了，但此时本地博客和 GitHub 上的静态托管还没有建立联系，想要在本地维护的博客能同步到 GitHub 仓库上，使得外网能通过 <code>xxx.github.io</code> 网页形式访问，还需要配置一下站点配置文件 <code>_config.yml</code>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repository:</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n\n<p>在其中的 <code>repository</code> 后面填写自己的 <code>Page 仓库</code> 地址，修改完保存并三连部署，即可部署到 <code>Page 仓库</code> 上并通过公网访问。</p>\n<p>另外还可以预先安装站点地图和百度站点地图生成插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save hexo-generator-sitemap</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install --save hexo-generator-baidu-sitemap</span><br></pre></td></tr></table></figure>\n\n<p>并在站点配置文件中进行如下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成sitemap</span></span><br><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">sitemap.xml</span></span><br><span class=\"line\"><span class=\"attr\">baidusitemap:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>\n\n<p>这样在部署后就会自动在网站根目录下生成对应的文件，可通过 <code>网站地址/sitemap.xml</code> 或 <code>网站地址/baidusitemap.xml</code> 访问。</p>\n<hr>\n<h2 id=\"7-修改文章URL格式\"><a href=\"#7-修改文章URL格式\" class=\"headerlink\" title=\"7. 修改文章URL格式\"></a>7. 修改文章URL格式</h2><p>默认情况下，文章的 URL 路径通常都是类似于：<code>XXX/2018/07/22/aaa/bbb</code>，不利于维护。Hexo 允许自定义 URL 格式配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># URL</span></span><br><span class=\"line\"><span class=\"comment\">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"># 实际域名，如果有自定义域名则修改为自定义域名</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">XXXXX</span></span><br><span class=\"line\"><span class=\"comment\"># 文章的根目录，相对于 source 目录的地址</span></span><br><span class=\"line\"><span class=\"attr\">root:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"comment\"># 文章的链接格式，&quot;:xxx&quot; 带有冒号表示从文章的 Front-Matter 中获取的值，&quot;xxx&quot; 没有冒号表示硬编的字符串</span></span><br><span class=\"line\"><span class=\"attr\">permalink:</span> <span class=\"string\">:year/:month/:day/:title/</span></span><br><span class=\"line\"><span class=\"attr\">permalink_defaults:</span></span><br></pre></td></tr></table></figure>\n\n<p>假如一篇文章的文件名为 <code>demo.md</code>，文章内的 Front-Matter 为：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">文章标题（文件名为demo.md）</span></span><br><span class=\"line\"><span class=\"attr\">from:</span> <span class=\"string\">test</span></span><br><span class=\"line\"><span class=\"attr\">categories:</span></span><br><span class=\"line\"><span class=\"attr\">tags:</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果设置 <code>permalink: post/:title/</code>，则生成的文章链接为：<code>url/post/demo</code>。</li>\n<li>如果设置 <code>permalink: :from/:title/</code>，则生成的文章链接为：<code>url/test/demo</code>。</li>\n</ul>\n<hr>\n<h2 id=\"8-多语言支持\"><a href=\"#8-多语言支持\" class=\"headerlink\" title=\"8. 多语言支持\"></a>8. 多语言支持</h2><ul>\n<li><a href=\"https://github.com/theme-next/hexo-theme-next/pull/1391\" title=\"@LINK\">Multilingual switch button support</a></li>\n<li><a href=\"https://blog.csdn.net/calvin_zhou/article/details/110957632\" title=\"@LINK\">Hexo站点建设之——国际化(i18n)</a></li>\n<li><a href=\"http://www.doczj.com/doc/2a13994261-4.html\" title=\"@LINK\">Hexo站点建设之——国际化(i18n)</a></li>\n<li><a href=\"https://github.com/Jamling/hexo-generator-i18n\" title=\"@LINK\">hexo-generator-i18n</a></li>\n<li><a href=\"https://github.com/xcatliu/hexo-generator-index-i18n\" title=\"@LINK\">hexo-generator-index-i18n</a></li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://github.com/google/styleguide/blob/gh-pages/docguide/style.md\" title=\"@LINK\">Markdown style guide</a></li>\n<li><a href=\"https://www.docin.com/p-2229638915.html\" title=\"@LINK\">中华人民共和国新闻出版社行业标准《CY/T 154-2017 中文出版物夹用英文的编辑规范》</a></li>\n<li><a href=\"https://github.com/theme-next/hexo-theme-next/pull/1391\" title=\"@LINK\">Multilingual switch button support</a></li>\n<li><a href=\"https://blog.csdn.net/calvin_zhou/article/details/110957632\" title=\"@LINK\">Hexo站点建设之——国际化(i18n)</a></li>\n<li><a href=\"http://www.doczj.com/doc/2a13994261-4.html\" title=\"@LINK\">Hexo站点建设之——国际化(i18n)</a></li>\n<li><a href=\"https://github.com/Jamling/hexo-generator-i18n\" title=\"@LINK\">hexo-generator-i18n</a></li>\n<li><a href=\"https://github.com/xcatliu/hexo-generator-index-i18n\" title=\"@LINK\">hexo-generator-index-i18n</a></li>\n</ul>\n","categories":["HexoDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo-自定义部署","url":"/post/hexodiy/hexodiy-deploy/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Hexo-自定义部署\"><a href=\"#Hexo-自定义部署\" class=\"headerlink\" title=\"Hexo-自定义部署\"></a>Hexo-自定义部署</h1><h2 id=\"1-多Page仓库部署\"><a href=\"#1-多Page仓库部署\" class=\"headerlink\" title=\"1. 多Page仓库部署\"></a>1. 多Page仓库部署</h2><p>在 <a href=\"/post/hexodiy/hexodiy-init/\" title=\"@LINK\">Hexo-初始化静态网站</a> 中提到，GitHub 允许一个账号拥有 1 个 <strong>账号 Page</strong> 和多个 <strong>项目 Page</strong>，因此可以利用多个项目 Page 达到分内容、分域名、冗余部署等。</p>\n<blockquote>\n<p>开启项目 Page 的前提是已经开启了账号 Page，确保可用默认域名 <code>[username].github.io</code> 访问账号 Page。</p>\n</blockquote>\n<h3 id=\"1-1-开启项目Page\"><a href=\"#1-1-开启项目Page\" class=\"headerlink\" title=\"1.1 开启项目Page\"></a>1.1 开启项目Page</h3><p>新建一个 GitHub 仓库用作项目 Page，GitHub 对项目 Page 的仓库名没有限制。</p>\n<p>新建完成后需要初始化仓库以及提交一个初始 Commit，以一个简单的 HTML 源文件为例，在本地创建如下代码并上传到项目 Page 仓库的 <code>main</code> 分支中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>This is Project Page.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在项目 Page 仓库的 <code>Settings - Pages</code> 中的部署源选项 <code>Source</code> 选择 <code>main</code> 分支，则项目 Page 就已经建立好了，默认情况下这个项目 Page 的访问域名为：<code>[username].github.io/DemoPage</code>。</p>\n<h3 id=\"1-2-自定义域名\"><a href=\"#1-2-自定义域名\" class=\"headerlink\" title=\"1.2 自定义域名\"></a>1.2 自定义域名</h3><p>GitHub Page 设置域名的方式是在 Page 仓库根目录下创建一个没有后缀的文件 <code>CNAME</code>，并在文件中写入一行（且只能有一行）需要自定义的域名，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">xxx.com</span><br></pre></td></tr></table></figure>\n\n<p>然后在 DNS 添加一条 CName记录，让 <code>xxx.com</code> 指向 <code>[username].github.io</code> 即可。需要注意的是，<code>CNAME</code> 文件中指定的是纯域名，不携带任何协议网络（例如 <code>http</code>、<code>https</code> 等）。</p>\n<blockquote>\n<p>假设账号 Page 设置了自定义域名 <code>xxx.com</code>、项目 Page 的仓库名为 <code>DemoPage</code>。</p>\n</blockquote>\n<p>默认情况下，项目 Page 的访问路径是作为账号 Page 的子路径访问的，则项目 Page 的访问路径会自动设置为 <code>xxx.com/DemoPage</code>。</p>\n<p>如果想要用自定义域名访问，只需要在 DemoPage 仓库根目录下创建 <code>CNAME</code> 文件，并在其中写入对应的域名。</p>\n<ul>\n<li>作为子域名访问时，写入例如：<code>demo.xxx.com</code></li>\n<li>作为独立的顶级域名访问时，写入例如：<code>yyy.com</code></li>\n</ul>\n<p>然后在对应域名的 DNS 中添加一条 CName 记录，同样指向账号 Page 的默认域名 <code>[username].github.io</code>，GitHub 会自动判断请求的域名是否指向了某个 Page，如果是则自动转发。</p>\n<hr>\n<h2 id=\"2-云服务器部署\"><a href=\"#2-云服务器部署\" class=\"headerlink\" title=\"2. 云服务器部署\"></a>2. 云服务器部署</h2><p>考虑到 GitHub Page 在国内访问不太稳定，受不同运营商、不同地域的影响差别很大，因此也希望能部署到云服务器上。</p>\n<h3 id=\"2-1-搭建云服务器\"><a href=\"#2-1-搭建云服务器\" class=\"headerlink\" title=\"2.1 搭建云服务器\"></a>2.1 搭建云服务器</h3><p>云服务器按照个人需求选择即可。</p>\n<blockquote>\n<p>以腾讯云轻量应用服务器 + Ubuntu Server 18 LTS 为例。</p>\n</blockquote>\n<h4 id=\"2-1-1-准备部署环境\"><a href=\"#2-1-1-准备部署环境\" class=\"headerlink\" title=\"2.1.1 准备部署环境\"></a>2.1.1 准备部署环境</h4><ul>\n<li>确保服务器已经可用，且具有公网 IP，允许公网访问。</li>\n<li>确保本地已有可用 SSH 密钥。</li>\n<li>服务器绑定 SSH 公钥，用于远端部署。</li>\n</ul>\n<h4 id=\"2-1-2-配置Ubuntu默认账号\"><a href=\"#2-1-2-配置Ubuntu默认账号\" class=\"headerlink\" title=\"2.1.2 配置Ubuntu默认账号\"></a>2.1.2 配置Ubuntu默认账号</h4><p>腾讯云轻量应用服务器的默认账号为 <code>ubuntu</code>，如果创建服务器实例时已经设置了该账号的密码则可以跳过。否则需要通过「重置密码」设置，注意设置时选择用户名 <code>系统默认 ubuntu</code>。</p>\n<h4 id=\"2-1-3-登录服务器\"><a href=\"#2-1-3-登录服务器\" class=\"headerlink\" title=\"2.1.3 登录服务器\"></a>2.1.3 登录服务器</h4><p>腾讯云轻量应用服务器在选择 Ubuntu 镜像时，默认会创建一个用户 <code>lighthouse</code>，并且腾讯云默认禁用了 root 用户，尽管可以通过配置开启，但远端登录时仍有许多问题。因此建议切换为标准的默认用户 <code>ubuntu</code>，否则后续需要多次调整权限。</p>\n<p>网页端控制台可以在登录后通过 <code>su ubuntu</code> 切换至 <code>ubuntu</code> 账号，远端登录时可以通过 SSH 连接直接指定登录用户：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">// [username] 即为需要登录的用户，前提是该用户已创建。</span><br><span class=\"line\">// [server ip] 即为服务器的公网 IP，如果没有则需要购买公网 IP。</span><br><span class=\"line\">ssh [username]@[server ip]</span><br></pre></td></tr></table></figure>\n\n<p>（1）如果首次从本地远端登录，可能会提示密钥交换信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">The authenticity of host &#x27;XXX.XXX.XXX.XXX (XXX.XXX.XXX.XXX)&#x27; can&#x27;t be established.</span><br><span class=\"line\">RSA key fingerprint is XXXXXXXXXXXXXXXXXXXXXXXXXXXXX.</span><br><span class=\"line\">Are you sure you want to continue connecting (yes/no/fingerprint)?</span><br></pre></td></tr></table></figure>\n\n<p>输入 <code>yes</code> 继续即可。</p>\n<p>（2）如果曾经连接过，但是服务器重置了或者公网 IP 有变更，则远端登录时可能提示错误：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class=\"line\">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class=\"line\">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class=\"line\">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class=\"line\">It is also possible that a host key has just been changed.</span><br><span class=\"line\">The fingerprint for the RSA key sent by the remote host is</span><br><span class=\"line\">SHA256:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.</span><br><span class=\"line\">Please contact your system administrator.</span><br><span class=\"line\">Add correct host key in ~/.ssh/known_hosts to get rid of this message.</span><br><span class=\"line\">Offending RSA key in ~/.ssh/known_hosts:4</span><br><span class=\"line\">RSA host key for XXX.XXX.XXX.XXX has changed and you have requested strict checking.</span><br><span class=\"line\">Host key verification failed.</span><br></pre></td></tr></table></figure>\n\n<p>根据提示编辑 <code>~/.ssh/known_hosts</code> 文件，删除曾经保存的服务器 IP 对应的 Host 信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 删除公网 IP 对应的这条 Host 记录并保存</span><br><span class=\"line\">XXX.XXX.XXX.XXX ecdsa-sha2-nistp256 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span><br></pre></td></tr></table></figure>\n\n<p>然后再重新登录即可。</p>\n<h3 id=\"2-2-配置云服务器\"><a href=\"#2-2-配置云服务器\" class=\"headerlink\" title=\"2.2 配置云服务器\"></a>2.2 配置云服务器</h3><p>配置云服务器有两种方式：</p>\n<ol>\n<li>使用默认 ubuntu 用户 + <code>sudo</code> 操作，但某些脚本可能需要单独设置 root 权限。</li>\n<li>使用 root 用户配置，但远端使用 SSH 鉴权 Push 时也需要指定为 root 用户，可能会有安全性问题，不推荐。</li>\n</ol>\n<p>结合上述问题，本文以第 2 种方式为例，使用 root 用户配置服务器，但禁用远端登录 root 用户，配置完后再对远端 Push 涉及的目录设置为 ubuntu 用户权限。</p>\n<h4 id=\"2-2-1-开启Root用户\"><a href=\"#2-2-1-开启Root用户\" class=\"headerlink\" title=\"2.2.1 开启Root用户\"></a>2.2.1 开启Root用户</h4><p>腾讯云轻量应用服务器默认禁用了 root 用户，需要先以普通用户（例如 ubuntu）登录后再手动开启：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 1. 设置 root 用户密码，可以与其他用户的相同：</span><br><span class=\"line\"><span class=\"meta\">ubuntu@~$</span><span class=\"bash\"> sudo passwd root</span></span><br><span class=\"line\">// 二次输入密码后提示设置成功：</span><br><span class=\"line\">passwd: password updated successfully</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 编辑配置文件 Authentication 部分，开启 root 密码登录：</span><br><span class=\"line\"><span class=\"meta\">ubuntu@~$</span><span class=\"bash\"> sudo vi /etc/ssh/sshd_config</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 2.1 取消 PermitRootLogin 选项的注释，</span><br><span class=\"line\">// 默认配置 prohibit-password，禁止 Root 用户使用密码登录：</span><br><span class=\"line\">PermitRootLogin prohibit-password</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.2 如果需要允许 Root 用户登录，则修改 PermitRootLogin：</span><br><span class=\"line\">PermitRootLogin yes</span><br><span class=\"line\">// 然后添加一条配置，允许使用密码认证：</span><br><span class=\"line\">PasswordAuthentication yes</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. 保存配置退出编辑模式后，重启 SSH 服务</span><br><span class=\"line\"><span class=\"meta\">ubuntu@~$</span><span class=\"bash\"> sudo service ssh restart</span></span><br></pre></td></tr></table></figure>\n\n<p>断开远端连接重新登录；如果允许直接通过密码远端登录 root 用户，则可以直接通过 <code>ssh root@[server ip]</code> 登录。本文为了安全性保持禁用 root 用户直接密码登录，因此仍需先以 ubuntu 用户登录，然后再切换至 root 用户：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 从本地登录至远端 ubuntu 用户：</span><br><span class=\"line\"><span class=\"meta\">[luis@~]#</span><span class=\"bash\"> ssh ubuntu@XXX.XXX.XXX.XXX</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 登录后切换至 root 用户，输入 root 密码：</span><br><span class=\"line\"><span class=\"meta\">ubuntu@~$</span><span class=\"bash\"> su root</span></span><br><span class=\"line\"></span><br><span class=\"line\">// 切换成功后可以看到已经切换至 root 用户，且命令进入特权模式：</span><br><span class=\"line\"><span class=\"meta\">root@/home/ubuntu#</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-安装环境\"><a href=\"#2-2-2-安装环境\" class=\"headerlink\" title=\"2.2.2 安装环境\"></a>2.2.2 安装环境</h4><p>在云服务器部署静态网站，主要需要用到两个开发环境：</p>\n<ul>\n<li>Nginx: 用于自动把公网请求映射到具体的静态网页资源。</li>\n<li>Git: 用于从本地推送静态网站资源。</li>\n</ul>\n<p>腾讯云轻量应用服务器的 Ubuntu 系统默认自带了 Git 环境，因此只需要安装 Nginx：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 更新 apt：</span><br><span class=\"line\"><span class=\"meta\">root@/home/ubuntu#</span><span class=\"bash\"> apt-get update</span></span><br><span class=\"line\">// 安装 nginx：</span><br><span class=\"line\"><span class=\"meta\">root@/home/ubuntu#</span><span class=\"bash\"> apt-get install git nginx -y</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Nginx 常用命令：</p>\n<ul>\n<li>启动服务：<code>service nginx start</code></li>\n<li>停止服务：<code>service nginx stop</code></li>\n<li>重启服务：<code>service nginx restart</code></li>\n<li>刷新配置：<code>nginx -s reload</code>（需要先启动 Nginx 服务）</li>\n</ul>\n<p>注意：启动服务并不会自动读取最新配置，每次修改 Nginx 配置后都需要刷新配置才能生效。</p>\n</blockquote>\n<h4 id=\"2-2-3-配置网站目录\"><a href=\"#2-2-3-配置网站目录\" class=\"headerlink\" title=\"2.2.3 配置网站目录\"></a>2.2.3 配置网站目录</h4><p>采用 Nginx + Git 托管静态网站需要用到两个目录：</p>\n<ul>\n<li>Nginx 最终代理和转发的网站资源文件目录。</li>\n<li>Git 接收远端 Push 网站资源文件的 Git 仓库目录。通过配置 Git Hook 将收到的文件自动关联到 Ngnix 的资源文件目录。</li>\n</ul>\n<p>（1）创建 Nginx 网站资源目录并授权；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实际目录可自定义：</span></span><br><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo mkdir -p /xxx/WebServer</span></span><br><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo chmod -R 755 /xxx/WebServer</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）创建 Git 接收裸仓库的目录并授权；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意创建的是裸仓库，添加 --bare 参数</span></span><br><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo git init --bare /xxx/Web.git</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 提示创建成功</span></span><br><span class=\"line\">Initialized empty Git repository in /xxx/Web.git/</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo chmod -R 755 /xxx/Web.git</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Git 裸仓库是指该仓库将只保存仓库的提交历史（<code>.git</code> 文件），而不会保存实际文件，但同样支持 Push 和 Pull，通常作为服务器存储仓库。</p>\n</blockquote>\n<p>（3）配置 Nginx 代理和转发目录（注意备份）；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo vim /etc/nginx/sites-available/default</span></span><br></pre></td></tr></table></figure>\n\n<p>修改 server 部分</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        # 监听普通 HTTP 的 80 端口：</span><br><span class=\"line\">        listen 80 default_server;</span><br><span class=\"line\">        listen [::]:80 default_server;</span><br><span class=\"line\"></span><br><span class=\"line\">        # SSL configuration（监听 HTTPS 的 443 端口）：</span><br><span class=\"line\">        listen 443 ssl default_server;</span><br><span class=\"line\">        listen [::]:443 ssl default_server;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 设置代理和转发的目录：</span><br><span class=\"line\">        root /xxx/WebServer;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 指定监听的域名：</span><br><span class=\"line\">        server_name example.com;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后重启 Nginx 服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo service nginx restart</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-4-验证网站访问性\"><a href=\"#2-2-4-验证网站访问性\" class=\"headerlink\" title=\"2.2.4 验证网站访问性\"></a>2.2.4 验证网站访问性</h4><p>（1）在 <code>WebServer</code> 目录下创建一个测试网页：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> vim /xxx/WebServer/index.html</span></span><br></pre></td></tr></table></figure>\n\n<p>随便填充一个元素：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>This is My Web.<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后访问公网 IP，如果可以正常访问说明配置正确；如果网页报 404 错误，则需要查看 Nginx 错误日志。</p>\n<p>（2）Nginx 日志存放目录配置在 Nginx 配置文件中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo vim /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>\n\n<p>找到 http 部分的 Logging 设置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">        access_log /var/log/nginx/access.log;</span><br><span class=\"line\">        error_log /var/log/nginx/error.log;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后查看错误日志：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo vim /var/<span class=\"built_in\">log</span>/nginx/error.log</span></span><br><span class=\"line\"></span><br><span class=\"line\">yyyy/MM/dd hh:mm:ss [crit] 18205#18205: *1 stat() &quot;/xxx/WebServer/&quot; failed (13: Permission denied), client: XXX.XXX.XXX.XXX, server: example.com, request: &quot;GET / HTTP/1.1&quot;, host: &quot;XXX.XXX.XXX.XXX&quot;</span><br></pre></td></tr></table></figure>\n\n<p>错误日志提示发生了 403 权限拒绝问题。</p>\n<p>（3）查看 Nginx 的运行和启动用户：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo ps aux | grep <span class=\"string\">&quot;nginx: worker process&quot;</span> | awk <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">www-data</span><br><span class=\"line\">root</span><br></pre></td></tr></table></figure>\n\n<p>发现 Nginx 启动用户是 root，但运行用户是 www-data，所以出现了用户权限被拒绝的情况。</p>\n<p>（4）将 Nginx 的运行用户也修改为 root 用户：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo vim /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>\n\n<p>将 user 修改为 root 用户：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">user root;</span><br></pre></td></tr></table></figure>\n\n<p>然后重启 Nginx 服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo service nginx restart</span></span><br></pre></td></tr></table></figure>\n\n<p>再次访问云服务器的公网 IP，可以正确访问了。</p>\n<h4 id=\"2-2-5-创建Git-Hook\"><a href=\"#2-2-5-创建Git-Hook\" class=\"headerlink\" title=\"2.2.5 创建Git-Hook\"></a>2.2.5 创建Git-Hook</h4><p>由于 Nginx 只能将网络请求代理和转发到 <code>WebServer</code> 目录下的网站资源文件，而本地的网站资源文件是通过 Git Push 到 <code>Web.git</code> 仓库下的，因此需要创建一个 Git-Hook，自动将 <code>Web.git</code> 下的资源文件关联到 <code>WebServer</code> 目录中：</p>\n<p>（1）创建一个 Hook 文件 <code>post-receive</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> vim /xxx/Web.git/hooks/post-receive</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）在 <code>post-receive</code> 中写入一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git --work-tree=/xxx/WebServer --git-dir=/xxx/Web.git checkout -f</span><br></pre></td></tr></table></figure>\n\n<p>（3）保存退出后，给 <code>post-receive</code> 文件添加执行权限：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> chmod +x /xxx/Web.git/hooks/post-receive</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-本地Push至云服务器\"><a href=\"#2-3-本地Push至云服务器\" class=\"headerlink\" title=\"2.3 本地Push至云服务器\"></a>2.3 本地Push至云服务器</h3><p>经过上述配置，服务器中的 Git 接收和 Nginx 代理转发已经配置好了，即可从本地将 Hexo 生成的静态网站 Push 至服务器。</p>\n<p>（1）在 Hexo 站点配置文件中添加云服务器 Git 部署配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"comment\">## 部署至 GitHub Page 仓库：</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">git@github.com:[username]/[username].github.io.git</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">main</span></span><br><span class=\"line\">  <span class=\"comment\">## 部署至云服务器：</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">ubuntu@[server</span> <span class=\"string\">ip]:/xxx/Web.git</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）本地执行 Hexo 命令部署：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">luis$</span><span class=\"bash\"> hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>\n\n<p>有可能报错 <code>unable to create temporary object directory</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: remote unpack failed: unable to create temporary object directory</span><br><span class=\"line\">error: failed to push some refs to &#x27;ubuntu@43.129.198.91:/xxx/Web.git&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>也有可能报错 <code>Permission denied</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: unable to create file xxx: Permission denied</span><br></pre></td></tr></table></figure>\n\n<p>向云服务器 Push 时报错，如果原因为 <code>unable to create</code>、<code>unable to access</code>、<code>permission denied</code> 等，绝大多数是因为 Git Push 的用户没有目标路径的权限导致的，在本例中，<code>WebServer</code> 或 <code>Web.git</code> 所在目录、以及其内所有子文件都是 root 用户权限，而云服务器为了安全禁用了远端登录 root 用户，所以 Git 在以 ubuntu 用户 Push 时就会导致权限不足。</p>\n<p>（3）将云服务器中 <code>WebServer</code> 和 <code>Web.git</code> 所在目录、以及内部递归所有子文件都改为 ubuntu 用户权限：</p>\n<blockquote>\n<p>需要修改 WebServer、Web.git、以及各自所在的所有父级目录。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 递归修改该目录及其内部所有子文件的权限，</span></span><br><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo chown -R <span class=\"variable\">$USER</span>:<span class=\"variable\">$USER</span> /xxx/xxx</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）再次查看文件权限，确保上述各个目录均可被 ubuntu 用户访问：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> ll</span></span><br><span class=\"line\"></span><br><span class=\"line\">drwxr-xr-x 4 ubuntu ubuntu 4096 Aug  1 hh:mm /xxx/xxx</span><br></pre></td></tr></table></figure>\n\n<p>（5）再次从本地执行 Hexo 命令，即可成功部署。</p>\n<h3 id=\"2-4-GitHub-Page开启HTTPS\"><a href=\"#2-4-GitHub-Page开启HTTPS\" class=\"headerlink\" title=\"2.4 GitHub-Page开启HTTPS\"></a>2.4 GitHub-Page开启HTTPS</h3><p>GitHub Page 只需要确保域名已绑定 SSL 证书，然后在 Page 仓库的 <code>Settings - Pages</code> 中勾选 <code>Enforce HTTPS</code> 即可。</p>\n<h3 id=\"2-5-云服务器开启HTTPS\"><a href=\"#2-5-云服务器开启HTTPS\" class=\"headerlink\" title=\"2.5 云服务器开启HTTPS\"></a>2.5 云服务器开启HTTPS</h3><p>云服务器开启 HTTPS 需要自行申请 SSL 证书：</p>\n<ul>\n<li>使用域名提供商颁发的证书：<ul>\n<li>通常有免费证书（一般有效期最大 90 天），不支持原证书续签，每次都要重新申请后手动替换证书公私钥；</li>\n<li>购买付费证书；</li>\n</ul>\n</li>\n<li>使用 LetsEncrypt 颁发的免费证书（有效期 90 天），可以直接在服务器使用脚本配置：<ul>\n<li>由于地区限制，<code>.cn</code> 顶域只能通过 DNS 的方式验证，因此域名过期后只能重新申请证书并手动更新 DNS 验证，但无需替换公私钥文件（Certbot 会用新证书覆盖）；</li>\n<li>其他国际域名可通过 HTTP + WebRoot 的方式自动验证域名，可以配合 <code>crontab</code> 实现自动续签；</li>\n</ul>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>根域名（顶级域名，如 <code>example.com</code>）和 子域名/泛域名（如 <code>xxx.example.com</code>）需要分别申请各自的证书。</li>\n<li>使用 LetsEncrypt 颁发的证书时，如果服务器在大陆境内则需要先为服务器备案。</li>\n<li>Nginx 配置 SSL 需要证书的公钥和私钥。</li>\n</ul>\n<h4 id=\"2-5-1-从域名提供商获取SSL证书\"><a href=\"#2-5-1-从域名提供商获取SSL证书\" class=\"headerlink\" title=\"2.5.1 从域名提供商获取SSL证书\"></a>2.5.1 从域名提供商获取SSL证书</h4><p>如果使用域名提供商的证书（不论 免费/付费），优先选择标明了 Nginx 场景的证书，或者下载包含 <code>pem 文件</code>、<code>crt 文件</code>、<code>key 文件</code> 的证书：</p>\n<ul>\n<li>公钥：<code>domain.crt</code> 或 <code>domain.pem</code> 文件；</li>\n<li>私钥：<code>domain.key</code> 文件；</li>\n</ul>\n<p>然后将证书从本地上传到远端：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在本地终端执行以下代码：</span></span><br><span class=\"line\">scp ./domain.crt ubuntu@xx.xx.xx.xx:/xxx/domain.crt</span><br><span class=\"line\">scp ./domain.key ubuntu@xx.xx.xx.xx:/xxx/domain.key</span><br></pre></td></tr></table></figure>\n\n<p>注意，这一步命令可能会遇到报错 <code>Permission denied (publickey)</code>，则检查以下配置：</p>\n<ul>\n<li><p>检查目标路径的用户权限，例如服务器当前用户是 ubuntu，但 <code>/DemoDir</code> 这个目录可能是 root 用户权限，解决办法为：</p>\n<ul>\n<li>scp 命令改为指定 root 用户登录服务器，但通常服务器为了安全会禁用 root 用户的远端登录，因此不推荐。</li>\n<li>scp 目标路径临时选择一个 ubuntu 用户有权限的目录，然后登录到服务器后再移动到其他目录，此时可以自由切换 root 用户了。</li>\n</ul>\n</li>\n<li><p>检查服务器用户的 SSH 配置中是否绑定了本地公钥：</p>\n<ul>\n<li>查看服务器的 <code>~/.ssh/authorized_keys</code> 文件，是否包含本地 <code>~/.ssh/id_rsa.pub</code> 公钥内容。</li>\n<li>如果没有，则将本地 <code>id_rsa.pub</code> 公钥内容追加到服务器 <code>authorized_keys</code> 文件后（该文件可以包含多个公钥的内容）。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-5-2-LetsEncrypt证书-DNS校验\"><a href=\"#2-5-2-LetsEncrypt证书-DNS校验\" class=\"headerlink\" title=\"2.5.2 LetsEncrypt证书+DNS校验\"></a>2.5.2 LetsEncrypt证书+DNS校验</h4><p>使用 LetsEncrypt 颁发的证书本质也是在服务器内下载证书，不过 LetsEncrypt 提供了 <code>certbot</code> 脚本，可以在服务器内完成：</p>\n<p>（1）安装 Certbot：</p>\n<blockquote>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Vanilla-chan/p/18900827\">在Ubuntu上使用Let&#39;s Encrypt配置Nginx SSL证书并自动更新</a></li>\n<li><a href=\"https://juejin.cn/post/7522006762511613971\">在Ubuntu上使用Certbot申请Let’s Encrypt SSL证书</a></li>\n<li><a href=\"https://www.cnblogs.com/KLangHu/p/17723048.html\">Ubuntu通过certbot手动配置Let&#39;s Encrypt SSL泛型域名证书</a></li>\n<li><a href=\"https://blog.arisa.moe/blog/2022/220407-certbot/\">certbot 常用操作</a></li>\n</ul>\n<p>Ubuntu 下默认没有 yum 源：</p>\n<ul>\n<li><a href=\"https://blog.51cto.com/u_13968834/13252792\">使用yum提示&quot;There are no enabled repos&quot;</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/2089090\">Ubuntu下安装yum和配置yum源</a></li>\n</ul>\n<p>Apache 服务器可以参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/MonkeyBananas/article/details/149022366\">ubuntu系统申请免费HTTPS证书</a></li>\n</ul>\n<p>其他 OS 可以使用 yum 安装，参考：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/Unstoppable9527/p/18709231\">CertBot自动更新Nginx证书</a></li>\n<li><a href=\"https://www.cnblogs.com/nickchou/p/12679518.html\">centos 7 nginx 配置Let&#39;s Encrypt证书，并自动更新</a></li>\n<li><a href=\"https://www.cnblogs.com/pyt666/p/18110240\">使用CertBot自动更新Nginx的ssl证书</a></li>\n<li><a href=\"https://www.xgss.net/6961.html\">Linux 下 Nginx 安装部署 Let’s Encrypt 证书实现 HTTPS</a></li>\n</ul>\n<p>使用 Docker 可以参考：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/LQ137969328/article/details/148745200\">生成https免费证书并绑定到nginx</a></li>\n</ul>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install certbot</span><br></pre></td></tr></table></figure>\n\n<p>（2）为根域名 <code>example.com</code> 和 泛域名 <code>*.example.com</code> 同时申请证书：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo certbot certonly -d example.com -d *.example.com --manual --preferred-challenges dns</span><br></pre></td></tr></table></figure>\n\n<p>LetsEncrypt 会询问是否接受服务器 IP 被记录，必须接受才能继续申请：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class=\"line\">Plugins selected: Authenticator manual, Installer None</span><br><span class=\"line\">Obtaining a new certificate</span><br><span class=\"line\">Performing the following challenges:</span><br><span class=\"line\">dns-01 challenge for example.com</span><br><span class=\"line\">dns-01 challenge for example.com</span><br><span class=\"line\"></span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class=\"line\">certificate. If you&#x27;re running certbot in manual mode on a machine that is not</span><br><span class=\"line\">your server, please ensure you&#x27;re okay with that.</span><br><span class=\"line\"></span><br><span class=\"line\">Are you OK with your IP being logged?</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">(Y)es/(N)o:</span><br></pre></td></tr></table></figure>\n\n<p>输入 <code>Y</code> 后 LetsEncrypt 会分别为根域名和泛域名生成 DNS 的 TXT 记录用于校验，需要手动将其添加到域名 DNS 解析中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">(Y)es/(N)o: Y</span><br><span class=\"line\"></span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Please deploy a DNS TXT record under the name</span><br><span class=\"line\">_acme-challenge.example.com with the following value:</span><br><span class=\"line\"></span><br><span class=\"line\">******************************************</span><br><span class=\"line\"></span><br><span class=\"line\">Before continuing, verify the record is deployed.</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Press Enter to Continue</span><br><span class=\"line\"></span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Please deploy a DNS TXT record under the name</span><br><span class=\"line\">_acme-challenge.example.com with the following value:</span><br><span class=\"line\"></span><br><span class=\"line\">******************************************</span><br><span class=\"line\"></span><br><span class=\"line\">Before continuing, verify the record is deployed.</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Press Enter to Continue</span><br></pre></td></tr></table></figure>\n\n<p>（3）在下一步之前，确保已经在 DNS 解析中为根域名和泛域名分别添加了一条 TXT 记录</p>\n<p>（4）输入回车继续，LetsEncrypt 会通过 DNS 校验域名的合法性，稍等片刻校验通过后将会自动下载证书到本地：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Waiting for verification...</span><br><span class=\"line\">Cleaning up challenges</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT NOTES:</span><br><span class=\"line\"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class=\"line\">   /etc/letsencrypt/live/example.com/fullchain.pem</span><br><span class=\"line\">   Your key file has been saved at:</span><br><span class=\"line\">   /etc/letsencrypt/live/example.com/privkey.pem</span><br><span class=\"line\">   Your cert will expire on YYYY-MM-DD. To obtain a new or tweaked</span><br><span class=\"line\">   version of this certificate in the future, simply run certbot</span><br><span class=\"line\">   again. To non-interactively renew *all* of your certificates, run</span><br><span class=\"line\">   &quot;certbot renew&quot;</span><br><span class=\"line\"> - If you like Certbot, please consider supporting our work by:</span><br><span class=\"line\"></span><br><span class=\"line\">   Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate</span><br><span class=\"line\">   Donating to EFF:                    https://eff.org/donate-le</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><code>/etc/letsencrypt/live/example.com/fullchain.pem</code> 为公钥</li>\n<li><code>/etc/letsencrypt/live/example.com/privkey.pem</code> 为私钥</li>\n</ul>\n<p>（5）使用 DNS 校验的证书续签时需要重新执行一遍申请流程，但由于证书文件路径不变（新证书将覆盖旧证书），只需要重新使用 Certbot 生成新的校验 Key 并更新到 DNS 即可。</p>\n<blockquote>\n<p>国内域名只能使用 DNS 校验，其他校验方式会报错（参考：<a href=\"https://blog.csdn.net/weixin_34200628/article/details/88118312\">Let&#39;s encrypt的TLS-SNI安全问题</a>）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Client with the currently selected authenticator does not support any combination of challenges that will satisfy the CA. You may need to use an authenticator plugin that can do challenges over DNS.</span><br></pre></td></tr></table></figure>\n\n<p>但 Github 上有不少工具可以通过 DNS 服务商提供的 API 接口实现续签时自动化更新 DNS 记录，例如腾讯云：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_53071854/article/details/147784021\">Certbot+Letsencrypt+腾讯云DNS验证自动续期证书</a></li>\n<li><a href=\"https://gitee.com/hillmans_admin/certbot-wildcard-qcloud-hook\">hellomeet/certbot-wildcard-qcloud-hook</a></li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/3304123301\">使用Certbot获取Let&#39;s Encrypt的SSL证书</a></li>\n<li><a href=\"https://blog.csdn.net/Leon_Jinhai_Sun/article/details/147659466\">Let‘s Encrypt 域名验证的 Nginx 设置</a></li>\n</ul>\n</blockquote>\n<p>查看所有 <code>certbot</code> 申请的证书的有效期：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo certbot certificates</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-3-LetsEncrypt证书-HTTP校验\"><a href=\"#2-5-3-LetsEncrypt证书-HTTP校验\" class=\"headerlink\" title=\"2.5.3 LetsEncrypt证书+HTTP校验\"></a>2.5.3 LetsEncrypt证书+HTTP校验</h4><p>（1）指定验证方式为 http：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo certbot certonly --preferred-challenges http -d example.com</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）三种方式任选一项即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class=\"line\"></span><br><span class=\"line\">How would you like to authenticate with the ACME CA?</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">1: Nginx Web Server plugin - Alpha (nginx)</span><br><span class=\"line\">2: Spin up a temporary webserver (standalone)</span><br><span class=\"line\">3: Place files in webroot directory (webroot)</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Select the appropriate number [1-3] then [enter] (press &#x27;c&#x27; to cancel):</span><br></pre></td></tr></table></figure>\n\n<p>（3）其中，方式 1（nginx）和方式 2（standalone）均为全自动完成，而方式 3（webroot）则需要指定一个目录；在证书续期（renew）时，LetsEncrypt 会在该目录下存放一个临时文件，并告知服务器通过访问域名的一个特定路径来验证是否可以读取到临时文件，因此这种方式还需要配置 Nginx，确保 LetsEncrypt 通过 HTTP 请求验证域名时可以被正确路由到该目录。</p>\n<p>（4）以方式 3（WebRoot）为例，按要求指定 WebRoot 的路径：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Plugins selected: Authenticator webroot, Installer None</span><br><span class=\"line\">Obtaining a new certificate</span><br><span class=\"line\">Performing the following challenges:</span><br><span class=\"line\">http-01 challenge for example.com</span><br><span class=\"line\">Input the webroot for example.com: (Enter &#x27;c&#x27; to cancel): /xxx/webroot</span><br><span class=\"line\">Waiting for verification...</span><br><span class=\"line\">Cleaning up challenges</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT NOTES:</span><br><span class=\"line\"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class=\"line\">   /etc/letsencrypt/live/example.com/fullchain.pem</span><br><span class=\"line\">   Your key file has been saved at:</span><br><span class=\"line\">   /etc/letsencrypt/live/example.com/privkey.pem</span><br><span class=\"line\">   Your cert will expire on 2025-xx-xx. To obtain a new or tweaked</span><br><span class=\"line\">   version of this certificate in the future, simply run certbot</span><br><span class=\"line\">   again. To non-interactively renew *all* of your certificates, run</span><br><span class=\"line\">   &quot;certbot renew&quot;</span><br><span class=\"line\"> - If you like Certbot, please consider supporting our work by:</span><br><span class=\"line\"></span><br><span class=\"line\">   Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate</span><br><span class=\"line\">   Donating to EFF:                    https://eff.org/donate-le</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><code>/etc/letsencrypt/live/example.com/fullchain.pem</code> 为公钥</li>\n<li><code>/etc/letsencrypt/live/example.com/privkey.pem</code> 为私钥</li>\n</ul>\n<p>（5）使用 <code>certbot</code> 手动更新证书</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 更新系统上所有 certbot 申请的证书：</span></span><br><span class=\"line\">sudo certbot renew</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 模拟 certbot 更新证书（但不会实际更新）：</span></span><br><span class=\"line\">sudo certbot renew --dry-run</span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>renew</code> 命令没有报错，就可以使用 <code>crontab</code> 周期性执行 <code>renew</code> 进行自动续签了。</p>\n<p>（6）使用 <code>crontab</code> 定期自动更新证书</p>\n<p>查看已配置的定期任务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo cat /etc/crontab</span><br></pre></td></tr></table></figure>\n\n<p>配置定期任务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo crontab -e</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># 根据提示选择习惯的编辑器：</span></span></span><br><span class=\"line\">Select an editor.  To change later, run &#x27;select-editor&#x27;.</span><br><span class=\"line\">  1. /bin/nano        &lt;---- easiest</span><br><span class=\"line\">  2. /usr/bin/vim.basic</span><br><span class=\"line\">  3. /usr/bin/vim.tiny</span><br><span class=\"line\">  4. /bin/ed</span><br><span class=\"line\"></span><br><span class=\"line\">Choose 1-4 [1]: 2</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># crontab 通过 6 个选项配置定期任务，其中各项的含义如下（使用 * 表示任意满足）：</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># Minute(0~59)  Hour(0~23)  DayOfMonth(1~31)  Month(1~12)  DayOfWeek(0~6)  Command</span></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"><span class=\"comment\"># crontab 的默认配置内容如下，</span></span></span><br><span class=\"line\">*/5 * * * * flock -xn /tmp/stargate.lock -c &#x27;/usr/local/qcloud/stargate/admin/start.sh &gt; /dev/null 2&gt;&amp;1 &amp;&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>在打开的编辑器中修改定期时间，并保存退出（以下配置表示每月 1 日执行 <code>certbot</code> 更新证书）：</p>\n<blockquote>\n<p>可以使用 <code>sudo certbot renew --dry-run</code> 测试证书更新流程是否能正确执行。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 0 1 * * /usr/bin/certbot renew --quiet</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-4-将SSL公私钥配置到Nginx\"><a href=\"#2-5-4-将SSL公私钥配置到Nginx\" class=\"headerlink\" title=\"2.5.4 将SSL公私钥配置到Nginx\"></a>2.5.4 将SSL公私钥配置到Nginx</h4><p>由于云服务器采用 Nginx 转发请求，因此需要将 SSL 证书的公私钥配置到 Nginx 中。</p>\n<blockquote>\n<p>如果使用 root 用户运行 Nginx，则需要切换至 root 用户再配置。</p>\n</blockquote>\n<p>（1）去除（注释掉）Nginx 默认 Server 配置 <code>/etc/nginx/sites-available/default</code>（注意备份）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        # listen 80 default_server;</span><br><span class=\"line\">        # listen [::]:80 default_server;</span><br><span class=\"line\">        # root /var/www/html;</span><br><span class=\"line\">        # server_name _;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）修改 Nginx 转发配置 <code>/etc/nginx/nginx.conf</code>（注意备份），参考以下部分按实际情况修改：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">user root;</span><br><span class=\"line\">worker_processes auto;</span><br><span class=\"line\">pid /run/nginx.pid;</span><br><span class=\"line\">include /etc/nginx/modules-enabled/*.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">        worker_connections 768;</span><br><span class=\"line\">        # multi_accept on;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">        ## ---------- Basic Settings ---------- ##</span><br><span class=\"line\"></span><br><span class=\"line\">        sendfile on;</span><br><span class=\"line\">        tcp_nopush on;</span><br><span class=\"line\">        tcp_nodelay on;</span><br><span class=\"line\">        keepalive_timeout 65;</span><br><span class=\"line\">        types_hash_max_size 2048;</span><br><span class=\"line\">        # server_tokens off;</span><br><span class=\"line\"></span><br><span class=\"line\">        # server_names_hash_bucket_size 64;</span><br><span class=\"line\">        # server_name_in_redirect off;</span><br><span class=\"line\"></span><br><span class=\"line\">        include /etc/nginx/mime.types;</span><br><span class=\"line\">        default_type application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">        proxy_intercept_errors on;</span><br><span class=\"line\"></span><br><span class=\"line\">        ## ---------- Server Settings ---------- ##</span><br><span class=\"line\"></span><br><span class=\"line\">        # 禁止 IP 直接访问</span><br><span class=\"line\">        server &#123;</span><br><span class=\"line\">                server_name _;</span><br><span class=\"line\">                listen 80 default_server;</span><br><span class=\"line\">                listen [::]:80 default_server;</span><br><span class=\"line\">                listen 443 ssl default_server;</span><br><span class=\"line\">                listen [::]:443 ssl default_server;</span><br><span class=\"line\">                return 444;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 所有子域名转发至根域名（需要 DNS 解析）；</span><br><span class=\"line\">        # 所有顶域（TLD）统一转发到 .com 顶域；</span><br><span class=\"line\">        # HTTP 转发到 HTTPS。</span><br><span class=\"line\">        #</span><br><span class=\"line\">        # server_name 支持正则匹配泛域名，其中：</span><br><span class=\"line\">        #   &#x27;~&#x27; 表示指定后面的内容为正则表达式，因此后面内容中的特殊符号需要反斜杠转义；</span><br><span class=\"line\">        #   &#x27;^&#x27; 表示开始匹配的位置，即判断是否以该符号的下一个部分开头；</span><br><span class=\"line\">        #   &#x27;$&#x27; 表示结束匹配的位置，即判断是否以该符号的前一个部分结尾；</span><br><span class=\"line\">        #   &#x27;?&lt;name&gt;&#123;reg&#125;&#x27; 表示命名捕获，即获取满足 &#123;reg&#125; 条件的部分，并命名为 name；</span><br><span class=\"line\">        #</span><br><span class=\"line\">        # 以 ~^(?&lt;name1&gt;.+)\\.example\\.(?&lt;name2&gt;.+)$ 为例：</span><br><span class=\"line\">        #   1. &#x27;~&#x27; 表示接下来的内容为正则表达式；</span><br><span class=\"line\">        #   2. &#x27;^&#x27; 表示待匹配的内容需要以接下来的部分作为开头；</span><br><span class=\"line\">        #   3. &#x27;?&lt;name1&gt;.+&#x27; 表示查找满足条件 .+ 的部分（且至少匹配一次）；</span><br><span class=\"line\">        #   4. &#x27;$&#x27; 表示待匹配的内容需要以前一部分作为结尾；</span><br><span class=\"line\">        # 若将规则用于匹配 sub.www.example.com 则：</span><br><span class=\"line\">        #   1. name1 = sub.www</span><br><span class=\"line\">        #   2. name2 = com</span><br><span class=\"line\">        # 若将规则用于匹配 example.com 则：</span><br><span class=\"line\">        #   匹配失败，因为 name1（对应 &#x27;.+&#x27;）表示必须至少匹配 1 次，也即不能为空。</span><br><span class=\"line\">        #</span><br><span class=\"line\">        # 可用变量：</span><br><span class=\"line\">        #   $scheme     : &quot;http&quot; / &quot;https&quot; / ...</span><br><span class=\"line\">        #   $host       : &quot;sub.example.com&quot;</span><br><span class=\"line\">        #   $request_uri: &quot;/path/to/file?param=xxx&quot;</span><br><span class=\"line\">        server &#123;</span><br><span class=\"line\">                # 防止恶意域名指向服务器后 DDOS，仅匹配 .com 和 .cn 域名：</span><br><span class=\"line\">                # server_name ~^(?&lt;subDomain&gt;.+)\\.example\\.(?&lt;domainTLD&gt;.+)$;</span><br><span class=\"line\">                server_name ~^(?&lt;subDomain&gt;.*)\\.?luisliu\\.(com|cn)$;</span><br><span class=\"line\">                listen 80;</span><br><span class=\"line\">                listen [::]:80;</span><br><span class=\"line\">                listen 443 ssl;</span><br><span class=\"line\">                listen [::]:443 ssl;</span><br><span class=\"line\">                return 301 https://example.com$request_uri;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # HTTP 自动转发至 HTTPS</span><br><span class=\"line\">        # server &#123;</span><br><span class=\"line\">        #         server_name example.com example.cn;</span><br><span class=\"line\">        #         listen 80;</span><br><span class=\"line\">        #         listen [::]:80;</span><br><span class=\"line\">        #         return 301 https://$host$request_uri;</span><br><span class=\"line\">        # &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 默认只代理 HTTPS 请求</span><br><span class=\"line\">        server &#123;</span><br><span class=\"line\">                server_name example.com example.cn;</span><br><span class=\"line\">                listen 443 ssl;</span><br><span class=\"line\">                listen [::]:443 ssl;</span><br><span class=\"line\"></span><br><span class=\"line\">                # 如果 LetsEncrypt 选择 Webroot 验证，则需要将 root 配置为同样的 WebRoot 目录：</span><br><span class=\"line\">                location /.well-known/acme-challenge/ &#123;</span><br><span class=\"line\">                        root /xxx/webroot;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                root /xxx/WebServer;</span><br><span class=\"line\">                # autoindex on;</span><br><span class=\"line\">                index index.html index.htm index.nginx-debian.html;</span><br><span class=\"line\">                error_page 404 500 502 503 504 $scheme://$host/404;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ## ---------- SSL Settings ---------- ##</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl_certificate /xxx/fullchain.pem;   # 对应前面获取的 SSL 证书的公钥</span><br><span class=\"line\">        ssl_certificate_key /xxx/privkey.pem; # 对应前面获取的 SSL 证书的私钥</span><br><span class=\"line\">        ssl_session_timeout 5m;</span><br><span class=\"line\">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE</span><br><span class=\"line\">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class=\"line\">        ssl_prefer_server_ciphers on;</span><br><span class=\"line\"></span><br><span class=\"line\">        ## ---------- Logging Settings ---------- ##</span><br><span class=\"line\"></span><br><span class=\"line\">        access_log /var/log/nginx/access.log;</span><br><span class=\"line\">        error_log /var/log/nginx/error.log;</span><br><span class=\"line\"></span><br><span class=\"line\">        ## ---------- Gzip Settings ---------- ##</span><br><span class=\"line\"></span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\"></span><br><span class=\"line\">        # gzip_vary on;</span><br><span class=\"line\">        # gzip_proxied any;</span><br><span class=\"line\">        # gzip_comp_level 6;</span><br><span class=\"line\">        # gzip_buffers 16 8k;</span><br><span class=\"line\">        # gzip_http_version 1.1;</span><br><span class=\"line\">        # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class=\"line\"></span><br><span class=\"line\">        ## ---------- Virtual Host Configs ---------- ##</span><br><span class=\"line\"></span><br><span class=\"line\">        include /etc/nginx/conf.d/*.conf;</span><br><span class=\"line\">        include /etc/nginx/sites-enabled/*;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意以上 <code>ssl_certificate</code> 和 <code>ssl_certificate_key</code> 需要分别替换为之前获取到的 SSL 证书的公钥和私钥。</p>\n<p>（3）验证 Nginx 配置并重启服务：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo nginx -t</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果输出如下，说明配置正确，否则根据 [warn] 或 [error] 的提示修改。</span></span><br><span class=\"line\">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 测试通过后，重启 Nginx 服务：</span></span><br><span class=\"line\"><span class=\"meta\">ubuntu$</span><span class=\"bash\"> sudo nginx -s reload</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-6-验证网站访问\"><a href=\"#2-6-验证网站访问\" class=\"headerlink\" title=\"2.6 验证网站访问\"></a>2.6 验证网站访问</h3><ul>\n<li>以 HTTP 协议访问云服务器公网 IP：报错 444.</li>\n<li>以 HTTPS 协议访问云服务器公网 IP：报错 444。</li>\n<li>以 HTTP 协议访问自定义域名：自动转发至 HTTPS。</li>\n<li>以 HTTPS 协议访问自定义域名：正常访问。</li>\n</ul>\n<p>如果以上均验证成功，则网站已经正常部署。</p>\n<h3 id=\"2-7-常见异常\"><a href=\"#2-7-常见异常\" class=\"headerlink\" title=\"2.7 常见异常\"></a>2.7 常见异常</h3><p>如果访问服务器时报错 403，先按上文所述查看 Nginx 的报错日志：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu@~$</span><span class=\"bash\"> vim /var/<span class=\"built_in\">log</span>/nginx/error.log</span></span><br></pre></td></tr></table></figure>\n\n<p>（1）<code>directory index of &quot;...&quot; is forbidden</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">yyyy/MM/dd hh:mm:ss [error] 28043<span class=\"comment\">#28043: *6 directory index of &quot;/home/ubuntu/Projects/WebServer/&quot; is forbidden, client: XXX.XXX.XXX.XXX, server: XXX.YYY, request: &quot;GET / HTTP/1.1&quot;, host: &quot;XXX.YYY&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>首先检查 Git Push 是否成功，Hexo 在 Deploy 时，一旦某个文件 Push 失败则 Git 会中断 Push 任务，但只要 Push 任务结束 Hexo 就会提示 <code>INFO  Deploy done: git</code>，所以看到这个提示并不一定代表 Push 是成功的，需要检查 Deploy 日志，确保没有提示任何文件写入失败。如果有，大概率是权限问题导致的，可参照上文配置；如果没有，则需要检查 Nginx 配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">ubuntu@~$</span><span class=\"bash\"> vim /etc/nginx/nginx.conf</span></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">        ## 默认只代理 HTTPS 请求</span><br><span class=\"line\">        server &#123;</span><br><span class=\"line\">                // 在默认代理 server 内添加该配置：</span><br><span class=\"line\">                index index.html index.htm index.nginx-debian.html;</span><br><span class=\"line\">                // 如果不确定网站使用的默认页，则添加如下配置：</span><br><span class=\"line\">                autoindex on;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/120743882\" title=\"@LINK\">将hexo个人博客部署到个人云服务器--最详细踩坑教程</a></li>\n<li><a href=\"https://cloud.tencent.com/document/product/1207/47027\" title=\"@LINK\">Nginx 服务器证书安装</a></li>\n</ul>\n","categories":["HexoDIY"],"tags":["Hexo","自定义"]},{"title":"Hexo-问题及方案","url":"/post/hexodiy/hexodiy-solutions/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Hexo-问题及方案\"><a href=\"#Hexo-问题及方案\" class=\"headerlink\" title=\"Hexo-问题及方案\"></a>Hexo-问题及方案</h1><h2 id=\"1-Low-Severity-Vulnerability\"><a href=\"#1-Low-Severity-Vulnerability\" class=\"headerlink\" title=\"1. Low Severity Vulnerability\"></a>1. Low Severity Vulnerability</h2><p>有时，在通过 <code>npm install</code> 或 <code>npm install xxx</code> 安装完包以后，终端会出现大致如下的信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">audited 6879 packages <span class=\"keyword\">in</span> 2.402s</span><br><span class=\"line\">found 1 low severity vulnerability</span><br><span class=\"line\">  run `npm audit fix` to fix them, or `npm audit` <span class=\"keyword\">for</span> details</span><br></pre></td></tr></table></figure>\n\n<p>提示“有一个低严重性的漏洞”，根据提示输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit fix</span><br><span class=\"line\"></span><br><span class=\"line\">up to date <span class=\"keyword\">in</span> 1.185s</span><br><span class=\"line\">fixed 0 of 1 vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability required manual review and could not be updated</span><br></pre></td></tr></table></figure>\n\n<p>很明显并没有用，反馈大致意思是「有 1 个漏洞需要人工检查，且无法更新」，使用强制修复试试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit fix --force</span><br><span class=\"line\"></span><br><span class=\"line\">npm WARN using --force I sure hope you know what you are doing.</span><br><span class=\"line\">up to date <span class=\"keyword\">in</span> 1.242s</span><br><span class=\"line\">fixed 0 of 1 vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability required manual review and could not be updated</span><br></pre></td></tr></table></figure>\n\n<p>强制修复也无效，只好手动修复：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm audit</span><br><span class=\"line\"></span><br><span class=\"line\">                       === npm audit security report ===</span><br><span class=\"line\">                                                                                </span><br><span class=\"line\">┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class=\"line\">│                                Manual Review                                 │</span><br><span class=\"line\">│            Some vulnerabilities require your attention to resolve            │</span><br><span class=\"line\">│                                                                              │</span><br><span class=\"line\">│         Visit https://go.npm.me/audit-guide <span class=\"keyword\">for</span> additional guidance          │</span><br><span class=\"line\">└──────────────────────────────────────────────────────────────────────────────┘</span><br><span class=\"line\">┌───────────────┬──────────────────────────────────────────────────────────────┐</span><br><span class=\"line\">│ Low           │ Regular Expression Denial of Service                         │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Package       │ marked                                                       │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Patched <span class=\"keyword\">in</span>    │ &gt;=0.7.0                                                      │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Dependency of │ hexo-renderer-marked                                         │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ Path          │ hexo-renderer-marked &gt; marked                                │</span><br><span class=\"line\">├───────────────┼──────────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│ More info     │ https://npmjs.com/advisories/1076                            │</span><br><span class=\"line\">└───────────────┴──────────────────────────────────────────────────────────────┘</span><br><span class=\"line\">found 1 low severity vulnerability <span class=\"keyword\">in</span> 6879 scanned packages</span><br><span class=\"line\">  1 vulnerability requires manual review. See the full report <span class=\"keyword\">for</span> details.</span><br></pre></td></tr></table></figure>\n\n<p>这些信息似乎是和版本号有关，顺手打开给出来的网址：<a href=\"https://npmjs.com/advisories/1076\" title=\"@LINK\">More info</a>，看到如下信息：</p>\n<p><img data-src=\"./more_info.png\" alt=\"More info 网页信息\" title=\"@ASSET\"></p>\n<p>果然给出的解决方案也是升级 marked 版本到 0.7.0，先看看当前的版本信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br></pre></td></tr></table></figure>\n\n<p>（1）发现确实是因为旧版本的问题，所以先尝试更新后再次查看版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm update</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br></pre></td></tr></table></figure>\n\n<p>（2）发现无法手动更新，那就手动把这个 <code>Blog/node_modules/marked</code> 目录删掉：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── UNMET DEPENDENCY marked@0.6.3 </span><br><span class=\"line\"></span><br><span class=\"line\">npm ERR! missing: marked@0.6.3, required by hexo-renderer-marked@1.0.1</span><br></pre></td></tr></table></figure>\n\n<p>（3）提示依赖包 marked 被删除了，然后再重新安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">added 1 package from 1 contributor and audited 6879 packages <span class=\"keyword\">in</span> 2.442s</span><br><span class=\"line\">found 1 low severity vulnerability</span><br><span class=\"line\">  run `npm audit fix` to fix them, or `npm audit` <span class=\"keyword\">for</span> details</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.6.3</span><br></pre></td></tr></table></figure>\n\n<p>（4）仍然是 0.6.3 版本！内心是崩溃的，干脆直接覆盖安装一次 marked，再查看版本信息。执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install --save marked</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 ~/Hexo</span><br><span class=\"line\">├─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">│ └── marked@0.6.3</span><br><span class=\"line\">└── marked@0.7.0</span><br></pre></td></tr></table></figure>\n\n<p>（5）现在问题来了，从层级结构上来看，手动执行安装后 Hexo 装了两个 marked，手动安装的这个 marked 是最新的 0.7.0 版本，被放在了原来老版本的目录下：<code>Blog/node_modules/marked</code>，而原本隶属于 <code>hexo-renderer-marked</code> 下面的老版本依赖包，由于被 <code>hexo-renderer-marked</code> 依赖，且手动安装了另一版本，导致其位置被自动放到：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked</code> 目录下。</p>\n<p><strong>也就是说，这个老版本的 marked，其版本并不是由站点主目录管理的，所以 update 和 删掉重新 install 都无法更新，而手动安装的 marked 是直接由站点主目录管理的，因此默认会安装最新版。这也说明被依赖的 marked 的版本号是在 hexo-renderer-marked 渲染引擎中控制的。</strong></p>\n<p>（6）为了防止冲突，先卸载手动安装的 marked：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm uninstall --save marked</span><br></pre></td></tr></table></figure>\n\n<p>现在 <code>Blog/node_modules/</code> 下已经没有 <code>marked</code> 目录了，同时也手动删掉老版本的 marked 目录：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked</code>。</p>\n<p>（7）然后 再到之前的网页：<a href=\"https://npmjs.com/advisories/1076\" title=\"@LINK\">点击这里</a> 内点击 <code>Versions</code> 栏查看最新的 marked 版本：</p>\n<p><img data-src=\"./marked_newest_version.png\" alt=\"marked 最新版本\" title=\"@ASSET\"></p>\n<p>（8）接着找到 <code>Blog/node_modules/hexo-renderer-marked/package.json</code>，修改其中的依赖部分：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;dependencies&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;hexo-util&quot;</span>: <span class=\"string\">&quot;^0.6.2&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;marked&quot;</span>: <span class=\"string\">&quot;^0.6.1&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;strip-indent&quot;</span>: <span class=\"string\">&quot;^2.0.0&quot;</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>把 <code>&quot;marked&quot;</code> 字段后面的 <code>&quot;^0.6.1&quot;</code> 强制改为 <code>&quot;^0.7.0&quot;</code>，，最后再次执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install</span><br><span class=\"line\"></span><br><span class=\"line\">added 1 package from 1 contributor, removed 1 package and audited 6879 packages <span class=\"keyword\">in</span> 3.168s</span><br><span class=\"line\">found 0 vulnerabilities</span><br></pre></td></tr></table></figure>\n\n<p>看到这个结果说明已经没有报“低严重性漏洞”了，再查看一下版本号，发现成功更新到 0.7.0 版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm ls marked</span><br><span class=\"line\"></span><br><span class=\"line\">hexo-site@0.0.0 /Users/luis/Downloads/Temp</span><br><span class=\"line\">└─┬ hexo-renderer-marked@1.0.1</span><br><span class=\"line\">  └── marked@0.7.0</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>假如执行这两步的时候依然报之前的信息，如果可以确保之前的步骤都是对的，可以暂时不管，通常是缓存信息还没有更新的缘故，把这两步执行完之后，退出并重新打开终端再查看 <code>npm ls marked</code> 即可看到已经更新。假如出现错误信息显示被删除，再执行一次 <code>npm install</code> 即可。</p>\n<p>由于已经卸载了之前手动安装的 marked，因此这个依赖包的位置又回到了：<code>Site/node_modules/marked</code> 下。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-FontAwesome不显示\"><a href=\"#2-FontAwesome不显示\" class=\"headerlink\" title=\"2. FontAwesome不显示\"></a>2. FontAwesome不显示</h2><p>某些情况下，在构建博客后，会出现图标不显示的问题，同时在页面上检查元素会出现一个报错信息：</p>\n<p><img data-src=\"./fontawesome_error_info.png\" alt=\"FontAwesome 显示异常\" title=\"@ASSET\"></p>\n<p>原因是没找到目录下 FontAwesome 的 CSS 文件，但其实并不需要手动下载，Next 主题在生成部署时会动态到 FontAwesome 网站上下载相关样式，这时就考虑可能是 FontAwesome 的某个 CDN 连接挂了，可以在 Next 的主题配置文件 <code>next/_config.yml</code> 中切换一下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Internal version: 4.6.2</span></span><br><span class=\"line\"><span class=\"comment\"># See: https://fontawesome.com</span></span><br><span class=\"line\"><span class=\"comment\"># Example:</span></span><br><span class=\"line\"><span class=\"comment\"># fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css</span></span><br><span class=\"line\"><span class=\"comment\"># fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br><span class=\"line\"><span class=\"attr\">fontawesome:</span> <span class=\"string\">https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br></pre></td></tr></table></figure>\n\n<p>重新部署，恢复正常。</p>\n<hr>\n<h2 id=\"3-Valine评论\"><a href=\"#3-Valine评论\" class=\"headerlink\" title=\"3. Valine评论\"></a>3. Valine评论</h2><p>Valine 评论和 LeanCloud 阅读统计同时开启会有冲突（2019-12-04 无意间发现已经不会冲突了），解决方案是关掉 LeanCloud 独立的阅读统计，并在 Valine 设置项中开启统计功能即可，Valine 设置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">appid:</span> <span class=\"string\">输入自己在</span> <span class=\"string\">LeanCloud</span> <span class=\"string\">处创建的应用中申请的</span> <span class=\"string\">AppID</span></span><br><span class=\"line\">  <span class=\"attr\">appkey:</span> <span class=\"string\">输入自己在</span> <span class=\"string\">LeanCloud</span> <span class=\"string\">处创建的应用中申请的</span> <span class=\"string\">AppKey</span></span><br><span class=\"line\">  <span class=\"string\">......</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-Valine支持邮箱信息\"><a href=\"#3-1-Valine支持邮箱信息\" class=\"headerlink\" title=\"3.1 Valine支持邮箱信息\"></a>3.1 Valine支持邮箱信息</h3><p>默认情况下 Valine 只支持用户输入昵称评论，不能自己输入邮箱、网址等等，效果如下：</p>\n<p><img data-src=\"./valine_only_nick.png\" alt=\"Valine 只能输入昵称\" title=\"@ASSET\"></p>\n<p>而官网提供的评论框可以同时输入昵称、邮箱、链接：</p>\n<p><img data-src=\"./valine_nick_email_link.png\" alt=\"官网 Valine 可输入全部信息\" title=\"@ASSET\"></p>\n<p>通过查看官网的配置信息，以及查看了 Next 主题源码之后发现是 Next 源码直接限制了只能输入昵称。找到 <code>next/layout/_third-party/comments/valine.swig</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> GUEST = [<span class=\"string\">&#x27;nick&#x27;</span>, <span class=\"string\">&#x27;mail&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">  guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#comments&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">verify</span>: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">notify</span>: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">appId</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appid &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">appKey</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appkey &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">placeholder</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.placeholder &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">avatar</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.avatar &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">guest_info</span>:[<span class=\"string\">&#x27;nick&#x27;</span>] ,  <span class=\"comment\">//评论者只需要提供评论的昵称即可</span></span><br><span class=\"line\">    <span class=\"attr\">meta</span>: guest,</span><br><span class=\"line\">    <span class=\"attr\">pageSize</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.pageSize &#125;&#125;&#x27;</span> || <span class=\"number\">10</span>,</span><br><span class=\"line\">    <span class=\"attr\">visitor</span>: &#123;&#123; theme.valine.visitor &#125;&#125;,</span><br><span class=\"line\">    <span class=\"attr\">lang</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.language &#125;&#125;&#x27;</span> || <span class=\"string\">&#x27;zh-cn&#x27;</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>重点：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">guest_info:[<span class=\"string\">&#x27;nick&#x27;</span>] ,  <span class=\"comment\">//评论者只需要提供评论的昵称即可</span></span><br></pre></td></tr></table></figure>\n\n<p>也就是这里写死了只能输入昵称，到底是否需要设置其他信息可以自行决定。在 NexT 主题配置文件中 Valine 有这么个配置项：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># custom comment header</span></span><br></pre></td></tr></table></figure>\n\n<p>这个属性对应在源码 <code>next/layout/_third-party/comments/valine.swig</code> 中传递给了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">meta</span>: guest,</span><br></pre></td></tr></table></figure>\n\n<p>这段代码的作用也就是从主体配置文件中获取 <code>guest_info</code> 属性，然后以 &#39;,&#39; 分隔开，再从 <code>[&#39;nick&#39;, &#39;mail&#39;, &#39;link&#39;]</code> 中分别获取对应的字符串并组成数组，然后传给 <code>meta</code>。查看 Valine 官网资料可知，这个 <code>meta</code> 属性是 LeanCloud 存储评论的头部信息，这里定义几个属性，在 Valine 写入 LeanCloud 存储时，就会写入几个属性。</p>\n<h4 id=\"3-1-1-直接修改写入属性\"><a href=\"#3-1-1-直接修改写入属性\" class=\"headerlink\" title=\"3.1.1 直接修改写入属性\"></a>3.1.1 直接修改写入属性</h4><p>如果希望输入框有几个属性，Valine 就固定向 LeanCloud 存储几个属性，则可以简单添加其他信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将 guest_info 重新赋值为 guest 遍历到的所有属性，否则默认只有上面 JS 中定义的 guest_info:[&#x27;nick&#x27;]</span></span><br><span class=\"line\"><span class=\"attr\">guest_info</span>: guest,</span><br><span class=\"line\"><span class=\"attr\">meta</span>: guest,</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-1-2-自定义存储信息\"><a href=\"#3-1-2-自定义存储信息\" class=\"headerlink\" title=\"3.1.2 自定义存储信息\"></a>3.1.2 自定义存储信息</h4><p>如果希望评论时读者写入的属性和实际存储到 LeanCloud 中的属性不一致，例如读者评论时只需要填写：昵称、邮箱，但 Valine 实际上存储时会存储：昵称、邮箱、链接，这样的好处是如果未来有一天新增了链接属性，原有的统计表不需要扩展，则需要自定义一个属性。首先在主题配置文件的 Valine 设置部分添加一个自定义属性（命名可自定义）：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span> </span><br><span class=\"line\">  <span class=\"attr\">guest_header:</span> <span class=\"string\">nick,mail</span> <span class=\"comment\"># 用户可以自定义输入的信息</span></span><br><span class=\"line\">  <span class=\"attr\">guest_info:</span> <span class=\"string\">nick,mail,link</span> <span class=\"comment\"># Valine 实际会向 LeanCloud 写入的信息</span></span><br><span class=\"line\">  <span class=\"string\">......</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在 Next 的 Valine 部署源码 <code>next/layout/_third-party/comments/valine.swig</code> 中修改这一部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> GUEST = [<span class=\"string\">&#x27;nick&#x27;</span>, <span class=\"string\">&#x27;mail&#x27;</span>, <span class=\"string\">&#x27;link&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> guest = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest = guest.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新定义一个变量 guest_header，用来存实际需要展示在评论区的属性列表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> guest_header = <span class=\"string\">&#x27;&#123;&#123; theme.valine.guest_header &#125;&#125;&#x27;</span>;</span><br><span class=\"line\">guest_header = guest_header.split(<span class=\"string\">&#x27;,&#x27;</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> GUEST.indexOf(item) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">  <span class=\"attr\">el</span>: <span class=\"string\">&#x27;#comments&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">verify</span>: &#123;&#123; theme.valine.verify &#125;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">notify</span>: &#123;&#123; theme.valine.notify &#125;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">appId</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appid &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">appKey</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.appkey &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">placeholder</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.placeholder &#125;&#125;&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">avatar</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.avatar &#125;&#125;&#x27;</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 将 guest_info 重新赋值为 guest_header 定义的属性，否则默认只有上面 JS 中定义的 guest_info:[&#x27;nick&#x27;]</span></span><br><span class=\"line\">  <span class=\"attr\">guest_info</span>: guest_header,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 但是 Valine 写入到 LeanCloud 的还是站点配置文件中配置的所有项</span></span><br><span class=\"line\">  <span class=\"attr\">meta</span>: guest,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">pageSize</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.pageSize &#125;&#125;&#x27;</span> || <span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"attr\">visitor</span>: &#123;&#123; theme.valine.visitor &#125;&#125;,</span><br><span class=\"line\">  <span class=\"attr\">lang</span>: <span class=\"string\">&#x27;&#123;&#123; theme.valine.language &#125;&#125;&#x27;</span> || <span class=\"string\">&#x27;zh-cn&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>主要就是获取主题配置文件中设置的 <code>guest_header</code> 然后组合成数组再传给 <code>guest_info</code> 即可。重新部署，效果如下：</p>\n<p><img data-src=\"./valine_guest_info_custom.png\" alt=\"Valine 自定义用户可输入信息\" title=\"@ASSET\"></p>\n<h3 id=\"3-2-隐藏Valine系统信息\"><a href=\"#3-2-隐藏Valine系统信息\" class=\"headerlink\" title=\"3.2 隐藏Valine系统信息\"></a>3.2 隐藏Valine系统信息</h3><p>常规配置好 Valine 后，会发现评论时自动读取了用户的系统信息等不太美观：</p>\n<p><img data-src=\"./valine_show_system_info.png\" alt=\"Valine 显示系统信息\" title=\"@ASSET\"></p>\n<p>想要隐藏系统信息可修改 <code>next/source/css/_custom/custom.styl</code>，在末尾添加如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Valine 隐藏系统信息</span></span><br><span class=\"line\">.vsys&#123;</span><br><span class=\"line\">  <span class=\"attr\">display</span>:none !important;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>custom.styl</code> 这个文件会在 <code>next/source/css/main.styl</code> 中被引入：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Custom Layer</span></span><br><span class=\"line\"><span class=\"comment\">// --------------------------------------------------</span></span><br><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">&quot;_custom/&quot;</span> + $custom_styles;</span><br></pre></td></tr></table></figure>\n\n<p>隐藏后的效果：</p>\n<p><img data-src=\"./valine_hide_system_info.png\" alt=\"Valine 隐藏系统信息\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"4-本地搜索框\"><a href=\"#4-本地搜索框\" class=\"headerlink\" title=\"4. 本地搜索框\"></a>4. 本地搜索框</h2><p>在使用搜索功能时，有时可能会遇到：点击搜索后一直处于加载中的状态，无法正确显示搜索框；点击搜索后不弹出搜索框或搜索框无法点击输入等，可以按照以下内容排查。</p>\n<h3 id=\"4-1-搜索Json格式不对\"><a href=\"#4-1-搜索Json格式不对\" class=\"headerlink\" title=\"4.1 搜索Json格式不对\"></a>4.1 搜索Json格式不对</h3><p>老版本的 Hexo 站点，记录搜索内容的文件是 <code>search.xml</code>，但新版本改为了 <code>search.json</code>，如果使用新版 Hexo 但参考旧版本的文章配置，可能导致无法解析搜索内容：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The following content is not recommended to modify</span></span><br><span class=\"line\"><span class=\"comment\"># 搜索数据文件路径设置，不建议改动：</span></span><br><span class=\"line\"><span class=\"attr\">search:</span></span><br><span class=\"line\">  <span class=\"attr\">path:</span> <span class=\"string\">search.json</span></span><br><span class=\"line\">  <span class=\"attr\">field:</span> <span class=\"string\">post</span></span><br></pre></td></tr></table></figure>\n\n<p>该文件的实际路径为：<code>url/search.json</code>，直接访问这个链接如果可以正确显示 Json 内容，则说明文件生成正常，生成目录为 <code>site/public/search.json</code>。</p>\n<h3 id=\"4-2-特殊字符问题\"><a href=\"#4-2-特殊字符问题\" class=\"headerlink\" title=\"4.2 特殊字符问题\"></a>4.2 特殊字符问题</h3><p>有一个特殊字符 <code>\\u8</code> 会导致本地搜索无法正常编码。</p>\n<p>（1）如果直接访问网站的本地搜索载体页（直接在首页网址后面接上 <code>/search.json</code>）如果能正常显示出很多文字就说明没有特殊字符：</p>\n<p><img data-src=\"./search_json_normal.png\" alt=\"正常的 search.json 样式\" title=\"@ASSET\"></p>\n<p>（2）否则会出现报错，由于我无法重现，因此从 <a href=\"https://www.sqlsec.com/2017/12/hexosearch.html\" title=\"@LINK\">这篇文章</a>内找了一个图片：</p>\n<p><img data-src=\"./search_json_error.png\" alt=\"有特殊字符的 search.json 样式\" title=\"@ASSET\"></p>\n<blockquote>\n<p>Sublime Text3 和 VS Code 都可以看到这个字符，因此可以使用这两个编辑器查看并删除字符。</p>\n</blockquote>\n<hr>\n<h3 id=\"4-3-不显示搜索结果\"><a href=\"#4-3-不显示搜索结果\" class=\"headerlink\" title=\"4.3 不显示搜索结果\"></a>4.3 不显示搜索结果</h3><p>如果已经开启搜索功能，直接进入搜索内容文件 <code>xxx.github.io/search.json</code> 也能打开并且没有异常，搜索框可以正确弹出，但是无论你搜索什么内容，下面的搜索结果栏都是空白的：</p>\n<p><img data-src=\"./search_error_no_result.png\" alt=\"搜索没有结果\" title=\"@ASSET\"></p>\n<p>这种情况很可能是因为某一篇文章没有标题。例如这个网站首页有一个置顶的通知栏，是通过设置 <code>header: false</code> 隐藏的标题，但在这篇文章依然需要设置 <code>title</code> 属性，否则就会导致无法搜索。</p>\n<hr>\n<h3 id=\"4-4-搜索框显示异常\"><a href=\"#4-4-搜索框显示异常\" class=\"headerlink\" title=\"4.4 搜索框显示异常\"></a>4.4 搜索框显示异常</h3><p>如果发现点击搜索后，博客页面有变暗的效果、但搜索框根本显示不出来也没有加载中的图标（Safari），或者能显示出来但无法获取焦点、无法输入文字（Chrome），就像这样：</p>\n<p><img data-src=\"./search_error_not_show.png\" alt=\"搜索框显示异常\" title=\"@ASSET\"></p>\n<p>出现这个情况的，很可能博客个性化比较丰富，很大可能是因为自己调整了博客整体的透明度，也就是修改了这个文件：<code>next/source/css/_custom/custom.styl</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改主体透明度</span></span><br><span class=\"line\">.main-inner &#123;</span><br><span class=\"line\">  <span class=\"attr\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改侧栏透明度</span></span><br><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  <span class=\"attr\">opacity</span>: <span class=\"number\">0.8</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>网上有不少 DIY 的文章里面都有提到，给博客加了一个自定义的背景图片以后，为了让博客具有一定的半透明效果给整体设置一个透明度。</p>\n<p><strong>但是由于 Next 主题中，搜索是基于固定侧栏（也就是 header-inner）的一个弹窗 Popup，而 <code>opacity</code> 这个属性设置的是整个界面控件的不透明度，所以会导致弹窗的绘制在后，使得弹窗被覆盖在了博客显示界面的底下。</strong></p>\n<p>如果既想保留搜索功能还想要带点不透明度，可以换一个透明度方案，从直接设置控件的透明度改为给背景设置一个本身带有透明度的 ARGB 颜色：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意修改的是 header-inner 部分</span></span><br><span class=\"line\">.header-inner &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 后两位代表透明度</span></span><br><span class=\"line\">  <span class=\"attr\">background</span>: #ddddddcc</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5-LaTeX转义问题\"><a href=\"#5-LaTeX转义问题\" class=\"headerlink\" title=\"5. LaTeX转义问题\"></a>5. LaTeX转义问题</h2><p>Hexo 的渲染引擎会自动转义部分特殊字符，但在 LaTeX 公式中这部分不应该被转义，问题详情可参考：<a href=\"https://segmentfault.com/a/1190000007261752\" title=\"@LINK\">Hexo下mathjax的转义问题</a>。</p>\n<p>目前网上普遍的做法是更换渲染引擎，老版本的 Hexo 尚不清楚，不过目前 <code>hexo: 3.9.0</code> <code>hexo-cli: 2.0.0</code> 原生渲染引擎 <code>hexo-renderer-marked</code> 已经支持 LaTeX 了，如果更换为 <code>hexo-renderer-kramed</code>，会遇到的一个很 X 蛋的事是和各种 Html 标签冲突，比如 <code>&lt;center&gt;</code> 之类的，甚至 MarkDown 的原生图片语法 <code>![]()</code> 都会被转义，通常还会建议修改渲染的语法，跳过指定的符号，因此可以直接修改默认的 <code>marked</code> 引擎的语法，默认在：<code>Blog/node_modules/marked/lib/marked.js</code>，如果有手动另外安装过 marked，则修改：<code>Blog/node_modules/hexo-renderer-marked/node_modules/marked/lib/marked.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inline = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 删掉下面这行</span></span><br><span class=\"line\">  <span class=\"comment\">//escape: /^\\\\([!&quot;#$%&amp;&#x27;()*+,\\-./:;&lt;=&gt;?@\\[\\]\\\\^_`&#123;|&#125;~])/,</span></span><br><span class=\"line\">  <span class=\"comment\">// ↓↓↓替换成下面这行↓↓↓</span></span><br><span class=\"line\">  <span class=\"attr\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ↑↑↑替换成上面这行↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 删掉下面这行</span></span><br><span class=\"line\">  <span class=\"comment\">//em: /^_([^\\s_])_(?!_)|^\\*([^\\s*&lt;\\[])\\*(?!\\*)|^_([^\\s&lt;][\\s\\S]*?[^\\s_])_(?!_|[^\\spunctuation])|^_([^\\s_&lt;][\\s\\S]*?[^\\s])_(?!_|[^\\spunctuation])|^\\*([^\\s&lt;&quot;][\\s\\S]*?[^\\s\\*])\\*(?!\\*|[^\\spunctuation])|^\\*([^\\s*&quot;&lt;\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/,</span></span><br><span class=\"line\">  <span class=\"comment\">// ↓↓↓替换成下面这行↓↓↓</span></span><br><span class=\"line\">  <span class=\"attr\">em</span>: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ↑↑↑替换成上面这行↑↑↑</span></span><br><span class=\"line\"></span><br><span class=\"line\">  ......</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>最新版本的 <a href=\"mailto:hexo-renderer-marked@2.0.0\">hexo-renderer-marked@2.0.0</a>^ 语法配置文件有修改，上述方法已不再适用，暂未找到修改方案，因此将 Marked 降级到了 0.7.0 版本。</p>\n</blockquote>\n","categories":["HexoDIY"],"tags":["Hexo","自定义","Low Severity Vulnerability","FontAwesome","Valine"]},{"title":"Hexo-自定义样式","url":"/post/hexodiy/hexodiy-style/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Hexo-自定义样式\"><a href=\"#Hexo-自定义样式\" class=\"headerlink\" title=\"Hexo-自定义样式\"></a>Hexo-自定义样式</h1><p>网站使用 Hexo-NexT 主题：</p>\n<ul>\n<li><a href=\"https://github.com/next-theme/hexo-theme-next\" title=\"@LINK\">Next-Theme（最新版本）</a></li>\n<li><a href=\"https://github.com/theme-next/hexo-theme-next\" title=\"@LINK\">Theme-Next（7.8 及更早版本）</a></li>\n</ul>\n<h2 id=\"0-NexT主题自定义\"><a href=\"#0-NexT主题自定义\" class=\"headerlink\" title=\"0. NexT主题自定义\"></a>0. NexT主题自定义</h2><p>NexT 主题提供了使用数据文件来自定义默认样式的能力，可以避免侵入修改源码，相关设置在 NexT 主题配置文件内：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">custom_file_path:</span></span><br><span class=\"line\">  <span class=\"attr\">head:</span> <span class=\"string\">source/_data/NextStyle/layout/head.njk</span></span><br><span class=\"line\">  <span class=\"attr\">header:</span> <span class=\"string\">source/_data/NextStyle/layout/header.njk</span></span><br><span class=\"line\">  <span class=\"attr\">sidebar:</span> <span class=\"string\">source/_data/NextStyle/layout/sidebar.njk</span></span><br><span class=\"line\">  <span class=\"attr\">postMeta:</span> <span class=\"string\">source/_data/NextStyle/post/post-meta.njk</span></span><br><span class=\"line\">  <span class=\"attr\">postBodyEnd:</span> <span class=\"string\">source/_data/NextStyle/post/post-body-end.njk</span></span><br><span class=\"line\">  <span class=\"attr\">footer:</span> <span class=\"string\">source/_data/NextStyle/layout/footer.njk</span></span><br><span class=\"line\">  <span class=\"attr\">bodyEnd:</span> <span class=\"string\">source/_data/NextStyle/layout/body-end.njk</span></span><br><span class=\"line\">  <span class=\"attr\">variable:</span> <span class=\"string\">source/_data/NextStyle/variables.styl</span></span><br><span class=\"line\">  <span class=\"comment\"># mixin: source/_data/NextStyle/mixins.styl</span></span><br><span class=\"line\">  <span class=\"attr\">style:</span> <span class=\"string\">source/_data/NextStyle/custom.styl</span></span><br></pre></td></tr></table></figure>\n\n<p>并且 NexT 内置了多种文章内的特殊格式：<a href=\"https://theme-next.js.org/docs/tag-plugins/\" title=\"@LINK\">Tag Plugins</a></p>\n<h2 id=\"1-侧栏头像动画\"><a href=\"#1-侧栏头像动画\" class=\"headerlink\" title=\"1. 侧栏头像动画\"></a>1. 侧栏头像动画</h2><p>使用自定义头像，将图片放入 <code>/source/images/</code> 下，然后在主题配置文件中修改：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">avatar:</span></span><br><span class=\"line\">  <span class=\"comment\"># 修改为自定义的头像图片文件路径，也可以是网络路径</span></span><br><span class=\"line\">  <span class=\"attr\">url:</span> <span class=\"string\">/images/avatar.jpg</span></span><br><span class=\"line\">  <span class=\"comment\"># 是否显示为圆形头像</span></span><br><span class=\"line\">  <span class=\"attr\">rounded:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># 头像透明度</span></span><br><span class=\"line\">  <span class=\"attr\">opacity:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"comment\"># 是否在鼠标覆盖在头像上时旋转头像</span></span><br><span class=\"line\">  <span class=\"attr\">rotated:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-自定义头像旋转效果\"><a href=\"#1-1-自定义头像旋转效果\" class=\"headerlink\" title=\"1.1 自定义头像旋转效果\"></a>1.1 自定义头像旋转效果</h3><p>头像的样式是通过 CSS 控制的，所以可以通过注入 <code>custom.style</code> 来修改。</p>\n<h4 id=\"1-1-1-鼠标Hover时旋转\"><a href=\"#1-1-1-鼠标Hover时旋转\" class=\"headerlink\" title=\"1.1.1 鼠标Hover时旋转\"></a>1.1.1 鼠标Hover时旋转</h4><p>如果想让鼠标一过去头像就控记不住记几鬼畜疯狂旋转，则在 <code>custom.style</code> 中添加自定义 CSS 动画：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> hexo-<span class=\"function\"><span class=\"title\">config</span>(<span class=\"params\"><span class=\"string\">&#x27;avatar.rotated&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">  .site-author-image &#123;</span><br><span class=\"line\">    <span class=\"attr\">transition</span>: transform <span class=\"number\">1.</span>0s ease-out;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* 原本只是简单地逆时针旋转 180°</span></span><br><span class=\"line\"><span class=\"comment\">  .site-author-image:hover &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    transform: rotateZ(-180deg);</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"comment\">// 鼠标 Hover 时执行 rotateAvatar 动画，动画每次 0.15 秒，线性加速度，重复无限次</span></span><br><span class=\"line\">  .site-author-image:hover &#123;</span><br><span class=\"line\">    <span class=\"attr\">animation</span>: rotateAvatar <span class=\"number\">0.</span>15s linear infinite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// rotateAvatar 定义动画为旋转 360 度</span></span><br><span class=\"line\">  @keyframes rotateAvatar&#123;<span class=\"keyword\">from</span>&#123;<span class=\"attr\">transform</span>: rotate(0deg)&#125;</span><br><span class=\"line\">  to&#123;<span class=\"attr\">transform</span>: rotate(360deg)&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"./avatar_rotate_hover.gif\" alt=\"鼠标覆盖头像鬼畜式旋转\" title=\"@ASSET\"></p>\n<h4 id=\"1-1-2-唱片式旋转\"><a href=\"#1-1-2-唱片式旋转\" class=\"headerlink\" title=\"1.1.2 唱片式旋转\"></a>1.1.2 唱片式旋转</h4><p>如果想让头像一直缓慢旋转，不受其他操作影响，同样在 <code>custom.style</code> 中添加自定义 CSS 动画：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> hexo-<span class=\"function\"><span class=\"title\">config</span>(<span class=\"params\"><span class=\"string\">&#x27;avatar.rotated&#x27;</span></span>)</span> &#123;</span><br><span class=\"line\">  .site-author-image &#123;</span><br><span class=\"line\">    <span class=\"attr\">transition</span>: transform <span class=\"number\">1.</span>0s ease-out;</span><br><span class=\"line\">    <span class=\"comment\">// 对自定义头像的 CSS 执行动画 rotateAvatar，动画每次 5 秒，线性加速度，重复无限次</span></span><br><span class=\"line\">    animation: rotateAvatar 5s linear infinite;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 去掉原本定义的鼠标 Hover 动画</span></span><br><span class=\"line\">  .site-author-image:hover &#123;</span><br><span class=\"line\">    <span class=\"attr\">transform</span>: none;</span><br><span class=\"line\">    <span class=\"comment\">// animation: rotateAvatar 0.15s linear infinite;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// rotateAvatar 定义动画为从 0 度旋转岛 360 度</span></span><br><span class=\"line\">  @keyframes rotateAvatar &#123;</span><br><span class=\"line\">    <span class=\"keyword\">from</span> &#123;</span><br><span class=\"line\">      <span class=\"attr\">transform</span>: rotate(0deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    to &#123;</span><br><span class=\"line\">      <span class=\"attr\">transform</span>: rotate(360deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"./avatar_rotate_normal.gif\" alt=\"唱片式旋转\" title=\"@ASSET\"></p>\n<hr>\n<h2 id=\"2-浏览器标签页动态标题\"><a href=\"#2-浏览器标签页动态标题\" class=\"headerlink\" title=\"2. 浏览器标签页动态标题\"></a>2. 浏览器标签页动态标题</h2><p><img data-src=\"./animate_browser_title.gif\" alt=\"浏览器标签页动态标题\" title=\"@ASSET\"></p>\n<p>由于只在打开某篇文章时才需要这个动画效果，因此可以在自定义数据文件 <code>post-body-end.njk</code> 中加载一个 JS：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;# 可写进 js 文件中并放在【hexo/source/xxx/】目录下或【next/source/xxx/】目录下 #&#125;</span><br><span class=\"line\">&#123;# 然后通过：&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span> src=<span class=\"string\">&quot;/xxx/*.js&quot;</span>&gt;&lt;/script&gt; 方式调用 #&#125;</span><br><span class=\"line\">&#123;# 但目录不能以下划线开头（会视为隐藏文件夹而无法访问） #&#125;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    &lt;!--动态浏览器标签--&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> OriginTitle = <span class=\"built_in\">document</span>.title;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleTime;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleTime2;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> titleTime3;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> blankTitle = <span class=\"string\">&quot;\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000\\u3000&quot;</span></span><br><span class=\"line\">    blankTitle = blankTitle + blankTitle + blankTitle;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">&#x27;visibilitychange&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.hidden) &#123;</span><br><span class=\"line\">            $(<span class=\"string\">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).attr(<span class=\"string\">&#x27;href&#x27;</span>, <span class=\"string\">&quot;/images/favicon-32x32-next.png&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 失去焦点时不切换标题</span></span><br><span class=\"line\">            <span class=\"comment\">// document.title = &quot;Waiting...&quot;;</span></span><br><span class=\"line\">            <span class=\"built_in\">document</span>.title = OriginTitle;</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(titleTime);</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(titleTime2);</span><br><span class=\"line\">            <span class=\"built_in\">clearTimeout</span>(titleTime3);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Welcome&quot;</span>;</span><br><span class=\"line\">            titleTime = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Back&quot;</span>;</span><br><span class=\"line\">                titleTime2 = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Welcome Back !&quot;</span>;</span><br><span class=\"line\">                    titleTime3 = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">document</span>.title = OriginTitle;</span><br><span class=\"line\">                    &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">            &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>具体的文件名和路径请按照实际情况修改。其实这种三个定时器的嵌套比较 Low，不知道有没有办法可以重用定时器。</p>\n<p><code>icon</code> 处可以自定义一个小图像，可以是本地图像也可以是网络图片。不过需要注意的是，这里如果选择本地图片，“/”表示的就不是博客根目录而是主题根目录，所以 <code>/images/</code> 其实等价于 <code>/next/images/</code>。同理，在主题配置文件中的 <code>favicon</code> 选项设置的也是浏览器标签页小图标，指定的路径也是以主题根目录为起始路径的。</p>\n</blockquote>\n<hr>\n<h2 id=\"3-页码导航栏增加显示数量\"><a href=\"#3-页码导航栏增加显示数量\" class=\"headerlink\" title=\"3. 页码导航栏增加显示数量\"></a>3. 页码导航栏增加显示数量</h2><p>默认情况下，Next 的页码导航栏只会显示以下页码，而其他页码将被隐藏：</p>\n<ul>\n<li>首页和尾页；</li>\n<li>当前页；</li>\n<li>当前页的前一页（如果有）和后一页（如果有）；</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 当前选中第 1 页时：</span><br><span class=\"line\">[1] 2 ... 8</span><br><span class=\"line\"></span><br><span class=\"line\">// 当前选中第 2 页时：</span><br><span class=\"line\">1 [2] 3 ... 8</span><br><span class=\"line\"></span><br><span class=\"line\">// 当前选中第 6 页时：</span><br><span class=\"line\">1 ... 5 [6] 7 8</span><br></pre></td></tr></table></figure>\n\n<p>但总页数较少时，会导致中间页码很容易被隐藏，切换页面时很麻烦，因此可以修改配置增加可显示范围：</p>\n<ul>\n<li><p><code>Next-8.0.0</code> 及之后版本的配置文件在 <code>Next/layout/_partials/pagination.njk</code>，并在该文件中通过引用 <code>Next/scripts/helpers/next-paginator.js</code> 实现；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo.extend.helper.register(<span class=\"string\">&#x27;next_paginator&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">  <span class=\"keyword\">let</span> paginator = <span class=\"built_in\">this</span>.paginator(&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"attr\">mid_size</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>Next-8.0.0</code> 之前版本的配置文件在 <code>Next/layout/_partials/pagination.swig</code>；</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;%- <span class=\"keyword\">if</span> page.prev or page.next %&#125;</span><br><span class=\"line\">  &lt;nav <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">&quot;pagination&quot;</span>&gt;</span><br><span class=\"line\">    &#123;&#123;</span><br><span class=\"line\">      paginator(&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"attr\">mid_size</span> : <span class=\"number\">1</span>,</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;&#125;</span><br><span class=\"line\">  &lt;/nav&gt;</span><br><span class=\"line\">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>其中 <code>mid_size</code> 即表示显示「当前页的前 <code>mid_size</code> 个页码」和「当前页的后 <code>mid_size</code> 个页码」，增大该值即可。</p>\n<hr>\n<h2 id=\"4-自动更新站点发布时间\"><a href=\"#4-自动更新站点发布时间\" class=\"headerlink\" title=\"4. 自动更新站点发布时间\"></a>4. 自动更新站点发布时间</h2><p>由于 Hexo 一般使用静态发布，网站更新后如果浏览器有本地缓存可能不会立即刷新，为了更好的判断网站版本，可以在发布 Hexo 时在控制台输出当前时间、并自动将该时间显示在网站中。实现该效果需要满足以下条件：</p>\n<ul>\n<li>可以感知 Hexo 的发布流程并执行自定义代码；</li>\n<li>可以将时间记录在某个 Hexo 定义的公共元素中，而与使用的主题 Theme 无关；</li>\n<li>不侵入主题 Theme 的代码，防止 切换/更新 主题时需要重新配置；</li>\n</ul>\n<p>经过查找，网站的 <code>title</code> 和 <code>subtitle</code> 均可满足，由于 <code>title</code> 通常需要作为品牌标识，最终选择使用 <code>subtitle</code> 来记录发布时间。</p>\n<p>（1）将发布时间作为 <code>subtitle</code> 的默认值</p>\n<p>编辑 <code>Site/node_modules/hexo/lib/hexo/default_config.js</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接给 Date 类添加原型方法 format()，用于解析传入的格式。</span></span><br><span class=\"line\"><span class=\"comment\">// chalk 用于控制台彩色日志</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chalk = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;chalk&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">Date</span>.prototype.format = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">format</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;M+&quot;</span> : <span class=\"built_in\">this</span>.getMonth()+<span class=\"number\">1</span>,                 <span class=\"comment\">//月份 </span></span><br><span class=\"line\">      <span class=\"string\">&quot;d+&quot;</span> : <span class=\"built_in\">this</span>.getDate(),                    <span class=\"comment\">//日 </span></span><br><span class=\"line\">      <span class=\"string\">&quot;h+&quot;</span> : <span class=\"built_in\">this</span>.getHours(),                   <span class=\"comment\">//小时 </span></span><br><span class=\"line\">      <span class=\"string\">&quot;m+&quot;</span> : <span class=\"built_in\">this</span>.getMinutes(),                 <span class=\"comment\">//分 </span></span><br><span class=\"line\">      <span class=\"string\">&quot;s+&quot;</span> : <span class=\"built_in\">this</span>.getSeconds(),                 <span class=\"comment\">//秒 </span></span><br><span class=\"line\">      <span class=\"string\">&quot;q+&quot;</span> : <span class=\"built_in\">Math</span>.floor((<span class=\"built_in\">this</span>.getMonth()+<span class=\"number\">3</span>)/<span class=\"number\">3</span>), <span class=\"comment\">//季度 </span></span><br><span class=\"line\">      <span class=\"string\">&quot;S&quot;</span> : <span class=\"built_in\">this</span>.getMilliseconds()              <span class=\"comment\">//毫秒 </span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"regexp\">/(y+)/</span>.test(format)) &#123;</span><br><span class=\"line\">    format=format.replace(<span class=\"built_in\">RegExp</span>.$1, (<span class=\"built_in\">this</span>.getFullYear()+<span class=\"string\">&quot;&quot;</span>).substr(<span class=\"number\">4</span> - <span class=\"built_in\">RegExp</span>.$1.length));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> o) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">&quot;(&quot;</span>+ k +<span class=\"string\">&quot;)&quot;</span>).test(format))&#123;</span><br><span class=\"line\">        format = format.replace(<span class=\"built_in\">RegExp</span>.$1, (<span class=\"built_in\">RegExp</span>.$1.length==<span class=\"number\">1</span>) ? (o[k]) : ((<span class=\"string\">&quot;00&quot;</span>+ o[k]).substr((<span class=\"string\">&quot;&quot;</span>+ o[k]).length)));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 输出生成时间（直接指定样式）：\\x1b 表示 ESC 的 ASCII 码，[40;92m 表示黑色背景绿色字体，末尾需要再加上 \\x1b[0m 表示复原</span></span><br><span class=\"line\">  <span class=\"comment\">// console.info(`\\x1b[40;92m[Generation Time] &gt;&gt;&gt; $&#123;format&#125;\\x1b[0m`);</span></span><br><span class=\"line\">  <span class=\"comment\">// 输出生成时间（通过 chalk 设置前景和背景），需要先引入：const chalk = require(&#x27;chalk&#x27;);</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(chalk<span class=\"string\">`&#123;rgb(11, 237, 183).bold.bgRgb(216, 72, 13) [Generation Time] &gt;&gt;&gt; <span class=\"subst\">$&#123;format&#125;</span>&#125;`</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> format;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把 SubTitle 定义为显示时间，但该文件定义的默认值仅在 _config.yml 中没有声明时生效。</span></span><br><span class=\"line\">  <span class=\"attr\">subtitle</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().format(<span class=\"string\">&quot;yyyy/MM/dd - hh:mm:ss&quot;</span>),</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>（2）删除 Hexo 网站配置中的 <code>subtitle</code> 字段，使其读取默认值</p>\n<p>编辑 <code>Site/_config.yml</code>：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">XXX</span></span><br><span class=\"line\"><span class=\"comment\"># subtitle: # 删除或注释该字段，则 Hexo 会读取默认值</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）根据主题显示时间</p>\n<p>大部份主题（例如 Next）会直接读取 Hexo 定义的 <code>subtitle</code> 字段值并显示，无需额外适配。</p>\n<hr>\n<h2 id=\"其他收录\"><a href=\"#其他收录\" class=\"headerlink\" title=\"其他收录\"></a>其他收录</h2><ul>\n<li>文章加密：<a href=\"https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md\" title=\"@LINK\">hexo-blog-encrypt</a></li>\n<li>点击爱心（会导致双击选中、三击选中整行失效）：<a href=\"https://asdfv1929.github.io/2018/01/26/click-love/\" title=\"@LINK\">Hexo NexT主题添加点击爱心效果</a></li>\n<li>页面加载进度条：<a href=\"https://blog.csdn.net/u011236348/article/details/88146947\" title=\"@LINK\">Hexo博客NexT主题美化之顶部加载进度条</a></li>\n<li>GitHub 角标：<a href=\"http://tholman.com/github-corners/\" title=\"@LINK\">GitHub Corners</a></li>\n<li>文章编辑器：<a href=\"https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md\" title=\"@LINK\">HexoEditor</a></li>\n</ul>\n","categories":["HexoDIY"],"tags":["Hexo","自定义"]},{"title":"iOS-让iPad始终以竖屏显示","url":"/post/ios/ios-ipad_keep_portrait/","content":"<span id=\"more\"></span>\n\n<h1 id=\"iOS-让iPad始终以竖屏显示\"><a href=\"#iOS-让iPad始终以竖屏显示\" class=\"headerlink\" title=\"iOS-让iPad始终以竖屏显示\"></a>iOS-让iPad始终以竖屏显示</h1><h2 id=\"1-iPad屏幕方向的限制\"><a href=\"#1-iPad屏幕方向的限制\" class=\"headerlink\" title=\"1. iPad屏幕方向的限制\"></a>1. iPad屏幕方向的限制</h2><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://developer.apple.com/forums/thread/6100\" title=\"@LINK\">How can I disable the system rotation in iOS 9?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/3301343/disabling-auto-rotation-for-a-uiview\" title=\"@LINK\">Disabling auto rotation for a UIView</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25666269/how-to-detect-orientation-change\" title=\"@LINK\">How to detect orientation change?</a></li>\n<li><a href=\"https://developer.apple.com/documentation/uikit/uiviewcontroller/1621458-willanimaterotationtointerfaceor\" title=\"@LINK\">willAnimateRotationToInterfaceOrientation:duration:</a></li>\n<li><a href=\"https://developer.apple.com/documentation/uikit/uicontentcontainer/1621466-viewwilltransitiontosize\" title=\"@LINK\">viewWillTransitionToSize:withTransitionCoordinator:</a></li>\n<li><a href=\"https://stackoverflow.com/questions/47782992/willrotatetointerfaceorientationduration-is-deprecated-implement-viewwilltrans\" title=\"@LINK\">willRotateToInterfaceOrientation:duration is deprecated. Implement viewWillTransitionToSize:withTransitionCoordinator</a></li>\n<li><a href=\"https://developer.apple.com/documentation/avkit/accessing_the_camera_while_multitasking\" title=\"@LINK\">Accessing the camera while multitasking</a></li>\n</ul>\n","categories":["iOS"],"tags":["iOS","iPad","Portrait","竖屏"]},{"title":"iOS-CGAffineTransform","url":"/post/ios/ios-transform/","content":"<span id=\"more\"></span>\n\n<h1 id=\"iOS-CGAffineTransform\"><a href=\"#iOS-CGAffineTransform\" class=\"headerlink\" title=\"iOS-CGAffineTransform\"></a>iOS-CGAffineTransform</h1><h2 id=\"1-Transform的定义\"><a href=\"#1-Transform的定义\" class=\"headerlink\" title=\"1. Transform的定义\"></a>1. Transform的定义</h2><p>scaleX = transform.a<br>scaleY = transform.d</p>\n<p>rotateX = transform.c<br>rotateY = transform.b</p>\n<p>translateX = transform.tx<br>translateY = transform.ty</p>\n<hr>\n<h2 id=\"2-Transform的逆运算\"><a href=\"#2-Transform的逆运算\" class=\"headerlink\" title=\"2. Transform的逆运算\"></a>2. Transform的逆运算</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)getScaleXFromTransform:(<span class=\"built_in\">CGAffineTransform</span>)transform &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(transform.a * transform.a + transform.c * transform.c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)getScaleYFromTransform:(<span class=\"built_in\">CGAffineTransform</span>)transform &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(transform.b * transform.b + transform.d * transform.d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)getRotateFromTransform:(<span class=\"built_in\">CGAffineTransform</span>)transform &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> atan2(transform.b, transform.d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)getTranslateXFromTransform(<span class=\"built_in\">CGAffineTransform</span>)transform &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transform.tx;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">CGFloat</span>)getTranslateYFromTransform(<span class=\"built_in\">CGAffineTransform</span>)transform &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transform.ty;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-使用Transform的注意事项\"><a href=\"#3-使用Transform的注意事项\" class=\"headerlink\" title=\"3. 使用Transform的注意事项\"></a>3. 使用Transform的注意事项</h2><p>如果一个 UIView 通过 CGAffineTransformScale 缩放，scale 比例为 0，会导致该 View 及其 Layer 无法获取 CGContext，如果尝试显示、或渲染这样的 View / Layer，会有如下错误日志：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Error&gt;: CGContextSaveGState: invalid context 0x0. If you want to see the backtrace, please <span class=\"built_in\">set</span> CG_CONTEXT_SHOW_BACKTRACE environmental variable.</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://stackoverflow.com/a/21166286\" title=\"@LINK\">Get just the rotation from a CGAffineTransform</a></li>\n<li><a href=\"https://blog.csdn.net/shaobo8910/article/details/51536526\" title=\"@LINK\">CGAffineTransformMake(a,b,c,d,tx,ty) 矩阵运算的原理</a></li>\n<li><a href=\"https://www.cnblogs.com/Free-Thinker/p/11269811.html\" title=\"@LINK\">iOS开发 CGAffineTransform 让图片旋转, 旋转后获得图片旋转的角度</a></li>\n<li><a href=\"https://stackoverflow.com/questions/24820164/get-scale-and-rotation-angle-from-cgaffinetransform\" title=\"@LINK\">Get scale and rotation angle from CGAffineTransform?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2690337/get-just-the-scaling-transformation-out-of-cgaffinetransform\" title=\"@LINK\">Get just the scaling transformation out of CGAffineTransform</a></li>\n</ul>\n","categories":["iOS"],"tags":["iOS","CGAffineTransform"]},{"title":"iOS-UIScrollView翻页效果","url":"/post/ios/ios-uiscrollview_paging/","content":"<span id=\"more\"></span>\n\n<h1 id=\"iOS-UIScrollView翻页效果\"><a href=\"#iOS-UIScrollView翻页效果\" class=\"headerlink\" title=\"iOS-UIScrollView翻页效果\"></a>iOS-UIScrollView翻页效果</h1><h2 id=\"1-Cell与UIScrollView等宽\"><a href=\"#1-Cell与UIScrollView等宽\" class=\"headerlink\" title=\"1. Cell与UIScrollView等宽\"></a>1. Cell与UIScrollView等宽</h2><p>如果 UIScrollView 中每一个 Cell 的宽度被设计为与 UIScrollView 等宽，那只需要一行代码就能实现：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">scrollView.pagingEnabled = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法非常适合用在多 Tab 的页面切换之类的场景。</p>\n<hr>\n<h2 id=\"2-Cell与UIScrollView不等宽\"><a href=\"#2-Cell与UIScrollView不等宽\" class=\"headerlink\" title=\"2. Cell与UIScrollView不等宽\"></a>2. Cell与UIScrollView不等宽</h2><p>但是实际项目中经常会有 Cell 的宽度与 UIScrollView 不等宽的设计，如果仍旧按上面的方法实现，会发现每一页滑动后停留的位置并不在正中央：</p>\n<p><img data-src=\"./uiscrollview_paging_scroll_over.gif\" alt=\"默认 Paging 实现为滚动 UIScrollView 宽度\"></p>\n<p>这是因为 ScrollView 默认的 Paging 实现为每次滚动一屏（即 ScrollView 自身宽度）的距离。</p>\n<p>（1）有个比较 hack 的方式：超出边界绘制。</p>\n<p>通常对于多个 Cell 的内容列表，设计上除了当前 Cell 之外还会稍微露出一小部份上一个/下一个 Cell 来提示用户，因此通常 UIScrollView 的宽度是大于单个 Cell 的：</p>\n<ul>\n<li>如果 Cell 与 UIScrollView 等宽，虽然能满足 Paging 的实现，但是就只能显示一个 Cell；</li>\n<li>如果 UIScrollView 的宽度大于 Cell，虽然能满足设计上显示超出一个 Cell 的要求，但又不能实现 Paging 效果；</li>\n</ul>\n<p>为了同时满足以上两条，可以允许 UIScrollView 的 subViews 超出边界绘制：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">collectionView.pagingEnabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">collectionView.clipsToBounds = <span class=\"literal\">NO</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"./uiscrollview_paging_expand_bounds.png\" alt=\"Cell 与 UIScrollView 不等宽\"></p>\n<p>如图所示，实际上只有红框内才是 UIScrollView，两边的 Cell 是超出 UIScrollView 边界绘制的。当然这样虽然能达成目的，但不够优雅，其最大的弊端是必须确保 UIScrollView 同一时间最多只能完整显示一个 Cell，这在 iPad 上（尤其是 iPad 横屏时）的适配表现就很糟糕，相当于强行把手机版 UI 放大显示。</p>\n<p>（2）作为合格的谷歌搜索工程师，肯定还能抄到这样的作业：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用来源：https://www.cnblogs.com/silence-cnblogs/p/6529728.html</span></span><br><span class=\"line\"></span><br><span class=\"line\">func scrollViewWillEndDragging(_ scrollView: <span class=\"built_in\">UIScrollView</span>, withVelocity velocity: <span class=\"built_in\">CGPoint</span>, targetContentOffset: UnsafeMutablePointer&lt;<span class=\"built_in\">CGPoint</span>&gt;) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Destination x</span></span><br><span class=\"line\">    let x = targetContentOffset.pointee.x</span><br><span class=\"line\">    <span class=\"comment\">// Page width equals to cell width</span></span><br><span class=\"line\">    let pageWidth = cellWidth</span><br><span class=\"line\">    <span class=\"comment\">// Check which way to move</span></span><br><span class=\"line\">    let movedX = x - pageWidth * <span class=\"built_in\">CGFloat</span>(selectedIndex)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> movedX &lt; -pageWidth * <span class=\"number\">0.5</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Move left</span></span><br><span class=\"line\">        selectedIndex -= <span class=\"number\">1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> movedX &gt; pageWidth * <span class=\"number\">0.5</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Move right</span></span><br><span class=\"line\">        selectedIndex += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> abs(velocity.x) &gt;= <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        targetContentOffset.pointee.x = pageWidth * <span class=\"built_in\">CGFloat</span>(selectedIndex)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If velocity is too slow, stop and move with default velocity</span></span><br><span class=\"line\">        targetContentOffset.pointee.x = scrollView.contentOffset.x</span><br><span class=\"line\">        scrollView.setContentOffset(</span><br><span class=\"line\">            <span class=\"built_in\">CGPoint</span>(</span><br><span class=\"line\">                x: pageWidth * <span class=\"built_in\">CGFloat</span>(selectedIndex),</span><br><span class=\"line\">                y: scrollView.contentOffset.y</span><br><span class=\"line\">            ),</span><br><span class=\"line\">            animated: <span class=\"literal\">true</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>乍一试这个方案可以满足要求：</p>\n<p><img data-src=\"./uiscrollview_paging_online_solution_scrolling.gif\" alt=\"网上方案的滑动效果\"></p>\n<p>但如果对这个列表做一些比较极端和边界的操作就会发现有 Bug，复现方式：缓慢拖动一个 View 到超过中线的位置后松手：</p>\n<p><img data-src=\"./uiscrollview_paging_online_solution_bug.gif\" alt=\"网上方案的 Bug\"></p>\n<hr>\n<h2 id=\"3-理解实现原理\"><a href=\"#3-理解实现原理\" class=\"headerlink\" title=\"3. 理解实现原理\"></a>3. 理解实现原理</h2><p>既然抄不到合格的作业，那就研究下如何自己实现吧。首先可以确定的是，要实现滑动过程的自定义定位，一定和这个方法有关：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView</span><br><span class=\"line\">                     withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity <span class=\"comment\">// 滑动的速度</span></span><br><span class=\"line\">              targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset; <span class=\"comment\">// UIScrollView 目标的停止位置坐标</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>targetContentOffset</code> 直接决定了列表滑动结束后需要停在哪里，因此通过一些逻辑判断，计算出用户操作的预期是停在哪个 Cell，就手动定位到对应位置即可。整个计算思路如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 判断当前是往哪个方向滚动；</span><br><span class=\"line\">2. 判断对应方向还有没有可以展示的 Cell；</span><br><span class=\"line\">3. 判断对应的目标 Cell 在第几位；</span><br><span class=\"line\">4. 计算滚动多远距离才能让目标 Cell 显示在居中位置，并手动让 ScrollView 滚动到目标位置；</span><br></pre></td></tr></table></figure>\n\n<p>步骤还是很简单的，并且该方案是通过自定义 UIScrollView 实现，理论上对 UITableView、UICollectionView 等任何基于 UIScrollView 的列表都可用。不过由于 UICollectionView 相比之下多了一些 Section 之类的概念所以需要多考虑一些影响，以 UICollectionView 为例，其他列表 UI 根据以下逻辑调整即可：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 部份宏定义可以根据命名理解其作用。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @Note</span></span><br><span class=\"line\"><span class=\"comment\"> * 计算松手后的瞬间哪个 Cell 最接近正中间，将其作为需要自动校正前的 Cell，</span></span><br><span class=\"line\"><span class=\"comment\"> * 因此这个计算逻辑必须放在松手后（即该回调方法）再判断，而不是 Scroll 刚开始的时候，</span></span><br><span class=\"line\"><span class=\"comment\"> * 因为从动画执行到真正改变 offset 需要一段时间，立即获取 contentOffset 仍可能是滑动前的。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)scrollViewWillEndDragging:(<span class=\"built_in\">UIScrollView</span> *)scrollView</span><br><span class=\"line\">                     withVelocity:(<span class=\"built_in\">CGPoint</span>)velocity</span><br><span class=\"line\">              targetContentOffset:(<span class=\"keyword\">inout</span> <span class=\"built_in\">CGPoint</span> *)targetContentOffset &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (scrollView != <span class=\"keyword\">self</span>.collectionView) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// @Note 1. 计算当前中心位置的点属于第几个 Item。</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">///          contentOffset 表示的是列表头部（而不是列表中心）距离内容起点的距离，</span></span><br><span class=\"line\">    <span class=\"comment\">///          对于横向列表则是列表最左侧距离起点的距离，</span></span><br><span class=\"line\">    <span class=\"comment\">///          所以列表中心的实际偏移 midpointOffset = 左侧 (contentOffset) + 列表宽度的一半 (UIScrollView.width / 2)。</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> contentOffset = <span class=\"keyword\">self</span>.collectionView.contentOffset.x;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> scrollViewCenterX = <span class=\"keyword\">self</span>.collectionView.width / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 可以画个图或者体验一下这里的功能，思考下 pagingWidth 与 cellWidth 与 collectionViewWidth 之间的关系。</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> pagingWidth = [<span class=\"keyword\">self</span> _getPagingWidth];</span><br><span class=\"line\">    <span class=\"keyword\">float</span> cellWidth = [<span class=\"keyword\">self</span> _getCellWidth];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pagingWidth &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        _centerItemRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> midpointOffset = contentOffset + scrollViewCenterX;</span><br><span class=\"line\">        _centerItemRow = floor(midpointOffset / pagingWidth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// @Note 2. 根据滑动速度 velocity 计算用户的拖动行为目的是滑至哪一个 Cell。</span></span><br><span class=\"line\">    <span class=\"comment\">///          因为要实现的是 Paging 效果，所以只需要判断 velocity 值的正负即可。</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> allContentWidth = <span class=\"keyword\">self</span>.collectionView.contentSize.width;</span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> newItemRow = _centerItemRow;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (velocity.x == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 速度为 0，说明没有发生滚动，不需要处理。</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newItemRow = velocity.x &gt; <span class=\"number\">0</span> ? newItemRow + <span class=\"number\">1</span> : newItemRow - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newItemRow &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            newItemRow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newItemRow &gt; allContentWidth / pagingWidth) &#123;</span><br><span class=\"line\">            newItemRow = ceil(allContentWidth / pagingWidth) - <span class=\"number\">1.0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 速度不为 0，这里就找到了目标需要显示在中间的 Cell 的 index。</span></span><br><span class=\"line\">        _centerItemRow = newItemRow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/// @Note 3. 将 CollectionView 手动位移到对应的页面。</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">///          列表居中位置 scrollViewCenterX = UIScrollView.width / 2；</span></span><br><span class=\"line\">    <span class=\"comment\">///          相邻分页需要滑动的距离为 pagingWidth = Item_n.centerX - Item_(n-1).centerX。</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">///          当 UIScrollView 的宽度远超单个 Cell 的宽度（例如 iPad）时，</span></span><br><span class=\"line\">    <span class=\"comment\">///          第一个 Item_0 会显示在列表头部而不是一开始就居中，</span></span><br><span class=\"line\">    <span class=\"comment\">///          此时 contentOffset = 0 但 Item_0.centerX &gt; 0，</span></span><br><span class=\"line\">    <span class=\"comment\">///          所以从 Item_0 滑动至 Item_1 不一定需要 pagingWidth 那么多，</span></span><br><span class=\"line\">    <span class=\"comment\">///          相差的 Diff = scrollViewCenterX - Item_0.centerX（即想让 Item_0 居中的距离），</span></span><br><span class=\"line\">    <span class=\"comment\">///          也等于 Item_0.left 滑动至 scrollViewCenterX 再减自己一半宽度。</span></span><br><span class=\"line\">    <span class=\"comment\">///</span></span><br><span class=\"line\">    <span class=\"comment\">///          如果 UIScrollView 还有 insetPadding 则 Diff 还要减去对应的间隔，</span></span><br><span class=\"line\">    <span class=\"comment\">///          因此最终 Diff = scrollViewCenterX - Item_0.centerX - insetPadding</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span> insetPadding = SECTION_SPACING_HORIZONTAL;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> firstPageOffset = scrollViewCenterX - cellWidth / <span class=\"number\">2</span> - insetPadding;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 最终计算出来需要让 ScrollView 滚动结束时停留在哪个位置：</span></span><br><span class=\"line\">    targetContentOffset-&gt;x = (newItemRow * pagingWidth) - firstPageOffset;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看下成果，不仅滑动丝滑、定位精准、支持慢速逐个滚动与快速多个滚动、还没有抄作业的 Bug：</p>\n<p><img data-src=\"./uiscrollview_paging_optimization.gif\" alt=\"优化方案\"></p>\n<p>当然，这里的示例是没有根据不同滚动速度调整切页的速度，但要加上也很简单，只需要根据产品/设计的要求对不同档位的 velocity 做判断、或是算个 log 函数来调整一次切换几个 row 即可。</p>\n","categories":["iOS"],"tags":["iOS","UIScrollView","Paging"]},{"title":"Android-Activity生命周期","url":"/post/android/android-activity_lifecycle/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Activity生命周期\"><a href=\"#Android-Activity生命周期\" class=\"headerlink\" title=\"Android-Activity生命周期\"></a>Android-Activity生命周期</h1><h2 id=\"1-Activity简介\"><a href=\"#1-Activity简介\" class=\"headerlink\" title=\"1. Activity简介\"></a>1. Activity简介</h2><p>Activity 即一个用户界面，可以理解成一个视图容器，容器内可以包裹和展示各类控件。全部 Activity 都需要在 Manifest 内声明。Activity 的生命周期为：</p>\n<p><img data-src=\"./activity_lifecycle.svg\" alt=\"Activity 生命周期\" title=\"@ASSET\"></p>\n<p>需要注意的是：</p>\n<ul>\n<li><code>onStop()</code> 在 Activity 不可见时才调用，例如 AActivity 启动 BActivity，若 BActivity 是透明或弹窗形式（<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>），则 AActiivty 不会调用 <code>onStop()</code>。</li>\n<li>Activity 的 <code>onSaveInstanceState()</code> 和 <code>onRestoreInstanceState()</code> 并不是生命周期方法，当 Activity 处于 <code>isFinishing()</code> 状态时，<code>onSaveInstanceState()</code> 就不会被调用，因此只适合用于保存一些临时性的状态。</li>\n</ul>\n<h3 id=\"1-1-启动Activity\"><a href=\"#1-1-启动Activity\" class=\"headerlink\" title=\"1.1 启动Activity\"></a>1.1 启动Activity</h3><p>假设有一个 DemoActivity 注册信息如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;demo.DemoActivity&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:exported</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:excludeFromRecents</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;demo.customActionName&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">category</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>exported</code>: 是否对外部 App 可见，默认为 <code>false</code>。隐式启动 Activity 时搜索 ActionName 的范围是当前 App 内，如果允许被其他 App 启动，则需要设置为 <code>true</code>。</li>\n<li><code>excludeFromRecents</code>: 是否在 Activity 进入后台时立即从「最近任务」中移除记录，默认为 <code>false</code>。如果设置为 `true，则该 Activity 一旦进入后台，就会从「最近任务」中删除其记录，不论该 Activity 是否是最后一个或唯一一个活跃的 Activity。</li>\n</ul>\n<p>（1）显式启动 Actiivty：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(context, DemoActivity.class);</span><br><span class=\"line\"><span class=\"comment\">// 直接插入数据</span></span><br><span class=\"line\">intent.putExtra(<span class=\"string\">&quot;key&quot;</span>, value)</span><br><span class=\"line\"><span class=\"comment\">// 通过 Bundle</span></span><br><span class=\"line\">Bundle bundle = <span class=\"keyword\">new</span> Bundle();</span><br><span class=\"line\">bundle.putXXX(String key, XXX value);</span><br><span class=\"line\">intent.putExtra(bundle);</span><br><span class=\"line\"></span><br><span class=\"line\">context.startActivity(intent);</span><br></pre></td></tr></table></figure>\n\n<p>（2）隐式启动 Activity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(<span class=\"string\">&quot;demo.customActionName&quot;</span>);</span><br><span class=\"line\">context.startActivity(intent)</span><br></pre></td></tr></table></figure>\n\n<p>（3）<code>startActivity()</code> 是 Context 中的方法，因此 Activity 或 Application 都可以调用。但如果使用 <code>Application.startActivity()</code> 则需要给 Intent 添加一个 Flag <code>FLAG_ACTIVITY_NEW_TASK</code>，否则会报错：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Activity、Application 都是 Context 抽象类的子类，而 ContextImpl 是 Context 的实现。ActivityThread 在 <code>main()</code> 方法中实例化一个 ComtextImpl 并与 Activity 绑定。</p>\n</blockquote>\n<h3 id=\"1-2-退出Activity\"><a href=\"#1-2-退出Activity\" class=\"headerlink\" title=\"1.2 退出Activity\"></a>1.2 退出Activity</h3><p>Activity 可以通过调用 <code>finish()</code> 退出。当 App 正在退出时，<code>isFinishing() == true</code>，可用于在 <code>onPause()</code> 或 <code>onStop()</code> 中判断该 Activity 是正在退出或只是进入后台。</p>\n<p>同时退出多个 Activity 的方法：</p>\n<ul>\n<li>在所有被开启的 Activity 中注册特定的广播监听，收到该广播时退出自己，并在需要统一退出时发送广播。</li>\n<li>启动新的 Activity 时，使用 <code>startActivityForResult()</code> 替代 <code>startActivity()</code>，并在 <code>onActivityResult()</code> 中将自己 <code>finish()</code>。</li>\n<li>用 List 等记录每个启动的 Activity，并在需要时分别关闭。需要注意的是，使用 List 存放 Activity 有内存泄露的风险，当 Activity 关闭后，要及时清掉对应 List 中的引用。</li>\n<li>启动一个 <code>singleTask</code> 模式的 Activity，或是给 Intent 添加 Flag：<code>FLAG_ACTIVITY_CLEAR_TOP</code>，则系统会在新 Activity 启动后将其上的所有 Activity 销毁。</li>\n</ul>\n<h3 id=\"1-3-Fragment懒加载\"><a href=\"#1-3-Fragment懒加载\" class=\"headerlink\" title=\"1.3 Fragment懒加载\"></a>1.3 Fragment懒加载</h3><p>关键点在于 <code>setUserVisibleHint()</code> 会在 <code>onCreateView</code> 之前执行，当 Fragment 可见状态改变时调用，设置一个标志位表示是否已经加载过，在 <code>setUserVisibleHint()</code> 回调时如果没加载过且可见，则加载数据并将标志位改为已加载。</p>\n<hr>\n<h2 id=\"2-Activity启动模式\"><a href=\"#2-Activity启动模式\" class=\"headerlink\" title=\"2. Activity启动模式\"></a>2. Activity启动模式</h2><p>Activity 有 4 种启动模式：</p>\n<ul>\n<li><code>standard</code></li>\n<li><code>singleTop</code></li>\n<li><code>singleTask</code></li>\n<li><code>singleInstance</code></li>\n</ul>\n<p>需要先了解到，Android 中 Activity 是存在任务栈 Task 中的，启动一个 Activity 时会将其压栈，销毁时弹出，不同启动模式会导致 Activity 任务栈产生不同的行为，且一个 App 进程可以拥有多个 Activity 任务栈。</p>\n<p>Activity 可以通过在 Manifest 中指定 <code>taskAffinity</code> 来指定其 <strong>倾向于</strong> 加入的任务栈，但只有在满足条件时才会添加到该指定任务栈中。Activity 在启动时会先查找是否存在指定的栈，假如存在则会 <strong>「优先尝试」</strong> 压入对应栈，否则才会新建一个栈并启动。如果 Activity 没有指定，则默认等同于 Application 的 taskAffinity，如果 Application 也没有指定，则默认等同于包名。</p>\n<p>但是，<code>taskAffinity</code> 并非 100% 生效；例如 singleInstance 模式启动 Activity 时，其栈内仅允许存在该 Activity；即使其他 Activity 指定同一个 taskAffinity，依然会启动到新的栈中，但这两个栈的 taskAffinity 名称相同；所以判断栈是否相同仍然只能通过 TaskID，而不是 taskAffinity。</p>\n<blockquote>\n<p>下文描述了 Activity 不同启动模式对栈的影响，用 <code>/</code> 表示 <strong>栈底</strong>，<code>&gt;</code> 表示 <strong>栈顶</strong>，任务栈之间用 <code>-</code> 连接，右侧的任务栈为最新任务栈。</p>\n</blockquote>\n<h3 id=\"2-1-Standard\"><a href=\"#2-1-Standard\" class=\"headerlink\" title=\"2.1 Standard\"></a>2.1 Standard</h3><p>（1）Standard 即标准默认模式。启动一个 Activity 时，不论 Activity 在任务栈中是否已经有实例，都新建一个实例并压入任务栈。当前 Activity 在当前任务栈可以有多个实例，每个实例也可以在不同任务栈。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start Standard B</td>\n</tr>\n<tr>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start Standard B</td>\n</tr>\n<tr>\n<td align=\"left\">/ABB&gt;</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"center\">Start Standard A</td>\n</tr>\n<tr>\n<td align=\"left\">/ABBA&gt;</td>\n<td align=\"left\">/ABB&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>（2）Standard 模式通常用于允许一个页面同时创建多个，或者从逻辑上可以保证不会触发多个的情况下。</p>\n<h3 id=\"2-2-SingleTop\"><a href=\"#2-2-SingleTop\" class=\"headerlink\" title=\"2.2 SingleTop\"></a>2.2 SingleTop</h3><p>（1）SingleTop 即栈顶唯一模式，启动一个 Activity 时，如果该 Activity 已在栈顶则不会新建一个 Activity 实例而是复用它，否则其行为和 Standard 模式一致。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start SingleTop B</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTop B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTop A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/ABA&gt;</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"center\">Start SingleTop B</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/ABAB&gt;</td>\n<td align=\"left\">/ABA&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>（2）SingleTop 模式通常用于可能多次弹出的页面。实际上，我认为除非某个 Activity 有明确的需求要打开多个实例，否则都应该使用 SingleTop。因为大多数页面跳转都有可能被误触发多次，但绝大多数情况下都是不希望同时存在多个实例的。</p>\n<h3 id=\"2-3-SingleTask\"><a href=\"#2-3-SingleTask\" class=\"headerlink\" title=\"2.3 SingleTask\"></a>2.3 SingleTask</h3><p>（1）SingleTask 即任务栈唯一模式，启动一个 Activity 时，如果任务栈中存在该 Activity 实例，则复用它，否则才创建一个新的 Activity 实例。SingleTask 和 SingleTop 的区别在于，SingleTop 只在栈顶 Activity 和要启动的 Activity 相同时才复用，而 SingleTask 是每个 Activity 在当前整个任务栈中都只有一个实例。</p>\n<p>此外 SingleTask 还有一个重要特性：当一个 SingleTask 模式 Activity 被从任务栈中间移到栈顶时，会将原本任务栈中位于该 SingleTask Activity 之上的其他 Activity 销毁。需要注意的是，如果新启动一个 SingleTask Activity 并压入任务栈，由于其原本并不在栈中而是直接压入栈顶，因此不会导致栈内其他 Activity 被销毁。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start SingleTask B</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTask B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">Start SingleTask A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start Standard B</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/AB&gt;</td>\n<td align=\"left\">/A&gt;</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>（2）SingleTask 模式常用在 App 的 MainActivity 中，因为大多数情况下 App 在主页面上返回时都应该返回到桌面或退出，而不是返回到其他页面中，因此可以在将 MainActivity 移入栈顶时，直接销毁其他 Activity。</p>\n<h3 id=\"2-4-SingleInstance\"><a href=\"#2-4-SingleInstance\" class=\"headerlink\" title=\"2.4 SingleInstance\"></a>2.4 SingleInstance</h3><p>（1）SingleInstance 即唯一实例模式，启动一个 Activity 时，寻找所有的任务栈，如果某个任务栈中存在该 Activity 实例，则切换到该任务栈，否则新建一个任务栈并创建该 Activity 实例。</p>\n<p>假如有三个 Activity 按照以下关系启动：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">A(Standard) -&gt; B(SingleInstance) -&gt; C(Standard)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>因为 B 是 SingleInstance，所以会创建一个新的栈，并在新的栈中启动 B。</li>\n<li>而 B 启动 C 时，同样由于 B 设置了 SingleInstance 属性，因此会先判断 C 的启动模式，以及 Manifest 中 C 对应的 <code>taskAffinity</code>，如果没有指定，则会把 C 启动在默认栈中，也就是和 A 同一个栈。</li>\n<li>因此如果在 C 中按下返回键，由于 A 和 C 在同一个栈，所以会回到 A，而不是 B。</li>\n</ul>\n<p>重点在于：任务栈不是唯一的，一个 App 可以有多个任务栈，每个任务栈又分别管理包含的 Activity。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"left\">当前任务栈</th>\n<th align=\"left\">如果返回</th>\n<th align=\"center\">执行任务</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td align=\"left\">未启动</td>\n<td align=\"left\">未启动</td>\n<td align=\"center\">Start standard M</td>\n</tr>\n<tr>\n<td>1</td>\n<td align=\"left\">/M&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">Start SingleInstance A</td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">/M&gt; - /A&gt;</td>\n<td align=\"left\">/M&gt;</td>\n<td align=\"center\">Start SingleInstance B</td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">/M&gt; - /A&gt; - /B&gt;</td>\n<td align=\"left\">/M&gt; - /A&gt;</td>\n<td align=\"center\">Start SingleInstance A</td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">/M&gt; - /B&gt; - /A&gt;</td>\n<td align=\"left\">/M&gt; - /B&gt;</td>\n<td align=\"center\">Start Standard C</td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">/B&gt; - /A&gt; - /MC&gt;</td>\n<td align=\"left\">/B&gt; - /A&gt; - /M&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>6</td>\n<td align=\"left\">/B&gt; - /A&gt; - /M&gt;</td>\n<td align=\"left\">/B&gt; - /A&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>7</td>\n<td align=\"left\">/B&gt; - /A&gt;</td>\n<td align=\"left\">/B&gt;</td>\n<td align=\"center\">返回</td>\n</tr>\n<tr>\n<td>8</td>\n<td align=\"left\">/B&gt;</td>\n<td align=\"left\">退出</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p>前 3 步都比较好理解，反正就是整个 App 所有任务栈都只允许有一个实例。重点在从第 4 步开始，由于最开始的 M 是 Standard 模式启动的，而第 4 步中 C 也是 Standard 模式，也就导致本来在最底下的任务栈 <code>/M&gt;</code> 处于最上层任务栈，并将 C 压入了 <code>/M&gt;</code> 所在的这个栈顶，因此从 C 返回的时候会先返回到 M。</p>\n<p>（2）SingleInstance 通常用于某些可被共享唤起的 App，但这些 App 仅有部分页面需要被共享唤起。</p>\n<p>例如：</p>\n<ul>\n<li>电话：其包括了拨号页和来电提醒页，而来电提醒页（通话页）则需要设置为 SingleInstance。</li>\n<li>闹铃：其包括了设置闹钟的页面和响铃提醒的页面，而响铃提醒页面则需要设置为 SingleInstance。</li>\n</ul>\n<p>以电话的来电提醒页为例：</p>\n<ul>\n<li>首先 standard 和 singleTop 是一定不能满足的，否则如果通话期间切到其他 App 后再切回来，就会再次创建一个新的「通话页」。</li>\n<li>而 singleTask 同样存在问题：假如用户通过「拨号页」拨打电话，进入「通话页」后，由于设置了 singleTask，「拨号页」就会被销毁，通话结束后用户就无法再次返回到「拨号页」了。收到来电提醒也是类似的场景。</li>\n<li>如果电话 App 的「拨号页」是启动的但被置到后台，假如用户正在某个 App「Demo」中，此时收到来电进入「通话页」，电话结束后用户当然是期望能返回到原先的「Demo」页面，因此「通话页」必须处于独立的栈中，否则「通话页」结束后返回时，就会回到「拨号页」了。</li>\n</ul>\n<hr>\n<h2 id=\"3-SingleInstance导致的异常现象\"><a href=\"#3-SingleInstance导致的异常现象\" class=\"headerlink\" title=\"3. SingleInstance导致的异常现象\"></a>3. SingleInstance导致的异常现象</h2><p>平时开发在绝大多数时候，都不会给 Activity 设置为 SingleInstance 模式，所以了解不够深入。有一次遇到一个需求，要给 App 开发一套闪屏 SplashActivity 流程，考虑到如下技术方案需求：</p>\n<ul>\n<li>闪屏页是 App 唯一的。</li>\n<li>由于闪屏是很重要的商业化手段，所以希望闪屏页可以在任意一个其他页面存在时被激活到前台。</li>\n<li>闪屏启动结束后，还需要返回到原来的页面（这也明确了不能使用 singleTask）。</li>\n</ul>\n<p>根据这三个需求，自然而然想到了 singleInstance，表面上看似乎完全满足以上条件。另外因为闪屏页会经常在触发某些条件时被唤起，但并不一定每一次都需要真实可见，例如闪屏资源未准备好时就需要直接 <code>finish()</code>，用伪代码表示如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Manifest</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&lt;manifest&gt;</span><br><span class=\"line\">    &lt;activity</span><br><span class=\"line\">        android:name=<span class=\"string\">&quot;demo.SplashActivity&quot;</span></span><br><span class=\"line\">        android:launchMode=<span class=\"string\">&quot;singleInstance&quot;</span>&gt;</span><br><span class=\"line\">        &lt;intent-filter&gt;</span><br><span class=\"line\">            &lt;action android:name=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class=\"line\">            &lt;category android:name=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class=\"line\">        &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;/activity&gt;</span><br><span class=\"line\">    &lt;activity android:name=<span class=\"string\">&quot;demo.MainActivity&quot;</span> /&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SplashActivity</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SplashActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里用 isFirstTime 模拟第一次进入 App 后，会跳转到 MainActivity，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后退到后台再切回来后，即第二次打开时，视为不满足闪屏条件，直接关闭闪屏。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isFirstTime = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isFirstTime) &#123;</span><br><span class=\"line\">            isFirstTime = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            startActivity(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, MainActivity.class));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        finish();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译运行，SplashActivity 正常跳转到 MainActivity，<strong>但此时如果在 MainActivity 点击 Home 键回到桌面，再点击 App 图标，不仅 App 无法唤起，而且最近任务中也没有 App 的记录了。</strong></p>\n<p><img data-src=\"./failed_to_start_app.gif\" alt=\"返回桌面后，点击图标无法启动 Activity，且最近任务记录消失\" title=\"@ASSET\"></p>\n<h3 id=\"3-1-问题定位\"><a href=\"#3-1-问题定位\" class=\"headerlink\" title=\"3.1 问题定位\"></a>3.1 问题定位</h3><p>出现这个现象，我的第一反应就是：两个 Activity 都被杀了，于是分别给两个 Activity 都添加了生命周期的日志，发现打印出来的如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 首次启动 App 后：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onCreate</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onCreate</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onResume</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onDestroy</span><br><span class=\"line\">// 点击 Home 键：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onPause</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onStop</span><br><span class=\"line\">// 点击多任务键，从最近任务中返回 App：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onResume</span><br><span class=\"line\">// 再次点击 Home 键：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onPause</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: MainActivity - onStop</span><br><span class=\"line\">// 点击 App 图标：</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onCreate</span><br><span class=\"line\">priv.luis.launchmodetest D/luis: SplashActivity - onDestroy</span><br></pre></td></tr></table></figure>\n\n<p>从日志上看，MainActivity 自始至终都没有被杀掉。如果仔细看录屏的后半部分，有一次在点击桌面图标之后，App 在一瞬间被拉起来了，然后又自动关闭了。结合点击 App 图标之后的日志来看，很明显是因为点击 App 图标后启动的是 <code>SplashActivity</code>，由于 <code>isFirstTime == false</code> 所以直接执行了 <code>finish()</code>。</p>\n<ul>\n<li>但是为什么 MainActivity 无法启动呢？难道是因为给 <code>SplashActivity</code> 设置了 <code>singleInstance</code> 吗？但即使改为给 <code>MainActivity</code> 设置 <code>singleInstance</code>，依然是同样的现象。</li>\n<li>为什么第一次点 Home 键返回桌面，最近任务中有 App 的记录，但是从桌面点击了 App 图标之后，即使 MainActivity 仍然存活，但最近任务中就没有 App 记录了呢？</li>\n<li>难道是 Application 被强制 Kill 掉了，以至于连 Log 的机会都没有吗？</li>\n</ul>\n<p>再次重复整个步骤，并且每一步都通过 ADB 查看当前 Activity 栈信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// （1）首次打开 APP，MainActivity 处于前台，Launcher 处于后台。</span></span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\"><span class=\"function\">  TaskRecord</span>&#123;392952a #<span class=\"number\">745</span> A=.abc U=<span class=\"number\">0</span> StackId=<span class=\"number\">744</span> sz=<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    Run #<span class=\"number\">0</span>: ActivityRecord&#123;a4f60c2 u0 priv.luis.launchmodetest/.MainActivity t745&#125;</span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\"><span class=\"function\">  TaskRecord</span>&#123;cf7cd87 #<span class=\"number\">2</span> I=com.google.android.apps.nexuslauncher/.NexusLauncherActivity U=<span class=\"number\">0</span> StackId=<span class=\"number\">0</span> sz=<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    Run #<span class=\"number\">0</span>: ActivityRecord&#123;5dab3ba u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivity t2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （2）点击 Home 键回到 Launcher，MainActivity 处于后台。</span></span><br><span class=\"line\"><span class=\"comment\">// 此时多任务中 App 记录正常显示，停留在 MainActivity 界面。</span></span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\"><span class=\"function\">  TaskRecord</span>&#123;cf7cd87 #<span class=\"number\">2</span> I=com.google.android.apps.nexuslauncher/.NexusLauncherActivity U=<span class=\"number\">0</span> StackId=<span class=\"number\">0</span> sz=<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    Run #<span class=\"number\">0</span>: ActivityRecord&#123;5dab3ba u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivity t2&#125;</span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\"><span class=\"function\">  TaskRecord</span>&#123;392952a #<span class=\"number\">745</span> A=.abc U=<span class=\"number\">0</span> StackId=<span class=\"number\">744</span> sz=<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    Run #<span class=\"number\">0</span>: ActivityRecord&#123;a4f60c2 u0 priv.luis.launchmodetest/.MainActivity t745&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// （3）点击 App 图标，App 未被唤起，仍然停留在桌面。</span></span><br><span class=\"line\"><span class=\"comment\">// 此时 多任务中 App 记录已经消失。</span></span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\"><span class=\"function\">  TaskRecord</span>&#123;cf7cd87 #<span class=\"number\">2</span> I=com.google.android.apps.nexuslauncher/.NexusLauncherActivity U=<span class=\"number\">0</span> StackId=<span class=\"number\">0</span> sz=<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    Run #<span class=\"number\">0</span>: ActivityRecord&#123;5dab3ba u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivity t2&#125;</span><br><span class=\"line\"><span class=\"function\">Running <span class=\"title\">activities</span> <span class=\"params\">(most recent first)</span>:</span></span><br><span class=\"line\"><span class=\"function\">  TaskRecord</span>&#123;96b6b62 #<span class=\"number\">750</span> A=.abc U=<span class=\"number\">0</span> StackId=<span class=\"number\">749</span> sz=<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    Run #<span class=\"number\">0</span>: ActivityRecord&#123;e949a28 u0 priv.luis.launchmodetest/.MainActivity t750&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WTF？<code>MainActivity</code> 竟然还存活着，说明 App 并没有被杀死，然而最近任务并没有任何记录！</p>\n<h3 id=\"3-2-原因分析\"><a href=\"#3-2-原因分析\" class=\"headerlink\" title=\"3.2 原因分析\"></a>3.2 原因分析</h3><p>首先尝试反向验证，在 SplashActivity 启动 MainActivity 的 Intent 中添加两个 Flag，并且去掉 SplashActivity 中 <code>finish()</code> 的逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Manifest</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&lt;manifest&gt;</span><br><span class=\"line\">    &lt;activity</span><br><span class=\"line\">        android:name=<span class=\"string\">&quot;demo.SplashActivity&quot;</span></span><br><span class=\"line\">        android:launchMode=<span class=\"string\">&quot;singleInstance&quot;</span>&gt;</span><br><span class=\"line\">        &lt;intent-filter&gt;</span><br><span class=\"line\">            &lt;action android:name=<span class=\"string\">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class=\"line\">            &lt;category android:name=<span class=\"string\">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class=\"line\">        &lt;/intent-filter&gt;</span><br><span class=\"line\">    &lt;/activity&gt;</span><br><span class=\"line\">    &lt;activity android:name=<span class=\"string\">&quot;demo.MainActivity&quot;</span> /&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SplashActivity</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SplashActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里用 isFirstTime 模拟第一次进入 App 后，会跳转到 MainActivity，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后退到后台再切回来后，即第二次打开时，视为不满足闪屏条件，直接关闭闪屏。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isFirstTime = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里延迟 2 秒，只是为了让 SplashActivity 的界面加载出来，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这样在最近任务中能看的更清晰，否则可能无法生成 Activity 的缩略图。</span></span><br><span class=\"line\">        mainHandler.postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isFirstTime) &#123;</span><br><span class=\"line\">                    isFirstTime = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    Intent intent = <span class=\"keyword\">new</span> Intent(SplashActivity.<span class=\"keyword\">this</span>, MainActivity.class);</span><br><span class=\"line\">                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);</span><br><span class=\"line\">                    intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK);</span><br><span class=\"line\">                    startActivity(intent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不再退出 SplashActivity</span></span><br><span class=\"line\">        <span class=\"comment\">// finish();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次尝试，即可在最近任务中看到 MainActivity 从启动后就一直存在未被销毁，只不过因为 App 进入后台后，点击图标启动时每次启动的都是 SplashActivity，且直接走了 <code>finishi()</code> 的逻辑（如果删除 <code>finish()</code> 的逻辑，就会停留在 SplashActivity 界面中），所以一直没有机会被唤醒而已：</p>\n<p><img data-src=\"./show_in_recent_task.gif\" alt=\"在最近任务中显示 MainActivity 的记录\" title=\"@ASSET\"></p>\n<h3 id=\"3-3-SingleInstance对Activity栈的影响\"><a href=\"#3-3-SingleInstance对Activity栈的影响\" class=\"headerlink\" title=\"3.3 SingleInstance对Activity栈的影响\"></a>3.3 SingleInstance对Activity栈的影响</h3><p>（1）思考一个问题，从一个 App 返回到桌面（App 在后台）后，「点击 App 图标打开」和「从最近任务列表打开」有什么不同？</p>\n<p>答案如下：</p>\n<ul>\n<li>Android 的桌面（或者应用列表）本身也是一个 Activity（Launcher），因此从桌面点击 App 图标打开一个 Activity，本质上也是一个 Activity 通过 <code>startActivity()</code> 启动另一个 Activity 的过程，只不过此时会默认给 Intent 添加一个 <code>FLAG_ACTIVITY_NEW_TASK</code> 的 Flag，作用是先查找目标 Activity 指定的 <code>taskAffinity</code> 栈是否存在，如果存在就会直接唤起这个栈。</li>\n<li>Android 在通过点击 App 图标启动时，启动的是 Manifest 中指定了 <code>android.intent.category.LAUNCHER</code> 属性的 Activity，而最近任务列表中显示的则是 App 最后活跃的栈中的栈顶 Activity。</li>\n</ul>\n<p>（2）因此，对上文 4.1 节的异常现象完整回放整个 App 的 Activity 栈状态。其中，用 <code>/</code> 表示一个栈的栈底，用 <code>&gt;</code> 表示一个栈的栈顶，用 <code>***</code> 表示会被显示在最近任务记录中的栈，且最后活跃的栈位于最上方：</p>\n<ol>\n<li><p>首次点击 App 图标打开 App，打开的是作为 <code>android.intent.category.LAUNCHER</code> 的 SplashActivity：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ SplashActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SplashActivity 启动 MainActivity，由于 SplashActivity 是 singleInstance 模式而独享一个栈，因此 MainActivity 被启动到新建的栈中：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ MainActivity &gt; ***</span><br><span class=\"line\">/ SplashActivity &gt;</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SplashActivity 调用 <code>finish()</code>，由于退出后其栈内所有 Activity 均已退出，所以该栈也被清理销毁：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ MainActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 MainActivity 中点击 Home 键返回桌面，MainActivity 及其栈进入后台：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ Laucher &gt;</span><br><span class=\"line\">/ MainActivity &gt; ***</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据栈状态可知，此时最近任务中记录的是 MainActivity 及其栈，因此从最近任务中点击进入，也自然会激活 MainActivity：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ MainActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再次点击 Home 键回到桌面，MainActivity 再次进入后台：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ Laucher &gt;</span><br><span class=\"line\">/ MainActivity &gt; ***</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>点击 App 图标打开 App，Launcher 通过 Manifest 定义的 <code>android.intent.category.LAUNCHER</code> 打开 SplashActivity，由于设置了 <code>singleInstance</code>，所以新建一个栈并在其中打开 SplashActivity：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ SplashActivity &gt; ***</span><br><span class=\"line\">/ Launcher &gt;</span><br><span class=\"line\">/ MainActivity &gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>SplashActivity 执行了 <code>finish()</code>，并且由于栈内所有 Activity 均已销毁，该栈也被清理销毁：</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">/ Launcher &gt;</span><br><span class=\"line\">/ MainActivity &gt;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>正是这一步将最近任务中的 App 记录清理了。因为默认情况下，一个 App 只在最近任务中记录一个栈，也就是最后活跃的栈，这个栈一旦被销毁，又没有其他栈被激活，则 App 记录就会从最近任务中删除。</strong></p>\n</li>\n</ol>\n","categories":["Android"],"tags":["Android","四大组件","Activty","taskAffinity","启动模式","生命周期","SingleInstance"]},{"title":"Android-ANR","url":"/post/android/android-anr/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-ANR\"><a href=\"#Android-ANR\" class=\"headerlink\" title=\"Android-ANR\"></a>Android-ANR</h1><p>ANR（Application Not Responding）出现的原因有：</p>\n<p>（1）输入事件（如触摸和按键等）在 5s 内未响应。</p>\n<p>（2）BroadcastReceiver 在规定时间内（前台广播 10s，后台广播 60s）未执行完 <code>onReceive()</code>，因此在 <code>onReceive()</code> 中不要执行耗时操作。</p>\n<p>（3）Service 在规定时间内（前台服务 20s，后台服务 10s）未完成启动（<code>onCreate()</code>）。</p>\n<p>（4）ContentProvider 在 10s 内未完成启动（<code>onCreate()</code>）。</p>\n<p>发生 ANR 时，Android 会在 <code>/data/anr/</code> 下生成一个 <code>traces.txt</code>，可通过 Adb 命令导出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">adb pull data/anr/traces.txt</span></span><br></pre></td></tr></table></figure>\n\n<p>打开文本，找到对应的进程名，在下面查找发生 ANR 相关的类、方法。</p>\n<p>也有可能是 CPU 满负载、IO 阻塞、内存泄漏等等。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&mid=2649498893&idx=1&sn=3836d5e2231a84506b816b4b317cfc16\" title=\"@LINK\">ANR 弹窗的显示原理</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzIzOTkwMDY5Nw==&mid=2247488218&idx=1&sn=412e3d0c1533b2f42f6103ecb3f3a3c9\" title=\"@LINK\">卡顿、ANR、死锁，线上如何监控？</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","ANR"]},{"title":"Android-Activity启动流程","url":"/post/android/android-activity_startup/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Activity启动流程\"><a href=\"#Android-Activity启动流程\" class=\"headerlink\" title=\"Android-Activity启动流程\"></a>Android-Activity启动流程</h1><h2 id=\"1-Activity启动入口\"><a href=\"#1-Activity启动入口\" class=\"headerlink\" title=\"1. Activity启动入口\"></a>1. Activity启动入口</h2><p>操作系统启动后，第一个启动的就是 <code>init</code> 进程，<code>init</code> 进程会启动 <code>Zygote</code>、<code>ServiceManager</code> 等基本进程。随后 Zygot 创建并初始化 system_service，system_service 会分裂出 AMS 等各项系统服务。当启动一个 App 时，实际流程是：</p>\n<ul>\n<li>Launcher 通过 IPC 通知 AMS。</li>\n<li>AMS 通知 system_service。</li>\n<li>system_service 通知 Zygote。</li>\n<li>Zygote 收到通知后 Fork 出子进程。</li>\n<li>子进程在 <code>Process#start()</code> 中通过反射调用 <code>ActivityThread.main()</code>。</li>\n</ul>\n<p>App 进程的入口在 <code>ActivityThread#main()</code>，包括初始化操作系统、用户环境、启动主线程 Looper 等。<code>ActivityThread$ActivityClientRecord</code> 以容器的形式持有了一个 Activity，以及管理这个 Activity 相关的其他资源，并且与持有的 Activity 是一一对应的，系统大多都是通过 ActivityClientRecord 操作 Activity 来管理和调度 Activity。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Activity client record, used for bookkeeping for the real &#123;<span class=\"doctag\">@link</span> Activity&#125; instance. */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityClientRecord</span> </span>&#123;</span><br><span class=\"line\">        Activity activity;</span><br><span class=\"line\">        Window window;</span><br><span class=\"line\">        Activity parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</span><br><span class=\"line\">        thread.attach(<span class=\"keyword\">false</span>, startSeq);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动一个 Activity 的入口，在 API 29 开始与之前版本有不同。在 API 29 之前的版本，ActivityThread 内部持有的一个 Handler 对象 <code>H</code> 监听了 <code>LAUNCH_ACTIVITY</code> 事件，并在收到 <code>LAUNCH_ACTIVITY</code> 请求后会调用 <code>handleLaunchActivity(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// API 29 移除了 LAUNCH_ACTIVITY 这个条件分支，</span></span><br><span class=\"line\">            <span class=\"comment\">// 而是放在 BIND_APPLICATION 中处理。</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class=\"line\">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class=\"line\"></span><br><span class=\"line\">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class=\"line\">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class=\"line\">                handleLaunchActivity(r, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;LAUNCH_ACTIVITY&quot;</span>);</span><br><span class=\"line\">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但在 API 29 以上版本已经移除了这个分支，下文基于 API 29 分析。</p>\n<h3 id=\"1-1-ActivityThread初始化\"><a href=\"#1-1-ActivityThread初始化\" class=\"headerlink\" title=\"1.1 ActivityThread初始化\"></a>1.1 ActivityThread初始化</h3><p>首先在入口方法 <code>ActivityThread#main()</code> 中，有一个关键步骤 <code>thread.attach(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部类 ApplicationThread 继承自 AIDL 类 IApplicationThread#Stub</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ApplicationThread mAppThread = <span class=\"keyword\">new</span> ApplicationThread();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(<span class=\"keyword\">boolean</span> system, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!system) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mgr 就是 AMS 的远程 AIDL 接口</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityManagerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IActivityManager</span>.<span class=\"title\">Stub</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Watchdog</span>.<span class=\"title\">Monitor</span>, <span class=\"title\">BatteryStatsImpl</span>.<span class=\"title\">BatteryCallback</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ActivityTaskManagerInternal 抽象类只有一个实现类：ActivityTaskManagerService$LocalService</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ActivityTaskManagerInternal mAtmInternal;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attachApplication</span><span class=\"params\">(IApplicationThread thread, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(IApplicationThread thread,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> callingUid, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// AMS 通过 ApplicationThread 这个 AIDL Proxy 和 App 进程的 ActivityThread 通信</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (app.isolatedEntryPoint != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// This is an isolated process which should just call an entry point instead of being bound to an application.</span></span><br><span class=\"line\">                thread.runIsolatedEntryPoint(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (instr2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                thread.bindApplication(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                thread.bindApplication(...);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试启动 Activity</span></span><br><span class=\"line\">        <span class=\"comment\">// See if the top visible activity is waiting to run in this process...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (normalMode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                Slog.wtf(TAG, <span class=\"string\">&quot;Exception thrown launching activities in &quot;</span> + app, e);</span><br><span class=\"line\">                badApp = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 AMS 调用 <code>attachApplication(...)</code> 后主要分为两个步骤：</p>\n<ul>\n<li>调用 <code>ActivityThread$ApplicationThread#bindApplication(...)</code></li>\n<li>调用 <code>ActivityTaskManagerService$LocalService#attachApplication(...)</code></li>\n</ul>\n<h3 id=\"1-2-创建和绑定Application\"><a href=\"#1-2-创建和绑定Application\" class=\"headerlink\" title=\"1.2 创建和绑定Application\"></a>1.2 创建和绑定Application</h3><p><code>AMS#attachApplication(...)</code> 内第 1 步执行 <code>ApplicationThread.bindApplication(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">IApplicationThread</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bindApplication</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// AppBindData 提供绑定 Application 对象的信息，例如 Process, Instrumentation, AppInfo 等。</span></span><br><span class=\"line\">            AppBindData data = <span class=\"keyword\">new</span> AppBindData();</span><br><span class=\"line\">            <span class=\"comment\">// 向 ActivityThread 的 Handler 发送了一条 BIND_APPLICATION 请求，回到 App 进程</span></span><br><span class=\"line\">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BIND_APPLICATION: &#123;</span><br><span class=\"line\">                AppBindData data = (AppBindData)msg.obj;</span><br><span class=\"line\">                handleBindApplication(data);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleBindApplication</span><span class=\"params\">(AppBindData data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 回调 Application#onCreate()</span></span><br><span class=\"line\">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-进入Activity启动事务\"><a href=\"#1-3-进入Activity启动事务\" class=\"headerlink\" title=\"1.3 进入Activity启动事务\"></a>1.3 进入Activity启动事务</h3><p><code>AMS#attachApplication(...)</code> 内第 2 步执行 <code>mAtmInternal.attachApplication(...)</code>，是启动 Activity 的起点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityTaskManagerService</span> <span class=\"keyword\">extends</span> <span class=\"title\">IActivityTaskManager</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalService</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActivityTaskManagerInternal</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplication</span><span class=\"params\">(WindowProcessController wpc)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mRootActivityContainer.attachApplication(wpc);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RootActivityContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ConfigurationContainer</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">DisplayManager</span>.<span class=\"title\">DisplayListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ActivityStackSupervisor mStackSupervisor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">attachApplication</span><span class=\"params\">(WindowProcessController app)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 结束 Application 启动流程，正式进入 Activity 启动流程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mStackSupervisor.realStartActivityLocked(activity, app,</span><br><span class=\"line\">                top == activity <span class=\"comment\">/* andResume */</span>, <span class=\"keyword\">true</span> <span class=\"comment\">/* checkConfig */</span>)) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-1-初始化Activity启动事务\"><a href=\"#1-3-1-初始化Activity启动事务\" class=\"headerlink\" title=\"1.3.1 初始化Activity启动事务\"></a>1.3.1 初始化Activity启动事务</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityStackSupervisor</span> <span class=\"keyword\">implements</span> <span class=\"title\">RecentTasks</span>.<span class=\"title\">Callbacks</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 proc.getThread 就是 IApplicationThread</span></span><br><span class=\"line\">        <span class=\"comment\">// Create activity launch transaction.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class=\"line\">                proc.getThread(), r.appToken);</span><br><span class=\"line\">        <span class=\"comment\">// 注意入参是 LaunchActivityItem 对象</span></span><br><span class=\"line\">        clientTransaction.addCallback(LaunchActivityItem.obtain(...));</span><br><span class=\"line\">        <span class=\"comment\">// Set desired final state.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class=\"line\">        <span class=\"comment\">// 如果是 App 启动则 andResume == true，表示需要让首个 Activity 进入 Resume 状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (andResume) &#123;</span><br><span class=\"line\">            lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            lifecycleItem = PauseActivityItem.obtain();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// mService 是 ClientLifecycleManager 对象</span></span><br><span class=\"line\">        <span class=\"comment\">// Schedule transaction.</span></span><br><span class=\"line\">        mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ActivityStackSupervisor 生成了一个 ClientTransaction 对象，用于记录客户端要处理的事务（也就是 Activity 启动）：</p>\n<ul>\n<li>给 ClientTransaction 添加 Callback，传入 LaunchActivityItem 类型的对象。</li>\n<li>给 ClientTransaction 设置生命周期状态流转请求，传入 ResumeActivityItem 类型的对象，表示目标是流转到 onResume 状态。</li>\n<li>调用 <code>ClientLifecycleManager#scheduleTransaction</code> 提交 ClientTransaction 启动事务。</li>\n</ul>\n<h4 id=\"1-3-2-提交Activity启动事务\"><a href=\"#1-3-2-提交Activity启动事务\" class=\"headerlink\" title=\"1.3.2 提交Activity启动事务\"></a>1.3.2 提交Activity启动事务</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientLifecycleManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IApplicationThread client = transaction.getClient();</span><br><span class=\"line\">        transaction.schedule();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientTransaction</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span>, <span class=\"title\">ObjectPoolItem</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IApplicationThread mClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Obtain an instance initialized with provided params. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ClientTransaction <span class=\"title\">obtain</span><span class=\"params\">(IApplicationThread client, IBinder activityToken)</span> </span>&#123;</span><br><span class=\"line\">        ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> ClientTransaction();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 入参的 client 就是 ApplicationThread，存到成员变量 mClient 中</span></span><br><span class=\"line\">        instance.mClient = client;</span><br><span class=\"line\">        instance.mActivityToken = activityToken;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 回到 ActivityThread#ApplicationThread 中</span></span><br><span class=\"line\">        mClient.scheduleTransaction(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApplicationThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">IApplicationThread</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实际是调用父类 ClientTransactionHandler 中的方法</span></span><br><span class=\"line\">            ActivityThread.<span class=\"keyword\">this</span>.scheduleTransaction(transaction);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        transaction.preExecute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发送 Message 到 ActivityThread，回到 App 进程</span></span><br><span class=\"line\">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，ClientTransaction, ClientLifecycleManager, ActivityThread 都并不直接执行事务：</p>\n<ul>\n<li>ClientTransaction 只用于记录事务。</li>\n<li>ClientLifecycleManager 调用 <code>scheduleTransaction(...)</code> 只是提交事务。</li>\n<li>ActivityThread 调用父类方法 <code>ClientTransactionHandler#scheduleTransaction(...)</code> 也只是提交事务。</li>\n</ul>\n<p>真正用于执行事务的是 ActivityThread 的成员变量：<code>TransactionExecutor mTransactionExecutor</code>。</p>\n<h4 id=\"1-3-3-执行Actviity启动事务\"><a href=\"#1-3-3-执行Actviity启动事务\" class=\"headerlink\" title=\"1.3.3 执行Actviity启动事务\"></a>1.3.3 执行Actviity启动事务</h4><p>上文中 ClientTransactionHandler 发送了 <code>EXECUTE_TRANSACTION</code> 消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入参传入了自己，TransactionExecutor 才是真正的事务「执行器」。</span></span><br><span class=\"line\">    <span class=\"comment\">// An executor that performs multi-step transactions.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TransactionExecutor mTransactionExecutor = <span class=\"keyword\">new</span> TransactionExecutor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">H</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> EXECUTE_TRANSACTION: &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class=\"line\">                mTransactionExecutor.execute(transaction);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ActivityThread 在成员变量初始化时把自己传进来，所以 mTransactionHandler 就是 ActivityThread 本身。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClientTransactionHandler mTransactionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Initialize an instance with transaction handler, that will execute all requested actions. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TransactionExecutor</span><span class=\"params\">(ClientTransactionHandler clientTransactionHandler)</span> </span>&#123;</span><br><span class=\"line\">        mTransactionHandler = clientTransactionHandler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于回调 onCreate()</span></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 用于流转到 onStart(), onResume()</span></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Cycle through all states requested by callbacks and execute them at proper times. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeCallbacks</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// transaction.getCallbacks() 获取的 Callback 实际是之前 ActivityStackSupervisor#realStartActivityLocked 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// ClientTransaction.addCallback(LaunchActivityItem) 传入的 LaunchActivityItem。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (...) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class=\"line\">            item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">            item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Transition to the final state if requested by the transaction. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>TransactionExecutor#execute(ClientTransaction)</code> 分为两个步骤：</p>\n<ul>\n<li><code>executedCallbacks(ClientTransaction)</code> 用于使 Activity 进入 onCreate 状态。</li>\n<li><code>executeLifecycleState(ClientTransaction)</code> 用于使 Activity 生命周期流转到 onResume 状态。</li>\n</ul>\n<h3 id=\"1-4-Activity启动事务总结\"><a href=\"#1-4-Activity启动事务总结\" class=\"headerlink\" title=\"1.4 Activity启动事务总结\"></a>1.4 Activity启动事务总结</h3><p>Activity 的启动事务可以分成两大块：Application 的初始化、Activity 启动事务的初始化。</p>\n<p>（1）Application 初始化：</p>\n<ul>\n<li>AMS 调用 ActivityThread 的 <code>main()</code> 方法启动。</li>\n<li><code>main()</code> 方法中创建一个 ActivityThread 对象，并调用 <code>ActivityThread#attach(...)</code>，内部获取 AMS 并与自己的内部类对象 ApplicationThread 绑定。</li>\n<li>绑定成功后，AMS 向 ActivityThread 发送 <code>BIND_APPLICATION</code> 消息，ActivityThread 回调 Application 的 onCreate 生命周期。</li>\n<li>ActivityThread 调用 <code>ActivityTaskManagerService#attachApplication(...)</code>，尝试启动 Activity。</li>\n<li>ActivityTaskManagerService 调用 <code>RootActivityContainer#attachApplication(...)</code>。</li>\n</ul>\n<p>（2）Activity 启动事务初始化：</p>\n<ul>\n<li>RootActivityContainer 调用 <code>ActivityStackSupervisor#realStartActivityLocked(...)</code>。</li>\n<li>ActivityStackSupervisor 创建 ClientTransaction 实例，传入 ApplicationThread，并调用 <code>ClientTransaction#addCallback(LaunchActivityItem)</code> 和 <code>ClientTransaction#setLifecycleStateRequest(ResumeActivityItem)</code></li>\n<li>ActivityStackSupervisor 调用 <code>ClientLifecycleManager#scheduleTransaction(...)</code>，并传入之前创建的 ClientTransaction 对象。</li>\n<li>ClientLifecycleManager 调用 <code>ClientTransaction#schedule()</code>。</li>\n<li>ClientTransaction 调用 <code>ApplicationThread#scheduleTransaction(...)</code>。</li>\n<li>ActivityThread 调用父类的 <code>ClientTransactionHandler#scheduleTransaction(...)</code> 发送一条 <code>EXECUTE_TRANSACTION</code> 消息。</li>\n<li>ActivityThread 收到消息后调用 <code>TransactionExecutor#execute(ClientTransaction)</code>。</li>\n<li>TransactionExecutor 分别调用 <code>executeCallbacks(ClientTransaction)</code>（对应 onCreate）和 <code>executeLifecycleState(ClientTransaction)</code>（对应 onStart 和 onResume）。</li>\n</ul>\n<p>从 TransactionExecuotr 正式调用 <code>execute(...)</code> 执行事务开始，Activity 才正式进入生命周期流转阶段。</p>\n<hr>\n<h2 id=\"2-Activity生命周期流转\"><a href=\"#2-Activity生命周期流转\" class=\"headerlink\" title=\"2. Activity生命周期流转\"></a>2. Activity生命周期流转</h2><h3 id=\"2-1-onCreate\"><a href=\"#2-1-onCreate\" class=\"headerlink\" title=\"2.1 onCreate\"></a>2.1 onCreate</h3><p>按照上文中 <code>TransactionExecutor#execute(ClientTransaction)</code> 的调用顺序，先执行 <code>executedCallbacks(ClientTransaction)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于回调 onCreate()</span></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 用于流转到 onStart(), onResume()</span></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeCallbacks</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过上文可以知道，callback 就是 LaunchActivityItem</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (...) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class=\"line\">            <span class=\"comment\">// 所以实际上调用的是 LaunchActivityItem#execute</span></span><br><span class=\"line\">            item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">            item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LaunchActivityItem</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 client 就是 ActivityThread</span></span><br><span class=\"line\">        Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class=\"string\">&quot;activityStart&quot;</span>);</span><br><span class=\"line\">        ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord(...);</span><br><span class=\"line\">        <span class=\"comment\">// 重点就是这一步调用的 ActivityThread#handleLaunchActivity</span></span><br><span class=\"line\">        client.handleLaunchActivity(r, pendingActions, <span class=\"keyword\">null</span> <span class=\"comment\">/* customIntent */</span>);</span><br><span class=\"line\">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此后才与 API 29 以下版本的逻辑重合。</p>\n<h4 id=\"2-1-1-handleLaunchActivity\"><a href=\"#2-1-1-handleLaunchActivity\" class=\"headerlink\" title=\"2.1.1 handleLaunchActivity()\"></a>2.1.1 handleLaunchActivity()</h4><p><code>LaunchActivityItem#execute(...)</code> 创建了一个 ActivityClientRecord 对象用于持有目标 Activity 以及一些相关资源，再通过 <code>ActivityThread.handleLaunchActivity(...)</code> 创建并启动目标 Activity：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Extended implementation of activity launch. Used when server requests a launch or relaunch.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">handleLaunchActivity</span><span class=\"params\">(ActivityClientRecord r,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 关键步骤 performLaunchActivity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ActivityTaskManager.getService().finishActivity(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>handleLaunchActivity(...)</code> 主要是调用 <code>performLaunchActivity(...)</code> 生成一个 Activity 实例对象，并在生成失败时直接通知 ActivityTaskManagerService 结束该 Activity，或是抛出一个异常，中断后续流程。</p>\n<h4 id=\"2-1-2-performLaunchActivity\"><a href=\"#2-1-2-performLaunchActivity\" class=\"headerlink\" title=\"2.1.2 performLaunchActivity()\"></a>2.1.2 performLaunchActivity()</h4><p><code>performLaunchActivity(...)</code> 是实际创建 Activity 的方法，过程中调用了一个重要方法 <code>Activity#attach</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        Window window = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.mPendingRemoveWindow != <span class=\"keyword\">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从 ActivityClientRecord 中取出了一个 Window</span></span><br><span class=\"line\">            window = r.mPendingRemoveWindow;</span><br><span class=\"line\">            r.mPendingRemoveWindow = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.mPendingRemoveWindowManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这个方法是重点，并且注意参数中传入了上面从 ActivityClientRecord 中取出的 Window</span></span><br><span class=\"line\">        activity.attach(...);</span><br><span class=\"line\">        <span class=\"comment\">// 通知 Instrumentation 回调 Activity 的 onCreate()</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在冷启 Activity 时，ActivityClientRecord 是在 <code>LaunchActivityItem#execute(...)</code> 中被 <code>new</code> 出来的，所以 <code>r.mPendingRemoveWindow</code> 肯定是 <code>null</code>，那什么时候才能进入 <code>if</code> 的条件呢？换句话说，什么时候 <code>ActivityThread#performLaunchActivity(...)</code> 传入的 ActivityClientRecord 中 <code>mPendingRemoveWindow != null</code> 呢？查找一下 ActivityClientRecord 中 <code>mPendingRemoveWindow</code> 写入的地方，发现在 <code>handleDestroyActivity(...)</code> 中有这么一段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDestroyActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finishing, <span class=\"keyword\">int</span> configChanges,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"keyword\">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = performDestroyActivity(...);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            View v = r.activity.mDecor;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 核心逻辑：</span></span><br><span class=\"line\">                        <span class=\"comment\">// Hold off on removing this until the new activity&#x27;s</span></span><br><span class=\"line\">                        <span class=\"comment\">// window is being added.</span></span><br><span class=\"line\">                        r.mPendingRemoveWindow = r.window;</span><br><span class=\"line\">                        r.mPendingRemoveWindowManager = wm;</span><br><span class=\"line\">                        <span class=\"comment\">// We can only keep the part of the view hierarchy that we control,</span></span><br><span class=\"line\">                        <span class=\"comment\">// everything else must be removed, because it might not be able to</span></span><br><span class=\"line\">                        <span class=\"comment\">// behave properly when activity is relaunching.</span></span><br><span class=\"line\">                        r.window.clearContentView();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        wm.removeViewImmediate(v);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码注释就能明白，当一个 Activity 销毁时，会在其 ActivityVlientRecord 中把自己的 Window 保存到 mPendingRemoveWindow 中，然后移除 Window 中所有 View，直到新的 Activity 的 Window 被添加为止：</p>\n<ul>\n<li>在 <code>handleRelaunchActivityInner(...)</code> 中，先调用了 <code>handleDestroyActivity(...)</code>，这一步就把当前 Activity 的 Window 存进了 <code>mPendingRemoveWindow</code></li>\n<li>接下来调用了 <code>handleLaunchActivity(...)</code></li>\n<li>然后在其内部调用了 <code>performLaunchActivity(...)</code></li>\n</ul>\n<p>这下明白了，当一个 Activity 被系统回收等等场景销毁时，有可能接下来又会回到这个 Activity，这种情况下就可以先把 Window 缓存下来，当自己这个 Activity 再次被激活时，就可以直接复用 Activity 上一次的 Window 而不需要从新分配。当然，由于 <code>r.window.clearContentView();</code>，Window 中的 View 被清空了，所以还是需要重新走一遍视图加载。这样做的好处也许是在效率和内存消耗中的一种折中，或许是因为 View 会占用很大内存，所以需要回收 View，但 Window 本身占用较少，每次都回收再让系统重新分配可能比缓存占用的内存更多、或者可能带来更大的内存抖动风险，所以选择临时缓存。继续查看 <code>Activity.attach(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过上文可知，冷启 Activity 时传入的 window 是 null，如果是 performRelaunchActivity 则会传入 Activity 上一次销毁前缓存下来的 window。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context, ActivityThread aThread,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Instrumentation instr, IBinder token, <span class=\"keyword\">int</span> ident,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            CharSequence title, Activity parent, String id,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个 Window 实例，这里 mWindow 是 Window 类型的接口对象，该接口只有 PhoneWindow 唯一一个实例对象，</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且当新启动一个 Activity 时，这里传入的 window 也是 null。</span></span><br><span class=\"line\">        mWindow = <span class=\"keyword\">new</span> PhoneWindow(<span class=\"keyword\">this</span>, window, activityConfigCallback);</span><br><span class=\"line\">        mUiThread = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统服务创建一个 WindowManager 的实例 WindowManagerImpl，并存进 mWindow (PhoneWindow) 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// 此外还存入了 IBinder 类型的 token，可以理解为用于在后续 App 创建 Window 时的授权。</span></span><br><span class=\"line\">        mWindow.setWindowManager(</span><br><span class=\"line\">                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class=\"line\">                mToken, mComponent.flattenToString(),</span><br><span class=\"line\">                (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mWindow.setContainer(mParent.getWindow());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 同时也把上面创建的 WindowManager 存入 Activity 内。</span></span><br><span class=\"line\">        mWindowManager = mWindow.getWindowManager();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> <span class=\"keyword\">implements</span> <span class=\"title\">MenuBuilder</span>.<span class=\"title\">Callback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructor for main window of an activity.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PhoneWindow</span><span class=\"params\">(Context context, Window preservedWindow,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里的判断条件，是需要 preservedWindow != null 才去初始化 DecorView。</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是新启动一个 Activity，传进来的 preservedWindow == null，是不会走这个逻辑的。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (preservedWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mDecor = (DecorView) preservedWindow.getDecorView();</span><br><span class=\"line\">            mElevation = preservedWindow.getElevation();</span><br><span class=\"line\">            mLoadElevation = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            mForceDecorInstall = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// If we&#x27;re preserving window, carry over the app token from the preserved</span></span><br><span class=\"line\">            <span class=\"comment\">// window, as we&#x27;ll be skipping the addView in handleResumeActivity(), and</span></span><br><span class=\"line\">            <span class=\"comment\">// the token will not be updated as for a new window.</span></span><br><span class=\"line\">            getAttributes().token = preservedWindow.getAttributes().token;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此 <code>Activity.attach()</code> 执行完毕，接下来会由 Instrumentation 回调 <code>Activity.onCreate()</code>，表示 Activity 走到了 <code>onCreate()</code> 的生命周期。</p>\n<h4 id=\"2-1-3-onCreate总结\"><a href=\"#2-1-3-onCreate总结\" class=\"headerlink\" title=\"2.1.3 onCreate总结\"></a>2.1.3 onCreate总结</h4><p>Activity 在 onCreate 时的流程可以这么总结：</p>\n<ul>\n<li>Application 成功启动、初始化、并绑定 AMS 后，调用 <code>TransactionExecutor#execute()</code>，内部先执行 <code>executeCallbacks(ClientTransaction)</code>，调用 <code>LaunchActivityItem#execute(...)</code>，进而调用 <code>handleLaunchActivity(...)</code>，进入启动 Activity 的流程。</li>\n<li><code>handleLaunchActivity(...)</code> 内部调用 <code>performLaunchActivity(...)</code>。</li>\n<li><code>performLaunchActivity(...)</code> 判断传入的 ActivityClientRecord.mPendingRemoveWindow 是否为空。<ul>\n<li>如果是通过 <code>LaunchActivityItem#execute(...)</code> 触发的 <code>performLaunchActivity(...)</code>，则 <code>ActivityClientRecord.mPendingRemoveWindow == null</code>；</li>\n<li>否则如果一个 Activity 是已经启动后被 <code>handleRelaunchActivityInner(...)</code> 唤醒的，就会先调用 <code>handleDestroyActivity(...)</code>，这一步将当前 Activity 的 Window 缓存在 mPendingRemoveWindow 后再销毁，然后调用 <code>performLaunchActivity(...)</code>，这样重新启动的同一个 Activity 就能拿到上一次销毁时保存的 Window 了。</li>\n</ul>\n</li>\n<li><code>performLaunchActivity(...)</code> 中从 ActivityClientRecord 取出对应的 Activity，并调用 <code>Activity.attach(...)</code>，传入了从 ActivityClientRecord 中取出的 mPendingRemoveWindow（可能为空）。</li>\n<li><code>Activity.attach(...)</code> 中直接 <code>new</code> 了一个新的 PhoneWindow，构造方法中传入了 ActivityClientRecord.mPendingRemoveWindow，PhoneWindow 判断 mPendingRemoveWindow 是否为空，为空说明是新启动的 Activity，否则说明是 relaunch 的 Activity。</li>\n<li>如果传入的 mPendingRemoveWindow 不为空，则从 mPendingRemoveWindow 中取出 DecorView，并作为当前 Activity 自己的 DecorView，否则不处理。</li>\n<li>创建完新的 PhoneWindow 后，再通过系统服务创建一个 WindowManager。</li>\n<li>将这个新建的 WindowManager 绑定到 Activity 新建的 PhoneWindow 中，以及在 Activity 本身中保存。</li>\n<li>此时 Activity 和对应的 ActivityClientRecord 共用同一个 WindowManager，但注意，Activity 在 <code>attach(...)</code> 中 <code>new</code> 出来的 Window，暂时还没有存入到对应的 ActivityClientRecord 中。</li>\n<li>如果</li>\n</ul>\n<p>也就是说，走完 <code>onCreate()</code> 的流程后，一个 Activity 就创建好了自己的 Window 并绑定了 WindowManager。并且如果这个 Activity 是 relaunch 的，还会直接复用上一次销毁时缓存的 Window 和 DecorView；但如果是新启动的 Activity，则到当前为止，Activity 已经创建好了 Window，但还不具有 DecorView。</p>\n<h3 id=\"2-2-onStart\"><a href=\"#2-2-onStart\" class=\"headerlink\" title=\"2.2 onStart\"></a>2.2 onStart</h3><p>按照上文中 <code>TransactionExecutor#execute(ClientTransaction)</code> 的调用顺序，第二步调用 <code>executeLifecycleState(ClientTransaction)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TransactionExecutorHelper mHelper = <span class=\"keyword\">new</span> TransactionExecutorHelper();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 用于回调 onCreate()</span></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 用于流转到 onStart(), onResume()</span></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** Transition to the final state if requested by the transaction. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        <span class=\"comment\">// 在生成 ClientTransaction 的方法 ActivityStackSupervisor#realStartActivityLocked 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// andResume == true 时 lifecycleItem 时 ResumeActivityItem 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际上 transaction 持有的 lifecycleItem 是 `ResumeActivityItem` 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此 lifecycleItem.getTargetState() 返回的就是 ON_RESUME。</span></span><br><span class=\"line\">        cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>, transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Transition the client between states with an option not to perform the last hop in the</span></span><br><span class=\"line\"><span class=\"comment\">     * sequence. This is used when resolving lifecycle state request, when the last transition must</span></span><br><span class=\"line\"><span class=\"comment\">     * be performed with some specific parameters.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cycleToPath</span><span class=\"params\">(ActivityClientRecord r, <span class=\"keyword\">int</span> finish, <span class=\"keyword\">boolean</span> excludeLastState,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于此前 Activity 刚完成 onCreate，所以 start == ON_CREATE，</span></span><br><span class=\"line\">        <span class=\"comment\">// executeLifecycleState(...) 方法中传入的 finish == ON_RESUME，</span></span><br><span class=\"line\">        <span class=\"comment\">// executeLifecycleState(...) 方法中传入的 excludeLastState == true。</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start = r.getLifecycleState();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class=\"line\">        performLifecycleSequence(r, path, transaction);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** Transition the client through previously initialized state sequence. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLifecycleSequence</span><span class=\"params\">(ActivityClientRecord r, IntArray path,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = path.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, state; i &lt; size; i++) &#123;</span><br><span class=\"line\">            state = path.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ON_START: &#123;</span><br><span class=\"line\">                    mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutorHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Calculate the path through main lifecycle states for an activity and fill</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@link</span> #mLifecycleSequence&#125; with values starting with the state that follows the initial</span></span><br><span class=\"line\"><span class=\"comment\">     * state.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;<span class=\"doctag\">NOTE:</span> The returned value is used internally in this class and is not a copy. It&#x27;s contents</span></span><br><span class=\"line\"><span class=\"comment\">     * may change after calling other methods of this class.&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@VisibleForTesting</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IntArray <span class=\"title\">getLifecyclePath</span><span class=\"params\">(<span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> finish, <span class=\"keyword\">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (finish &gt;= start) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start + <span class=\"number\">1</span>; i &lt;= finish; i++) &#123;</span><br><span class=\"line\">                mLifecycleSequence.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Remove last transition in case we want to perform it with some specific params.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mLifecycleSequence.remove(mLifecycleSequence.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mLifecycleSequence;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于 <code>for(...)</code> 循环中的起始序号是从 <code>start + 1</code> 开始，实际上就是先把 <code>ON_CREATE</code>（不包括）到 <code>ON_RESUME</code>（包括）之间的生命周期都添加到了 <code>mLifecycleSequence</code>，但由于 <code>excludeLastState == true</code>，因此 mLifecycleSequence 又移除了最后一项（也即 <code>ON_RESUME</code>），因此最终 <code>path = mHelper.getLifecyclePath(start, finish, excludeLastState)</code> 返回的 mLifecycleSequence 只包含 <code>ON_START</code>。</p>\n<p>由于 mTransactionHandler 就是 ActivityThread，所以 <code>TransactionExecutor#performLifecycleSequence(...)</code> 最终会调用 <code>ActivityThread#handleStartActivity(...)</code>。</p>\n<h4 id=\"2-2-1-handleStartActivity\"><a href=\"#2-2-1-handleStartActivity\" class=\"headerlink\" title=\"2.2.1 handleStartActivity()\"></a>2.2.1 handleStartActivity()</h4><p><code>ActivityThread#handleStartActivity(...)</code> 主要是调用 <code>performStart(String)</code>，并判断是否需要回调 <code>onRestoreInstanceState()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleStartActivity</span><span class=\"params\">(ActivityClientRecord r,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity activity = r.activity;</span><br><span class=\"line\">        <span class=\"comment\">// Start</span></span><br><span class=\"line\">        activity.performStart(<span class=\"string\">&quot;handleStartActivity&quot;</span>);</span><br><span class=\"line\">        r.setState(ON_START);</span><br><span class=\"line\">        <span class=\"comment\">// Restore instance state</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span> || r.persistentState != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class=\"line\">                            r.persistentState);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-performStart\"><a href=\"#2-2-2-performStart\" class=\"headerlink\" title=\"2.2.2 performStart()\"></a>2.2.2 performStart()</h4><p>需要注意的是，<code>performStart(...)</code> 是 Activity 内的方法，而不是 ActivityThread 的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performStart</span><span class=\"params\">(String reason)</span> </span>&#123;</span><br><span class=\"line\">        mInstrumentation.callActivityOnStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instrumentation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Perform calling of an activity&#x27;s &#123;<span class=\"doctag\">@link</span> Activity#onStart&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * method.  The default implementation simply calls through to that method.</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity The activity being started.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnStart</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        activity.onStart();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>performStart()</code> 主要就是通知 Instrumentation 来回调 Activity 的 onStart 生命周期。</p>\n<h4 id=\"2-2-3-onStart总结\"><a href=\"#2-2-3-onStart总结\" class=\"headerlink\" title=\"2.2.3 onStart总结\"></a>2.2.3 onStart总结</h4><p>Activity 在 onStart 的流程可以这么总结：</p>\n<ul>\n<li>如果 ActivityThreade 在 <code>handleLauncherActivity</code> 期间，通过 <code>performLauncherActivity()</code> 未能成功创建一个 Activity 实例对象，则会请求 AMS 直接中断后续流程。</li>\n<li>否则 <code>executeCallbacks(ClientTransaction)</code> 执行完 handleLaunchActivity 后，再执行 <code>executeLifecycleState(ClientTransaction)</code>。</li>\n<li>executeLifecycleState 内先执行 <code>cycleToPath(...)</code>，回调 Activity 需要经过的生命周期。</li>\n<li>cycleToPath 传入 <code>ON_CREATE</code>, <code>ON_START</code>, <code>ONRESUME</code>，但从第二个开始选择，并排除最后一个，因此最终只有 <code>ON_START</code> 被送入 <code>TransactionExecutor#performLifecycleSequence(...)</code>，并由此回调 <code>ActivityThread#handleActivityStart(...)</code>。</li>\n<li>ActivityThread 调用 <code>Activity#performStart(...)</code>，Activity 调用 <code>Instrumentation#callActivityOnStart(this);</code>，并由 Instrumentation 回调 Activity 的 onStart 生命周期。</li>\n<li>ActivityThread 判断是否需要回调 onRestoreInstanceState 以及 onPostCreate。</li>\n</ul>\n<h3 id=\"2-3-onResume\"><a href=\"#2-3-onResume\" class=\"headerlink\" title=\"2.3 onResume\"></a>2.3 onResume</h3><p>回顾 <code>TransactionExecutor#executeLifecycleState</code>，当 <code>cycleToPath(...)</code> 执行完毕后，Activity 需要先经过的生命周期均已回调：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransactionExecutor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Transition to the final state if requested by the transaction. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        <span class=\"comment\">// 在生成 ClientTransaction 的方法 ActivityStackSupervisor#realStartActivityLocked 中，</span></span><br><span class=\"line\">        <span class=\"comment\">// andResume == true 时 lifecycleItem 时 ResumeActivityItem 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 实际上 transaction 持有的 lifecycleItem 是 `ResumeActivityItem` 类型，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此 lifecycleItem.getTargetState() 返回的就是 ON_RESUME。</span></span><br><span class=\"line\">        cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>, transaction);</span><br><span class=\"line\">        <span class=\"comment\">// 这里传入的 mTransactionHandler 就是 ActivityThread</span></span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上文也提到此处的 lifecycleItem 实际就是 <code>ResumeActivityItem</code>，因此查看 <code>ResumeActivityItem#execute(...)</code> 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Request to move an activity to resumed state.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResumeActivityItem</span> <span class=\"keyword\">extends</span> <span class=\"title\">ActivityLifecycleItem</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// client 就是 ActivityThread，从 AMS 回到 ActivityThread#handleResumeActivity 中。</span></span><br><span class=\"line\">        client.handleResumeActivity(token, <span class=\"keyword\">true</span> <span class=\"comment\">/* finalStateRequest */</span>, mIsForward,</span><br><span class=\"line\">                <span class=\"string\">&quot;RESUME_ACTIVITY&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-1-handleResumeActivity\"><a href=\"#2-3-1-handleResumeActivity\" class=\"headerlink\" title=\"2.3.1 handleResumeActivity()\"></a>2.3.1 handleResumeActivity()</h4><p><code>ActivityThread#handleResumeActivity</code> 内部通过调用 <code>performResumeActivity(...)</code> 获取包装了各类资源的 ActivityClientRecord，并用该 ActivityClientRecord 为 Activity 初始化与视图相关的资源，例如绑定 Window，初始化 DecorView 等：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过 token 从所有 ActivityClientRecord 中取出目标</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果是新启动的 Activity，可以理解为这里取出来的 ActivityClientRecord 就是上面 startActivityNow(...) 中 new 出来的 ActivityClientRecord</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ActivityThread#performLaunchActivity 阶段在 Activity#attach 中 new 了一个 PhoneWindow，但 ActivityClientRecord 并没有持有 PhoneWindow，</span></span><br><span class=\"line\">            <span class=\"comment\">// 这一步就将 PhoneWindow 存入了 ActivityClientRecord，此时 Activity 和对应的 ActivityClientRecord 都持有了同一个 Window 和 WindowManager 对象</span></span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            <span class=\"comment\">// 获取目标 Activity 的 Window 的 DecorView</span></span><br><span class=\"line\">            <span class=\"comment\">// Window#getDecorView() 内部包含两个逻辑，如果持有的 DecorView 已存在（例如 relaunch 的场景）则直接返回，否则（例如 startActivityNow 的场景）就 new 一个再返回</span></span><br><span class=\"line\">            <span class=\"comment\">// 详见下面的源码</span></span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            <span class=\"comment\">// 取出之前 Activity.attach() 中存入 PhoneWindow 的 WindowManager 接口实例 WindowManagerImpl 对象。</span></span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            <span class=\"comment\">// 创建的 DecorView 的窗口属性</span></span><br><span class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">            <span class=\"comment\">// 将创建的的 DecorView 作为目标 Activity 的 DecorView，此时还未创建 ViewRootImpl</span></span><br><span class=\"line\">            a.mDecor = decor;</span><br><span class=\"line\">            <span class=\"comment\">// 判断 Activity 的 Window 是不是从上一次销毁时缓存下来的，如果是则通知 DecorView 的所有子 View 即将重建</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取 DecorView 的 ViewRootImpl，如果没有则返回 null</span></span><br><span class=\"line\">                <span class=\"comment\">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class=\"line\">                <span class=\"comment\">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class=\"line\">                <span class=\"comment\">// the decor view we have to notify the view root that the</span></span><br><span class=\"line\">                <span class=\"comment\">// callbacks may have changed.</span></span><br><span class=\"line\">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class=\"line\">                <span class=\"comment\">// 当 Activity 是 relaunch 的时候，Window 和其持有的 DecorView 是从上一次缓存下来的，则 DecorView#getViewRootImpl 才不为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通知所有的子 View：「准备重新创建视图」</span></span><br><span class=\"line\">                    impl.notifyChildRebuilt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                    a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 调用 WindowManagerImpl#addView</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 清除掉 Activity 缓存的 Window 等，并重置了 r.mPreserveWindow 标志位</span></span><br><span class=\"line\">        <span class=\"comment\">// Get rid of anything left hanging around.</span></span><br><span class=\"line\">        cleanUpPendingRemoveWindows(r, <span class=\"keyword\">false</span> <span class=\"comment\">/* force */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一段逻辑可以分为两个关键点：</p>\n<ul>\n<li><code>r.window.getDecorView();</code>: 如果 Activity 不是 ReLaunch 的，也没有调用过 <code>setContentView(...)</code>，则需要先初始化 DecorView。</li>\n<li><code>wm.addView(decor, l);</code>: 通过 <code>WindowManagerImpl#addView</code> 传入 DecorView，然后创建 ViewRootImpl，并使得 ViewRootImpl 持有 DecorView。</li>\n</ul>\n<p>（1）初始化 DecorView：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对应上面 View decor = r.window.getDecorView(); 的源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ViewGroup mContentParent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Retrieve the top-level window decor view (containing the standard</span></span><br><span class=\"line\"><span class=\"comment\">     * window frame/decorations and the client&#x27;s content inside of that), which</span></span><br><span class=\"line\"><span class=\"comment\">     * can be added as a window to the window manager.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;&lt;em&gt;Note that calling this function for the first time &quot;locks in&quot;</span></span><br><span class=\"line\"><span class=\"comment\">     * various window characteristics as described in</span></span><br><span class=\"line\"><span class=\"comment\">     * &#123;<span class=\"doctag\">@link</span> #setContentView(View, android.view.ViewGroup.LayoutParams)&#125;.&lt;/em&gt;&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Returns the top-level window decor view.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"meta\">@NonNull</span> <span class=\"function\">View <span class=\"title\">getDecorView</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span> || mForceDecorInstall) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 内部逻辑其实就是 new 出来一个 DecorView，并与当前 Window 绑定</span></span><br><span class=\"line\">            installDecor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDecor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class=\"line\">            mContentParent = generateLayout(mDecor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）通过 <code>WindowManagerImpl#addView</code> 创建 ViewRootImpl 并持有 DecorView：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// handleResumeActivity(...) 中，调用该方法传入的 View 实际上就是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        applyDefaultToken(params);</span><br><span class=\"line\">        <span class=\"comment\">// 这个 mGlobal 是 WindowManagerGlobal 实例对象</span></span><br><span class=\"line\">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应 mGlobal.addView(...) 的源码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//  这里传入的 View 实际上是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建 ViewRootImpl。</span></span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            <span class=\"comment\">// mRoots 是一个 ArrayList&lt;ViewRootImpl&gt; 类型的集合。</span></span><br><span class=\"line\">            mRoots.add(root);</span><br><span class=\"line\">            mParams.add(wparams);</span><br><span class=\"line\">            <span class=\"comment\">// do this last because it fires off messages to start doing things</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// ViewRootImpl 持有 DecorView。</span></span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终于找到了 ViewRootImpl 初始化的地方，其构造方法内绑定了初始化时的线程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> IWindowSession mWindowSession;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个 WindowSession，App 创建 Window 时，实际上都是通过 ViewRootImpl 拿到 WindowSession，</span></span><br><span class=\"line\">        <span class=\"comment\">// 再通过 WindowSession 与 WindowManagerService 交互完成的，</span></span><br><span class=\"line\">        <span class=\"comment\">// 其中用到了 Activity#attach 传入 PhoneWindow 的 IBinder token。</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以实际上 PhoneWindow 持有了和 Window 相关的信息，但真正和 WMS 通信的是 ViewRootImpl。</span></span><br><span class=\"line\">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定了初始化时的线程</span></span><br><span class=\"line\">        mThread = Thread.currentThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 view 就是 DecorView。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mView = view;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"comment\">// 调用 WindowSession#addToDisplay(...)，才是真正创建了一个 Window。</span></span><br><span class=\"line\">                res = mWindowSession.addToDisplay(...);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后 Instrumentation 会回调 <code>Activity.onResume()</code>，表示 Activity 进入到了 <code>onResume()</code> 的生命周期。到了这一步，Activity 初始化了 PhoneWindow 以及 DecorView，并且在 ViewRootImpl 中加载了 DecorView，这也表示 Activity 已经从视觉上可见。</p>\n<h4 id=\"2-3-2-performResumeActivity\"><a href=\"#2-3-2-performResumeActivity\" class=\"headerlink\" title=\"2.3.2 performResumeActivity()\"></a>2.3.2 performResumeActivity()</h4><p>ActivityThread 在 Activity 的 onResume 阶段大部分逻辑都在 <code>handlerResumeActivity(...)</code> 内，和视图资源相关。<code>performResumeActivity(...)</code> 则主要是为 <code>handlerResumeActivity(...)</code> 提供了依赖的 ActivityClientRecord 资源，以及通知 Instrumentation 回调 <code>onResume()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = <span class=\"keyword\">new</span> ArrayMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class=\"line\">            r.state = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.persistentState = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.setState(ON_RESUME);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">(<span class=\"keyword\">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class=\"line\">        dispatchActivityPreResumed();</span><br><span class=\"line\">        performRestart(<span class=\"keyword\">true</span> <span class=\"comment\">/* start */</span>, reason);</span><br><span class=\"line\">        <span class=\"comment\">// mResumed is set by the instrumentation</span></span><br><span class=\"line\">        mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instrumentation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnResume</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        activity.mResumed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        activity.onResume();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-onResume总结\"><a href=\"#2-3-3-onResume总结\" class=\"headerlink\" title=\"2.3.3 onResume总结\"></a>2.3.3 onResume总结</h4><p>Activity 在 onResume 时的流程可以这么总结：</p>\n<ul>\n<li>ActivityThread 已经通过 <code>handleLaunchActivity(...)</code> 成功创建 Activity 实例，并且通过 <code>TransactionExecutor#cycleToPath(...)</code> 回调了 Activity 需要经历的生命周期。</li>\n<li>TransactionExecutor 调用 <code>ResumeActivityItem#execute(...)</code>，从而调用了 <code>ActivityThread#handleResumeActivity(...)</code>。</li>\n<li>ActivityThread 在 handleResumeActivity 中通过 <code>performResumeActivity(...)</code> 获取对应的 ActivityClientRecord。</li>\n<li>获取 DecorView，分为两种逻辑：由于 startActivityNow 触发的 handleResumeActivity、以及由于 relaunch 触发的 handleResumeActivity。<ul>\n<li>如果是由于 startActivityNow 触发的，则 DecorView 尚未创建，立即创建一个 DecorView，此时 DecorView 或者说 Activity 尚未初始化 ViewRootImpl。</li>\n<li>如果是由于 relaunch 触发的，则 Window、DecorView 均是从上一次销毁时缓存中复用的，此时 DecorView 已经初始化过了 ViewRootImpl，也即 Activity 已经拥有 ViewRootImpl 了，只需要通知所有子 View 即将重建。</li>\n</ul>\n</li>\n<li>如果 Activity 还未初始化 ViewRootImpl（对应 startActivityNow 的场景），则调用 <code>WindowManager#addView(...)</code>，其内部初始化了 ViewRootImpl，将初始化 ViewRootImpl 时的所在线程，作为 ViewRootImpl 的初始线程。</li>\n<li>ViewRootImpl 持有 DecorView。</li>\n</ul>\n<p>也就是说，到了 onResume 这一步，Activity 已经创建了 DecorView 和 ViewRootImpl，并且对 ViewRootImpl 的原始线程做了初始化。此时 Activity 已经完整具有了 Window、DecorView、ViewRootImpl。</p>\n<hr>\n<h2 id=\"3-Activity布局加载流程\"><a href=\"#3-Activity布局加载流程\" class=\"headerlink\" title=\"3. Activity布局加载流程\"></a>3. Activity布局加载流程</h2><h3 id=\"3-1-setContentView\"><a href=\"#3-1-setContentView\" class=\"headerlink\" title=\"3.1 setContentView()\"></a>3.1 setContentView()</h3><p>接下来就是 Activity 的另一项重要功能，加载布局文件。通常加载布局文件都是通过 <code>setContentView(...)</code> 实现的，这里其实分为两个版本：</p>\n<p>（1）早期的 Activity 直接继承自 Activity 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">        getWindow().setContentView(layoutResID);</span><br><span class=\"line\">        initWindowDecorActionBar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是通过之前 <code>Activity.attach(...)</code> 时创建的 PhoneWindow 去直接加载布局。</p>\n<p>（2）新版本的 Activity 继承自 AppCompatActivity 类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// getDelegate() 返回一个 AppCompatDelegate 接口类型的实例对象</span></span><br><span class=\"line\">        getDelegate().setContentView(layoutResID);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AppCompatDelegate <span class=\"title\">getDelegate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDelegate == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 实际上内部就是 new 了一个 AppCompatDelegateImpl</span></span><br><span class=\"line\">            mDelegate = AppCompatDelegate.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDelegate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再看看 <code>AppCompatDelegateImpl.setContentView()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatDelegateImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这个方法，创建了一个叫 subDecor 的东西</span></span><br><span class=\"line\">        ensureSubDecor();</span><br><span class=\"line\">        ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class=\"line\">        contentParent.removeAllViews();</span><br><span class=\"line\">        LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class=\"line\">        mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要分为两个部分：</p>\n<ul>\n<li><code>ensureSubDecor();</code>: 创建一个 SubDecorView。</li>\n<li>从 SubDecorView 中找到 ID 为 <code>android.R.id.content</code> 的 <code>ViewGroup contentParent</code>，清除其中所有 View，并把传入的布局 ID <code>resId</code> 解析并加载进 contentParent 内。</li>\n</ul>\n<p>（1）创建 SubDecorView：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppCompatDelegateImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureSubDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mSubDecorInstalled) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 真正的创建是这个方法</span></span><br><span class=\"line\">            mSubDecor = createSubDecor();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 可以看到在 setContentView(...) 内部加载了标题和 ActionBar</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是为什么在 Activity 中，对 ActionBar 或 Title 的修改必须放在 setContentView(...) 调用之前</span></span><br><span class=\"line\">            <span class=\"comment\">// If a title was set before we installed the decor, propagate it now</span></span><br><span class=\"line\">            CharSequence title = getTitle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!TextUtils.isEmpty(title)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDecorContentParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mDecorContentParent.setWindowTitle(title);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (peekSupportActionBar() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    peekSupportActionBar().setWindowTitle(title);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mTitleView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mTitleView.setText(title);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mSubDecorInstalled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> ViewGroup <span class=\"title\">createSubDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class=\"line\">        <span class=\"comment\">// 这下面有一堆 if - else 都只是为了确定这个 Activity 对应 Window 的样式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (...) &#123;......&#125;</span><br><span class=\"line\">        a.recycle();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 先确保了 Window 已经初始化</span></span><br><span class=\"line\">        <span class=\"comment\">// Now let&#x27;s make sure that the Window has installed its decor by retrieving it</span></span><br><span class=\"line\">        ensureWindow();</span><br><span class=\"line\">        <span class=\"comment\">// 从 Activity 存储的 PhoneWindow 中获取 DecorView，但并不是需要拿到 DecorView 实例，</span></span><br><span class=\"line\">        <span class=\"comment\">// 而是为了像上面 handleResumeActivity(...) 中的 r.activity.getWindow() 一样，确保 DecorView 已被创建</span></span><br><span class=\"line\">        mWindow.getDecorView();</span><br><span class=\"line\">        <span class=\"comment\">// 这个就是目标 subDecor</span></span><br><span class=\"line\">        ViewGroup subDecor = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mWindowNoTitle) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 Activity 含有 WindowTitle：</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mIsFloating) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 加载悬浮窗样式的 subDecor</span></span><br><span class=\"line\">                subDecor = (ViewGroup) inflater.inflate(...);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mHasActionBar) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 加载有 ActionBar 样式的 subDecor</span></span><br><span class=\"line\">                subDecor = (ViewGroup) LayoutInflater.from(themedContext).inflate(...);</span><br><span class=\"line\">                <span class=\"comment\">// 这个 mDecorContentParent 是 ActionBarOverlayLayout 类型的，用于管理 ActionBar</span></span><br><span class=\"line\">                mDecorContentParent = (DecorContentParent) subDecor.findViewById(R.id.decor_content_parent);</span><br><span class=\"line\">                mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果仍然无法加载出 subDecor，就抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;AppCompat does not support the current theme features: &#123; &quot;</span> + ...... + <span class=\"string\">&quot; &#125;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将 subDecor 加载到 PhoneWindow 中</span></span><br><span class=\"line\">        mWindow.setContentView(subDecor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subDecor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）将传入的布局 ID 解析成 View 并加载进 SubDecor 的一个 ViewGroup 子元素 <code>contentParent</code> 中：</p>\n<p>在 <code>createSubDecor()</code> 中，先确保 Window 和 DecorView 已创建，然后根据 Title 和 ActionBar 的样式不同，通过 <code>inflate</code> 的方式加载对应的模板 subDecor。然后再从加载好的 SubDecor 中通过 <code>findViewById(...)</code> 的方式获取到一个 ViewGroup 子元素 <code>contentParent</code> 并把布局加载进其中，也就是说，实际上在 Activity 中调用的 <code>setContentView(int resId)</code> 传入的布局文件，是加载在 subDecor 的一个子 View 中，而 DecorView 又持有了 SubDecor。</p>\n<blockquote>\n<p>如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，从类名也能看出这个 View 就是专门负责 ActionBar 的。</p>\n</blockquote>\n<p>当 subDecor 被成功创建后，通过 <code>mWindow.setContentView(subDecor);</code> 把 subDecor 添加到 PhoneWindow 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneWindow</span> <span class=\"keyword\">extends</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入的参数 View 就是 subDecor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里也可以看出，默认情况下是全屏的</span></span><br><span class=\"line\">        setContentView(view, <span class=\"keyword\">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 传入的参数 View 就是 subDecor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// mContentParent 是 DecorView 中的一个 ViewGroup 子元素。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            installDecor();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">            mContentParent.removeAllViews();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 传入的参数 View 就是 subDecor，所以实际是将 SubDecor 添加到 DecorView 的 ViewGroup 子元素 mContentParent 内。</span></span><br><span class=\"line\">            mContentParent.addView(view, params);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mContentParent.requestApplyInsets();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">            cb.onContentChanged();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mContentParentExplicitlySet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// mContentParent 其实就是 DecorView 加载出来之后的布局容器 ViewGroup</span></span><br><span class=\"line\">            mContentParent = generateLayout(mDecor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在 PhoneWindow 中有一个成员变量 <code>mContentParent</code> 是 DecorView 的一个 ViewGroup 子元素，而 <code>AppCompatDelegateImpl#setContentView(...)</code> 中从 SubDecor 中 <code>findViewById(android.R.id.content)</code> 获取了一个局部变量 <code>contentParent</code> 是 SubDecor 的一个 ViewGroup 子元素，二者是不同的。总的来说：</p>\n<ul>\n<li>DecorView 分为两大部分，一个是 Title，一个是 Content；</li>\n<li>PhoneWindow 根据属性从预定义的模板中加载了一个 DecorView，主要就是 Title 的样式，因为 Content 只是一个空的 ViewGroup；</li>\n<li><code>AppCompatActivity#setContentView(...)</code> 将布局实际上加载到了 SubDecor 的 <code>(ViewGroup) contentParent</code> 中；</li>\n<li>因为 DecorView 的 Content 用于包裹实际的内容，但 DecorView 没办法预知 Activity 加载的 ContentView，所以就用 SubDecor 来包裹实际的 Activity 布局；</li>\n<li>最后再把 SubDecor 加载到 DecorView 的 <code>(ViewGroup) mContentParent</code> 中。</li>\n</ul>\n<p>并且，当调用了 <code>setContentView(...)</code> 后，就已经创建好了 DecorView 和 SubDecor、加载好了布局、将 DecorView 传入了 PhoneWindow，因此：</p>\n<ul>\n<li>如果在 onCreate 阶段调用 <code>setContentView(...)</code>，则 <code>ActivityThread#handleResumeActivity</code> 阶段 <code>r.window.getDecorView()</code> 获取的 DecorView 就不为 <code>null</code>，并且 DecorView 已经加载了对应布局。</li>\n<li>否则 DecorView 和 SubDecor 都会在 <code>ActivityThread#handleResumeActivity</code> 阶段用默认模板加载出来。</li>\n<li>不论是否调了 <code>setContentView(...)</code>，ViewRootImpl 都是在 <code>ActivityThread#handleResumeActivity</code> 阶段通过 <code>WindowManagerImpl#addView</code> 才加载的，并且持有了 DecorView。</li>\n<li>如果 ViewRootImpl 已经初始化并持有了默认模板的 DecorView 之后才调用 <code>setContentView(...)</code>，由于布局最终只是加载进了 SubDecor 的一个子 ViewGroup，所以并不会重新初始化 SubDecor、DecorView、PhoneWindow、ViewRootImpl。</li>\n</ul>\n<h3 id=\"3-2-setContentView-总结\"><a href=\"#3-2-setContentView-总结\" class=\"headerlink\" title=\"3.2 setContentView()总结\"></a>3.2 setContentView()总结</h3><p>至此，可以对 Activty 中调用 <code>setContentView(int resId)</code> 后的流程做一个总结：</p>\n<ul>\n<li>如果是老版本直接继承自 Activity，则调用 <code>setContentView(int resId)</code> 后会直接把布局 <code>inflate</code> 到 Activity 对应的 Window 中。</li>\n<li>如果是新版本继承自 AppCompatActivity，则先确保 subDecor 已创建。</li>\n<li>在创建 subDecor 前，先确保 Window 和 DecorView 已创建。</li>\n<li>首先判断 PhoneWindow 是否创建，如果未创建则先创建 Window。</li>\n<li>然后通过 <code>PhoneWindow#getDecorView() - installDecor()</code> 确保了 DecorView 已被创建并根据属性初始化了一份模板布局。</li>\n<li>创建 subDecor 时，根据 Activity 及其 Window 的属性加载预置的 subDecor 模板，如果 Activity 含有 WindowTitle，且具有 ActionBar，还会从 subDecor 的模板布局中通过 <code>findViewById(int)</code> 的方式获取一个叫 mDecorContentParent 的 ActionBarOverlayLayout 类型的 View，专门用于管理 ActionBar 相关的视图。</li>\n<li>根据模板创建了 subDecor 后，通过 <code>Window#setContentView(View)</code> 将 subDecor 传入，并把传入的 subDecor 作为子 View 添加到 <code>PhoneWindow#mContentParent</code> 中，本质上就是把 subDecor 添加到 DecorView 中。</li>\n<li>subDecor 创建好后，从 subDecor 中通过 <code>findViewById(android.R.id.content)</code> 获取一个布局 <code>contentParent</code>，接着先 remove 掉所有子 View 再 <code>inflate</code> 传入的布局文件。这一步才真正加载 Activity 布局。</li>\n</ul>\n<p>也就是说，在 setContentView 的时候，Activity 实际上是在确保 Window 和 DecorView 均已创建的基础上，把 subDecor 根据模板创建出来并 add 进 <code>mContentParent</code> 这个 ViewGroup 中（<code>mContentParent</code> 是从 DecorView 加载出来的），然后从 subDecor 的模板布局中获取一个子元素 <code>contentParent</code>，最后把实际的 Activity 布局 <code>inflate</code> 进 <code>contentParent</code>。</p>\n<p>此外，Window 有「子 Window」的概念，例如当 Activity 创建一个 Dialog 的 Window 时，会传入把 Activity 的 PhoneWindow 作为 WindowParant，当判断 <code>parent != null</code> 时，就会用 <code>parent</code> 的 Token 创建 Window。</p>\n","categories":["Android"],"tags":["Android","四大组件","Activty","生命周期","启动流程"]},{"title":"Android-架构和设计模式","url":"/post/android/android-architecture/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-架构和设计模式\"><a href=\"#Android-架构和设计模式\" class=\"headerlink\" title=\"Android-架构和设计模式\"></a>Android-架构和设计模式</h1><h2 id=\"1-App架构\"><a href=\"#1-App架构\" class=\"headerlink\" title=\"1. App架构\"></a>1. App架构</h2><p>App 架构的核心思想，主要就是为了降低 UI 逻辑和数据业务逻辑之间的耦合度。</p>\n<h3 id=\"1-1-MVC模式\"><a href=\"#1-1-MVC模式\" class=\"headerlink\" title=\"1.1 MVC模式\"></a>1.1 MVC模式</h3><p>MVC 即：Model - View - Controller 模式，Model 与 View、View 与 Controller、Controller 与 Model，都是单向直接通信，View 层负责 UI 逻辑，Model 层负责数据，Controller 负责替 View 层操作 Model 层，但由于 Android 中，Activity 通常会同时担任 View 层和 Controller 层，随着业务变得复杂，Activity 也会越来越臃肿，而且 Activity 与 Model 层交互时，相当于 View 层可以与 Model 层直接交互，没有完全解耦。</p>\n<h3 id=\"1-2-MVP模式\"><a href=\"#1-2-MVP模式\" class=\"headerlink\" title=\"1.2 MVP模式\"></a>1.2 MVP模式</h3><p>MVP 即：Model - View - Presenter 模式，Presenter 与 View、Presenter 与 Model 之间都是双向通信，而 Model 与 View 之间完全没有直接通信，从而彻底解耦。并且由于将 MVC 模式中的 Controller 完全解放成独立的 Presenter，也避免了 Activity 中逻辑代码过多的情况。</p>\n<ul>\n<li><p>MVP 模式的变种：Passive View</p>\n<p>Passive View 即：被动 View 层，是 MVP 模式最广泛的一个变种，其核心思想就是：View 层所需的数据，不是由其主动拉取 Presenter 获得的，而是被动地由 Presenter 推送的，在 Android 中，也就是 View 层开放自己被动接受数据的接口，Presenter 在转发 View 层请求数据的逻辑给 Model 后，由 Model 通过 Presenter 来主动调用 View 的接口来回传数据。</p>\n</li>\n</ul>\n<h3 id=\"1-3-MVVM模式\"><a href=\"#1-3-MVVM模式\" class=\"headerlink\" title=\"1.3 MVVM模式\"></a>1.3 MVVM模式</h3><p>MVVM 即：Model - View - ViewModel 模式，View 仍然对应了 UI 层，Model 仍然是负责主要的数据处理，但一些和 View 层有关的属性及操作则放入了 ViewModel 中实现，其关键在于 DataBinding 技术，View 的变化和 ViewModel 的操作会双向同步，实际上是 Jetpack 框架替开发人员做了一些工作。</p>\n<ul>\n<li><p>DataBinding 原理</p>\n<p>DataBinding 会对布局文件中使用 <code>&lt;layout&gt;</code> 标签包裹的元素预处理，会为每个元素增加一个 <code>tag</code> 属性，然后将各个元素抽取出来生成一个名为 <code>xxxxx-layout.xml</code> 的文件（<code>xxxxx</code> 是原本 xml 布局文件的命名），文件中将原本的所有 View 标签，都转换成了 <code>&lt;Target id=&quot;xxx&quot; tag=&quot;yyy&quot; view=&quot;ZzzView&quot;&gt;</code> 的形式，其中根布局对应的 tag 是 <code>layout</code>，然后根据原布局文件和新生成的文件，生成一个继承自 <code>ViewDataBinding</code> 的类，并将布局文件中的元素，都根据类型和 id 创建成员变量。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-设计模式\"><a href=\"#2-设计模式\" class=\"headerlink\" title=\"2. 设计模式\"></a>2. 设计模式</h2><h3 id=\"2-1-单例模式\"><a href=\"#2-1-单例模式\" class=\"headerlink\" title=\"2.1 单例模式\"></a>2.1 单例模式</h3><h4 id=\"2-1-1-饿汉式\"><a href=\"#2-1-1-饿汉式\" class=\"headerlink\" title=\"2.1.1 饿汉式\"></a>2.1.1 饿汉式</h4><p>饿汉式写法简单，线程安全，但没有懒加载的效果，如果没有使用过会浪费内存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\">pubilc <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> singleton; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-2-懒汉式\"><a href=\"#2-1-2-懒汉式\" class=\"headerlink\" title=\"2.1.2 懒汉式\"></a>2.1.2 懒汉式</h4><p>懒汉式：懒加载，节约内存，但线程不安全</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> stati Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\">pubilc <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-3-线程安全的懒汉式\"><a href=\"#2-1-3-线程安全的懒汉式\" class=\"headerlink\" title=\"2.1.3 线程安全的懒汉式\"></a>2.1.3 线程安全的懒汉式</h4><p>线程安全的懒汉式：懒加载同时线程安全，但使用锁会造成不必要的同步开销，大部分情况下用不到同步</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> stati Singleton singleton = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\">pubilc <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-4-双锁检测DCL\"><a href=\"#2-1-4-双锁检测DCL\" class=\"headerlink\" title=\"2.1.4 双锁检测DCL\"></a>2.1.4 双锁检测DCL</h4><p>双锁检测：懒加载，线程安全，效率高，但 volatile 影响一点性能，高并发下有一定的缺陷。volatile 关键字可以禁止代码重排序，所有的写（write）操作都将发生在读（read）操作之前，保证singleton是一定被初始化了的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == singleton) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == singleton) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-5-静态内部类\"><a href=\"#2-1-5-静态内部类\" class=\"headerlink\" title=\"2.1.5 静态内部类\"></a>2.1.5 静态内部类</h4><p>静态内部类：懒加载，线程安全，推荐使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//第一次调用getInstance方法时才加载SingletonHolder并初始化sInstance</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.sInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//静态内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton sInstance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-工厂模式\"><a href=\"#2-2-工厂模式\" class=\"headerlink\" title=\"2.2 工厂模式\"></a>2.2 工厂模式</h3><h4 id=\"2-2-1-简单工厂模式\"><a href=\"#2-2-1-简单工厂模式\" class=\"headerlink\" title=\"2.2.1 简单工厂模式\"></a>2.2.1 简单工厂模式</h4><p>（1）定义抽象产品类及公共接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）定义具体产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product A&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product B&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建工厂类，创建具体的产品</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Product <span class=\"title\">create</span><span class=\"params\">(String productName)</span> </span>&#123;</span><br><span class=\"line\">        Product product = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (productName) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;A&quot;</span>:</span><br><span class=\"line\">                product = <span class=\"keyword\">new</span> ProductA();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;B&quot;</span>:</span><br><span class=\"line\">                product = <span class=\"keyword\">new</span> ProductB();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> product;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-抽象工厂模式\"><a href=\"#2-2-2-抽象工厂模式\" class=\"headerlink\" title=\"2.2.2 抽象工厂模式\"></a>2.2.2 抽象工厂模式</h4><p>抽象工厂最复杂，假如有 <code>N</code> 种产品，<code>M</code> 个工厂实体，则一共会有 <code>N * M</code> 种产品实体。</p>\n<p>（1）创建抽象产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CPU</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">showCPU</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Memory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">showMemory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HD</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">showHD</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）创建产品实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntelCPU</span> <span class=\"keyword\">extends</span> <span class=\"title\">CPU</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showCPU</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Intet CPU&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SamsungMemory</span> <span class=\"keyword\">extends</span> <span class=\"title\">Memory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showMemory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;三星 内存&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WdHD</span> <span class=\"keyword\">extends</span> <span class=\"title\">HD</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showHD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;西部数据 硬盘&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建抽象工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComputerFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> CPU <span class=\"title\">createCPU</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Memory <span class=\"title\">createMemory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> HD <span class=\"title\">createHD</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）创建工厂实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DellComputerFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComputerFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CPU <span class=\"title\">createCPU</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IntelCPU();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Memory <span class=\"title\">createMemory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SamsungMemory();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> HD <span class=\"title\">createHD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WdHD();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-3-工厂方法模式\"><a href=\"#2-2-3-工厂方法模式\" class=\"headerlink\" title=\"2.2.3 工厂方法模式\"></a>2.2.3 工厂方法模式</h4><p>工厂方法模式可以看成是抽象工厂模式的一个特例，当抽象工厂中，只有一种产品时，就和工厂方法一样了。</p>\n<p>（1）创建抽象产品类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）创建产品实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product A&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;product B&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建抽象工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Product <span class=\"title\">create</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）创建工厂实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryA</span> <span class=\"keyword\">extends</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Product <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductA();<span class=\"comment\">//创建ProductA</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryB</span> <span class=\"keyword\">extends</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Product <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductB();<span class=\"comment\">//创建ProductB</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-建造者模式\"><a href=\"#2-3-建造者模式\" class=\"headerlink\" title=\"2.3 建造者模式\"></a>2.3 建造者模式</h3><p>（1）创建产品实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Computer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mCPU;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mMemory;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mHD;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCPU</span><span class=\"params\">(String CPU)</span> </span>&#123;</span><br><span class=\"line\">        mCPU = CPU;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMemory</span><span class=\"params\">(String memory)</span> </span>&#123;</span><br><span class=\"line\">        mMemory = memory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHD</span><span class=\"params\">(String HD)</span> </span>&#123;</span><br><span class=\"line\">        mHD = HD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）创建建造者抽象类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">buildCPU</span><span class=\"params\">(String cpu)</span></span>;<span class=\"comment\">//组装CPU</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">buildMemory</span><span class=\"params\">(String memory)</span></span>;<span class=\"comment\">//组装内存</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">buildHD</span><span class=\"params\">(String hd)</span></span>;<span class=\"comment\">//组装硬盘</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Computer <span class=\"title\">create</span><span class=\"params\">()</span></span>;<span class=\"comment\">//返回组装好的电脑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）创建建造者实体类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">Builder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建产品实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Computer mComputer = <span class=\"keyword\">new</span> Computer();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildCPU</span><span class=\"params\">(String cpu)</span> </span>&#123;<span class=\"comment\">//组装CPU</span></span><br><span class=\"line\">        mComputer.setCPU(cpu);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildMemory</span><span class=\"params\">(String memory)</span> </span>&#123;<span class=\"comment\">//组装内存</span></span><br><span class=\"line\">        mComputer.setMemory(memory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">buildHD</span><span class=\"params\">(String hd)</span> </span>&#123;<span class=\"comment\">//组装硬盘</span></span><br><span class=\"line\">        mComputer.setHD(hd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Computer <span class=\"title\">create</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//返回组装好的电脑</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mComputer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）创建指挥者实体类，用于控制建造者进行建造任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Director</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Builder mBuild = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Director</span><span class=\"params\">(Builder build)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mBuild = build;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//指挥装机人员组装电脑</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Construct</span><span class=\"params\">(String cpu, String memory, String hd)</span> </span>&#123;</span><br><span class=\"line\">        mBuild.buildCPU(cpu);</span><br><span class=\"line\">        mBuild.buildMemory(memory);</span><br><span class=\"line\">        mBuild.buildHD(hd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-观察者模式\"><a href=\"#2-4-观察者模式\" class=\"headerlink\" title=\"2.4 观察者模式\"></a>2.4 观察者模式</h3><p><code>java.util.Observable</code>：抽象被观察者。</p>\n<ul>\n<li>需要继承并根据不同功能重写 <code>Observable</code>，表示被观察者。使用单例模式，由静态内部类管理一个实例，将构造方法私有化。</li>\n<li><code>Observable</code> 的实例（单例）对象也就是被观察者，在内部根据需要添加方法，方法内部调用 <code>setChanged()</code> 和 <code>notifyObservers(Object data)</code>。</li>\n<li>而被观察者需要通过调用 <code>Observable#addObserver(Object observer)</code> 来添加观察者。</li>\n<li><code>notifyObservers(Object data)</code> 方法内部会遍历所有添加给被观察者的观察者，并调用观察者的 <code>update(Observable observable, Object arg)</code> 方法，也即表示带着数据 <code>data</code> 通知所有观察者。</li>\n<li>因此充当观察者的类（添加给被观察者的类）需要实现 <code>Observe</code> 接口，重写 <code>update(Observable o, Object arg)</code> 方法，用 <code>instanceof</code> 判断参数 <code>observable</code> 到底是哪一个被观察者，然后用数据 <code>arg</code> 做相应的操作。</li>\n</ul>\n<p>（1）一个被观察者可以被多个观察者观察，也即给被观察者 <code>add</code> 多个观察者，并添加业务方法，当业务执行的时候，业务方法内部会通知所有被添加的观察者，所有被添加的观察者都会收到通知，但一个被观察者可以有多个业务，并不是每个观察者都需要用到每个业务，因此可以在不同业务的方法内的 <code>notifyObservers(Object data)</code> 中，传不同类型的数据 <code>data</code>，在观察者的 <code>update(Observable observable, Object arg)</code> 方法内，需要用 <code>instanceof</code> 判断数据 <code>arg</code> 的类型，来判断自己是否需要处理。</p>\n<p>（2）一个观察者可以观察多个被观察者，也就是多个被观察者调用 <code>Observable.addObserver()</code> 的时候，可以添加同一个观察者，因此当观察者的 <code>update(Observable observable, Object arg)</code> 方法被调用时，还要先用 <code>instanceof</code> 来判断参数 <code>observable</code> 到底是来自哪个被观察者，然后再用 <code>instanceof</code> 判断数据 <code>arg</code> 是由被观察者中哪个业务方法调用传递过来的，这样才能唯一确定一个业务逻辑。</p>\n<p>（3）接口回调与观察者模式的选择：回调是一对一的关系，只监听一个事件；观察者模式则是可以一对多也可以多对一，因此观察者模式的数据流图是网状结构，如果业务逻辑比较简单的时候，用回调反而能提升代码可读性以及降低开发复杂度。</p>\n<h3 id=\"2-5-中介者模式\"><a href=\"#2-5-中介者模式\" class=\"headerlink\" title=\"2.5 中介者模式\"></a>2.5 中介者模式</h3><p>当程序存在大量的类时，多个对象之间存在着依赖的关系，呈现出网状结构，那么程序的可读性和可维护性就变差了，并且修改一个类需要牵涉到其他类，不符合开闭原则。</p>\n<p>当多个类之间有复杂交互时，通过创建一个中介者类，用于处理其他类之间的交互问题，提高耦合但也提高了代码逻辑清晰度和可读性，在类和类交互时，也不需要针对不同的类定制专用的接口，只需要通过中介者提供的公用接口调用即可。</p>\n","categories":["Android"],"tags":["Android","架构","设计模式","MVC","MVP","MVVM","单例模式","工厂模式","建造者模式","观察者模式","中介者模式"]},{"title":"Android-Binder","url":"/post/android/android-binder/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Binder\"><a href=\"#Android-Binder\" class=\"headerlink\" title=\"Android-Binder\"></a>Android-Binder</h1><h2 id=\"1-Linux跨进程通信\"><a href=\"#1-Linux跨进程通信\" class=\"headerlink\" title=\"1. Linux跨进程通信\"></a>1. Linux跨进程通信</h2><h3 id=\"1-1-内核态与用户态\"><a href=\"#1-1-内核态与用户态\" class=\"headerlink\" title=\"1.1 内核态与用户态\"></a>1.1 内核态与用户态</h3><p>为了保障操作系统最基本的运行不受其他应用的影响，Linux 将内存分为内核空间和用户空间：</p>\n<ul>\n<li>内核空间可以调用所有系统资源、执行任何指令，执行内核代码时，CPU 特权等级处于最高的 0，此时 CPU 处于内核态。</li>\n<li>用户空间只支持简单运算，不能直接调用系统资源，执行用户代码时，CPU 特权等级处于最低的 3，此时 CPU 处于用户态。</li>\n</ul>\n<p>用户空间想要调用部分系统资源则必须通过 <code>SysCall</code> 向内核空间发送指令由内核空间完成。<code>SysCall</code> 可以理解为，内核空间向外暴露的接口，<code>SysCall</code> 预先定义了一套允许用户空间发送的指令，并根据这些指令执行具体的系统命令。</p>\n<p>用户空间可以借助 <code>SysCall</code> 向内核空间发送命令，如果多个用户空间之间需要通信，则需要借助内核空间完成交互。传统的 Linux 通信机制，例如 Socket 和管道，都是内核原生支持的，而 Binder 并不是 Linux 内核的一部分，而是通过 Linux 的动态可加载内核模块（Loadable Kernel Module, LKM）链接到 Linux 的内核中。LKM 允许独立编译但不允许独立运行，其运行时会被链接到内核作为内核的一部分运行于内核空间，因此用户空间不同进程之间就可以通过 Binder 通信。</p>\n<blockquote>\n<p>在与 ServiceManager 和 Binder 通信的过程中，Client 和 Service 会发送多条命令，其中 Client 发起的请求命令称为 BC（Binder Client）命令；Service 响应的命令称为 BR（Binder Reply）命令。</p>\n</blockquote>\n<h3 id=\"1-2-Linux中的驱动\"><a href=\"#1-2-Linux中的驱动\" class=\"headerlink\" title=\"1.2 Linux中的驱动\"></a>1.2 Linux中的驱动</h3><p>Linux 把硬件的读写抽象为文件 IO，而驱动就是对这个抽象的封装和实现。Linux 中有三种类型的驱动设备：字符设备、块设备、网络设备。</p>\n<ul>\n<li>字符设备是指能像字节流文件一样被访问的设备，对字符设备 IO 时，硬件也同时进行 IO。例如显示屏、键盘、串口、LCD、LED 等。<ul>\n<li>字符设备中有一个比较特殊的 misc 杂项设备，设备号为 10，可以自动生成设备节点。Binder 就属于 misc 杂项设备。</li>\n</ul>\n</li>\n<li>块设备是指通过传输数据块（一般为 512b 或 1k）来访问的设备，例如硬盘、SD 卡、U 盘、光盘等。</li>\n<li>网络设备是指能和其他主机交换数据的设备，例如网卡、蓝牙等。</li>\n</ul>\n<h3 id=\"1-3-Binder驱动\"><a href=\"#1-3-Binder驱动\" class=\"headerlink\" title=\"1.3 Binder驱动\"></a>1.3 Binder驱动</h3><p>Binder 驱动并没有真正建立硬件 IO，而是借助驱动的方式，通过内存映射 <code>mmap()</code> 实现进程间通信。</p>\n<p>跨进程无法直接通信的原因是，不同进程之间的内存不可见，因此两个进程无法直接操作另一个进程的内存。通常 Client 进程向 Service 进程请求通信时，需要先将 Client 的请求数据拷贝到内核区，然后再从内核区拷贝到 Service，造成两次数据拷贝，效率较低，因此 Binder 采用了内存映射 MemoryMap 的方式，仅用一次拷贝实现进程间通信：</p>\n<ul>\n<li>使用 Binder 进行进程间通信时，Binder 驱动在内核创建一个数据接收缓冲区，然后在内核开辟一块内核缓冲区，并建立两个缓冲区之间的映射关系、以及 Service 用户空间中一块内存地址与数据接收缓冲区的映射关系；相当于此时 Service 的一块用户内存直接映射到了内核中的数据接收缓冲区。</li>\n<li>将 Client 的数据拷贝到内核中的内核缓冲区，由于内核缓冲区与数据接收缓冲区存在映射关系，而数据接收缓冲区又与 Service 的一块用户内存存在映射关系，所以 Service 就能通过映射，直接操作内核缓冲区中来自 Client 拷贝的数据。</li>\n<li>当 Service 处理完毕，对 Client 响应时，就会重复上述过程，只不过这时反过来，请求时的 Client 变为了响应时的 Service，请求时的 Service 变为了响应时的 Client。</li>\n</ul>\n<hr>\n<h2 id=\"2-ServiceManager\"><a href=\"#2-ServiceManager\" class=\"headerlink\" title=\"2. ServiceManager\"></a>2. ServiceManager</h2><p>Android 基于 Linux 的系统，因此 Android 的系统运行也需要遵循 Linux 运行的基本原则。Linux 系统在启动时，第一启动的进程就是 <code>init.c</code>：</p>\n<p><img data-src=\"./linux_android_startup.png\" alt=\"Android 系统启动加载流程\" title=\"@ASSET\"></p>\n<ul>\n<li>启动 <code>init</code> 进程，进入 Linux 系统的第一步。</li>\n<li>启动各类基础服务，包括 Zygote 和 ServiceManager 等。<ul>\n<li>Zygote 启动 SystemService，SystemService 又会分裂出不同的系统服务，包括 ActviityManageService、PackageManageService 等，这些 SystemService 处于同一进程内，所以不同 SystemService 之间是可以互相访问甚至互相持有的。</li>\n</ul>\n</li>\n<li>ServiceManager 启动 Binder 进程，并初始化 Binder 驱动。</li>\n<li>ServiceManager 将自己存入 Binder 驱动中的第 1 个 ServiceNode，并将自己设为 Binder 的守护进程。</li>\n<li>Binder 开始处理 C/S 进程通信。</li>\n</ul>\n<h3 id=\"2-1-ServiceManager启动\"><a href=\"#2-1-ServiceManager启动\" class=\"headerlink\" title=\"2.1 ServiceManager启动\"></a>2.1 ServiceManager启动</h3><p><img data-src=\"./service_manager_startup.jpeg\" alt=\"ServiceManager 启动流程\" title=\"@ASSET\"></p>\n<p>ServiceManager 启动后，在 main 函数中对 Binder 和 Binder 驱动做了初始化：</p>\n<ul>\n<li>调用 <code>binder_open()</code> 打开 Binder 驱动；<ul>\n<li>这一步还会在 Binder 内创建一个全局链表 <code>binder_procs</code>，并且将 ServiceManager 自己存入到第一个 <code>binder_proc</code> 节点，也即序号为 0。</li>\n<li>由于 ServiceManager 也是一个独立进程，所以其他 Service 和 ServiceManager 通信本身又涉及到进程间通信；</li>\n<li>因此 ServiceManager 存放在 <code>binder_procs</code> 的 0 号节点，Binder 自动为其创建一个 Binder 实体，这样任何 Service 都可以通过 0 号引用从 Binder 中获取到 ServiceManager。</li>\n</ul>\n</li>\n<li>调用 <code>binder_become_context_manager()</code> 设为 Binder 进程的守护进程；</li>\n<li>调用 <code>binder_loop</code> 开启 Binder 循环，Binder 循环会不断执行 <code>binder_parse()</code> 轮询 BR_XXX 命令。</li>\n</ul>\n<h3 id=\"2-2-ServiceManager注册和查找服务\"><a href=\"#2-2-ServiceManager注册和查找服务\" class=\"headerlink\" title=\"2.2 ServiceManager注册和查找服务\"></a>2.2 ServiceManager注册和查找服务</h3><p>ServiceManager 有两大主要功能：注册服务和查找服务。</p>\n<p><img data-src=\"./service_manager_work.jpeg\" alt=\"ServiceManager 工作流程\" title=\"@ASSET\"></p>\n<p>（1）Service 启动后通过 ServiceManager 注册服务 <code>do_add_service()</code>：</p>\n<ul>\n<li><p>ServiceManager 向 Binder 发送 BC_TRANSACTION 命令，携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入阻塞等待状态。</p>\n</li>\n<li><p>Binder 驱动收到命令后，向 ServiceManager 的 todo 队列中添加一条事务，事务的内容就是创建服务端进程 binder_node，并插入到 binder_procs 链表中。</p>\n</li>\n<li><p>Binder 处理完后，向 ServiceManager 发送 BR_TRANSACTION 命令，ServiceManager 收到后向已注册服务列表 svclist 中写入对应的信息 ServiceInfo，并发送 BR_REPLY 命令唤醒阻塞等待的线程。</p>\n</li>\n<li><p>每个 Service 启动时会创建一个 Binder 线程池，并向其中注册一个线程。Binder 线程池默认上线为 16 个，当 Client 调用 BinderService 处理事务时，都是通过添加到 Service 的线程池处理的：</p>\n<p><img data-src=\"./binder_process_thread.jpeg\" alt=\"Binder 进程中的线程池\" title=\"@ASSET\"></p>\n</li>\n</ul>\n<p>（2）其他进程通过 ServiceManager 查找服务 <code>do_find_service()</code>：</p>\n<ul>\n<li>ServiceManager 在 Java 层有一个 HashMap 的缓存，缓存了所有被获取过的 Service，如果命中了缓存就会直接返回。</li>\n<li>否则 ServiceManager 向 Binder 发送 BC_TRANSACTION 命令，携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入阻塞等待状态。</li>\n<li>Binder 驱动收到命令后，向 ServiceManager 发送 BC_TRANSACTION 命令，优先从已注册服务列表 svclist 中查找；<ul>\n<li>如果 serviceInfo 中存在则直接响应 BR_REPLY 并唤醒阻塞等待的线程。</li>\n<li>如果不存在，则向 binder_procs 链表中插入一条事务进行通信，事务执行后再返回响应。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-Binder机制的安全性\"><a href=\"#3-Binder机制的安全性\" class=\"headerlink\" title=\"3. Binder机制的安全性\"></a>3. Binder机制的安全性</h2><p>Binder 作为 Android 中大量使用的 IPC 机制，不仅提供了 App 之间的通信能力，还提供了 App 与系统服务之间的通信能力，因此 Binder 需要一套安全机制来确保两个进程在通信时的行为是可控的、数据是合法的，否则一个恶意进程可以通过伪造信息来模仿正常进程的行为，导致系统异常。在 Binder 机制中，从底向上一共有 3 层防护机制来确保通信双方进程以及涉及数据的安全性：</p>\n<ul>\n<li>Linux 进程信息验证</li>\n<li>SEAndroid 权限机制</li>\n<li>ServiceManager 守护</li>\n</ul>\n<h3 id=\"3-1-Linux进程信息验证\"><a href=\"#3-1-Linux进程信息验证\" class=\"headerlink\" title=\"3.1 Linux进程信息验证\"></a>3.1 Linux进程信息验证</h3><p>Linux 原生的 IPC 记录了进程的基本信息，可以通过 <code>UID</code> 或 <code>PID</code> 获取调用方和被调用方的进程，但也仅仅只有记录的功能，Linux 原生 IPC 并没有对这些信息做安全校验。</p>\n<h3 id=\"3-2-SEAndroid权限机制\"><a href=\"#3-2-SEAndroid权限机制\" class=\"headerlink\" title=\"3.2 SEAndroid权限机制\"></a>3.2 SEAndroid权限机制</h3><p>由于原生的 IPC 机制对于数据安全性没有校验，因此 Android 提供了 SELinux 模块，用于控制系统运行时敏感操作的权限。SELinux 中定义了 4 个敏感操作：</p>\n<ul>\n<li><code>call</code>: 是否允许 Client 请求 Service 通信。</li>\n<li><code>transfer</code>: 是否允许 Client 向 Service 传输 Binder 对象或文件描述符 FD。</li>\n<li><code>set_context_mgr</code>: 是否允许进程注册为 ContextManager。</li>\n<li><code>impersonate</code>: 是否允许进程代理另一个进程的通信请求（例如进程 A 请求进程 B，然后 B 携带 A 的数据向进程 C 请求通信，实际上 Android 没有出现这种情况，所以该权限实际上没有被用到）。</li>\n</ul>\n<p>SEAndroid 中定义了多个具有不同权限的安全策略 Domain，其中有一个 <code>unconfineddomain</code> 具有上述的 <code>call</code>、<code>transfer</code>、<code>set_context_mgr</code> 权限。在原生 Linux 中，进程是通过 SysCall <code>exec</code> 将可执行文件加载生成的，但在 Android 中，系统首先加载 <code>/system/bin/app_process</code> 生成 Zygote 进程，之后所有的 SystemService 和 App 进程都是由 Zygote Fork 出来的，由于 Zygote 具有 <code>unconfineddomain</code> 策略，因此 App 进程和 SystemService 都具有同样的 SELinux 权限。</p>\n<p>Client 进程对 Service 的请求都需要经过 Binder 驱动的 <code>binder_transaction</code> 处理，其中参数 <code>reply</code> 表示当前处理的事务类型：</p>\n<ul>\n<li>当 <code>reply == false</code> 时表示 Binder 正在处理的是 Client 向 Service 的请求，此时 <code>binder_transaction</code> 就需要检查 Client 是否有权限请求 Service。</li>\n<li>当 <code>reply == true</code> 时表示 Binder 正在处理的是 Service 返回 Client 的数据，此时 <code>binder_transaction</code> 就不需要检查权限。</li>\n</ul>\n<p>上文提到，ServiceManager 初始化 Binder 驱动后，会将自己注册为第 1 个 ServiceNode，因此 ServiceManager 本身也是一个 BinderService，从而 App 可以通过 ServiceManager 获取其他的 SystemService。因此当一个 Client 尝试请求 Service 时，先从 Binder 驱动中找到 ServiceManager，然后向 ServiceManager 获取目标 Service 的描述 <code>binder_transaction_data</code> 结构体，该结构体的整型成员变量 <code>target.handle</code> 就是指向目标 Service 对应 Binder 的句柄。</p>\n<blockquote>\n<p>对于 ServiceManager，其 <code>target.handle == 0</code>，对于其他 Service，<code>target.handle != 0</code>。</p>\n</blockquote>\n<p>因此 Client 通过 Binder 请求 Service 的流程大致如下：</p>\n<ul>\n<li>Client 通过 Binder 驱动中找到下标为 0 的 BinderNode，对应的即为 ServiceManager</li>\n<li>Client 请求 ServiceManager 根据 Service 名获取 TargetService 对应的 Binder 对象的句柄 <code>target.handle</code></li>\n<li>ServiceManager 找到后将 <code>target.handle</code> 存入结构体 <code>binder_transaction_data</code></li>\n<li>ServiceManager 调用 Binder 驱动的 <code>binder_transaction</code> 函数，传入 Client 的进程信息、描述 Service 对应 Binder 的句柄的结构体 <code>binder_transaction_data</code>等信息</li>\n<li>Binder 驱动调用 <code>binder_get_ref</code> 函数获取 TargetService 进程的 Binder 对象的引用 <code>ref</code></li>\n<li>Binder 驱动通过 <code>ref.node</code> 获取 TargetService 进程的 Binder 实例对象 BinderNode</li>\n<li>Binder 驱动通过 <code>BinderNode.proc</code> 获取用于描述 TargetService 进程的结构体 <code>proc</code></li>\n<li>Binder 驱动通过 <code>proc.tsk</code> 获取 TargetService 进程的结构体 <code>task_struct</code>，其中包含了 TargetService 的进程信息，以及安全上下文信息</li>\n<li>Binder 驱动调用 <code>security_binder_transaction</code> 函数，根据通信双方进程的安全上下文信息（当前进程的安全上下文 mysid、发起调用的进程的安全上下文 fromsid、目标进程的安全上下文 tosid）校验权限：<ul>\n<li>如果 <code>mysid != fromsid</code>，则需要首先校验 fromsid 是否具有 <code>impersonate</code> 权限。上文提到，由于 Android 不存在代理进程通信，因此实际上 mysid 总是等于 fromsid。</li>\n<li>校验 Client 进程是否具有请求 Service 的权限 <code>call</code>，由于所有 Zygote Fork 出来的进程都具有 <code>unconfineddomain</code> 安全策略，因此 Client 也具有 <code>call</code> 权限。</li>\n<li>校验 Client 是否具有传输 Binder 的权限 <code>transfer</code>，因为 Client 有可能会传输一个 Binder 对象给 Service 调用。同样由于具有 <code>unconfineddomain</code> 安全策略，因此 Client 也具有 <code>transfer</code> 权限。</li>\n<li>校验 <strong>目标进程 TargetService</strong> 是否具有 FD 权限，这一步与上面有区别。文件描述符 FD 用于描述一个文件，FD 包含了该文件的信息、指针等，可以理解为持有一个文件的 FD 即可操作该文件。由于 IPC 时可能会传递文件描述符 FD，因此为了避免一个拥有权限的进程获取到 FD 后就无限制传递给其他进程，就需要校验 <strong>目标进程</strong> 是否具有使用该 FD 的权限。</li>\n<li>上述校验过程中如果出现任何越权情况，都会抛出异常。</li>\n</ul>\n</li>\n</ul>\n<p>Binder 驱动通过上述流程，严格控制了通信双方进程对数据的访问是在操作系统的监控下进行的，保障了通信的安全性。</p>\n<h3 id=\"3-3-ServiceManager守护\"><a href=\"#3-3-ServiceManager守护\" class=\"headerlink\" title=\"3.3 ServiceManager守护\"></a>3.3 ServiceManager守护</h3><p>上文提到，Binder 驱动严格控制了通信双方进程的权限，因此保障了通信的安全性，但是 Binder 进程的启动以及 Binder 驱动的初始化都是由 ServiceManager 处理的，而如果 ServiceManager 被篡改，仍然有可能导致数据安全性问题。</p>\n<p>在 SELinux 模块中，Android 对注册 ServiceManager 也校验了 <code>set_context_mgr</code> 权限，但是由于 Zygote Fork 出来的进程与 ServiceManager 一样都具有 <code>unconfineddomain</code> 安全策略，因此也都会具有 <code>set_context_mgr</code> 权限，所以 Android 还采用了单例互斥的方式保障 ServiceManager 的安全：</p>\n<ul>\n<li>ServiceManager 启动时，会启动 Binder 进程以及调用 <code>binder_ioctl</code> 函数初始化 Binder 驱动，并且将 ServiceManager 自己的进程信息 <code>proc</code> 传入</li>\n<li><code>binder_ioctl</code> 函数初始化 BinderNode 链表，创建第一个 BinderNode 并存入 ServiceManager，然后用一个全局静态指针 <code>binder_context_mgr_node</code> 指向这个 BinderNode<blockquote>\n<p>当其他用户进程获取 ServiceManager 时，实际上 Binder 驱动也是直接返回该指针。</p>\n</blockquote>\n</li>\n<li>每当有进程尝试注册 ContextManager 时都会判断，如果 <code>binder_context_mgr_node != null</code> 则禁止注册</li>\n<li>由于 ServiceManager 与 Zygote 都是在 <code>init</code> 进程中创建的，因此用户进程将无法篡改 ServiceManager，保护的逻辑类似于 ClassLoader 的双亲加载模型。</li>\n</ul>\n<hr>\n<h2 id=\"4-选择Binder的理由\"><a href=\"#4-选择Binder的理由\" class=\"headerlink\" title=\"4. 选择Binder的理由\"></a>4. 选择Binder的理由</h2><p>Android 的 IPC 方式按照系统支持分为两大类：</p>\n<ul>\n<li>内核原生支持的：管道、消息队列、Socket、共享内存</li>\n<li>Android 扩展的：Binder</li>\n</ul>\n<h3 id=\"4-1-管道\"><a href=\"#4-1-管道\" class=\"headerlink\" title=\"4.1 管道\"></a>4.1 管道</h3><p>管道的通信原理是文件 IO，读与写都可以看作对管道文件的读写，分为匿名管道和命名管道两种：</p>\n<ul>\n<li>匿名管道（Pipe）：匿名管道的管道文件是存在内存中的一种特殊文件，因此只能在父子进程或兄弟进程间通信，仅支持半双工通信，而且是非永久性通信机制，通信双方进程均销毁后，则 Pipe 也会自动销毁。典型的使用方式是：A 进程调用 pipe 创建一个管道并持有描述符 <code>fd0， fd1</code> 分别指向管道文件的读端和写端，然后 Fork 出 B 进程同样持有描述符 <code>fd0, fd1</code>，根据希望的数据流向决定 Pipe 的操作：<ul>\n<li>如果希望从 A 写入、从 B 读出，则 A 关闭读端 <code>fd0</code>、B 关闭写端 <code>fd1</code>，使得 <code>fd0</code> 和 <code>fd1</code> 的引用计数都为 1，然后开始通信。</li>\n<li>如果希望从 B 写入、从 A 读出，则 A 关闭写端 <code>fd1</code>、B 关闭读端 <code>fd0</code>，使得 <code>fd0</code> 和 <code>fd1</code> 的引用计数都为 1，然后开始通信。</li>\n</ul>\n</li>\n<li>命名管道（FIFO）：命名管道的管道文件是真实存在文件系统中的文件，因此可以在任意两个能访问该文件的进程间通信，支持半双工或全双工，而且是永久性通信机制。FIFO 的读取总是从头部开始，写入总是追加到尾部。</li>\n</ul>\n<p>管道通信中每一次数据传输都需要内核两次拷贝。</p>\n<h3 id=\"4-2-消息队列\"><a href=\"#4-2-消息队列\" class=\"headerlink\" title=\"4.2 消息队列\"></a>4.2 消息队列</h3><p>消息队列的原理是缓冲区，在内核中创建一块内存（由唯一的 qid 标识）用于存放通信的消息，但消息可以是不同类型，写入时将消息写入尾部，读取时可以按照消息类型读取而不一定遵循 FIFO。消息队列位于内核中的一块内存区域，独立于通信双方进程，因此相比于 Pipe 或 FIFO，可以避免通信双方进程在同步和阻塞上的问题。</p>\n<p>消息队列在消息的传输效率上优于管道，但仍然没有避免每一次数据传输都需要内核两次数据拷贝。</p>\n<h3 id=\"4-3-Socket\"><a href=\"#4-3-Socket\" class=\"headerlink\" title=\"4.3 Socket\"></a>4.3 Socket</h3><p>Socket 本质上只是对具体协议的封装，并不参与实际的数据传输和编解码，因此 Socket 跨进程通信的原理需要根据其实现协议而定。由于 Socket 通常用于网络通信，因此可以抽象的理解为，Socket 借助了网络层的 IP 协议，由 IP 地址、端口号等唯一标识两个进程，然后通过 TCP 或 UDP 等传输层协议实现具体的通信过程。</p>\n<h3 id=\"4-4-内存共享\"><a href=\"#4-4-内存共享\" class=\"headerlink\" title=\"4.4 内存共享\"></a>4.4 内存共享</h3><p>内存共享的原理是在内核空间中开辟一块内存，并将这块地址映射到通信双方进程的虚拟地址空间，则双方进程就能通过操作这块共享内存直接将数据同步给对方，而不需要内核两次数据拷贝，内存共享极大提高了数据传输的效率，但是内存共享使得通信双方进程不再具有 C/S 模型，双方进程以类似互相持有的方式进行通信，使得通信的过程难以在操作系统的控制下进行，因此需要单独管理一套安全机制以保障通信安全性。</p>\n<h3 id=\"4-5-Binder\"><a href=\"#4-5-Binder\" class=\"headerlink\" title=\"4.5 Binder\"></a>4.5 Binder</h3><p>通过上文可以看出，Linux 原生的 IPC 方式安全则效率低，效率高则不安全，因此 Android 选择了折中的方案：Binder。</p>\n<p>Binder 基于 C/S 模型，因此对于 Server 端可以很好的保障其稳定性，并且通过 Binder 驱动的权限机制、ServiceManager 的单例模式等保障了 Binder 机制的安全性。从效率上，由于 ServiceManager 和 SystemService 都经过了安全机制的校验，因此是可信任的，所以在通信时 Binder 在内核中开辟一块内存空间，并其映射到 Service 的虚拟内存空间中，而仅拷贝一次 Client 的数据，很好地结合了安全与高效的有点。</p>\n<p>但是，Binder 作为非 Linux 原生支持的 IPC 方式，其启动过程在 ServiceManager 和 Zygote 之后，这就导致在其之前的 IPC 将无法使用 Binder 通信，典型的例子就是 InputManagerService，因为设备输入信号的监听可能发生在 ServiceManager 启动之前，因此 InputManagerService 仍然使用 Socket 与 WindowManagerService 通信。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/freekiteyu/article/details/70082302\" title=\"@LINK\">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a></li>\n<li><a href=\"https://blog.csdn.net/AndroidStudyDay/article/details/93749470\" title=\"@LINK\">腾讯面试题——谈一谈Binder的原理和实现一次拷贝的流程</a></li>\n<li><a href=\"https://blog.csdn.net/qq_27672101/article/details/108186072\" title=\"@LINK\">Binder死磕到底（一）：Linux进程通信和service manager进程</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/152237289\" title=\"@LINK\">说说你对 binder 驱动的了解？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/116440847\" title=\"@LINK\">为什么 Android 要采用 Binder 来实现 IPC 呢？</a></li>\n<li><a href=\"https://www.zhihu.com/question/39440766/answer/89210950\" title=\"@LINK\">为什么 Android 要采用 Binder 作为 IPC 机制？</a></li>\n<li><a href=\"https://blog.csdn.net/luoshengyang/article/details/38326729\" title=\"@LINK\">SEAndroid安全机制对Binder IPC的保护分析</a></li>\n<li><a href=\"https://blog.csdn.net/luoshengyang/article/details/38054645\" title=\"@LINK\">SEAndroid安全机制中的进程安全上下文关联分析</a></li>\n<li><a href=\"https://www.zhihu.com/question/41003297/answer/89328987\" title=\"@LINK\">Android源码的Binder权限是如何控制？</a></li>\n<li><a href=\"https://blog.csdn.net/chzphoenix/article/details/78854540\" title=\"@LINK\">Android中Intent/Bundle的通信原理及大小限制（Parcelable原理及与Serializable的区别）</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","Binder"]},{"title":"Android-编译、打包、安装","url":"/post/android/android-build_install/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-编译、打包、安装\"><a href=\"#Android-编译、打包、安装\" class=\"headerlink\" title=\"Android-编译、打包、安装\"></a>Android-编译、打包、安装</h1><h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><hr>\n<h2 id=\"6-MultiDex\"><a href=\"#6-MultiDex\" class=\"headerlink\" title=\"6. MultiDex\"></a>6. MultiDex</h2><p>（1）为什么方法数不能超过 65535？</p>\n<p>Android 编译时会将字节码生成 Dex 文件，而用于优化 Dex 的工具 DexOpt 会给每个方法编号检索，但是编号用的是 short，只有 2 字节，所以最高只能表示 <code>2^16 - 1 = 65535</code></p>\n<p>（2）方法数超 65535 怎么办？</p>\n<p>使用 MultiDex，将不同类和不同方法编译到不同的 Dex 中，保证每一个 Dex 中的方法数小于 65535。</p>\n<p>（3）MultiDex 是哪个版本开始支持的？之前的版本不支持，如何加载 Dex 文件？</p>\n<hr>\n<h2 id=\"混淆\"><a href=\"#混淆\" class=\"headerlink\" title=\"混淆\"></a>混淆</h2><hr>\n<h2 id=\"APK手动签名\"><a href=\"#APK手动签名\" class=\"headerlink\" title=\"APK手动签名\"></a>APK手动签名</h2><ul>\n<li><ol>\n<li>手动签名可使用第三方工具，或使用 API &gt;= 25 的 Build-Tools 中提供的 <code>apksigner.jar</code></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li><code>apksigner.jar</code> 在 <code>SDK/build-tools/XX.XX.XX（Build-Tools版本号）/lib/apksigner.jar</code>，可复制到自定义路径下使用。需要确保 <code>apksigner.jar</code> 有执行权限：<code>sudo chmod a+x apksigner.jar</code></li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>签名需要 jks 格式的 Keystore，可通过 AndroidStudio 创建，注意保存 Store 密码、Key Alias、Key 密码</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>假设 <code>apksigner.jar</code> 和未前面的 <code>Source.apk</code> 以及 <code>Key.jks（假设信息为：StorePassword: password, Alias: KeyAlias, KeyPassword: password2）</code>均在：<code>/Demo/</code> 下，且签名后输出在同一目录下的：<code>Signed.apk</code></li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>签名：<code>java -jar apksigner.jar sign --ks Demo/Key.jks --ks-key-alias KeyAlias --ks-pass pass:password --key-pass pass:password2 --out /Demo/Signed.apk /Demo/Source.apk</code></li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>检查签名：<code>java -jar apksigner.jar verify -v Signed.apk</code></li>\n</ol>\n</li>\n<li><ol start=\"7\">\n<li>执行后会列出 3 种签名的状态，后面为 false 则表示对应项未签名，并且可能会有一些 WARNING：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Verifies</span><br><span class=\"line\">Verified using v1 scheme (JAR signing): true</span><br><span class=\"line\">Verified using v2 scheme (APK Signature Scheme v2): true</span><br><span class=\"line\">Verified using v3 scheme (APK Signature Scheme v3): true</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"生成APKKey\"><a href=\"#生成APKKey\" class=\"headerlink\" title=\"生成APKKey\"></a>生成APKKey</h2><p><a href=\"https://my.oschina.net/lijindou/blog/726169\">https://my.oschina.net/lijindou/blog/726169</a></p>\n<hr>\n<h2 id=\"APK加固\"><a href=\"#APK加固\" class=\"headerlink\" title=\"APK加固\"></a>APK加固</h2><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/aha_jasper/article/details/104944929\" title=\"@LINK\">Android APK文件结构 完整打包编译的流程 APK安装过程 详解</a></li>\n<li><a href=\"https://blog.csdn.net/daitu_liang/article/details/72987378\" title=\"@LINK\">Android 分包导致报错ClassNotFoundException</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/24311062\" title=\"@LINK\">通过预安装给MultiDex加速</a></li>\n<li><a href=\"https://www.jianshu.com/p/257c3af94627\" title=\"@LINK\">Android Multidex热修复CLASS_ISPREVERIFIED问题解决方案</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","编译","打包","安装"]},{"title":"Android-Broadcast","url":"/post/android/android-broadcast/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-BroadcastReceiver\"><a href=\"#Android-BroadcastReceiver\" class=\"headerlink\" title=\"Android-BroadcastReceiver\"></a>Android-BroadcastReceiver</h1><p>BroadcastReceiver 本质上通过设置过滤来有选择地响应某些事件，例如网络状态的变化、锁屏的变化等等，其本身没有用户界面，但可以启动 Activity 或 Service，或使用 Notification 通知用户。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 接收广播后的响应</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-Broadcast的分类\"><a href=\"#1-Broadcast的分类\" class=\"headerlink\" title=\"1. Broadcast的分类\"></a>1. Broadcast的分类</h2><h3 id=\"1-1-静态和动态\"><a href=\"#1-1-静态和动态\" class=\"headerlink\" title=\"1.1 静态和动态\"></a>1.1 静态和动态</h3><p>静态和动态仅针对接收器 BroadcastReceiver，由注册方式决定。</p>\n<h4 id=\"1-1-1-静态Receiver\"><a href=\"#1-1-1-静态Receiver\" class=\"headerlink\" title=\"1.1.1 静态Receiver\"></a>1.1.1 静态Receiver</h4><p>在 Manifest 中静态声明注册的 BroadcastReceiver 就称为静态 Receiver。静态 Receiver 会随系统的启动而保持活跃，即使 App 未运行，只要接收到指定广播就会触发响应。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    <span class=\"attr\">android</span>:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:enabled=<span class=\"string\">&quot;true&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">intent-filter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;ACTION_DEMO&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-1-2-动态Receiver\"><a href=\"#1-1-2-动态Receiver\" class=\"headerlink\" title=\"1.1.2 动态Receiver\"></a>1.1.2 动态Receiver</h4><p>通过代码动态注册和销毁的 BroadcastReceiver 就称为动态 Receiver。动态 Receiver 只有在生命周期内才能接收广播。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DemoReceiver demoReceiver = <span class=\"keyword\">new</span> DemoReceiver();</span><br><span class=\"line\"><span class=\"comment\">// 动态注册</span></span><br><span class=\"line\">registerReceiver(demoReceiver, <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 销毁广播接收器</span></span><br><span class=\"line\">unregisterReceiver(demoReceiver);</span><br></pre></td></tr></table></figure>\n\n<p><code>registerReceiver()</code> 和 <code>unregisterReceiver()</code> 都是 Context 中的方法，但需要注意的是，Register 和 Unregister 必须由同一个 Context 对象调用，例如：</p>\n<ul>\n<li>AActivity 注册的 Receiver，必须由 AActivity 反注册。</li>\n<li>AActivity 注册的 Receiver，由其他 Activity 或 Application 反注册会抛出异常。</li>\n<li>同理，Application 注册的 Receiver，由其他 Activity 反注册也会抛出异常。</li>\n</ul>\n<p>注册和反注册一定要确保成对调用，如果 Activity 注册 Receiver 后未主动销毁，会导致 Activity 退出后无法回收导致内存泄漏。</p>\n<blockquote>\n<p>动态注册的 Receiver <strong>只能接收「隐式」广播</strong>。</p>\n</blockquote>\n<h3 id=\"1-2-全局和本地\"><a href=\"#1-2-全局和本地\" class=\"headerlink\" title=\"1.2 全局和本地\"></a>1.2 全局和本地</h3><p>全局和本地同时针对 Broadcast 和 BroadcastReceiver，由 Broadcast 发送方式和 Receiver 的注册方式决定。</p>\n<h4 id=\"1-2-1-全局广播\"><a href=\"#1-2-1-全局广播\" class=\"headerlink\" title=\"1.2.1 全局广播\"></a>1.2.1 全局广播</h4><p>全局 Broadcast 可以被任意全局 Receiver 接收，即使 App 并未启动。</p>\n<ul>\n<li>静态注册的 Receiver，如果 <code>exported=true</code> 则为全局 Receiver，否则为本地 Receiver。</li>\n<li>通过 <code>Context#registerReceiver()</code> 注册的是全局 Receiver。</li>\n<li><code>Context#sendBroadcast()</code> 发送的是全局广播。</li>\n</ul>\n<p>全局 Receiver 通常应该设置 <code>permission</code> 属性，可以视为「密钥」，如果 <code>permission</code> 有值，则仅当广播的 <code>permission</code> 属性匹配成功时才会响应。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态 Receiver 设置 Permission：</span></span><br><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span></span><br><span class=\"line\">    android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:enabled=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:permission=<span class=\"string\">&quot;PERMISSION_STR&quot;</span>&gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;ACTION_DEMO&quot;</span>&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 动态 Receiver 设置 Permission：</span></span><br><span class=\"line\">context.reisterReceiver(receiver, intentFilter, permission, schedulerHandler);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-2-本地广播\"><a href=\"#1-2-2-本地广播\" class=\"headerlink\" title=\"1.2.2 本地广播\"></a>1.2.2 本地广播</h4><p>本地 Broadcast 通过 <code>LocalBroadcastManager</code> 发送，只能在应用程序内部传播。本地 Receiver 通过 <code>LocalBroadcastManager</code> 注册和反注册，也只能接收应用内部的 Broadcast。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 Context 获取 LocalBroadcastManager 实例对象</span></span><br><span class=\"line\">LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);</span><br><span class=\"line\"><span class=\"comment\">// 注册本地 Receiver</span></span><br><span class=\"line\">localBroadcastManager.registerReceiver(<span class=\"keyword\">new</span> DemoReceiver(), <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 发送本地 Broadcast</span></span><br><span class=\"line\">localBroadcastManager.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本地 Broadcast 无法指定 <code>permission</code> 属性，本地注册的 Receiver 也无法过滤 <code>permission</code> 属性。</p>\n</blockquote>\n<h3 id=\"1-3-标准和有序\"><a href=\"#1-3-标准和有序\" class=\"headerlink\" title=\"1.3 标准和有序\"></a>1.3 标准和有序</h3><p>标准广播和有序广播仅针对 Broadcast，由发送方式决定。</p>\n<h4 id=\"1-3-1-标准Broadcast\"><a href=\"#1-3-1-标准Broadcast\" class=\"headerlink\" title=\"1.3.1 标准Broadcast\"></a>1.3.1 标准Broadcast</h4><p>标准 Broadcast 可以被所有类型符合的 Receiver 接收，且不能被拦截和修改。</p>\n<p>（1）发送「全局」标准 Broadcast：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不指定 Permission 的全局 Broadcast：</span></span><br><span class=\"line\">context.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 指定 Permission 的全局 Broadcast：</span></span><br><span class=\"line\">context.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>), <span class=\"string\">&quot;PERMISSION_STR&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>（2）发送「本地」标准 Broadcast：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">localBroadcastManager.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-2-有序Broadcast\"><a href=\"#1-3-2-有序Broadcast\" class=\"headerlink\" title=\"1.3.2 有序Broadcast\"></a>1.3.2 有序Broadcast</h4><p>只有全局 Broadcast 可以有序发送，按照 Receiver 的优先级（范围：-1000 ~ 1000）从高到低逐级传播，Receiver 可以修改广播数据、也可以终止广播事件。</p>\n<blockquote>\n<p>当 Priority 属性相等时，动态 Receiver 比静态 Receiver 优先。</p>\n</blockquote>\n<p>（1）设置静态 Receiver 的优先级：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;receiver</span><br><span class=\"line\">    <span class=\"attr\">android</span>:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span>&gt;</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">intent-filter</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">        <span class=\"attr\">android:priority</span>=<span class=\"string\">&quot;100&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;ACTION_DEMO&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">intent-filter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">receiver</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>（2）设置动态 Receiver 的优先级：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>);</span><br><span class=\"line\">intentFilter.setPriority(<span class=\"number\">100</span>);</span><br><span class=\"line\">context.registerReceiver(<span class=\"keyword\">new</span> DemoReceiver(), intentFilter);</span><br></pre></td></tr></table></figure>\n\n<p>（3）发送「全局」有序 Broadcast（必须指定 <code>permission</code> 属性）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">context.sendOrderedBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>), <span class=\"string\">&quot;PERMISSION_STR&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本地 Broadcast 无法设置有序。</p>\n</blockquote>\n<p>如果 Receiver 需要消费掉有序 Broadcast，阻止其继续向更低优先级的 Receiver 传递，可以通过 <code>BroadcastReceiver#abortBroadcast()</code> 方法中断后续传递：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">    Log.d(<span class=\"string\">&quot;DemoReceiver&quot;</span>, <span class=\"string\">&quot;--- onReceive ---&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该方法调用仅在收到的是有序 Broadcast 时有效。</span></span><br><span class=\"line\">    abortBroadcast();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 Receiver 想向后续优先级更低的 Receiver 传递一些信息，可以通过 <code>BroadcastReceiver#setResultExtras(Bundle)</code> 存入，由下一个 Receiver 通过 <code>BroadcastReceiver#getResultExtras(boolean)</code> 取出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HighPriorityReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 存入当前高优先级 Receiver 的数据：</span></span><br><span class=\"line\">        setResultExtras(<span class=\"keyword\">new</span> Bundle());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LowPriorityReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 取出上一个 Receiver 存入的数据</span></span><br><span class=\"line\">        <span class=\"comment\">// - 入参为 true 表示如果没有数据，会自动构造一个空 Map。</span></span><br><span class=\"line\">        <span class=\"comment\">// - 入参为 false 表示如果没有数据，会返回 null。</span></span><br><span class=\"line\">        Bundle lastData = getResultExtras(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-Broadcast的限制\"><a href=\"#2-Broadcast的限制\" class=\"headerlink\" title=\"2. Broadcast的限制\"></a>2. Broadcast的限制</h2><h3 id=\"2-1-耗时任务\"><a href=\"#2-1-耗时任务\" class=\"headerlink\" title=\"2.1 耗时任务\"></a>2.1 耗时任务</h3><p>BroadcastReceiver 的 <code>onReceive()</code> 默认运行在主进程的主线程，因此前台卡顿超过 10 秒、后台卡顿超过 60 秒就会抛出 ANR。但也不应该在 <code>onReceive()</code> 中开启子线程，因为 BroadcastReceiver 可能在 App 未启动的时候触发并启动进程，如果开启子线程，<code>onReceive()</code> 方法立即返回，则主线程及主进程可能会被退出，导致其子线程被中断，这种情况是不可预料的，因此不应该在 BroadcastReceiver 中通过子线程的方式处理耗时任务。</p>\n<p>BroadcastReceiver 通常作为一个通知者，在接收到特定的消息后，如果需要执行的耗时任务与 UI 有关，可以通过启动 Activity 的方式由 Activity 处理，如果与 UI 无关则可以通过启动 Service 的方式由 Service 处理，此时 App 进程被正常启动，Activity 或 Service 都将按照各自的生命周期执行，因此任务的处理是可预料的。</p>\n<h3 id=\"2-2-显式和隐式广播\"><a href=\"#2-2-显式和隐式广播\" class=\"headerlink\" title=\"2.2 显式和隐式广播\"></a>2.2 显式和隐式广播</h3><p>全局 BroadcastReceiver 在收到符合条件的 Broadcast 后，如果原本 App 未启动则会先启动 Application，但不会启动 Activity，此时 App 在最近任务不可见，且用户不可感知。所以高 API 对隐式广播做了限制，禁止通过隐式 Broadcast 唤起静态 Receiver，避免 App 偷偷互相拉起的情况。</p>\n<ul>\n<li>隐式广播：广播 Intent 仅指定 ActionName 属性。</li>\n<li>显式广播：广播 Intent 需要指定 <code>ComponentName</code> 属性，包含 Receiver 所在 App 的包名、以及 Receiver 的全路径。</li>\n</ul>\n<p>（1）App 内部发送的本地隐式 Broadcast 可以被其 App 内的任意 Receiver 接收。</p>\n<p>因为本地广播仅在当前 App 内传播，所以任意 Receiver 都可以接收来自其同一个 App 内部发送的「本地」隐式广播：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过隐式 Intent 发送本地 Broadcast，该 App 内所有对应 ActionName 的 Receiver 都可以收到：</span></span><br><span class=\"line\">localBroadcastManager.sendBroadcast(<span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>（2）动态注册的 Receiver 只能接收隐式 Broadcast。</p>\n<p>在 Manifest 中注册的四大组件，App 安装时系统就能明确获取到对应的信息，因此通常跨 App 调用组件时，都需要采用显式调用的方式，系统会根据显示调用的信息搜索已经静态注册的组件。但四大组件中只有 BroadcastReceiver 可以动态注册，而动态注册的 Receiver 是不会被记录在 Manifest 中的，如果向其发送显式广播，系统将无法从已注册的组件信息中搜索到对应的 Receiver，因此动态 Receiver 只能接收隐式 Broadcast。</p>\n<p>（3）外部 App 发送的隐式 Broadcast 可以被动态 Receiver 接收。</p>\n<p>因为 Google 在高 API 版本对隐式 Broadcast 唤起的限制主要时避免 App 偷偷互相拉起，因此对于已经启动的 App，其 Receiver 被唤起并不会影响用户体验。而动态 Receiver 一定是在 App 运行时注册的，因此动态 Receiver 可以接收来自其他 App 发送的隐式广播。</p>\n<p>（4）外部 App 发送的隐式 Broadcast 无法被静态 Receiver 接收。</p>\n<p>由于静态 Receiver 在 App 未启动时也响应对符合条件的 Broadcast，并且会静默启动 Application，因此静态 Receiver 被禁止接收来自外部 App 发送的全局隐式 Broadcast。向其他 App 的 Receiver 发送全局 Broadcast 时，Receiver 必须指定 <code>exported=&quot;true&quot;</code>，且发送方必须采用显式 Intent 的方式，指定 Receiver 所在 App 的包名和 Receiver 全路径：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        Log.d(<span class=\"string\">&quot;DemoReceiver&quot;</span>, <span class=\"string\">&quot;--- onReceive ---&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接收方 App 必须设置 exported=true，permission 可选。</span></span><br><span class=\"line\">&lt;manifest <span class=\"keyword\">package</span>=<span class=\"string\">&quot;priv.luis&quot;</span>&gt;</span><br><span class=\"line\">    &lt;receiver</span><br><span class=\"line\">        android:name=<span class=\"string\">&quot;.DemoReceiver&quot;</span></span><br><span class=\"line\">        android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">        /&gt;</span><br><span class=\"line\">&lt;/manifest&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送方必须指定 Receiver 所在 App 的包名以及 Receiver 的全路径：</span></span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"string\">&quot;ACTION_DEMO&quot;</span>);</span><br><span class=\"line\">intent.setComponent(<span class=\"keyword\">new</span> ComponentName(<span class=\"string\">&quot;priv.luis&quot;</span>, <span class=\"string\">&quot;priv.luis.DemoReceiver&quot;</span>));</span><br><span class=\"line\">content.sendBroadcast(intent);</span><br></pre></td></tr></table></figure>\n\n<p>查看日志即可发现，如果 Receiver 所在 App 原本未启动，则发送广播后会先启动 Application，然后触发 <code>onReceive()</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">D/OemNetd: setPidForPackage: packageName=priv.luis, pid=25234, pid=10408</span><br><span class=\"line\">I/ActivityManager: Start proc 25234:priv.luis/u0a408 <span class=\"keyword\">for</span> broadcast &#123;priv.luis/priv.luis.DemoReceiver&#125; <span class=\"built_in\">caller</span>=priv.luis.demosender</span><br><span class=\"line\">D/DemoReceiver: --- onReceive ---</span><br></pre></td></tr></table></figure>\n","categories":["Android"],"tags":["Android","四大组件","Broadcast","Receiver"]},{"title":"Android-编译时注解APT","url":"/post/android/android-compile_apt/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-APT\"><a href=\"#Android-APT\" class=\"headerlink\" title=\"Android-APT\"></a>Android-APT</h1><p>APT (Annotation Processing Tool) 发生在 Javac 编译成 Class 文件之后、Class 编码成 Dex 之前。Processor 处理的输入数据是 Javac 编译后的 Class 信息，因此 APT 的执行流程在 Javac 之后，对于 Android 开发中多 Module 的场景，由于每一个 Module 都是并行编译的，只有在产生依赖关系时才会具有先后顺序，因此只要 Module 在 Gradle 中声明了 <code>annotationProcessor</code>，则每个声明了的 Module 都会独立在 Javac 之后调用对应的 Processor 进行处理。因此 Processor 的代码可能会被调用多次，而且每一次调用时的环境都是独立、互不影响的。</p>\n<h2 id=\"1-自定义APT\"><a href=\"#1-自定义APT\" class=\"headerlink\" title=\"1. 自定义APT\"></a>1. 自定义APT</h2><p>创建自定义的 Annotation Processor 有两个前提：</p>\n<ul>\n<li><strong>Processor Module 必须是纯 Java / Kotlin Library</strong></li>\n<li><strong>Module 只需要通过 <code>annotationProcessor xxx</code> 即可应用 APT，不需要也不能依赖 Processor Module</strong></li>\n</ul>\n<p>因此 APT 的整体结构一般分为如下几个部分：</p>\n<ul>\n<li>AnnotationModule：用于存放自定义注解类，并且为纯 Java / Kotlin Library（应为需要被 Processor Module 依赖，而后者也是纯 Java / Kotlin Library）；</li>\n<li>ProcessorModule：用于存放扫描自定义注解的 Processor，依赖 AnnotationModule，同样为纯 Java / Kotlin Library；</li>\n<li>APIModule：用于对外提供业务功能，因为 APT 的作用是根据注解完成一些自动化逻辑，因此通常还会提供一些接口，当然如果是一个纯粹服务于编译流程的 APT，可以没有该 Module。同样依赖 AnnotationModule，可以是纯 Java / Kotlin Library、也可以是一个 Android Library，。</li>\n</ul>\n<h3 id=\"1-1-创建注解类\"><a href=\"#1-1-创建注解类\" class=\"headerlink\" title=\"1.1 创建注解类\"></a>1.1 创建注解类</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> DemoAnnotation &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 示例：如何为注解添加参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果参数名为 value，则使用注解时可以隐式赋值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-创建Processor\"><a href=\"#1-2-创建Processor\" class=\"headerlink\" title=\"1.2 创建Processor\"></a>1.2 创建Processor</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @SupportedOptions 注解搭配 #getSupportedOptions() 回调使用</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedOptions(&#123;&quot;org.gradle.annotation.processing.aggregating&quot;&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Filer filer;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messager messager;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Types typeUtils;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Elements elements;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化 Processor 环境，通常用于初始化 Filer，Message，ElementUtil。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\"></span><br><span class=\"line\">        filer = processingEnvironment.getFiler();</span><br><span class=\"line\">        messager = processingEnvironment.getMessager();</span><br><span class=\"line\">        typeUtils = processingEnvironment.getTypeUtils();</span><br><span class=\"line\">        elements = processingEnvironment.getElementUtils();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 支持的 JDK 版本，通常选择最新版。</span></span><br><span class=\"line\"><span class=\"comment\">     * 如果用到了某个版本 JDK 特性，则需要选择该版本或更新版本。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SourceVersion <span class=\"title\">getSupportedSourceVersion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// return SourceVersion.RELEASE_8;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> SourceVersion.latestSupported();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定 Processor 编译选项，需要 Processor 添加 <span class=\"doctag\">@SupportedOptions</span> 并指定同样的 Options。</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过该方法可以指定 Processor 的编译方式，包括全量、增量两种：</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     &lt;li&gt;默认为全量编译。&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     &lt;li&gt;在 META-INF 中注册 Processor 时指定为 isolating，则使用增量编译。&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     &lt;li&gt;在 META-INF 中注册 Processor 时指定为 dynamic，则可在该方法中选择增量编译。&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * Note: 如果一个 Module 应用了 Processor 但又没有任何一个类被 Process、</span></span><br><span class=\"line\"><span class=\"comment\">     * 或是在 Gradle 中设置了自定义 compileOptions 但未在 SupportedOptions 中定义，</span></span><br><span class=\"line\"><span class=\"comment\">     * 则会出现日志警告：</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *     The following options were not recognized by any processor: &#x27;[xxxOptionName]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * Note: Auto-Service 1.0-rc6 才支持增量编译。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedOptions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// return super.getSupportedOptions();</span></span><br><span class=\"line\">        <span class=\"comment\">// 支持增量模式：</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.singleton(<span class=\"string\">&quot;org.gradle.annotation.processing.aggregating&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 用于指定该 Processor 需要处理的注解的类。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 一个 Processor 可以同时处理多个注解，所以返回值为 Set。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Colletions.singleton(DemoAnnotation.class.getCanonicalName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 编译时处理注解的入口。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-注册Processor\"><a href=\"#1-3-注册Processor\" class=\"headerlink\" title=\"1.3 注册Processor\"></a>1.3 注册Processor</h3><p>在 Android 中使用自定义注解，有两种注册 Processor 的方式：</p>\n<ul>\n<li>AutoService 自动注册</li>\n<li>META-INF 中手动注册</li>\n</ul>\n<blockquote>\n<p>假设 Processor 所在 Module 为 <code>module_processor</code>。</p>\n</blockquote>\n<h4 id=\"1-3-1-AutoService自动注册\"><a href=\"#1-3-1-AutoService自动注册\" class=\"headerlink\" title=\"1.3.1 AutoService自动注册\"></a>1.3.1 AutoService自动注册</h4><p>借助 Google 推出的 AutoService 工具自动完成 Processor 的注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Processor 所在 Module 添加 AutoService 的依赖，并用 AutoService 的注解处理器代替完成注册：</span></span><br><span class=\"line\">implementation <span class=\"string\">&#x27;com.google.auto.service:auto-service:1.0&#x27;</span></span><br><span class=\"line\">annotationProcessor <span class=\"string\">&#x27;com.google.auto.service:auto-service:1.0&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 给 Processor 添加 AutoService 的注解：</span></span><br><span class=\"line\"><span class=\"meta\">@AutoService(Processor.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上就是用 <code>@AutoService</code> 的 Processor 动态创建了 DemoProcessor 的注册信息完成注册的。</p>\n<h4 id=\"1-3-2-META-INF中手动注册\"><a href=\"#1-3-2-META-INF中手动注册\" class=\"headerlink\" title=\"1.3.2 META-INF中手动注册\"></a>1.3.2 META-INF中手动注册</h4><p>通过 META-INF 手动注册，与 Java 中的注册方式是一样的：</p>\n<p>（1）在 Processor 所在 Module 下创建注册信息文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">module_processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor</span><br><span class=\"line\"></span><br><span class=\"line\">// 该文件目录结构如下：</span><br><span class=\"line\">module_processor</span><br><span class=\"line\">    └─ src</span><br><span class=\"line\">        └─ main</span><br><span class=\"line\">            └─ java</span><br><span class=\"line\">            └─ resources</span><br><span class=\"line\">                └─ META-INF</span><br><span class=\"line\">                    └─ services</span><br><span class=\"line\">                        └─ javax.annotation.processing.Processor</span><br></pre></td></tr></table></figure>\n\n<p>（2）在 <code>javax.annotation.processing.Processor</code> 中声明 Processor 的全路径，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">priv.demo.DemoProcessor</span><br></pre></td></tr></table></figure>\n\n<p>重新 Build 即可发现 DemoProcessor 已经可以正确处理。</p>\n<h3 id=\"1-4-使用Processor\"><a href=\"#1-4-使用Processor\" class=\"headerlink\" title=\"1.4 使用Processor\"></a>1.4 使用Processor</h3><p>当一个 Processor 成功被注册后，默认情况下只会处理 Processor 所在 Module 的注解，如果其他 Module 也需要使用该 Processor，则需要在 Gradle 中声明：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 应用 module_processor 的 Processor，并不要求与 module_processor 有依赖关系</span></span><br><span class=\"line\">annotationProcessor project(<span class=\"attr\">path:</span> <span class=\"string\">&#x27;:module_processor&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>如果想对 Gradle 编译时断点调试，需要新增单独的调试任务：</p>\n<p>（1）在 <code>Run/Debug Configurations</code> 中新增一个 <code>Remote</code> 或 <code>Remote JVM Debug</code> 任务，然后再右侧栏将目标地址选择为本地的某个端口，例如 8888：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Name: RemoteDebug（可自定义）</span><br><span class=\"line\">......</span><br><span class=\"line\">Host: localhost  Port: 8888</span><br></pre></td></tr></table></figure>\n\n<p>（2）修改项目根目录下的 <code>gradle.properties</code>，为 Gradle 添加 2 条 Debug 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Dorg.gradle.debug=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 注意配置中 address 参数的端口号要和 Configuration 中的一致：</span></span><br><span class=\"line\">org.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,<span class=\"built_in\">suspend</span>=n,address=8888</span><br></pre></td></tr></table></figure>\n\n<p>（3）重新进入 <code>Run/Debug Configurations</code> 中查看新增的 Remote Configuration，可以在其中的 <code>Command line arguments for remote JVM</code> 看到新增的 Gradle 配置参数。</p>\n<p>（4）在 <code>Run/Debug Configurations</code> 中选中新增的 Remote Configuration，执行 <strong>Debug</strong>，然后再执行编译任务（Rebuild, Assemble...），即可进入断点。</p>\n<hr>\n<h2 id=\"2-Processor开启增量编译\"><a href=\"#2-Processor开启增量编译\" class=\"headerlink\" title=\"2. Processor开启增量编译\"></a>2. Processor开启增量编译</h2><p>通过上述方式成功注册一个 Processor 后，在 Build 时 Gradle 可能会报如下警告：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">The following annotation processors are not incremental: jetified-module_processor.jar (project :module_processor).</span><br><span class=\"line\">Make sure all annotation processors are incremental to improve your build speed.</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>大致含义为 Processor 每次都是全量编译的，尽可能确保采用增量编译以提高编译速度。</p>\n</blockquote>\n<p>查阅相关资料后发现，增量编译选项需要在 Processor 的注册信息中指定，对于上文中的两种注册方式：</p>\n<ul>\n<li>如果使用 AutoService 自动注册，Auto-Service 在 1.0-rc6 版本中才支持增量编译。</li>\n<li>如果使用手动注册，则需要从 Java 原生模式注册信息修改为 Gradle 注册信息。</li>\n</ul>\n<h3 id=\"2-1-AutoService开启增量编译\"><a href=\"#2-1-AutoService开启增量编译\" class=\"headerlink\" title=\"2.1 AutoService开启增量编译\"></a>2.1 AutoService开启增量编译</h3><p>将 AutoService 的依赖以及对应的 annotationProcessor 升级到 <code>1.0-rc6</code> 或以上即可。</p>\n<h3 id=\"2-2-手动注册开启增量编译\"><a href=\"#2-2-手动注册开启增量编译\" class=\"headerlink\" title=\"2.2 手动注册开启增量编译\"></a>2.2 手动注册开启增量编译</h3><p>手动注册的 Processor 要开启增量编译，则需要切换为 Gradle 模式的注册信息。</p>\n<p>（1）在 Processor 所在 Module 创建 Gradle 模式的注册信息文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">module_processor/src/main/resources/META-INF/gradle/incremental.annotation.processors</span><br><span class=\"line\"></span><br><span class=\"line\">// Java 原生模式和 Gradle 模式的注册信息文件结构对比：</span><br><span class=\"line\">module_processor</span><br><span class=\"line\">    └─ src</span><br><span class=\"line\">        └─ main</span><br><span class=\"line\">            └─ java</span><br><span class=\"line\">            └─ resources</span><br><span class=\"line\">                └─ META-INF</span><br><span class=\"line\">                    └─ gradle</span><br><span class=\"line\">                        └─ incremental.annotation.processors (Gradle 模式注册信息文件)</span><br><span class=\"line\">                    └─ services</span><br><span class=\"line\">                        └─ javax.annotation.processing.Processor (Java 原生模式注册信息文件)</span><br></pre></td></tr></table></figure>\n\n<p>两种模式的注册信息文件可以共存，Gradle 编译时会优先选择 Gradle 模式的注册信息。</p>\n<p>（2）在 <code>incremental.annotation.processors</code> 中声明支持增量编译的注册信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">priv.demo.DemoProcessor,isolating</span><br></pre></td></tr></table></figure>\n\n<p>重新 Build，Gradle 相关警告日志已经消除。</p>\n<p>此外，Gradle 模式注册信息还支持在 Processor 代码中决定编译类型，只需要在 <code>incremental.annotation.processors</code> 中的注册信息声明为 <code>dynamic</code> 类型，然后在 <code>Processor#getSupportedOptions(...)</code> 中指定具体的编译类型即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// incremental.annotation.processors 文件中声明为 dynamic 模式：</span></span><br><span class=\"line\">priv.demo.DemoProcessor,dynamic</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Processor#getSupportedOptions(...) 中指定编译类型：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedOptions</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Aggregating 增量编译</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.singleton(<span class=\"string\">&quot;org.gradle.annotation.processing.aggregating&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-APT过滤元素\"><a href=\"#3-APT过滤元素\" class=\"headerlink\" title=\"3. APT过滤元素\"></a>3. APT过滤元素</h2><p>一个 Processor 可以同时处理多个自定义注解，因此过滤 Class 分为两步：</p>\n<ul>\n<li>确定需要过滤的注解</li>\n<li>获取并处理包含注解的元素（类、方法、属性等）。</li>\n</ul>\n<h3 id=\"3-1-选择需要过滤的注解\"><a href=\"#3-1-选择需要过滤的注解\" class=\"headerlink\" title=\"3.1 选择需要过滤的注解\"></a>3.1 选择需要过滤的注解</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; routerAnnotationTypeSet = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 添加需要处理的注解类的全限定类名。</span></span><br><span class=\"line\">        routerAnnotationTypeSet.add(DemoAnnotation.class.getCanonicalName());</span><br><span class=\"line\">        <span class=\"comment\">// 值得注意的是，方法返回的集合是注解类全限定类名的集合，</span></span><br><span class=\"line\">        <span class=\"comment\">// 这意味着 Processor 并不一定要真正具有注解类的依赖关系，</span></span><br><span class=\"line\">        <span class=\"comment\">// 手动指定一个类的全限定类名也是可行的，例如：</span></span><br><span class=\"line\">        routerAnnotationTypeSet.add(<span class=\"string\">&quot;priv.demo.DemoAnnotation&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> routerAnnotationTypeSet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-根据注解过滤需要处理的元素\"><a href=\"#3-2-根据注解过滤需要处理的元素\" class=\"headerlink\" title=\"3.2 根据注解过滤需要处理的元素\"></a>3.2 根据注解过滤需要处理的元素</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractProcessor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Elements elementUtils;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(processingEnvironment);</span><br><span class=\"line\"></span><br><span class=\"line\">        elementUtils = processingEnvironment.getElementUtils();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (set == <span class=\"keyword\">null</span> || set.isEmpty() || roundEnvironment == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (roundEnvironment != <span class=\"keyword\">null</span> &amp;&amp; roundEnvironment.processingOver()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 示例：判断是否正在处理当前 Module 的最后一个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取包含了某个注解的元素集合：</span></span><br><span class=\"line\">        Set&lt;? extends Element&gt; demoAnnotatedClassSet = roundEnvironment.getElementsAnnotatedWith(DemoAnnotation.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 同样也可以直接通过注解的全限定类名获取：</span></span><br><span class=\"line\">        TypeElement demoAnnotationClassElement = elementUtils.getTypeElement(<span class=\"string\">&quot;priv.demo.DemoAnnotation&quot;</span>);</span><br><span class=\"line\">        Set&lt;? extends Element&gt; demoAnnotatedClassSet = roundEnvironment.getElementsAnnotatedWith(demoAnnotationClassElement);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理包含了注解的元素：</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Element annotatedElement : demoAnnotatedClassSet) &#123;</span><br><span class=\"line\">            processElement(annotatedElement);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processElement</span><span class=\"params\">(RoundEnvironment roundEnvironment, Element annotatedElement)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotatedElement == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((annotatedElement <span class=\"keyword\">instanceof</span> TypeElement) &amp;&amp; annotatedElement.getKind() == ElementKind.CLASS) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 示例：判断注解是否声明在类上，同理也可判断是否在方法、属性等元素上，</span></span><br><span class=\"line\">            <span class=\"comment\">// 可根据注解定义的类型选择是否需要处理该元素。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (annotatedElement.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 示例：判断被注解的元素包含的标识符，同理也可判断 private、static 等。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 示例：获取被注解的 Class（前提是被注解的元素是 Class 类型）实现的所有接口：</span></span><br><span class=\"line\">        TypeElement annotatedTypeElement = ((TypeElement) annotatedElement);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (TypeMirror eachTypeMirror : annotatedTypeElement.getInterfaces()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 示例：判断某个接口是否是另一个接口或是其子类：</span></span><br><span class=\"line\">            TypeMirror superInterfaceTypeMirror = elementUtils.getTypeElement(<span class=\"string\">&quot;priv.demo.IDemoInterface&quot;</span>).asType();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isSubInterface = typeUtils.isSubtype(eachTypeMirror, superInterfaceTypeMirror);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，当使用全限定类名的方式（<code>elementUtils.getTypeElement(&quot;priv.demo.DemoAnnotation&quot;)</code>）获取注解类对应的 TypeElement 对象时，仅当应用了 Processor 的 Module 可以访问注解类时返回值才不为 null，但与 Processor 所在 Module 本身是否可以访问注解类无关，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">- module_annotation：不依赖任何 Module</span><br><span class=\"line\">- module_processor：不依赖任何 Module</span><br><span class=\"line\">- module_app：通过 annotationProcessor project(path: <span class=\"string\">&#x27;:module_processor&#x27;</span>) 应用 APT</span><br></pre></td></tr></table></figure>\n\n<p>此时如果 module_app 具有 module_annotation 的依赖，则 <code>elementUtils.getTypeElement(&quot;priv.demo.DemoAnnotation&quot;)</code> 可以正确返回 DemoAnnotation 的 TypeElement 对象，否则将返回 null，与 module_processor 是否具有 module_annotation 的依赖无关。</p>\n<hr>\n<h2 id=\"4-APT生成类\"><a href=\"#4-APT生成类\" class=\"headerlink\" title=\"4. APT生成类\"></a>4. APT生成类</h2><p>成功注册一个 Processor 后，就能通过对应的注解获取相关信息，并根据这些信息动态生成类。生成类文件时，可以通过 JavaPoet 等工具生成，也可以自行拼接代码文本 String 内容后直接写入文件。</p>\n<h3 id=\"4-1-在同一个Module中生成类\"><a href=\"#4-1-在同一个Module中生成类\" class=\"headerlink\" title=\"4.1 在同一个Module中生成类\"></a>4.1 在同一个Module中生成类</h3><p>仍以 <code>DemoAnnotation</code> 为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> DemoAnnotation &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果参数名为 value，则使用注解时可以隐式赋值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以 JavaPoet 为例，获取所有添加了 <code>@DemoAnnotation</code> 注解的类，并在与之相同的 Module 的 Build 目录下生成一个名为 <code>&#123;ClassName&#125;_&#123;AnnotationValue&#125;</code> 新的类：</p>\n<blockquote>\n<p>例如：</p>\n<ul>\n<li><code>@DemoAnnotation class DemoClassA &#123;&#125;</code> 将生成一个名为 <code>DemoClassA_0</code> 的类（因为 <code>DemoAnnotation#value()</code> 的默认值为 0）；</li>\n<li><code>@DemoAnnotation(123) class DemoClassB &#123;&#125;</code> 将生成一个名为 <code>DemoClassB_123</code> 的类。</li>\n</ul>\n<p>使用 JavaPoet 需要添加依赖：<code>implementation &#39;com.squareup:javapoet:1.13.0&#39;</code></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoProcessor</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseRouterProcessor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processElement</span><span class=\"params\">(Element annotatedElement)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 示例 1：获取被添加了注解的类所在的包名以及类名</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((eachElement <span class=\"keyword\">instanceof</span> TypeElement) &amp;&amp; annotatedElement.getKind() == ElementKind.CLASS) &#123;</span><br><span class=\"line\">            String packageName = annotatedElement.getEnclosingElement().toString();</span><br><span class=\"line\">            String className = annotatedElement.getSimpleName().toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 示例 2：获取元素上的注解实例（前提是有注解类的依赖，能直接访问注解类），返回值是泛型：</span></span><br><span class=\"line\">        DemoAnnotation demoAnnotation = annotatedElement.getAnnotation(DemoAnnotation.class);</span><br><span class=\"line\">        <span class=\"comment\">// 然后就能获取使用注解时的参数赋值（如果有参数的话）：</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = demoAnnotation.value();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 示例 3：如果 Processor 不能直接访问注解类，则只能获取注解包含的抽象参数 List：</span></span><br><span class=\"line\">        <span class=\"comment\">// 可以通过 List 是否为空判断元素上的注解是否设置了参数，</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果参数是枚举或 String 类型，可以尝试是否能通过字符串匹配的方式判断取值。</span></span><br><span class=\"line\">        List&lt;? extends AnnotationMirror&gt; annotationMirrorList = element.getAnnotationMirrors();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 示例：使用 JavaPoet 生成类（伪代码）</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            JavaFile.builder(packageName,</span><br><span class=\"line\">                    TypeSpec.classBuilder(className + <span class=\"string\">&quot;_&quot;</span> + value)</span><br><span class=\"line\">                            .addJavadoc(<span class=\"string\">&quot;DO NOT edit this file !!!&quot;</span>)</span><br><span class=\"line\">                            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class=\"line\">                            .build())</span><br><span class=\"line\">                    .build()</span><br><span class=\"line\">                    .writeTo(filer);</span><br><span class=\"line\">            messager.printMessage(Kind.NOTE, <span class=\"string\">&quot;Generated: &quot;</span> + packageName + <span class=\"string\">&quot;.&quot;</span> + className);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            messager.printMessage(Kind.ERROR, <span class=\"string\">&quot;Failed: &quot;</span> + packageName + <span class=\"string\">&quot;.&quot;</span> + className);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中在 <code>Processor#process(...)</code> 中，通过 JavaPoet 生成类的最后一步，调用的是 <code>writeTo(filer)</code>，而 <code>filer</code> 是在 <code>Processor#init(...)</code> 中通过运行环境获取的，可以理解为：每一个 Module 在 Javac 之后，Processor 都会被当前 Module 调用，因此 Filer 中的信息都是针对当前 Module 的，所以 <code>writeTo(filer)</code> 将会在当前 Module 下生成文件。</p>\n<h3 id=\"4-2-在任意目录生成类\"><a href=\"#4-2-在任意目录生成类\" class=\"headerlink\" title=\"4.2 在任意目录生成类\"></a>4.2 在任意目录生成类</h3><p>通过查看 JavaPoet 和 Filer 的源码可以知道，<code>writeTo(filer)</code> 实际上也是通过 Filer 获取了当前 Module 的路径信息，只不过该路径信息是相对当前 Module 的，但实际上 JavaPoet 的 <code>writeTo(...)</code> 是允许直接指定任意路径的，只需要传入对应路径的 Path 对象即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">File generatedFile = <span class=\"keyword\">new</span> File(<span class=\"string\">&quot;/DemoProject/&quot;</span> + className + <span class=\"string\">&quot;.java&quot;</span>);</span><br><span class=\"line\">JavaFile.builder(packageName,</span><br><span class=\"line\">        TypeSpec.classBuilder(className)</span><br><span class=\"line\">                .build())</span><br><span class=\"line\">        .build()</span><br><span class=\"line\">        .writeTo(generatedFile.toPath());</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/4fef2ad51f5a?utm_campaign\" title=\"@LINK\">Android APT 编译期进入debug模式</a></li>\n<li><a href=\"https://jiyang.site/posts/2020-03-24-让annotation-processor-支持增量编译/\" title=\"@LINK\">让 Annotation Processor 支持增量编译</a></li>\n<li><a href=\"https://docs.gradle.org/4.10.1/userguide/java_plugin.html#sec:incremental_annotation_processing\" title=\"@LINK\">Incremental annotation processing</a></li>\n<li><a href=\"https://blog.mindorks.com/speed-up-gradle-build-for-android-to-save-your-time\" title=\"@LINK\">Speed up Gradle build for Android to save your time</a></li>\n<li><a href=\"https://www.jianshu.com/p/9bbbf66b4fbf\" title=\"@LINK\">Gradle字符串替换</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","Annotation","注解","Processor","APT"]},{"title":"Android-编译时插件Plugin","url":"/post/android/android-compile_plugin/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-编译时插件Plugin\"><a href=\"#Android-编译时插件Plugin\" class=\"headerlink\" title=\"Android-编译时插件Plugin\"></a>Android-编译时插件Plugin</h1><p>现如今，MAD (Modern Android Development) 是一定离不开 Gradle 的；作为 Google 大力支持的新一代编译和依赖管理工具，Gradle 比早期的 ANT 及 Maven 有太多先进的地方，当然这不是本文的重点。而 Gradle 在作为编译工具时，Plugin 就是其强大的因素之一，可以说 Gradle 为编译过程提供的高自由度定制化，正是以 Plugin 为基础的。</p>\n<h2 id=\"1-Gradle和Plugin\"><a href=\"#1-Gradle和Plugin\" class=\"headerlink\" title=\"1. Gradle和Plugin\"></a>1. Gradle和Plugin</h2><p>要介绍 Gradle Plugin，就不得不提到 Gradle 和 Plugin 的关系，简单来说：<strong>Plugin 决定了 Gradle 的工作内容</strong>。</p>\n<p>一个 Android 项目几乎不可能完全仅通过本地的源码构建，除了开发过程中需要添加的依赖（包括 Android 原生的组件等）之外、还需要根据需要定制化编译脚本。如果每一个依赖或者每一个编译脚本都需要手动维护，会极大地增加开发成本，而 Gradle 同时具备「编译工具」和「依赖管理」的功能正是为了解决这一问题。Gradle 定制了一系列标准，通过代码的形式维护项目的依赖管理和编译脚本，尽可能将这些与业务开发无关的事情剥离出来，并且带来了一个非常重要的好处：自动化。因此，开发人员可以专注于编写业务代码，编译和构建的事情都可以交给流水线或其他工具自动化运行，例如定时构建、多渠道并行构建、自动化构建发布等等。</p>\n<p>因此，Gradle 是一个工具，它可以执行用于编译或依赖管理的脚本，并为项目提供开发环境。但 Gradle 是一个纯粹的工具。抽象地说，Gradle 本身只具备一些基础的执行能力，负责执行开发人员定义的脚本功能，而 Plugin，则是定义了 Gradle 执行方式的一个载体。Plugin 可以包含一系列 Gradle 的可执行脚本，并且在注册给 Gradle 后，将由 Gradle 创建，因此 Plugin 具有 Gradle 的上下文环境，可以灵活地操作各项 Gradle 执行任务。</p>\n<p>很粗略地说，Gradle 与 Plugin 就像 JVM 与 Java 类一样。</p>\n<hr>\n<h2 id=\"2-自定义Plugin\"><a href=\"#2-自定义Plugin\" class=\"headerlink\" title=\"2. 自定义Plugin\"></a>2. 自定义Plugin</h2><p>为了更方便阅读 Gradle 的源码或者查询 API，可以添加 Gradle 自己的接口依赖：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">&#x27;com.android.tools.build:gradle:x.x.x&#x27;</span>  <span class=\"comment\">// 根据需要选择版本号</span></span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">    implementation localGroovy()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义 Plugin 只需要创建一个 <code>Plugin&lt;Project&gt;</code> 的子类、并声明在配置文件中即可，Gradle Plugin 支持使用 Groovy 或 Kotlin 编写。以 Groovy 为例（其语法和规范与 Java 几乎一致）：</p>\n<ul>\n<li>创建 Groovy 代码目录及对应的包结构。</li>\n<li>创建一个 Plugin 的 Groovy 类。</li>\n<li>创建用于注册 Plugin 的配置文件。</li>\n</ul>\n<p>创建后的文件及目录结构大致为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">module_demo</span><br><span class=\"line\">└─ src</span><br><span class=\"line\">   └─ main</span><br><span class=\"line\">      ├─ groovy</span><br><span class=\"line\">      │  └─ priv.demo</span><br><span class=\"line\">      │     └─ DemoPlugin.groovy</span><br><span class=\"line\">      ├─ java</span><br><span class=\"line\">      └─ resources</span><br><span class=\"line\">         └─ META-INF</span><br><span class=\"line\">            └─ gradle-plugins</span><br><span class=\"line\">               └─ demo-plugin-custom-name.properties</span><br></pre></td></tr></table></figure>\n\n<p>（1）编写 <code>DemoPlugin.groovy</code></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> priv.demo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.Plugin</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.Project</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;This is the demo plugin.&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）将 Plugin 注册到 <code>demo-plugin-custom-name.properties</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">implementation-class=priv.demo.DemoPlugin</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>该注册文件的文件名 <code>XXX.properties</code> 就是最终可用的 Plugin 名称，可以自定义；</li>\n<li>Plugin 的 Groovy 类名只是为了编译生成 Plugin；</li>\n<li>注册文件 <code>XXX.propertyies</code> 必须放在 <code>resources/META-INF/gradle-plugins/</code> 中，文件内声明的就是 Plugin 的 Groovy 类全地址。</li>\n</ul>\n<p>（3）在其他 Module 的 <code>build.gradle</code> 文件中应用 Plugin：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 应用的 Plugin 名对应的是注册文件的文件名。</span></span><br><span class=\"line\">apply <span class=\"attr\">plugin:</span> <span class=\"string\">&quot;demo-plugin-custom-name&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）Sync Gradle，即可在 Log 中看到日志。</p>\n<hr>\n<h2 id=\"3-Plugin常见操作\"><a href=\"#3-Plugin常见操作\" class=\"headerlink\" title=\"3. Plugin常见操作\"></a>3. Plugin常见操作</h2><hr>\n<h2 id=\"4-Plugin常见问题\"><a href=\"#4-Plugin常见问题\" class=\"headerlink\" title=\"4. Plugin常见问题\"></a>4. Plugin常见问题</h2><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://stackoverflow.com/questions/18532415/execute-task-before-android-gradle-build\" title=\"@LINK\">Execute task before Android Gradle build?</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","Plugin","Gradle","插件"]},{"title":"Android-编译时插桩Transform","url":"/post/android/android-compile_transform/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-编译时插桩Transform\"><a href=\"#Android-编译时插桩Transform\" class=\"headerlink\" title=\"Android-编译时插桩Transform\"></a>Android-编译时插桩Transform</h1><h2 id=\"1-Transform简介\"><a href=\"#1-Transform简介\" class=\"headerlink\" title=\"1. Transform简介\"></a>1. Transform简介</h2><p>通过 Android 的打包流程可知，Android 除了将 Java 源文件编译成 class 文件之外，还需要将 class 文件转换为 dex 文件，而 Gradle 就为这个过程提供了一个注入节点，允许在转换为 dex 前修改编译生成的 class 文件，因此 <strong>Transform 针对的是编译后的产物</strong>。</p>\n<hr>\n<h2 id=\"2-自定义Transform\"><a href=\"#2-自定义Transform\" class=\"headerlink\" title=\"2. 自定义Transform\"></a>2. 自定义Transform</h2><h3 id=\"2-1-注册Transform\"><a href=\"#2-1-注册Transform\" class=\"headerlink\" title=\"2.1 注册Transform\"></a>2.1 注册Transform</h3><p>Gradle 编译的执行单元是 Plugin，因此 Transform 的执行也需要借助 Plugin；将 Transform 注册到 Plugin 后，当 Plugin 被执行时就会根据注册的顺序执行 Transform 任务。</p>\n<p>（1）创建一个 Transform 类并继承自 Gradle Transform：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoTransform</span> <span class=\"keyword\">extends</span> <span class=\"title\">Transform</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Transform 任务名，编译时会在日志中显示执行的任务。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    String getName() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;DemoTransform&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定该 Transform 处理的内容类型为 class 文件。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TransformManager.CONTENT_CLASS</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定该 Transform 扫描的范围，与 #getInputTypes 搭配用于过滤输入的文件内容。</span></span><br><span class=\"line\"><span class=\"comment\">     * SCOPE_FULL_PROJECT 表示扫描所有项目。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class=\"line\">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 是否支持增量处理，如果支持，则 #transform 传入的文件需要根据俄文件状态判断是否需要处理。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    boolean isIncremental() &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Transform 执行时将通过 transformInvocation 传入过滤后需要处理的内容。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断文件状态：</span></span><br><span class=\"line\">        <span class=\"comment\">// checkFileState(...)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理输入的文件：</span></span><br><span class=\"line\">        <span class=\"comment\">// handleTransform(...)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）创建一个 Plugin 并注册 Transform 任务（Plugin 的注册方式可参考上篇文章）：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoPlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化并注册至 Plugin 中：</span></span><br><span class=\"line\">        DemoTransform demoTransform = <span class=\"keyword\">new</span> DemoTransform()</span><br><span class=\"line\">        project.android.registerTransform(demoTransform)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Transform处理流程\"><a href=\"#2-2-Transform处理流程\" class=\"headerlink\" title=\"2.2 Transform处理流程\"></a>2.2 Transform处理流程</h3><p>Transform 的工作流程简单来说就是以下几步：</p>\n<ul>\n<li>（1）通过包名筛选符合条件的 Class 文件，其中 Class 有两种可能的文件来源：</li>\n<li>（2）通过读取 Class 文件包含的类信息（例如接口、注解等）进一步筛选符合条件的 Class 文件；</li>\n<li>（3）对最终符合条件的 Class 做处理（修改字节码、插桩等）；</li>\n<li>（4）将产物拷贝至 Transform 的输出目录，作为下一个 Transform 的输入；</li>\n</ul>\n<h4 id=\"2-2-1-过滤Class包名\"><a href=\"#2-2-1-过滤Class包名\" class=\"headerlink\" title=\"2.2.1 过滤Class包名\"></a>2.2.1 过滤Class包名</h4><p>Gradle 处理的 Class 文件有两种可能的来源：</p>\n<ul>\n<li>Java 文件源码编译生成的 ClassDir 下的 Class 文件；</li>\n<li>Jar、AAR 依赖包中已经集成的 Class 文件；</li>\n</ul>\n<p><code>TransformInput</code> 提供了分别读取两种来源的 Class 的接口。此外上文提到 Transform 可以指定是否开启增量模式，增量模式可以通过忽略未发生变更的文件来优化编译速度。因此可以在 <code>JarInput</code> 和 <code>DirectoryInput</code> 两个接口中先分别判断一下文件状态：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> transform(TransformInvocation transformInvocation) <span class=\"keyword\">throws</span> TransformException, InterruptedException, IOException &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.transform(transformInvocation)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果不是增量模式，需要先删除所有之前生成的产物再重新生成。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!transformInvocation.isIncremental()) &#123;</span><br><span class=\"line\">        transformInvocation.outputProvider.deleteAll()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    transformInvocation.inputs.each &#123; -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// 解析 Jar 中的 Class：</span></span><br><span class=\"line\">        it.jarInputs.each &#123; JarInput eachJarInput -&gt;</span><br><span class=\"line\">            <span class=\"comment\">// 也可以单独判断 Jar 中 Class 的文件状态：</span></span><br><span class=\"line\">            Status jarClassStatus = eachJarInput.getStatus();</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 解析 ClassDir 中的 Class：</span></span><br><span class=\"line\">        it.directoryInputs.each &#123; DirectoryInput eachDirectoryInput -&gt;</span><br><span class=\"line\">            <span class=\"comment\">// 也可以单独判断 ClassDir 中 Class 的文件状态：</span></span><br><span class=\"line\">            Map&lt;File, Status&gt; classStatusMap = eachDirectoryInput.getChangedFiles();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Status</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The file was not changed since the last build.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    NOTCHANGED,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The file was added since the last build.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ADDED,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The file was modified since the last build.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    CHANGED,</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The file was removed since the last build.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    REMOVED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-过滤Class类信息\"><a href=\"#2-2-2-过滤Class类信息\" class=\"headerlink\" title=\"2.2.2 过滤Class类信息\"></a>2.2.2 过滤Class类信息</h4><p>由于 Transform 是以文件形式接收 Class 输入，因此第一层过滤只能通过文件路径反推包名来大致过滤包名符合条件的 Class 文件，但要确定一个 Class 是否为 Transform 的处理目标，还需要读取 Class 文件中包含的类信息，例如接口、注解等，此时需要借助 ClassWriter、ClassReader 等 ASM 工具。</p>\n<h4 id=\"2-2-3-读写Class字节码\"><a href=\"#2-2-3-读写Class字节码\" class=\"headerlink\" title=\"2.2.3 读写Class字节码\"></a>2.2.3 读写Class字节码</h4><p>借助 ASM 工具可以读写文件形式的 Class。</p>\n<h4 id=\"2-2-4-拷贝Transform的产物\"><a href=\"#2-2-4-拷贝Transform的产物\" class=\"headerlink\" title=\"2.2.4 拷贝Transform的产物\"></a>2.2.4 拷贝Transform的产物</h4><p>由于 Transform 的输入和输出是「流式」的，每个 Transform 的输出即作为下一个 Transform 的输入，所以为了让下一个 Transform 仍有机会处理所有的类（而不论当前 Transform 是否已经处理过），通常会将每个原始输入（包含 Jar 或 ClassDir）都拷贝至输出目录下。</p>\n<p>当然，Transform 也可以根据是否增/删/改了某个 Class 的情况自由调整拷贝的内容，只需切记 <strong>Transform 的输出将作为下一个 Transform 的输入</strong> 即可。</p>\n<hr>\n<h2 id=\"3-Transform过滤Class\"><a href=\"#3-Transform过滤Class\" class=\"headerlink\" title=\"3. Transform过滤Class\"></a>3. Transform过滤Class</h2><h3 id=\"3-1-从Jar文件中筛选Class\"><a href=\"#3-1-从Jar文件中筛选Class\" class=\"headerlink\" title=\"3.1 从Jar文件中筛选Class\"></a>3.1 从Jar文件中筛选Class</h3><p>筛选 Jar 文件实际上就是将 Jar 解包后读取其中的 Class。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> transform(TransformInvocation transformInvocation) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.transform(transformInvocation)</span><br><span class=\"line\"></span><br><span class=\"line\">    transformInvocation.inputs.each &#123; -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 解析 Jar 中的 Class：</span></span><br><span class=\"line\">        it.jarInputs.each &#123; JarInput eachJarInput -&gt;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 从 JarInput 转为原始 Jar 文件：</span></span><br><span class=\"line\">            File srcJarFile = eachJarInput.file</span><br><span class=\"line\">            <span class=\"comment\">// 2. 计算 Transform 执行后即将被转换的新 Jar 文件：</span></span><br><span class=\"line\">            File targetJarFile = getTargetJarFile(transformInvocation, eachJarInput)</span><br><span class=\"line\">            <span class=\"comment\">// 3. 排除 Android 原生包下的文件：</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isJarInvalid(eachJarInput)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 4. 筛选 Jar 包内解析的 Class：</span></span><br><span class=\"line\">            enumerateJarEntryFromJarFile(srcJarFile)</span><br><span class=\"line\">            <span class=\"comment\">// 5. 拷贝 Jar 文件：</span></span><br><span class=\"line\">            <span class=\"comment\">//   由于 Transform 的输入和输出是「流式」的，每一个 Transform 的输出都将作为下一个 Transform 的输入，</span></span><br><span class=\"line\">            <span class=\"comment\">//   因此为了确保下一个 Transform 仍然有机会处理每个 Jar（不论当前 Transform 是否已经处理过），</span></span><br><span class=\"line\">            <span class=\"comment\">//   都需要把 Jar 重新拷贝一份到当前 Transform 的输出目录下，</span></span><br><span class=\"line\">            <span class=\"comment\">//   targetJarFile 就是就是根据原始 Jar 计算出的当前 Transform 处理后「将要」生成的输出文件。</span></span><br><span class=\"line\">            FileUtils.copyFile(jarSrcFile, jarTargetFile)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 解析 ClassDir 中的 Class：</span></span><br><span class=\"line\">        it.directoryInputs.each &#123; DirectoryInput eachDirectoryInput -&gt;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取原始 Jar 文件对应的 Transform 执行后的文件。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 该方法实际上并不会创建一个新的文件，</span></span><br><span class=\"line\"><span class=\"comment\"> * 而是通过 TransformOutputProvider 提前获取到了某个 Jar 文件被 Transform 处理后「将要」生成的文件信息。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> File getTargetJarFile(TransformInvocation transformInvocation, JarInput jarInput) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 截取原始 Jar 文件的 ShortName：</span></span><br><span class=\"line\">    String srcJarFileName = jarInput.name</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (srcJarFileName.toLowerCase().endsWith(<span class=\"string\">&quot;.jar&quot;</span>)) &#123;</span><br><span class=\"line\">        srcJarFileName = srcJarFileName.substring(<span class=\"number\">0</span>, srcJarFileName.length() - <span class=\"number\">4</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算原始 Jar 文件的 MD5 拼接成一个新的唯一文件名，仅仅是为了作为唯一区分，直接用原始文件名一般也可行：</span></span><br><span class=\"line\">    String srcJarFileMd5 = DigestUtils.md5Hex(jarInput.file.absolutePath)</span><br><span class=\"line\">    String targetJarFileName = srcJarFileName + <span class=\"string\">&#x27;_&#x27;</span> + srcJarFileMd5</span><br><span class=\"line\">    <span class=\"comment\">// 可以粗略地理解为，每一个 Jar 文件如果被 Transform 处理则会对应产生一个新的文件，这一步就是提前拿到将要产生的新文件信息（但不会提前创建）。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformInvocation</span><br><span class=\"line\">            .outputProvider</span><br><span class=\"line\">            .getContentLocation(targetJarFileName, jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 跳过 Android 原生包下的 Jar。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isJarInvalid(JarInput jarInput) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (pathName.contains(<span class=\"string\">&quot;com.android.support&quot;</span>)</span><br><span class=\"line\">            || pathName.contains(<span class=\"string\">&quot;/android/m2repository&quot;</span>)</span><br><span class=\"line\">            || pathName.contains(<span class=\"string\">&quot;androidx.&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 遍历 Jar 文件内的每个元素，找出包名符合规则的 Class。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> enumerateJarEntryFromJarFile(File srcJarFile) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> jarFile = <span class=\"keyword\">new</span> JarFile(jarSrcFile)</span><br><span class=\"line\">    Enumeration allElementsInJar = jarFile.entries()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (allElementsInJar != <span class=\"literal\">null</span> &amp;&amp; allElementsInJar.hasMoreElements()) &#123;</span><br><span class=\"line\">        JarEntry eachJarEntry = (JarEntry) allElementsInJar.nextElement()</span><br><span class=\"line\">        <span class=\"comment\">// 判断 Jar 中的元素是否满足条件：</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eachJarEntry.getName().startsWith(<span class=\"string\">&quot;priv/demo&quot;</span>)</span><br><span class=\"line\">                &amp;&amp; eachJarEntry.getName().toLowerCase().endsWith(<span class=\"string\">&quot;.class&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 找到包名满足条件的 Class 后，还要判断其类信息（例如接口、注解等）是否也满足条件：</span></span><br><span class=\"line\">            <span class=\"comment\">// scanClassFromJarEntry(...)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    jarFile.close()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-从编译目录中筛选Class\"><a href=\"#3-2-从编译目录中筛选Class\" class=\"headerlink\" title=\"3.2 从编译目录中筛选Class\"></a>3.2 从编译目录中筛选Class</h3><p>筛选 Class 目录实际上就是遍历目录中包含的每个 Class 文件：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> transform(TransformInvocation transformInvocation) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.transform(transformInvocation)</span><br><span class=\"line\"></span><br><span class=\"line\">    transformInvocation.inputs.each &#123; -&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 解析 Jar 中的 Class：</span></span><br><span class=\"line\">        it.jarInputs.each &#123; JarInput eachJarInput -&gt;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 解析 ClassDir 中的 Class：</span></span><br><span class=\"line\">        it.directoryInputs.each &#123; DirectoryInput eachDirectoryInput -&gt;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 从 DictionaryInput 转换为原始目录文件：</span></span><br><span class=\"line\">            File srcClassDir = directoryInput.file</span><br><span class=\"line\">            <span class=\"comment\">// 2. 计算 Transform 执行后即将被转换的新目录文件：</span></span><br><span class=\"line\">            File targetClassDir = getTargetClassDirectoryFile(transformInvocation, eachDirectoryInput)</span><br><span class=\"line\">            <span class=\"comment\">// 3. 筛选 Class 目录内的 Class：</span></span><br><span class=\"line\">            enumerateClassFromClassDir(srcClassDir)</span><br><span class=\"line\">            <span class=\"comment\">// 4. 拷贝 Class 目录：</span></span><br><span class=\"line\">            <span class=\"comment\">//   同理，为了确保下一个 Transform 仍然有机会处理每个 ClassDir（不论当前 Transform 是否已经处理过），</span></span><br><span class=\"line\">            <span class=\"comment\">//   都需要把 ClassDir 重新拷贝一份到当前 Transform 的输出目录下，</span></span><br><span class=\"line\">            <span class=\"comment\">//   targetClassDir 就是就是根据原始 ClassDir 计算出的当前 Transform 处理后「将要」生成的目录文件。</span></span><br><span class=\"line\">            FileUtils.copyDirectory(srcClassDir, targetClassDir)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取原始 Class 目录对应的 Transform 处理后的目录。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 该方法实际上并不会创建一个新的目录，</span></span><br><span class=\"line\"><span class=\"comment\"> * 而是通过 TransformOutputProvider 提前获取到了某个 Class 目录被 Transform 处理后「将要」生成的目录信息。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> File getTargetClassDirectoryFile(TransformInvocation transformInvocation, DirectoryInput directoryInput) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformInvocation</span><br><span class=\"line\">            .outputProvider</span><br><span class=\"line\">            .getContentLocation(directoryInput.name, directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 遍历 Class 目录内的每个文件，找出包名符合规则的 Class。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> enumerateClassFromClassDir(File srcClassDir) &#123;</span><br><span class=\"line\">    srcClassDir.eachFileRecurse &#123; File eachClassFile -&gt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!eachClassFile.isFile()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据每个 Class 文件的路径反推 Class 的包名：</span></span><br><span class=\"line\">        String eachClassShortPath = getClassShortPathFromFile(srcClassDir, eachClassFile)</span><br><span class=\"line\">        <span class=\"comment\">// 判断每个 Class 是否满足条件：</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eachClassShortPath.startsWith(<span class=\"string\">&quot;priv/demo&quot;</span>)</span><br><span class=\"line\">                &amp;&amp; eachClassShortPath.endsWith(<span class=\"string\">&quot;.class&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 找到包名满足条件的 Class 后，还要判断其类信息（例如接口、注解等）是否也满足条件：</span></span><br><span class=\"line\">            <span class=\"comment\">// scanClassFromClassFile(...)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 根据 Class 文件以及所在目录反推 Class 的文件短路径。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 因为每个 Java 类会根据包名创建对应的目录结构，但在不同构建设备上绝对路径并不一定相同，</span></span><br><span class=\"line\"><span class=\"comment\"> *   例如：priv.demo.DemoClass.java 绝对路径可能为 XXX/Project/src/main/java/priv/demo/DemoClass.java</span></span><br><span class=\"line\"><span class=\"comment\"> * 只有包名对应的短路径一定相同：priv/demo/DemoClass.Java，所以只能通过短路径反推包名是否符合条件。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String getClassShortPathFromFile(File srcClassDir, File srcClassFile) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先拿出类所在目录的绝对路径：</span></span><br><span class=\"line\">    String srcClassDirPath = srcClassDir.absolutePath</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!srcClassDirPath.endsWith(File.separator)) &#123;</span><br><span class=\"line\">        srcClassDirPath += File.separator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 从类的绝对路径中删掉前面所在目录的部分：</span></span><br><span class=\"line\">    <span class=\"comment\">// Class 目录是一个大目录，其路径不包含 Class 包名对应目录。</span></span><br><span class=\"line\">    String classShortPath = srcClassFile.absolutePath.replace(srcClassDirPath, <span class=\"string\">&#x27;&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 由于构建机系统并不确定，还需要将路径转换为统一的标准，此处均以 Unix 路径为标准：</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (File.separator != <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">        classShortPath = classShortPath.replace(<span class=\"string\">&quot;\\\\\\\\&quot;</span>, <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> classShortPath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-判断Class文件的类信息\"><a href=\"#3-3-判断Class文件的类信息\" class=\"headerlink\" title=\"3.3 判断Class文件的类信息\"></a>3.3 判断Class文件的类信息</h3><p>上文在筛选 Jar 及 ClassDir 时，实际上都是通过 <code>enumerateXXX</code> 读取了文件/目录内的每个元素，但：</p>\n<ul>\n<li>Jar 文件遍历的目标是 <code>JarEntry</code>；</li>\n<li>ClassDir 遍历的目标是 Class 对应的 <code>File</code>；</li>\n</ul>\n<p>本质上它们都是文件类型，而仅仅判断包名通常并不足以满足条件，有时还需要读取文件获取与 Class 相关的信息（例如接口、注解等）进一步判断，此时可以通过 ClassVisitor 读取：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建一个自定义的 ClassVisitor，用于读取 Class 文件的类信息。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassScannerClassVisitor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassVisitor</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> scanFromFileInputStream(InputStream classFileInputStream) &#123;</span><br><span class=\"line\">        ClassReader classReader = <span class=\"keyword\">new</span> ClassReader(classFileInputStream)</span><br><span class=\"line\">        ClassWriter classWriter = <span class=\"keyword\">new</span> ClassWriter(classReader, <span class=\"number\">0</span>)</span><br><span class=\"line\">        ClassScannerClassVisitor scannerClassVisitor = <span class=\"keyword\">new</span> ClassScannerClassVisitor(Opcodes.ASM5, classWriter)</span><br><span class=\"line\">        classReader.accept(scannerClassVisitor, ClassReader.EXPAND_FRAMES)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ClassScannerClassVisitor(<span class=\"keyword\">int</span> api, ClassVisitor classVisitor) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(api, classVisitor)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> visit(<span class=\"keyword\">int</span> version, <span class=\"keyword\">int</span> access, String className, String signature,</span><br><span class=\"line\">                String superName, String[] interfaces) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.visit(version, access, className, signature, superName, interfaces)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 示例 - 读取类的接口信息：</span></span><br><span class=\"line\">        interfaces.each &#123; interfaceName -&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过自定义的 ClassScannerClassVisitor 从 JarEntry 中读取类信息。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> scanClassFromJarEntry(File srcJarFile, JarEntry jarEntry) &#123;</span><br><span class=\"line\">    InputStream srcJarFileInputStream = srcJarFile.getInputStream(jarEntry)</span><br><span class=\"line\">    ClassScannerClassVisitor.scanFromFileInputStream(srcJarFileInputStream)</span><br><span class=\"line\">    srcJarFileInputStream.close()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过自定义的 ClassScannerClassVisitor 从 Class 文件中读取类信息。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> scanClassFromClassFile(File classFile) &#123;</span><br><span class=\"line\">    FileInputStream classFileInputStream = <span class=\"keyword\">new</span> FileInputStream(classFile)</span><br><span class=\"line\">    ClassScannerClassVisitor.scanFromFileInputStream(classFileInputStream)</span><br><span class=\"line\">    classFileInputStream.close()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-Transform字节码插桩\"><a href=\"#4-Transform字节码插桩\" class=\"headerlink\" title=\"4. Transform字节码插桩\"></a>4. Transform字节码插桩</h2><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://xiaozhuanlan.com/topic/9503782164\" title=\"@LINK\">和我一起用 ASM 实现编译期字节码织入</a></li>\n<li><a href=\"https://www.jianshu.com/p/72f051f26f18\" title=\"@LINK\">transform+asm进行字节码修改</a></li>\n<li><a href=\"https://stackoverflow.com/questions/11065262/how-to-add-static-final-field-with-initializer-using-asm/14757540#14757540\" title=\"@LINK\">How to add static final field with initializer using ASM?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4135064/static-initializer-in-asm/5328440\" title=\"@LINK\">Static Initializer in asm</a></li>\n<li><a href=\"https://www.jianshu.com/p/a7aaee4f7e4f\" title=\"@LINK\">ASM之StaticInitMerger</a></li>\n<li><a href=\"https://www.bilibili.com/read/cv10794772\" title=\"@LINK\">Java ASM详解：MethodVisitor与Opcode（一）基本操作与运算</a></li>\n<li><a href=\"https://www.jianshu.com/p/49179dea54b7\" title=\"@LINK\">MethodVisitor不调用visitMaxs()方法</a></li>\n<li><a href=\"https://juejin.cn/post/6844904072894480397\" title=\"@LINK\">Android统计方法耗时之:ASM插桩编译问题&quot;stack overflow&quot;</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_34184561/article/details/87992796\" title=\"@LINK\">利用 Transform 解决模块化开发服务调用问题</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_34138056/article/details/91368016\" title=\"@LINK\">深入理解Transform</a></li>\n<li><a href=\"https://www.jianshu.com/p/abba54baf617\" title=\"@LINK\">ASM字节码插桩详解</a></li>\n</ul>\n","categories":["Android"],"tags":["Gradle","插件","Transform"]},{"title":"Android-ContentProvider","url":"/post/android/android-contentprovider/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-ContentProvider\"><a href=\"#Android-ContentProvider\" class=\"headerlink\" title=\"Android-ContentProvider\"></a>Android-ContentProvider</h1><p>ContentProvider 使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过 ContentResolver 类从该内容提供者中获取或存入数据。</p>\n<p>只有需要在多个应用程序间共享数据是才需要内容提供者，且必须存储在一个内容提供者中。好处是可以统一数据访问方式。例如通讯录数据被多个应用程序使用。</p>\n<p>ContentProvider 使用 URI（Universal Resource Identifier，统一资源定位符）来唯一标识其数据集，URI 以 <code>content://</code> 作为前缀。通常不会直接使用 ContentProvider 类的对象，大多数是通过 ContentResolver 对象实现对 ContentProvider 的操作。</p>\n<p>一个 ContentProvider 应该包括或重写如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoContentProvider</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">&quot;luis.demo.DemoContentProvider&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 匹配成功后返回的匹配码</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MATCH_CODE = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用于判断数据请求的 URI 是否匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> UriMatcher uriMatcher;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该 APP 用于共享的数据集</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DemoData demoData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 数据改变后通知该 URI</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri NOTIFY_URI = Uri.parse(<span class=\"string\">&quot;content://&quot;</span> + AUTHORITY + <span class=\"string\">&quot;/data&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若匹配不成功则返回 NO_MATCH == -1</span></span><br><span class=\"line\">        uriMatcher = <span class=\"keyword\">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//添加预留需要匹配的 URI</span></span><br><span class=\"line\">        uriMatcher.addURI(AUTHORITY, <span class=\"string\">&quot;data&quot;</span>, MATCH_CODE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        demoData = DemoData.getInstance();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cursor <span class=\"title\">query</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> String[] projection,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                        <span class=\"meta\">@Nullable</span> String sortOrder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行数据的增删改查前先验证请求的 URI 和预留的 URI 是否匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            Cursor cursor = demoData.queryData();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cursor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getType</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Uri <span class=\"title\">insert</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> ContentValues values)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            demoData.insertData(values);</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">delete</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> deleteCount = demoData.deleteData();</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> deleteCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Uri uri, <span class=\"meta\">@Nullable</span> ContentValues values,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                      <span class=\"meta\">@Nullable</span> String selection, <span class=\"meta\">@Nullable</span> String[] selectionArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uriMatcher.match(uri) == MATCH_CODE)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> updateCount = demoData.updateData();</span><br><span class=\"line\">            notifyChange();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> updateCount;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyChange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        getContext().getContentResolver().notifyChange(NOTIFY_URI, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在其他应用中使用 ContentResolver 获取数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ContentResolver contentResolver = getContentObserver();</span><br></pre></td></tr></table></figure>\n\n<p>非必须的可选功能：如果需要对 URI 指向的数据监听变化，则需要重写并注册 ContentObserver，并传入一个 Handler 以在数据发生变化时通过 Handler 通知主线程更新 UI：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler Handler;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyContentObserver</span><span class=\"params\">(Handler handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(handler);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.Handler = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(<span class=\"keyword\">boolean</span> selfChange)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onChange(selfChange);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChange</span><span class=\"params\">(<span class=\"keyword\">boolean</span> selfChange, Uri uri)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onChange(selfChange, uri);</span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        message.obj = uri;</span><br><span class=\"line\">        Handler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在需要接收数据的 ContentResolver 中注册该 ContentObserver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String AUTHORITY = <span class=\"string\">&quot;luis.demo.DemoContentProvider&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Uri DATA_URI = Uri.parse(<span class=\"string\">&quot;content://&quot;</span> + AUTHORITY + <span class=\"string\">&quot;/data&quot;</span>);</span><br><span class=\"line\">contentResolver.registerContentObserver(DATA_URI, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DemoContentObserver(handler));</span><br></pre></td></tr></table></figure>\n\n<p>当需要对某个 ContentProvider 提供的数据增删改查时：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\">Cursor cursor = contentResolver.query(DATA_URI, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cursor != <span class=\"keyword\">null</span> &amp;&amp; cursor.getCount() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cursor.moveToNext()) &#123;</span><br><span class=\"line\">        dataValue1 = cursor.getXXX(cursor.getColumnIndex(<span class=\"string\">&quot;column1&quot;</span>));</span><br><span class=\"line\">        dataValue2 = cursor.getXXX(cursor.getColumnIndex(<span class=\"string\">&quot;column2&quot;</span>));</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入</span></span><br><span class=\"line\">ContentValues contentValues = <span class=\"keyword\">new</span> ContentValues();</span><br><span class=\"line\">contentValues.put(<span class=\"string\">&quot;culumn1&quot;</span>, dataValue1);</span><br><span class=\"line\">contentValues.put(<span class=\"string\">&quot;culumn2&quot;</span>, dataValue2);</span><br><span class=\"line\">......</span><br><span class=\"line\">contentResolver.insert(DATA_URI, contentValues);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\">contentResolver.delete(DATA_URI, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，对一个 App 共享的数据集，通常是通过 ContentResolver 处理的，而 ContentProvider 更像是提供了一个可以处理数据的接口，其定义了入口 URI，调用增删改查时的具体逻辑，并返回数据处理的结果。</p>\n","categories":["Android"],"tags":["Android","四大组件","ContentProvider"]},{"title":"Android-设计模式","url":"/post/android/android-design_pattern/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-设计模式\"><a href=\"#Android-设计模式\" class=\"headerlink\" title=\"Android-设计模式\"></a>Android-设计模式</h1>","categories":["Android"],"tags":["Android","设计模式"]},{"title":"Android-Handler","url":"/post/android/android-handler/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Handler\"><a href=\"#Android-Handler\" class=\"headerlink\" title=\"Android-Handler\"></a>Android-Handler</h1><h2 id=\"1-Handler的实例化和初始化\"><a href=\"#1-Handler的实例化和初始化\" class=\"headerlink\" title=\"1. Handler的实例化和初始化\"></a>1. Handler的实例化和初始化</h2><p>Handler 在 Android 开发中还是相当相当常见的，其涉及到了很多 Android 和 Java 的数据结构。Handler 的源码并不复杂，原理也很有意思，常用的方法里实例化和初始化就占了很大一部分，消息 Message 的传递也占了很大一部分，本文主要也是分析这两点，剩下的用的不是太多，直接阅读源码也很快，在本文就不分析了。通过阅读 Handler 以及相关类的源码，可以深刻体会到 Android 的一些通用设计理念。</p>\n<h3 id=\"1-1-什么是Handler\"><a href=\"#1-1-什么是Handler\" class=\"headerlink\" title=\"1.1 什么是Handler\"></a>1.1 什么是Handler</h3><p>在 Handler 的源码中，有一段很长的注释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A Handler allows you to send and process &#123;<span class=\"doctag\">@link</span> Message&#125; and Runnable</span></span><br><span class=\"line\"><span class=\"comment\"> * objects associated with a thread&#x27;s &#123;<span class=\"doctag\">@link</span> MessageQueue&#125;.  Each Handler</span></span><br><span class=\"line\"><span class=\"comment\"> * instance is associated with a single thread and that thread&#x27;s message</span></span><br><span class=\"line\"><span class=\"comment\"> * queue.  When you create a new Handler, it is bound to the thread /</span></span><br><span class=\"line\"><span class=\"comment\"> * message queue of the thread that is creating it -- from that point on,</span></span><br><span class=\"line\"><span class=\"comment\"> * it will deliver messages and runnables to that message queue and execute</span></span><br><span class=\"line\"><span class=\"comment\"> * them as they come out of the message queue.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and</span></span><br><span class=\"line\"><span class=\"comment\"> * runnables to be executed at some point in the future; and (2) to enqueue</span></span><br><span class=\"line\"><span class=\"comment\"> * an action to be performed on a different thread than your own.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;Scheduling messages is accomplished with the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #post&#125;, &#123;<span class=\"doctag\">@link</span> #postAtTime(Runnable, long)&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #postDelayed&#125;, &#123;<span class=\"doctag\">@link</span> #sendEmptyMessage&#125;,</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #sendMessage&#125;, &#123;<span class=\"doctag\">@link</span> #sendMessageAtTime&#125;, and</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@link</span> #sendMessageDelayed&#125; methods.  The &lt;em&gt;post&lt;/em&gt; versions allow</span></span><br><span class=\"line\"><span class=\"comment\"> * you to enqueue Runnable objects to be called by the message queue when</span></span><br><span class=\"line\"><span class=\"comment\"> * they are received; the &lt;em&gt;sendMessage&lt;/em&gt; versions allow you to enqueue</span></span><br><span class=\"line\"><span class=\"comment\"> * a &#123;<span class=\"doctag\">@link</span> Message&#125; object containing a bundle of data that will be</span></span><br><span class=\"line\"><span class=\"comment\"> * processed by the Handler&#x27;s &#123;<span class=\"doctag\">@link</span> #handleMessage&#125; method (requiring that</span></span><br><span class=\"line\"><span class=\"comment\"> * you implement a subclass of Handler).</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;When posting or sending to a Handler, you can either</span></span><br><span class=\"line\"><span class=\"comment\"> * allow the item to be processed as soon as the message queue is ready</span></span><br><span class=\"line\"><span class=\"comment\"> * to do so, or specify a delay before it gets processed or absolute time for</span></span><br><span class=\"line\"><span class=\"comment\"> * it to be processed.  The latter two allow you to implement timeouts,</span></span><br><span class=\"line\"><span class=\"comment\"> * ticks, and other timing-based behavior.</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;When a</span></span><br><span class=\"line\"><span class=\"comment\"> * process is created for your application, its main thread is dedicated to</span></span><br><span class=\"line\"><span class=\"comment\"> * running a message queue that takes care of managing the top-level</span></span><br><span class=\"line\"><span class=\"comment\"> * application objects (activities, broadcast receivers, etc) and any windows</span></span><br><span class=\"line\"><span class=\"comment\"> * they create.  You can create your own threads, and communicate back with</span></span><br><span class=\"line\"><span class=\"comment\"> * the main application thread through a Handler.  This is done by calling</span></span><br><span class=\"line\"><span class=\"comment\"> * the same &lt;em&gt;post&lt;/em&gt; or &lt;em&gt;sendMessage&lt;/em&gt; methods as before, but from</span></span><br><span class=\"line\"><span class=\"comment\"> * your new thread.  The given Runnable or Message will then be scheduled</span></span><br><span class=\"line\"><span class=\"comment\"> * in the Handler&#x27;s message queue and processed when appropriate.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>大概翻译一下，这段注释基本也介绍清楚了 Handler 的工作流程：</p>\n<ul>\n<li>Handler 允许你发送和处理和线程的 MessageQueue 相关联的 Message 和 Runnable 对象。每个 Handler 实例对象都只和一个线程以及该线程的消息队列。当创建一个 Handler 实例时，这个 Handler 会与线程以及这个线程创建的消息队列绑定，这之后，这个 Handler 会负责给 MessageQueue 传送 Message 和 Runnable，或者负责处理从 MessageQueue 中取出的 Message 和 Runnable。</li>\n<li>Handler 有 2 个主要的用途：（1）给 Message 和 Runnable 安排一个未来执行的时间（可以是相差 0，表示立即执行）；（2）将一个事务提交到另一个不同的线程处理。</li>\n<li>Handler 通过 <code>post</code>，<code>postAtTime(Runnable, long)</code>，<code>postDelayed</code>，<code>sendEmptyMessage</code>，<code>sendMessage</code>，<code>sendMessageAtTime</code>，<code>sendMessageDelayed</code> 方法调度 Message。<code>post</code> 方式允许发送一个 Runnable 对象并在被 MessageQueue 接收后调用。<code>shendMessage</code> 方式允许发送一个包括了一个 Bundle 形式的数据的 Message，并且在 <code>Handler.handleMessage()</code> 方法中处理（要求实现一个 Handler 的子类）。</li>\n<li>不论使用 <code>post</code> 还是 <code>send</code> 方式发送消息，都可以让这些消息在 MessageQueue 可用时立即处理，或者指定一个延时间隔来延迟处理，或者指定一个具体的处理事件。后面二者可以通过：延迟、具体时间、或其他基于时间的行为来实现。</li>\n<li>当 App 的进程被创建时，它的主线程则专门用来运行一个管理顶层应用对象的 MessageQueue，这些顶层应用对象可以是例如：Activity，BroadcastReceiver 等等，或是他们创建的其他 Windows。你可以创建自己的子线程，并通过 Handler 与主线程通信，只需要在子线程中调用上述的 <code>send</code> 类型或 <code>post</code> 类型的方法即可，发送的 Message 或 Runnable 将在 Handler 的 MessageQueue 合适的时候被调度和处理。</li>\n</ul>\n<p>需要注意的几个重点：（1）Handler 可以用来发送消息也可以用来处理消息；（2）发送消息有两种类型的方式，处理消息可以跨进程；（3）Handler 的实例是和当前线程以及当前线程的 MessageQueue 绑定的；（4）MessageQueue 中维护的单链表只支持 Message 对象，因此 Runnable 是通过封装进 Message 来实现的。</p>\n<h3 id=\"1-2-Handler构造方法\"><a href=\"#1-2-Handler构造方法\" class=\"headerlink\" title=\"1.2 Handler构造方法\"></a>1.2 Handler构造方法</h3><p>Handler 内部有多个不同参数的构造方法，依次看看：</p>\n<p>（1）无参默认构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Default constructor associates this handler with the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the</span></span><br><span class=\"line\"><span class=\"comment\">  * current thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class=\"line\"><span class=\"comment\">  * so an exception is thrown.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该构造方法会使得 Handler 与当前线程的 Looper 关联，如果当前线程没有 Looper，则 Handler 将无法接收消息，从而抛出异常。</p>\n<p>（2）1 个参数（<code>Callback</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Constructor associates this handler with the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the</span></span><br><span class=\"line\"><span class=\"comment\">  * current thread and takes a callback interface in which you can handle</span></span><br><span class=\"line\"><span class=\"comment\">  * messages.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * If this thread does not have a looper, this handler won&#x27;t be able to receive messages</span></span><br><span class=\"line\"><span class=\"comment\">  * so an exception is thrown.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和默认无参构造方法类似，只不过重写了接收消息后处理的回调方法 <code>handleMessage</code>。</p>\n<p>（3）1 个参数（<code>async</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和默认无参构造方法类似，只不过指定了通过这个 Handler 发送的消息为异步消息（Async）。</p>\n<p>（4）以上第 1、2、3 种构造方法最终均调用了 2 个参数（<code>Callback, async</code>）的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Looper.myLooper()</code> 就是返回了当前线程中的 Looper 实例对象，如果当前线程不具备处理消息的功能，也即没有 Looper 实例，则返回 <code>null</code>，接下来也就是当存在 Looper 实例对象时，获取并绑定其消息队列 MessageQueue，处理事件的回调 Callback，以及设置是否异步 async。</p>\n<p>（5）1 个参数（<code>Looper</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>手动指定这个 Handler 需要绑定的线程，当我们需要从子线程更新 UI 时，通常会使用如下方法来实例化一个 Handler：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Handler handler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper());</span><br></pre></td></tr></table></figure>\n\n<p>这其实就是调用的这个构造方法，而 <code>Looper.getMainLooper()</code> 返回的就是主线程的 Looper 实例对象。</p>\n<p>（6）2 个参数（<code>Looper, Callback</code>）的构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one and take a callback</span></span><br><span class=\"line\"><span class=\"comment\">  * interface in which to handle messages.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时指定 Looper 和 Callback。</p>\n<p>（7）以上第 5、6 种构造方法最终均调用了 3 个参数的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the provided &#123;<span class=\"doctag\">@link</span> Looper&#125; instead of the default one and take a callback</span></span><br><span class=\"line\"><span class=\"comment\">  * interface in which to handle messages.  Also set whether the handler</span></span><br><span class=\"line\"><span class=\"comment\">  * should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by conditions such as display vsync.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> looper The looper, must not be null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    mLooper = looper;</span><br><span class=\"line\">    mQueue = looper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个构造方法则是最详细的，可以同时指定 Looper，Callback，以及是否异步 async。</p>\n<p>通过查看以上 7 种构造方法，可以总结出 Handler 的实例化过程：如果没有显式传入任何参数，则默认绑定当前线程的 Looper，使用默认 Callback，发送同步消息，否则按照对应显式传入的参数手动指定。</p>\n<hr>\n<h2 id=\"2-Handler发送Message\"><a href=\"#2-Handler发送Message\" class=\"headerlink\" title=\"2. Handler发送Message\"></a>2. Handler发送Message</h2><h3 id=\"2-1-源码分析\"><a href=\"#2-1-源码分析\" class=\"headerlink\" title=\"2.1 源码分析\"></a>2.1 源码分析</h3><p>在平时开发中 Handler 最主要的用途就是在子线程中更新 UI，两种方式：</p>\n<ul>\n<li><p><code>send</code> 方式，包括：</p>\n<ul>\n<li><code>sendMessage</code> 或 <code>sendEmptyMessage</code></li>\n<li><code>sendMessageDelayed</code> 或 <code>sendEmptyMessageDelayed</code></li>\n<li><code>sendMessageAtTime</code> 或 <code>sendEmptyMessageAtTime</code></li>\n<li><code>sendMessageAtFrontOfQueue</code>（比较特殊，会在后面详细讲解）</li>\n</ul>\n</li>\n<li><p><code>post</code> 方式，包括：</p>\n<ul>\n<li><code>post</code></li>\n<li><code>postDelayed</code></li>\n<li><code>postAtTime</code></li>\n<li><code>postAtFrontOfQueue</code></li>\n</ul>\n</li>\n</ul>\n<p>其中，通过查看 <code>post</code> 方式的源码可以发现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  sendMessageDelayed(getPostMessage(r), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Delayed</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@hide</span> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(Runnable r, <span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r).setWhat(what), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"meta\">@Nullable</span> Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(getPostMessage(r, token), delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AtTime</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r, <span class=\"meta\">@Nullable</span> Object token, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AtFrontOfQueue</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">postAtFrontOfQueue</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Runnable r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtFrontOfQueue(getPostMessage(r));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上 <code>post</code> 方式最终都是通过 <code>send</code> 方式实现的。再看一下各个 <code>send</code> 方式的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> what)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendEmptyMessageDelayed(what, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendEmptyMessageAtTime</span><span class=\"params\">(<span class=\"keyword\">int</span> what, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    Message msg = Message.obtain();</span><br><span class=\"line\">    msg.what = what;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageDelayed</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delayMillis &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        delayMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtTime</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">sendMessageAtFrontOfQueue</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">    MessageQueue queue = mQueue;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        RuntimeException e = <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"keyword\">this</span> + <span class=\"string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class=\"line\">        Log.w(<span class=\"string\">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enqueueMessage(queue, msg, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在以上源码中可以看到一个参数：<code>uptimeMillis</code>，这个参数是从开机到当前时刻的时间间隔（毫秒，当设备处于睡眠时不计算），表示消息需要被处理时的时间，任意不同时刻获取到的该值都是不同的，<code>uptimeMillis</code> 越小表示消息越早处理。<strong>消息在添加到消息队列中时，是按照实际处理的时间从先到后按顺序排列的</strong>，并且除了 <code>sendMessageAtFrontOfQueue</code> 方法之外，其他 <code>send</code> 方式本质都是通过这一个方法发送的：<code>sendMessageAtTime</code>，而这两个方法最终都调用了 <code>enqueueMessage</code>，看看这个方法内部：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> MessageQueue queue, <span class=\"meta\">@NonNull</span> Message msg, <span class=\"keyword\">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class=\"line\">    msg.target = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAsynchronous) &#123;</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法每一句都说明了 Message 的一个性质：</p>\n<ul>\n<li><code>msg.target = this;</code> 这句把 Message 和 Handler 绑定在了一起。</li>\n<li><code>msg.workSourceUid = ThreadLocalWorkSource.getUid();</code> 这句是获取到了当前线程的 Uid，也就是和当前线程绑定在了一起。</li>\n<li><code>msg.setAsynchronous(true);</code> 这句是设置为异步，<code>if</code> 也表示默认情况下的 Message 是同步的。</li>\n</ul>\n<p>最后调用了 <code>MessageQueue.enqueueMessage</code> 方法把 Message 插入到消息队列中。</p>\n<h3 id=\"2-2-流程总结\"><a href=\"#2-2-流程总结\" class=\"headerlink\" title=\"2.2 流程总结\"></a>2.2 流程总结</h3><p>通过以上源码分析，Handler 在发送一个消息后的流程也就清楚了：</p>\n<ol>\n<li>接收一个 Message，并根据设置的延时，设置 Message 的 <code>when</code></li>\n<li>根据情况设置 Message 的类型，默认情况下为同步消息</li>\n<li>将 Message 的 <code>target</code> 设置为自己</li>\n<li>调用 MessageQueue 的 <code>enqueueMessage</code> 方法</li>\n<li><code>MessageQueue.enqueueMessage</code> 方法中，根据 <code>when</code> 从小到大的顺序将 Message 插入到单链表对应位置</li>\n<li>根据条件唤醒 Native 层的消息队列</li>\n</ol>\n<hr>\n<h2 id=\"3-Handler机制总结\"><a href=\"#3-Handler机制总结\" class=\"headerlink\" title=\"3. Handler机制总结\"></a>3. Handler机制总结</h2><p>通过分析 Handler 的实例化和初始化，以及 Handler 发送消息的流程，可以总结出 Handler 的工作机制：</p>\n<ol>\n<li>Handler 默认和当前线程以及当前线程的 MessageQueue 绑定，默认发送同步消息。</li>\n<li>可以手动指定 Handler 的线程、重写接收消息后的回调方法 <code>Callback.handleMessage()</code>。</li>\n<li>可以手动指定发送的消息类型，但一个 Handler 只能发送一种消息，不能交替发送。</li>\n<li>Handler 所在线程由实例化时的 Looper 有关，且只能接收到与之绑定的线程中的消息，如果线程不具备处理消息的功能，则 Handler 无法接收消息且会抛出异常。</li>\n<li>Handler 有两种发送消息的方式，但本质上都是 <code>send</code> 方式。</li>\n<li>Handler 可以发送 Message，也可以发送 Runnable，但由于 MessageQueue 维护的单链表元素是 Message，因此 Runnable 实际上是封装在 message 中的。</li>\n</ol>\n","categories":["Android"],"tags":["Android","Handler","源码"]},{"title":"Android-热更新","url":"/post/android/android-hotfix/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-热更新\"><a href=\"#Android-热更新\" class=\"headerlink\" title=\"Android-热更新\"></a>Android-热更新</h1><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.cnblogs.com/popfisher/p/8543973.html\" title=\"@LINK\">Android热修复技术原理详解（最新最全版本）</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","热更新"]},{"title":"Android-线程间通信","url":"/post/android/android-itc/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-线程间通信\"><a href=\"#Android-线程间通信\" class=\"headerlink\" title=\"Android-线程间通信\"></a>Android-线程间通信</h1><h2 id=\"1-Android创建线程\"><a href=\"#1-Android创建线程\" class=\"headerlink\" title=\"1. Android创建线程\"></a>1. Android创建线程</h2><blockquote>\n<p>线程池可参考：<a href=\"/post/java/java-thread\" title=\"@LINK\">Java-Thread</a>。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-线程间通信ITC\"><a href=\"#2-线程间通信ITC\" class=\"headerlink\" title=\"2. 线程间通信ITC\"></a>2. 线程间通信ITC</h2><blockquote>\n<p>ITC, Inter Thread Communication</p>\n</blockquote>\n<p>（1）<code>runOnUiThread()</code></p>\n<p>直接将指定代码运行在主线程。</p>\n<p>（2）<code>View.post()</code></p>\n<p>（3）<code>AsyncTask</code></p>\n<p>在主线程中调用开启后台任务，然后通过继承自 <code>AsyncTask</code> 的类并重写 <code>doInBackground(Object[] objs)</code> 和 <code>onPostExecute(Object obj)</code> 分别指定后台任务以及任务执行完毕后的步骤。</p>\n<ul>\n<li><code>AsyncTask</code> 至少两个线程，最多有 <code>2 * CPU + 1</code>，核心线程数最少 2 个、最大 4 个，空闲线程存活时间 30 秒。</li>\n<li><code>AsyncTask</code> 内部维护了一个线程池和一个 <code>Handler</code>，所以有可能发生内存泄漏。</li>\n</ul>\n<p>（4）Handler</p>\n","categories":["Android"],"tags":["Android"]},{"title":"Android-Looper","url":"/post/android/android-looper/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Looper\"><a href=\"#Android-Looper\" class=\"headerlink\" title=\"Android-Looper\"></a>Android-Looper</h1><p>前言：本文是针对 Looper 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：</p>\n<ul>\n<li><a href=\"/post/java/java-threadlocal/java-threadlocal/\" title=\"@LINK\">Java——ThreadLocal</a></li>\n<li><a href=\"/post/android/android-message/android-message/\" title=\"@LINK\">Android——Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/android-messagequeue/\" title=\"@LINK\">Android——MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/android-looper/\" title=\"@LINK\">Android——Looper</a></li>\n<li><a href=\"/post/android/android-handler/android-handler/\" title=\"@LINK\">Android——Handler</a></li>\n</ul>\n<hr>\n<h2 id=\"1-Looper简介\"><a href=\"#1-Looper简介\" class=\"headerlink\" title=\"1. Looper简介\"></a>1. Looper简介</h2><p>首先看一下源码中对 Looper 的注释说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Class used to run a message loop for a thread.  Threads by default do</span></span><br><span class=\"line\"><span class=\"comment\">  * not have a message loop associated with them; to create one, call</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #prepare&#125; in the thread that is to run the loop, and then</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #loop&#125; to have it process messages until the loop is stopped.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;Most interaction with a message loop is through the</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Handler&#125; class.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This is a typical example of the implementation of a Looper thread,</span></span><br><span class=\"line\"><span class=\"comment\">  * using the separation of &#123;<span class=\"doctag\">@link</span> #prepare&#125; and &#123;<span class=\"doctag\">@link</span> #loop&#125; to create an</span></span><br><span class=\"line\"><span class=\"comment\">  * initial Handler to communicate with the Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  *  class LooperThread extends Thread &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *      public Handler mHandler;</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *      public void run() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *          Looper.prepare();</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *          mHandler = new Handler() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *              public void handleMessage(Message msg) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  *                  // process incoming messages here</span></span><br><span class=\"line\"><span class=\"comment\">  *              &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  *          &#125;;</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *          Looper.loop();</span></span><br><span class=\"line\"><span class=\"comment\">  *      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">  *  &#125;&lt;/pre&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Looper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * API Implementation Note:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * This class contains the code required to set up and manage an event loop</span></span><br><span class=\"line\"><span class=\"comment\">     * based on MessageQueue.  APIs that affect the state of the queue should be</span></span><br><span class=\"line\"><span class=\"comment\">     * defined on MessageQueue or Handler rather than on Looper itself.  For example,</span></span><br><span class=\"line\"><span class=\"comment\">     * idle handlers and sync barriers are defined on the queue whereas preparing the</span></span><br><span class=\"line\"><span class=\"comment\">     * thread, looping, and quitting are defined on the looper.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大致翻译：</p>\n<p>（1）Looper 被 Thread 用于运行一个消息循环。一个线程默认不具有与之关联的消息循环（消息队列），如果想要为线程创建一个消息队列，在该线程中调用 <code>Looper.prepare()</code>，然后再调用 <code>Looper.loop()</code> 来启动消息处理循环，该循环将一直运行直到被终止。</p>\n<p>（2）大多数情况下，和消息循环的交互是通过 <code>Handler</code> 完成的。</p>\n<p>（3）以下代码是实现一个具有消息循环的线程的典型方式，通过分别调用 <code>prepare()</code> 和 <code>loop()</code> 来创建一个初始化的 <code>Handler</code> 并用于和 <code>Looper</code> 交互：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LooperThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Handler mHandler;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// process incoming messages here</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）Looper 类中包含某些代码，是需要通过 MessageQueue 来设置和管理事件循环的。影响消息队列的状态的 API 应该在 MessageQueue 或 Handler 中而不是在 Looper 本身定义，例如 <code>Idle Handler</code> 和同步障栅是在消息队列中定义的，而 Thread 的前期准备、消息循环、退出则是在 Looper 中完成的。</p>\n<p>以上内容可能涉及到 Handler 或 Message 的内容，可以通过系列对应的文章查阅。</p>\n<hr>\n<h2 id=\"2-Looper初始化和实例化\"><a href=\"#2-Looper初始化和实例化\" class=\"headerlink\" title=\"2. Looper初始化和实例化\"></a>2. Looper初始化和实例化</h2><p>Looper 类光是从名字就能看出来作用，通过之前对 Handler 的源码分析可以知道，Handler 构造时，可以手动传入一个 Looper 对象和处理消息的回调 Callback，用来与 Handler 绑定，此时这个 Handler 则会用来处理该 Looper 的消息队列中的消息，并且与该 Looper 处在同一线程，而默认构造方法则最终都调用了以下构造方法，并且内部给 Looper 传入了一个 <code>null</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到默认情况下会调用 <code>Looper.myLooper()</code>，再查看一下这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Return the Looper object associated with the current thread.  Returns</span></span><br><span class=\"line\"><span class=\"comment\">  * null if the calling thread is not associated with a Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">Looper <span class=\"title\">myLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sThreadLocal.get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法也就是从 <code>ThreadLocal</code> 中获取一个对象，ThreadLocal 的相关内容在系列文章中已有介绍，简单来说，首先需要向当前线程中 <code>set()</code> 一个对象，才能 <code>get()</code> 出来，并且 ThreadLocal 中存放的对象是和线程绑定的，不同线程只能 <code>get()</code> 到该线程自己 <code>set()</code> 进去的对象，再看一下这个 <code>sThreadLocal</code> 在一开始的声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>说明存取的都是 Looper 对象。Looper 其实有两个 <code>prepare()</code> 方法，一个无参，另一个就是以下这个有一个布尔类型参数的，但无参的 <code>prepare()</code> 最终也是调用的有参这个：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Initialize the current thread as a looper.</span></span><br><span class=\"line\"><span class=\"comment\">  * This gives you a chance to create handlers that then reference</span></span><br><span class=\"line\"><span class=\"comment\">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #quit()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>Looper.prepare(boolean)</code> 方法中有这么一段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepare</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sThreadLocal.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sThreadLocal.set(<span class=\"keyword\">new</span> Looper(quitAllowed));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里就清楚了，Looper 在调用 <code>prepare()</code> 方法后，会往对应的 ThreadLocal 中存放一个实例化的 Looper 对象，而 <code>Looper.myLooper()</code> 则是从 ThreadLocal 中取出这个对象，因此如果一个 Looper 没有先调用 <code>prepare()</code> 就直接使用会报错。但是为什么不直接通过 <code>new</code> 来生成实例对象呢？因为 Looper 的构造方法是私有的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Looper</span><span class=\"params\">(<span class=\"keyword\">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class=\"line\">    mQueue = <span class=\"keyword\">new</span> MessageQueue(quitAllowed);</span><br><span class=\"line\">    mThread = Thread.currentThread();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这么设计的好处我个人理解为：① Looper、Handler、Thread 这些类都是由系统进行资源管理的，用户不应具有太大的修改权限，并且 Looper 类是 <code>final</code> 修饰的，也不允许用户继承重写。② Looper 必须和指定的线程绑定，指定调用 <code>prepare()</code> 方法可以强调这一特性。③ Looper 只能和一个线程绑定，使用 ThreadLocal 管理，采用 <code>new</code> 的方式可能会有多线程的问题。</p>\n<hr>\n<h2 id=\"3-Looper总结\"><a href=\"#3-Looper总结\" class=\"headerlink\" title=\"3. Looper总结\"></a>3. Looper总结</h2><p>其实到这里 Looper 的工作原理和流程就已经可以总结了：</p>\n<ol>\n<li>Looper 是一个消息循环。</li>\n<li>Looper 内有成员变量 MessageQueue，并通过它循环取出、派发消息进行事件处理。</li>\n<li>Looper 无法通过构造方法实例化，而是通过 <code>prepare()</code> 方法，并在内部调用了 <code>myLooper()</code> 方法来实例化一个 Looper 对象，且会和线程绑定，通过对应线程的 ThreadLocal 来存取。</li>\n<li>Looper 所在的线程决定了 Handler 处理消息时所在的线程。实例化 Handler 时，可以自行创建某线程的 Looper 实例化对象，并将其与 Handler 绑定，则 Handler 处理的消息即来自于 Looper 所在的线程。</li>\n<li>线程默认是不具有消息循环的，也即默认情况下一个 Thread 是不会维护 Looper 的，通过继承重写 Thread，并在其中调用 <code>Looper.prepare()</code> 来创建消息循环，再通过 <code>Looper.loop()</code> 来开启循环。</li>\n</ol>\n<p>但在实际开发中其实有些比较常见的问题：</p>\n<p>（1）平时用 Handler 处理消息时，并没有调用 <code>Looper.prepare()</code> 或通过其手动创建一个 Looper 对象，但依然可以正常处理消息。这是因为，Android 的主线程即 UI 线程，有一定的特殊性，整个 App 过程中仅允许存在一个 UI 线程，而 App 的主线程对应在 <code>ActivityThread.main()</code> 方法，其也是整个 App 的入口方法，在这个方法里面就生成了 Looper 的实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Looper.prepareMainLooper();</span><br></pre></td></tr></table></figure>\n\n<p>对应 Looper 中的源码为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Initialize the current thread as a looper, marking it as an</span></span><br><span class=\"line\"><span class=\"comment\">  * application&#x27;s main looper. The main looper for your application</span></span><br><span class=\"line\"><span class=\"comment\">  * is created by the Android environment, so you should never need</span></span><br><span class=\"line\"><span class=\"comment\">  * to call this function yourself.  See also: &#123;<span class=\"doctag\">@link</span> #prepare()&#125;</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    prepare(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sMainLooper != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sMainLooper = myLooper();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然本质上仍然是通过 <code>prepare(boolean)</code> 方法生成了一个成员变量 <code>sMainLooper</code>，但是加了类锁，并且只允许创建一次，由于 App 运行期间，主线程一直存在，因此主线程的对应的 Looper 实例对象 <code>sMainLooper</code> 在 App 运行期间有且仅有一个，所以在主线程中使用 Handler 无需手动创建 Looper 实例对象以及显式调用 <code>prepare()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程中实例化 Handler</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Handler mainHandler = <span class=\"keyword\">new</span> Handler(<span class=\"keyword\">new</span> Handler.Callback() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>（2）即使在子线程中，也可以不显式调用 <code>prepare()</code> 方法，这时 Handler 的初始化方式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Handler mainHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.handleMessage(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里是 <code>void handleMessage(Message)</code>和（1）中使用匿名 Callback 的 <code>boolean handleMessage(Message)</code> 不同。</p>\n</blockquote>\n<p>这里不需要显式调用 <code>prepare()</code> 的原因是给 Handler 传了一个 <code>Looper.getMainLooper()</code> 的参数，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Returns the application&#x27;s main looper, which lives in the main thread of the application.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Looper <span class=\"title\">getMainLooper</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (Looper.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sMainLooper;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到实际上就是返回了主线程的 <code>sMainLooper</code>，所以也不需要手动创建 Looper 实例对象。</p>\n<p>（3）利用 <strong>Handler 处理消息所在线程由其实例化时传入的 Looper 对象决定</strong> 这一特性，可以衍生出主线程和子线程之间交互的方式：</p>\n<ol>\n<li>子线程向主线程发送消息：在子线程实例化 Handler 时传入 <code>Looper.getMainLooper()</code> 参数。</li>\n<li>主线程向子线程发送消息：在主线程实例化 Handler 时传入一个在子线程中调用过 <code>prepare()</code> 方法已初始化的 Looper 对象。</li>\n</ol>\n<p>针对以上情形 ②，主线程开启子线程后向下执行，如果主线程发送消息的时间较早，可能子线程还没有完成对 Looper 的实例化，则会导致空指针异常，此时可以将子线程用 <code>HandlerThread</code> 类代替，实例化时传入一个 <code>String</code> 类型的线程标记名，HandlerThread 不能重写 <code>run()</code> 方法，当然也不需要显式调用 <code>prepare()</code> 和 <code>loop()</code>，通过 <code>HandlerThread.getLooper()</code> 即可获取 Looper 实例对象。</p>\n","categories":["Android"],"tags":["Android","源码","Looper"]},{"title":"Android-内存优化","url":"/post/android/android-memory/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-内存优化\"><a href=\"#Android-内存优化\" class=\"headerlink\" title=\"Android-内存优化\"></a>Android-内存优化</h1><h1 id=\"内存泄漏和内存抖动\"><a href=\"#内存泄漏和内存抖动\" class=\"headerlink\" title=\"内存泄漏和内存抖动\"></a>内存泄漏和内存抖动</h1><h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>（1）内存泄漏的原因：</p>\n<ul>\n<li>Handler 发送的消息未被处理则会导致 MessageQueue 一直持有 Handler 和 Message 的引用，解决办法：创建静态内部 Handler 类继承自 Handler，并实例化该内部的 Handler，并且在 <code>onDestroy()</code> 方法中手动移除所有未处理的消息、或者使用进程唯一的 MainLooper 来实例化 Handler。</li>\n<li>单例模式的生命周期通常和 App 一致，若其中传入了 Context，则会导致对应的 Context 无法被回收，此时可以改用 Application 的 Context。</li>\n<li>使用 View、Context 等作为参数传递到外部对象中，由于 Context 和 View 对象很容易被回收，如果被外部对象持有，很可能会导致内存泄漏。可以使用弱引用 WeakReference。</li>\n<li>非静态匿名内部类，例如一个非静态的 Runnable 对象，被用来实例化一个匿名 Thread 对象：<code>new Thread(runnable).start();</code>，由于该 Runnable 对象非静态，会自动持有其外部类的引用，则导致外部类无法被回收。可以通过把 Runnable 对象声明为 <code>static</code> 解决。</li>\n<li>注册/反注册未成对使用，例如广播接收器，可以在 <code>onCreate()</code> 或 <code>onResume()</code> 中注册，在 <code>onDestroy()</code> 或 <code>onPause()</code> 中释放。</li>\n<li>资源为关闭，例如 Cursor、File、Bitmap、视频等，通常内部实现了一些缓冲技术，并且可能还涉及到 Native 层，都需要手动关闭资源，否则会引起内存泄漏。</li>\n<li>集合未及时清理，例如将一些 View、Context 等存入集合中导致无法回收，或是将集合声明为 <code>static</code>，都会导致内存泄漏。</li>\n</ul>\n<p>（2）内存泄漏的检测：</p>\n<p>主要是引入 LeakCanary，然后在 Application 中初始化和安装，之后在设备上运行 App 即可在 LeakCanary 中自动检测。还有MAT、Lint等。</p>\n<ul>\n<li>LeakCanary 原理</li>\n<li>利用logging监听方法耗时，会不会让app增大延迟</li>\n</ul>\n<p>通过Looper.setMessageLogging(Printer)来设置自己的Printer，Printer会在Looper处理一个事件的开始和结束输出Msg的相关信息。</p>\n<h2 id=\"内存抖动\"><a href=\"#内存抖动\" class=\"headerlink\" title=\"内存抖动\"></a>内存抖动</h2><p>内存抖动主要是短时间内有大量对象产生和销毁，伴随着频繁的 GC，占用大量 CPU 和 UI 线程资源，导致 App 卡顿。</p>\n<p>（1）内存抖动的原因：</p>\n<ul>\n<li>在循环中声明和创建对象，可以改为在外部创建对象，然后在循环内实例化。</li>\n<li>频繁改变 <code>String</code> 对象，可以改为使用 <code>StringBuilder</code> 最后再转为 <code>String</code>。</li>\n<li><code>View</code> 中的 <code>onDraw()</code> 方法会被频繁调用，应当尽量避免创建对象。</li>\n<li>频繁使用的图片资源，或者复用几率较大的对象，可以建立缓存。</li>\n</ul>\n<p>（2）内存抖动的检测和定位：</p>\n<p>使用 AndroidStudio 自带的工具 Android Profile，选择 Memory 栏，当出现 GC 时，会显示一个垃圾桶图标，如果 GC 出现的频繁，则很可能是内存抖动。</p>\n<p>使用 AndroidStudio 自带的工具：Tools - Android - Android Device Monitor，打开 App，在 Monitor 工具中选择 App 对应的进程，然后运行对应的功能后，选择 DDMS 工具，查看一个 .trace 文件，在“main”栏会显示具体的抖动，找到发生抖动（柱状图起伏很大的一段）放大后，对应的找到相关的方法（方法被调用时，调用者的方法序号小于其调用的方法的序号），根据实际情况追溯到对应的方法中去查看有没有可能导致内存抖动的代码并修改。</p>\n<hr>\n<h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><p>（1）逻辑层</p>\n<p>尽可能消除或减少内存泄漏、内存抖动。</p>\n<p>（2）UI 层</p>\n<ul>\n<li>减少布局层级，可通过手机的“过渡绘制”和 AndroidStudio - Tools - Layout Inspector 查看。</li>\n<li>使用 ViewStub 占位不常用资源。</li>\n<li>使用简单的布局，例如在层级相同的前提下，使用 FrameLayout 或 LinearLayout 替代 RelativeLayout。</li>\n<li>优化自定义 View 中的 <code>onDraw()</code>，避免复杂语句。</li>\n</ul>\n<p>（3）应用层</p>\n<ul>\n<li>耗时操作异步处理。</li>\n<li>复用资源本地缓存。</li>\n<li>Bitmap 优化，例如读取信息时，设置 <code>BitmapFactory.Options.inJustDecodeBounds = true;</code>，则仅读取宽高而不将具体数据读入内存，当图片过大时，对图片进行压缩，缓存一份压缩后的图片，对需要显示大图的地方，使用 <code>BitmapRegionDecoder</code>，指定 Bitmap 的区域进行解码。</li>\n</ul>\n<p>（4）代码层</p>\n<ul>\n<li>ListView、RecyclerView，使用 ViewHolder 复用布局。</li>\n<li>减少枚举类。由于 JVM 使用 int 作为默认整型变量，因此在数据量大和非必要场景下，使用 int 替代 short、byte 反而性能更好。</li>\n<li>使用 SparseArray 或 ArrayMap 代替简单的 HashMap 结构。</li>\n</ul>\n<p>稀疏数组是针对替换 <code>HashMap&lt;Integer, Object&gt;</code> 的，其意义在于：如果一个 HashMap 里面存的数据很少，会浪费很多空闲的内存空间，因此可以使用一个压缩后的矩阵来表示。SparseArray 矩阵，分为上下两个部分，共三列。上部分只有第一行，从左到右三列分别是：原 HashMap 的行数、原 HashMap 的列数、原 HashMap 共使用了几个元素。下部分则分别记录了原 HashMap 中使用了的元素分别在原 HashMap 中的行下标、列下标、取值。</p>\n<p>ArrayMap使用两个数组来存放键值对，一个数组存放Key，另一个存放Value。</p>\n<p>如果Key确定是Int，可使用SparseArray，Long可使用LongSparseArray，其他使用ArrayMap，但数据量大时，还是使用HashMap，因为SparseArray和ArrayMap使用二分法，将计算后的Hash值按从小到大的顺序排列插入和读取。</p>\n<p>（5）启动优化</p>\n<p>利用window background快速展示一个界面给用户快速的心理预期，启动的过程，如第一个Activity的onCreate中避免繁重的初始化任务，IO、网络等耗时操作懒加载，减少布局嵌套等。</p>\n<p>（6）APK体积优化</p>\n<p>资源文件方面：使用webp代替传统jpg和png格式，单色背景或简单几何图形使用drawable或者Vector代替图片，大型媒体文件使用动态联网加载代替打进APK包，多Module之间复用的资源避免冗余。</p>\n<p>代码层，去除无用的第三方依赖，减少枚举类，代码混淆，</p>\n<hr>\n<h2 id=\"ListView和RecyclerView性能对比和性能优化\"><a href=\"#ListView和RecyclerView性能对比和性能优化\" class=\"headerlink\" title=\"ListView和RecyclerView性能对比和性能优化\"></a>ListView和RecyclerView性能对比和性能优化</h2><p>ListView 开发成本低，性能和功能上 RecyclerView 更优。</p>\n<p>RecyclerView在很多方面能取代ListView，Google为什么还不弃用ListView？</p>\n<p>在某些轻量级场景下，例如纯文字的列表时，RecyclerView强制使用Holder的形式芳儿增加了开销，而且开发成本也更高一些。</p>\n<p>（1）ListView：</p>\n<p>Adapter.getView中，ConvertView==null时，说明当前的Item的View还没创建，LayoutInflate一个View，否则说明View可复用，直接让View=convertView。</p>\n<p>根据每个Item都有的布局创建一个ViewHolder，这个ViewHolder保存了每一个Item通用的布局的View的对象，如果ConvertView==null，说明当前Item的View还没创建，则新建一个ViewHolder并将该Holder存入View.tag里，否则说明可复用，直接getTag取出holder，然后重新给里面的View对象赋值。</p>\n<p>（2）RecyclerView：</p>\n<p>onBindViewHolder运行在UI线程中，尽量避免耗时操作</p>\n<p>数据量较大时，用DiffUtil代替notifyDataSetChanged，只刷新局部数据：<br>DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(oldDatas, newDatas), true);<br>diffResult.dispatchUpdatesTo(mAdapter);<br>其本质是计算出新旧数据具体在哪些地方和哪一段发生了变化，然后根据实际情况调用：<br>mAdapter.notifyItemRangeInserted(position, count);<br>mAdapter.notifyItemRangeRemoved(position, count);<br>mAdapter.notifyItemMoved(fromPosition, toPosition);<br>mAdapter.notifyItemRangeChanged(position, count, payload);<br>来实现的。</p>\n<p>布局优化，减少Item的过度绘制、减少Item的层级</p>\n<p>RecyclerView的Item很灵活，因此每一次加载，都会调用requestLayout来刷新父布局，如果所有Item的高度固定，可以调用RecyclerView.setHasFixedSize(true);避免</p>\n<p>如果RecyclerView嵌套了RecyclerView，且可以使用相同的Adapter，则可以设置RecyclerView.setRecycledViewPool(pool)来共用一个RecycledViewPool，如果LayoutManager是LinearLayoutManager或其子类，需要手动开启：layout.setRecycleChildrenOnDetach(true)</p>\n<hr>\n<h2 id=\"Bitmap加载大图（加载局部）\"><a href=\"#Bitmap加载大图（加载局部）\" class=\"headerlink\" title=\"Bitmap加载大图（加载局部）\"></a>Bitmap加载大图（加载局部）</h2><p><a href=\"https://www.jianshu.com/p/73aecb2b85e6\">https://www.jianshu.com/p/73aecb2b85e6</a></p>\n<p>（1）设置 <code>inJustDecodeBounds</code> 来预检测图片大小。</p>\n<p>（2）大图尝试先压缩显示预览图。</p>\n<p>（3）当放大显示时，测量当前 ImageView 实际可显示的范围，按照实际可显示范围加载局部图（<code>BitmapRegionDecoder</code>）。</p>\n<p>（4）<code>BitmapRegionDecoder.newInstance(InputStream, boolean)</code>，传入图片输入流实例化一个 <code>bitmapRegionDecoder</code>。</p>\n<p>（5）编码局部：<code>bitmapRegionDecoder.decodeRegion(Rect, BitmapFactory.Options);</code></p>\n<p>（6）绘制：<code>canvas.drawBitmap()</code></p>\n<p>（7）通过手势监听类 GestureDetector 的实例对象在 <code>onTouch(View v, MotionEvent event)</code> 中调用 <code>gestureDetector.onTouchEvent(event)</code>，并继承重写 <code>GestureDetector.onScroll(motionEvent e1, MotionEvent e2, float distanceX, float distanceY)</code> 来监听手势变化，并重新计算需要显示的矩形范围，然后在 <code>onDraw()</code> 中重新绘制对应区域的 Bitmap。</p>\n<hr>\n","categories":["Android"],"tags":["Android"]},{"title":"Android-Message","url":"/post/android/android-message/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Message\"><a href=\"#Android-Message\" class=\"headerlink\" title=\"Android-Message\"></a>Android-Message</h1><h2 id=\"1-Message的种类\"><a href=\"#1-Message的种类\" class=\"headerlink\" title=\"1. Message的种类\"></a>1. Message的种类</h2><p>在 Android 中经常使用 Message 来发送一些“消息”，这个“消息”有自己的标识 <code>what</code>，有自己的两个通用参数 <code>arg1</code> 和 <code>arg2</code>，有自己的具体消息内容 <code>obj</code>，似乎消息就是一个通过标识传递数据的功能，但其实里面大有门道。</p>\n<p>在使用 Message 时，默认情况下越早发送的消息越早被处理，这是因为默认的消息即为同步消息，而实际上消息有三种：同步消息、异步消息、障栅消息：</p>\n<ol>\n<li>在默认情况下均为 <strong>同步消息</strong>，同步消息的意义即：除非指定 Message 的执行时间，否咋 Message 会以队列（FIFO，先进先出）的机制顺序处理消息。</li>\n<li>异步消息则不受顺序的限制，即使在同步消息阻塞的情况下，依然可以处理异步消息。</li>\n<li>障栅消息本身并不携带额外的数据，可以看成是一个阻塞器，它用于阻塞同步消息而对异步消息没有影响，可以看成是让异步消息优先执行的一个调节器。</li>\n</ol>\n<p>而消息是否同步，并不是由 Message 本身决定的，而是由处理消息的 Handler 决定的。</p>\n<hr>\n<h2 id=\"2-同步消息\"><a href=\"#2-同步消息\" class=\"headerlink\" title=\"2. 同步消息\"></a>2. 同步消息</h2><p>在默认初始化 Handler 时，不论是调用无参构造方法，还是传递 Looper 的构造方法，或者重写回调的构造方法，其实源码里都有这么一个内部调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(looper, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(callback, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>内部调用了有布尔值的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略了其他几个带布尔值的构造方法，详细可查源码</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>这些带布尔值的内部构造方法，其布尔值含义都是一样的：<code>async</code>，是否异步。可以看到，当我们实例化 Handler 没有显式传入一个 <code>true</code> 作为参数时，默认调用的内部构造方法均使用了 <code>false</code> 作为参数，也即：<strong>默认情况下不使用异步</strong>。</p>\n<hr>\n<h2 id=\"3-异步消息\"><a href=\"#3-异步消息\" class=\"headerlink\" title=\"3. 异步消息\"></a>3. 异步消息</h2><p>如果需要使用异步消息，则需要实例化 Handler 时手动指定 <code>async</code> 参数。从源码可以看到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(<span class=\"keyword\">null</span>, async);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@hide</span></span><br><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Looper looper, <span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于这 3 个可以指定 <code>async</code> 的构造方法，均添加了 <code>@hide</code> 或 <code>@UnsupportedAppUsage</code> 注解，因此只能通过反射才能手动构造。查看第二个方法的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Use the &#123;<span class=\"doctag\">@link</span> Looper&#125; for the current thread with the specified callback interface</span></span><br><span class=\"line\"><span class=\"comment\">  * and set whether the handler should be asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Handlers are synchronous by default unless this constructor is used to make</span></span><br><span class=\"line\"><span class=\"comment\">  * one that is strictly asynchronous.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * Asynchronous messages represent interrupts or events that do not require global ordering</span></span><br><span class=\"line\"><span class=\"comment\">  * with respect to synchronous messages.  Asynchronous messages are not subject to</span></span><br><span class=\"line\"><span class=\"comment\">  * the synchronization barriers introduced by &#123;<span class=\"doctag\">@link</span> MessageQueue#enqueueSyncBarrier(long)&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> callback The callback interface in which to handle messages, or null.</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> async If true, the handler calls &#123;<span class=\"doctag\">@link</span> Message#setAsynchronous(boolean)&#125; for</span></span><br><span class=\"line\"><span class=\"comment\">  * each &#123;<span class=\"doctag\">@link</span> Message&#125; that is sent to it or &#123;<span class=\"doctag\">@link</span> Runnable&#125; that is posted to it.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Callback callback, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class=\"line\">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Log.w(TAG, <span class=\"string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class=\"line\">                klass.getCanonicalName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mLooper = Looper.myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLooper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">            <span class=\"string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()</span><br><span class=\"line\">                    + <span class=\"string\">&quot; that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mQueue = mLooper.mQueue;</span><br><span class=\"line\">    mCallback = callback;</span><br><span class=\"line\">    mAsynchronous = async;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释里面很清楚地写到，该方法使用当前线程的 Looper 来实例化 Handler。手动指定该方法的参数 <code>async = true</code>，即可使得该 Handler 所发送的消息均为 <strong>异步消息</strong>。</p>\n<hr>\n<h2 id=\"4-障栅消息\"><a href=\"#4-障栅消息\" class=\"headerlink\" title=\"4. 障栅消息\"></a>4. 障栅消息</h2><p>障栅消息的本质也只是一个 Message，但是其 <code>target</code> 为 <code>null</code>（其他消息不能设置为 <code>null</code>，否则会报异常），且 <code>arg1</code> 设置为一个从 0 开始每次自增 1 的 token，用于标识不同的障栅消息。前面已经介绍到，障栅消息的作用是阻塞添加到消息队列的时间比它晚的同步消息，因此障栅消息添加到队列时，会根据添加的时间 <code>when</code> 来插入到对应的消息位置。为了便于理解，这里把 <code>when</code> 比障栅消息小的最后一个消息（即障栅消息前一个）称为 LAST，把这个消息的下一个（即障栅消息后一个）称为 ONEMORE。</p>\n<p>（1）在 MessageQueue 中发送障栅消息的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其调用了另一个私有同名方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">postSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Enqueue a new sync barrier token.</span></span><br><span class=\"line\">    <span class=\"comment\">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mNextBarrierToken 从 0 开始</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> token = mNextBarrierToken++;</span><br><span class=\"line\">        <span class=\"comment\">// 障栅消息</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Message msg = Message.obtain();</span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        msg.arg1 = token;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 中间变量，用于记录比障栅消息早的最后一个消息（障栅消息的前一个）</span></span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 当前第一条消息</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (when != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息比障栅消息更早，则不阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 用 prev 记录当前消息 p</span></span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                <span class=\"comment\">// p 指向下一条消息</span></span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 循环完成后，会找出所有 when 比障栅消息更小的 Message</span></span><br><span class=\"line\">            <span class=\"comment\">// 且按照原顺序连接在单链表中，这些消息不会阻塞。</span></span><br><span class=\"line\">            <span class=\"comment\">// 此时 LAST 即是 prev，而 p 则指向了 ONEMORE。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            <span class=\"comment\">// 说明循环进到了内部，也即障栅消息将位于 LAST 和 ONEMORE 的中间</span></span><br><span class=\"line\">            <span class=\"comment\">// 则障栅消息的下一条为 ONEMORE，即 p</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            <span class=\"comment\">// LAST 的下一条为障栅消息</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明循环没有进入，也即障栅消息将位于消息队列的首位</span></span><br><span class=\"line\">            <span class=\"comment\">// 则障栅消息的下一条为原先消息队列的第一条消息</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            <span class=\"comment\">// 消息队列的第一条消息变为障栅消息</span></span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并返回了一个 token，当一个障栅消息被加入到 MessageQueue 后，比障栅消息被添加的时间 <code>when</code> 更晚的同步消息将被阻塞，而异步消息不受影响，直到使用和返回值相同的 token 作为参数调用 <code>removeSyncBarrier(int token)</code> 将该障栅消息移除后，同步消息才恢复处理。</p>\n<p>从源码中可以得知，这一步其实只是把一个障栅消息插入到 MessageQueue 中，插入的位置是由障栅消息的 <code>when</code> 决定的，而障栅消息的 <code>when</code> 则是在公有无参 <code>postSyncBarrier()</code> 中，传入了一个 <code>SystemClock.uptimeMillis()</code>，因此障栅消息的添加无法自定义插入点，只能在代码中手动在想要阻塞的同步消息的前面执行 <code>postSyncBarrier()</code>。</p>\n<p>（2）接下来是移除障栅消息 <code>removeSyncBarrier(int token)</code> 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Removes a synchronization barrier.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #postSyncBarrier&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remove a sync barrier token from the queue.</span></span><br><span class=\"line\">    <span class=\"comment\">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从消息队列的第一个元素开始</span></span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"comment\">//遍历消息队列的所有元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有 p.targe == null 且 p.arg1 == token 的才是对应的障栅消息</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 是否需要唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 说明目标障栅消息不是第一个消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 则将障栅消息的前一条消息的 next 指向障栅消息的下一条</span></span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            <span class=\"comment\">// 因为障栅消息之前有消息，还没有阻塞，所以不需要唤醒</span></span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果障栅消息是第一条消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 则消息队列的第一条消息直接设置为障栅消息的下一条</span></span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息（原先障栅消息的下一条）为 null，说明消息队列中没有消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果当前消息的 target != null，说明</span></span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the loop is quitting then it is already awake.</span></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>移除障栅消息就比较简单了，就是遍历消息队列找到 <code>target == null</code> 且 token 对应的消息并移除即可，满足某些条件时还需要唤醒 native 层的消息队列。</p>\n","categories":["Android"],"tags":["Android","源码","Message","消息"]},{"title":"Android-MessageQueue","url":"/post/android/android-messagequeue/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-MessageQueue\"><a href=\"#Android-MessageQueue\" class=\"headerlink\" title=\"Android-MessageQueue\"></a>Android-MessageQueue</h1><h2 id=\"1-认识MessageQueue\"><a href=\"#1-认识MessageQueue\" class=\"headerlink\" title=\"1. 认识MessageQueue\"></a>1. 认识MessageQueue</h2><p>在分析 MessageQueue 之前，首先要了解到一个消息队列的误区：MessageQueue 从名字上看来是一个“队列”，主要是其处理消息的方式比较像一个队列。实际上，因为会频繁地出现 Message 的插入和删除等操作，如果是用传统的“队列”来存放 Message，插入、删除的效率会很低，因此 MessageQueue 采用单链表的形式（单链表插入、删除只需要变动两个节点对象的连接目标即可）来管理 Message。</p>\n<p>MessageQueue 源码里的注释对其一些性质进行了说明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Low-level class holding the list of messages to be dispatched by a</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Looper&#125;.  Messages are not added directly to a MessageQueue,</span></span><br><span class=\"line\"><span class=\"comment\">  * but rather through &#123;<span class=\"doctag\">@link</span> Handler&#125; objects associated with the Looper.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;You can retrieve the MessageQueue for the current thread with</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> Looper#myQueue() Looper.myQueue()&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br></pre></td></tr></table></figure>\n\n<p>大概意思是：</p>\n<blockquote>\n<p>MessageQueue 是一个持有 Message 的低等级类，它所持有的 Message 由 Looper 分发。Message 并不是直接被添加到 MessageQueue 中的，而是通过 Handler 的对象与 Looper 绑定起来。</p>\n<p>你可以通过 <code>Looper.myQueue()</code> 方法取回当前线程的 MessageQueue。</p>\n</blockquote>\n<p>这段注释特别关键，以至于我觉得已经足以说明整个 MessageQueue 的工作方式了，上半段概括了 MessageQueue 如何管理 Message，下半段概括了 MessageQueue、Looper 以及线程的关系。</p>\n<hr>\n<h2 id=\"2-MessageQueue管理Message\"><a href=\"#2-MessageQueue管理Message\" class=\"headerlink\" title=\"2. MessageQueue管理Message\"></a>2. MessageQueue管理Message</h2><h3 id=\"2-1-添加Message\"><a href=\"#2-1-添加Message\" class=\"headerlink\" title=\"2.1 添加Message\"></a>2.1 添加Message</h3><p>（1）当一个 Message 产生并且被发送时，通过 Handler 的对象将这个 Message 和当前线程绑定，再插入到 MessageQueue 单链表中。</p>\n<p>通过 Handler 源码可知，一个消息被发送后，Handler 最终会调用 <code>MessageQueue.enqueueMessage(Message msg, long when)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg.isInUse()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(msg + <span class=\"string\">&quot; This message is already in use.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    msg.target + <span class=\"string\">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class=\"line\">            Log.w(TAG, e.getMessage(), e);</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键点：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Message must have a target.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这句也就是手动将 <code>Message.target</code> 设置为 <code>null</code> 会报异常的原因。其余部分也就是根据 Message 的 <code>when</code> 来将 Message 插入到 MessageQueue 的指定位置，并且根据情况唤醒 Native 层的消息队列。</p>\n<h3 id=\"2-2-移除Message\"><a href=\"#2-2-移除Message\" class=\"headerlink\" title=\"2.2 移除Message\"></a>2.2 移除Message</h3><p>移除消息有两个不同参数的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用默认回调初始化 Handler 时移除消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, <span class=\"keyword\">int</span> what, Object object)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages at front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class=\"line\">                &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            p.recycleUnchecked();</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages after front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123;</span><br><span class=\"line\">                    Message nn = n.next;</span><br><span class=\"line\">                    n.recycleUnchecked();</span><br><span class=\"line\">                    p.next = nn;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用自定义回调初始化 Handler 时移除消息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeMessages</span><span class=\"params\">(Handler h, Runnable r, Object object)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h == <span class=\"keyword\">null</span> || r == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages at front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; p.target == h &amp;&amp; p.callback == r</span><br><span class=\"line\">                &amp;&amp; (object == <span class=\"keyword\">null</span> || p.obj == object)) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            mMessages = n;</span><br><span class=\"line\">            p.recycleUnchecked();</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Remove all messages after front.</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Message n = p.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n.target == h &amp;&amp; n.callback == r</span><br><span class=\"line\">                    &amp;&amp; (object == <span class=\"keyword\">null</span> || n.obj == object)) &#123;</span><br><span class=\"line\">                    Message nn = n.next;</span><br><span class=\"line\">                    n.recycleUnchecked();</span><br><span class=\"line\">                    p.next = nn;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实对应的是初始化 Handler 时，一个是使用默认回调，一个是使用自定义回调的情况，具体移除消息的过程几乎是一样的，都是单链表从中移除一个节点的逻辑。</p>\n<h3 id=\"2-3-移除BarrierMessage\"><a href=\"#2-3-移除BarrierMessage\" class=\"headerlink\" title=\"2.3 移除BarrierMessage\"></a>2.3 移除BarrierMessage</h3><p>源码是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Removes a synchronization barrier.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> #postSyncBarrier&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"meta\">@TestApi</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeSyncBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> token)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remove a sync barrier token from the queue.</span></span><br><span class=\"line\">    <span class=\"comment\">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        Message prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span> &amp;&amp; (p.target != <span class=\"keyword\">null</span> || p.arg1 != token)) &#123;</span><br><span class=\"line\">            prev = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;The specified message queue synchronization &quot;</span></span><br><span class=\"line\">                    + <span class=\"string\">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            prev.next = p.next;</span><br><span class=\"line\">            needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mMessages = p.next;</span><br><span class=\"line\">            needWake = mMessages == <span class=\"keyword\">null</span> || mMessages.target != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p.recycleUnchecked();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the loop is quitting then it is already awake.</span></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和发送一个障栅消息一样，这个方法也加了 <code>@hide</code> 注解，移除的过程和移除普通消息比较类似，也是单链表移除节点的逻辑。</p>\n<hr>\n<h2 id=\"3-MessageQueue和线程的交互\"><a href=\"#3-MessageQueue和线程的交互\" class=\"headerlink\" title=\"3. MessageQueue和线程的交互\"></a>3. MessageQueue和线程的交互</h2><p>MessageQueue 中有一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Callback interface for discovering when a thread is going to block</span></span><br><span class=\"line\"><span class=\"comment\">  * waiting for more messages.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Called when the message queue has run out of messages and will now</span></span><br><span class=\"line\"><span class=\"comment\">      * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class=\"line\"><span class=\"comment\">      * to have it removed.  This may be called if there are still messages</span></span><br><span class=\"line\"><span class=\"comment\">      * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class=\"line\"><span class=\"comment\">      * after the current time.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过注释可以知道：</p>\n<ul>\n<li>这个接口的作用是：找出一个线程什么时候阻塞并等待更多（新的）消息。</li>\n<li><code>queueIdle()</code> 的作用是：当一个消息队列处理完全部消息，并且将进入等待的状态时调用。返回 <code>true</code> 则激活 Idle Handler，返回 <code>false</code> 则在执行完后将其移除。如果一个消息队列中还存在消息，但在当前时间之后的所有消息，均已经被计划好了分发的时间（也即这些消息都属于 Delay 型的消息，因此在执行到这些消息之前，线程也处在没有消息需要处理的状态），则该方法仍然可能被调用。</li>\n</ul>\n<p>具体的意义如下：</p>\n<p>Handler 本身除了可以用来发送消息之外，另一个很重要的功能就是去处理接收到的消息，也就是 <code>handleMessage</code> 方法，普通的 Handler 只会处理人为指定的消息，这些消息对应的事务优先级比较高，因此当消息队列中存在 Message 时，线程会优先处理。但是不论是 Dalvik 还是 JVM，都有一些自己的管理事务，这些事务的优先级不是特别高，或者是不可预期的，但依然需要占用线程才能处理（毕竟线程是 CPU 调度的基本单位），比如 GC，内存碎片整理等，这些事务在非紧急情况下，只会在线程中没有消息时处理，此时处理这些事务的就是 Idle Handler。Idle Handler 并不是一个独立的类型，只需要实现 <code>IdleHandler</code> 接口即可。</p>\n<h3 id=\"3-1-添加IdleHandler\"><a href=\"#3-1-添加IdleHandler\" class=\"headerlink\" title=\"3.1 添加IdleHandler\"></a>3.1 添加IdleHandler</h3><p>既然 <code>IdleHandler</code> 只是一个接口，那如何让 MessageQueue 在空闲时可以唤起呢？以下方法即可添加一个 IdleHandler 到 IdleHandler 的 ArrayList 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Add a new &#123;<span class=\"doctag\">@link</span> IdleHandler&#125; to this message queue.  This may be</span></span><br><span class=\"line\"><span class=\"comment\">  * removed automatically for you by returning false from</span></span><br><span class=\"line\"><span class=\"comment\">  * &#123;<span class=\"doctag\">@link</span> IdleHandler#queueIdle IdleHandler.queueIdle()&#125; when it is</span></span><br><span class=\"line\"><span class=\"comment\">  * invoked, or explicitly removing it with &#123;<span class=\"doctag\">@link</span> #removeIdleHandler&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This method is safe to call from any thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> handler The IdleHandler to be added.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addIdleHandler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mIdleHandlers.add(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释的大致意思是：将一个 IdleHandler 添加到 MessageQueue 中，如果 <code>IdleHandler.queueIdle()</code> 返回 <code>false</code>，或者直接调用 <code>removeIdleHandler()</code> 方法，则会移除这个 IdleHandler。</p>\n<h3 id=\"3-2-移除IdleHandler\"><a href=\"#3-2-移除IdleHandler\" class=\"headerlink\" title=\"3.2 移除IdleHandler\"></a>3.2 移除IdleHandler</h3><p>移除 IdleHandler 的方法也很简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * Remove an &#123;<span class=\"doctag\">@link</span> IdleHandler&#125; from the queue that was previously added</span></span><br><span class=\"line\"><span class=\"comment\">  * with &#123;<span class=\"doctag\">@link</span> #addIdleHandler&#125;.  If the given object is not currently</span></span><br><span class=\"line\"><span class=\"comment\">  * in the idle list, nothing is done.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * &lt;p&gt;This method is safe to call from any thread.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@param</span> handler The IdleHandler to be removed.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeIdleHandler</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> IdleHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mIdleHandlers.remove(handler);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-调用IdleHandler\"><a href=\"#3-3-调用IdleHandler\" class=\"headerlink\" title=\"3.3 调用IdleHandler\"></a>3.3 调用IdleHandler</h3><p>添加和移除 Idle Handler 都已经清楚了，Idle Handler 具体使用的地方，在 MessageQueue 实际处理消息的方法 <code>next()</code> 里，在默认情况下，每一次调用 <code>next</code> 就会返回一个 Message，这个 Message 就是下一个需要分发的消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@UnsupportedAppUsage</span></span><br><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// mPtr 是通过调用 nativeInit() 获取的返回值</span></span><br><span class=\"line\">    <span class=\"comment\">// 可以认为这个是 Native 层 MessageQueue 初始化后的指针地址</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 重点是 msg.target == null，如果满足说明这个 msg 是一个障栅消息</span></span><br><span class=\"line\">            <span class=\"comment\">// 那么就要阻塞这条消息之后的所有同步消息，而放行异步消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 循环结束后有两种情况：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1. 整个消息队列中都没有异步消息，则终止条件为：msg == null</span></span><br><span class=\"line\">                <span class=\"comment\">// 2. 找到了异步消息，则终止条件为：msg.isAsynchronous() == true</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// msg != null 有两种可能：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1. 消息队列没阻塞，msg 是一条同步消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 2. 消息队列被障栅消息阻塞了，但是找到了异步消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 说明还没到需要分发消息的时候，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 则计算到需要分发消息中间的间隔，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 在间隔时间后再唤醒消息队里进行分发</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 说明到了需要分发消息的时候</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 开始分发消息了，不是阻塞状态</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 由于将这条消息分发出去了，相当于要从链表里去掉这个消息</span></span><br><span class=\"line\">                    <span class=\"comment\">// 需要判断当前消息是不是第一个消息</span></span><br><span class=\"line\">                    <span class=\"comment\">// prevMsg 表示该 msg 的前一个消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 由于该消息即将被分发出去，因此该消息的下一条就没用了</span></span><br><span class=\"line\">                    <span class=\"comment\">// 置为空，去掉无用引用，防止内存溢出</span></span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"string\">&quot;Returning message: &quot;</span> + msg);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 把该 msg 标识为“使用中”</span></span><br><span class=\"line\">                    msg.markInUse();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 返回这条 msg 作为需要处理的消息</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 说明 msg == null，此时有两种可能：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1. 已经没有消息需要分发</span></span><br><span class=\"line\">                <span class=\"comment\">// 2. 当前队列被障栅消息阻塞了，却又没有异步消息（不论是否有同步消息）</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前消息队列是正在退出的状态</span></span><br><span class=\"line\">                <span class=\"comment\">// 则调用 dispose() 销毁 Native 层的消息队列</span></span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ======================</span></span><br><span class=\"line\">            <span class=\"comment\">// 以下为 IdleHandler 部分</span></span><br><span class=\"line\">            <span class=\"comment\">// ======================</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本的解读都在代码注释中了，还是比较通俗易懂的。重点注意专门加的这句注释：<code>// 以下为 IdleHandler 部分</code>，可以看看这句注释以上的部分，首先是判断了下一条消息，然后判断了当前消息队列是否正在退出，这个 <code>next()</code> 方法基本上要么返回了下一条需要分发的 Message，要么返回了 <code>null</code>，只有以下几种情况时才能执行到这句注释的地方：</p>\n<ol>\n<li>当前消息队列没有任何消息了，且不在退出状态。</li>\n<li>当前消息队列没有被障栅消息阻塞，且没有同步消息，也没有异步消息，且不在退出状态。</li>\n<li>当前消息队列没有被障栅消息阻塞，没有同步消息，虽然有异步消息，但还没有到需要分发的时间，且不在退出状态。</li>\n<li>当前消息队列被障栅消息阻塞了，但没有异步消息（不论是否有同步消息），且不在退出状态。</li>\n<li>当前消息队列被障栅消息阻塞了，虽然有异步消息（不论是否有同步消息），但还没有到需要分发的时间，且不在退出状态。</li>\n</ol>\n<p>以上几种情况中，（2）和（3）其实可以归到一起，（3）和（4）也可以归到一起，再进一步合并逻辑，其实就代表了这么一种状态：消息队列当前没有任务，而且也不在退出状态。只有这个状态下，才会调用 <code>IdleHandler.queueIdle</code>，具体的任务则由 <code>IdleHandler</code> 接口的具体实现决定了。消息队列中对 IdleHandler 的处理比较简单，注释也已经讲得比较详细，就不另行分析了。</p>\n<hr>\n<h2 id=\"4-MessageQueue总结\"><a href=\"#4-MessageQueue总结\" class=\"headerlink\" title=\"4. MessageQueue总结\"></a>4. MessageQueue总结</h2><p>通过以上的源码分析，MessageQueue 的工作流程也就清楚了：</p>\n<ol>\n<li>初始化 MessageQueue，同时初始化 Native 层的 MessageQueue。</li>\n<li>通过 Handler 添加或移除 Message。</li>\n<li>线程执行的过程中，不断调用 <code>next()</code> 方法来获取需要分发处理的消息。</li>\n<li>如果线程中有需要分发处理的消息，则正常分发。</li>\n<li>如果线程中已经没有或暂时没有需要分发处理的普通消息，则去处理 Idle 事务。</li>\n<li>如果既没有普通消息需要分发处理，也没有 Idle 事务，则阻塞消息队列，使其进入等待新消息的状态。</li>\n<li>如果需要退出消息队列，则调用 <code>dispose()</code> 方法同步销毁 Native 层的 MessageQueue。</li>\n</ol>\n","categories":["Android"],"tags":["Android","源码","MessageQueue","消息队列"]},{"title":"Android-Messenger","url":"/post/android/android-messenger/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Messenger\"><a href=\"#Android-Messenger\" class=\"headerlink\" title=\"Android-Messenger\"></a>Android-Messenger</h1>","categories":["Android"],"tags":["Android","Messenger"]},{"title":"Android-OOM","url":"/post/android/android-oom/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-OOM\"><a href=\"#Android-OOM\" class=\"headerlink\" title=\"Android-OOM\"></a>Android-OOM</h1><p>OOM（Out Of Memory）出现的原因有：</p>\n<p>（1）单次加载过大的对象，如图片。可以压缩、加载小图、绘制局部、使用第三方框架等。</p>\n<p>（2）内存中资源过多，无法为新的数据开辟内存。对不用的数据及时回收、减少内存泄漏等。</p>\n<p>（3）Dalvik 虚拟机分配的 Heap Size 太小。适当调整 HeapSize，可在 Manifest 中标注 <code>largeheap=true</code> 属性。</p>\n","categories":["Android"],"tags":["Android","OOM"]},{"title":"Android-渲染机制","url":"/post/android/android-render/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android渲染机制\"><a href=\"#Android渲染机制\" class=\"headerlink\" title=\"Android渲染机制\"></a>Android渲染机制</h1><h2 id=\"1-View发起绘制请求\"><a href=\"#1-View发起绘制请求\" class=\"headerlink\" title=\"1. View发起绘制请求\"></a>1. View发起绘制请求</h2><p>在 View 涉及到 UI 更新的方法中，几乎都会在最后调用 <code>View#invalidate()</code> 或者 <code>View#requestLayout()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        invalidate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidate</span><span class=\"params\">(<span class=\"keyword\">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class=\"line\">        invalidateInternal(<span class=\"number\">0</span>, <span class=\"number\">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invalidateInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b, <span class=\"keyword\">boolean</span> invalidateCache,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"keyword\">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (...) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用 invalidate() 会给当前 View 添加 PFLAG_DIRTY 标志</span></span><br><span class=\"line\">            mPrivateFlags |= PFLAG_DIRTY;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> AttachInfo ai = mAttachInfo;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ViewParent p = mParent;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; ai != <span class=\"keyword\">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class=\"line\">                damage.set(l, t, r, b);</span><br><span class=\"line\">                <span class=\"comment\">// 调用父 View 的 ViewParent#invalidateCild(...)</span></span><br><span class=\"line\">                p.invalidateChild(<span class=\"keyword\">this</span>, damage);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 requestLayout() 会给当前 View 添加 PFLAG_FORCE_LAYOUT 标志</span></span><br><span class=\"line\">        mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class=\"line\">        mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向上递归调用 mParent.requestLayout()，直到 mParent == null</span></span><br><span class=\"line\">            mParent.requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewGroup</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span>, <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidateChild</span><span class=\"params\">(View child, <span class=\"keyword\">final</span> Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">        ViewParent parent = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 返回值是 parent 的 parent，一直向上递归直到 parent == null</span></span><br><span class=\"line\">                parent = parent.invalidateChildInParent(location, dirty);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (parent != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewParent <span class=\"title\">invalidateChildInParent</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] location, <span class=\"keyword\">final</span> Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mParent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>invalidate()</code> 会逐级递归调用 <code>ViewParent#invalidateChildInParent(...)</code>；</li>\n<li><code>requestLayout()</code> 会逐级递归调用 <code>mParent.requestLayout()</code>；</li>\n</ul>\n<p>而一个 ViewTree 中，最顶层的 ViewParent 就是 ViewRootImpl，所以实际上 <code>View#invalidate()</code> 和 <code>View#requestLayout()</code> 最终都会调用到 <code>ViewRootImpl#invalidateChildInParent(...)</code> 和 <code>ViewRootImpl#requestLayout()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ViewRootImpl 持有的成员变量 Handler，处于 ViewRootImpl 初始化线程。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewRootHandler mHandler = <span class=\"keyword\">new</span> ViewRootHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewParent <span class=\"title\">invalidateChildInParent</span><span class=\"params\">(<span class=\"keyword\">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查 UI 线程</span></span><br><span class=\"line\">        checkThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dirty == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        invalidateRectOnScreen(dirty);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidateRectOnScreen</span><span class=\"params\">(Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 收集汇总需要重绘的区域</span></span><br><span class=\"line\">        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 发起绘制事件</span></span><br><span class=\"line\">        scheduleTraversals();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 检查 UI 线程</span></span><br><span class=\"line\">            checkThread();</span><br><span class=\"line\">            mLayoutRequested = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 发起绘制事件</span></span><br><span class=\"line\">            scheduleTraversals();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，不论是 <code>invalidate()</code> 还是 <code>requestLayout()</code>，最终在 ViewRootImpl 中都会通过 <code>checkThread()</code> 检查线程，并调用 <code>ViewRootImpl#scheduleTraversals()</code> 发起绘制。但是：</p>\n<ul>\n<li>调用 <code>View#invalidate()</code> 会将 View 的 Rect 标记 <code>PFLAG_DIRTY</code>，然后在下一帧刷新 ViewTree 时，ViewRootImpl 会调用最顶层的 <code>View#draw(Canvas)</code>，然后逐层向下分发，但只会在具有 <code>PFLAG_DIRTY</code> 时回调 <code>onDraw(Canvas)</code>。</li>\n<li>调用 <code>View#requestLayout()</code> 会将当前 View 标记 <code>PFLAG_FORCE_LAYOUT</code>，然后在下一帧刷新 ViewTree 时，ViewRootImpl 会调用最顶层的 <code>View#measure()</code> 和 <code>View#layout()</code>，然后逐层向下分发，但只会在具有 <code>PFLAG_FORCE_LAYOUT</code> 时回调 <code>onMeasure()</code> 和 <code>onLayout()</code>。</li>\n</ul>\n<p>此外，ViewRootImpl 在构造方法中记录了自己的初始化线程，作为允许更新 UI 的线程，并且持有了一个 Handler 成员变量，同样也处于 ViewRootImpl 的初始化线程。<code>View#postInvalidate()</code> 和 <code>View#postInvalidateDelayed(delayTime)</code> 会向这个 Handler 发送一个事件，携带了调用的 View 本身，然后 ViewRootImpl 会在事件回调中直接调用这个 <code>View#invalidate()</code>，因此相当于把 <code>View#invalidate()</code> 抛到 ViewRootImpl 初始线程中执行，多用于跨线程请求刷新 UI。</p>\n<hr>\n<h2 id=\"2-Android绘制渲染流程\"><a href=\"#2-Android绘制渲染流程\" class=\"headerlink\" title=\"2. Android绘制渲染流程\"></a>2. Android绘制渲染流程</h2><p>上文提到，View 在更新 UI 时会通过 <code>invalidate()</code> 或者 <code>requestLayout()</code> 请求 ViewRootImpl 绘制，最终都会调用到 <code>ViewRootImpl#scheduleTraversals()</code> 中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Choreographer mChoreographer;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ViewRootHandler mHandler = <span class=\"keyword\">new</span> ViewRootHandler();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> TraversalRunnable mTraversalRunnable = <span class=\"keyword\">new</span> TraversalRunnable();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doTraversal();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">            mTraversalScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 移除屏障消息</span></span><br><span class=\"line\">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">            <span class=\"comment\">// 真正开始绘制</span></span><br><span class=\"line\">            performTraversals();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> </span>&#123;</span><br><span class=\"line\">        mChoreographer = Choreographer.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">            mTraversalScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 先向 ViewRootImpl 的初始线程发送一条屏障消息，阻塞后续的同步消息。</span></span><br><span class=\"line\">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">            mChoreographer.postCallback(</span><br><span class=\"line\">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，<code>scheduleTraversals()</code> 先发送一条屏障消息阻塞了 ViewRootImpl 线程，然后 post 了一个 Runnable，这个 Runable 的目的是在回调时调用 <code>performTraversals()</code>，这也是绘制真正开始的入口。因此重点就在于 <code>mChoreographer.postCallback(...)</code> 内的逻辑。</p>\n<h3 id=\"2-1-注册绘制信号回调\"><a href=\"#2-1-注册绘制信号回调\" class=\"headerlink\" title=\"2.1 注册绘制信号回调\"></a>2.1 注册绘制信号回调</h3><p>Choreographer 中一共定义了 5 种帧同步信号回调类型，在 <code>ViewRootImpl#scheduleTraversals()</code> 中调用的 <code>mChoreographer#postCallback(...)</code> 指定了回调类型为 <code>CALLBACK_TRAVERSAL</code>，表示 <strong>绘制信号回调</strong>，并注册了一个回调 Runnable：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Choreographer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CALLBACK_INPUT = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CALLBACK_ANIMATION = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CALLBACK_INSETS_ANIMATION = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CALLBACK_TRAVERSAL = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CALLBACK_COMMIT = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CALLBACK_LAST = CALLBACK_COMMIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CallbackQueue[] mCallbackQueues;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"keyword\">int</span> vsyncSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Choreographer 在 ThreadLocal 中使用当前线程的 Looper 初始化，</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于 ViewRootImpl 在构造方法中初始化 Choreographer，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此 Choreographer 与 ViewRootImpl 是同一线程。</span></span><br><span class=\"line\">        mLooper = looper;</span><br><span class=\"line\">        <span class=\"comment\">// 所以 Choreographer 的 mHandler 也是把消息发送到 ViewRootImpl 同一线程中。</span></span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> FrameHandler(looper);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化 CallbackQueues，其中每一个 CallbackQueue 都是一个链表，</span></span><br><span class=\"line\">        <span class=\"comment\">// 每个 CallbackQueue 对应的下标就是常量中定义的 5 个 Callback 类型。</span></span><br><span class=\"line\">        mCallbackQueues = <span class=\"keyword\">new</span> CallbackQueue[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">            mCallbackQueues[i] = <span class=\"keyword\">new</span> CallbackQueue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallback</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class=\"line\">        postCallbackDelayed(callbackType, action, token, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallbackDelayed</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Runnable action, Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Object action, Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> dueTime = now + delayMillis;</span><br><span class=\"line\">            <span class=\"comment\">// 按照传入的 Callback 类型，向对应类型的 CallbackQueue 中添加一个 Callback 节点</span></span><br><span class=\"line\">            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果没有延迟则直接调用 scheduleFrameLocked(now)，</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则会 post 一个延时消息，最终同样是调用 scheduleFrameLocked(now)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">                scheduleFrameLocked(now);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">                msg.arg1 = callbackType;</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class=\"line\">                    doScheduleCallback(msg.arg1);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doScheduleCallback</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class=\"line\">                    scheduleFrameLocked(now);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Choreographer#postCallback(...)</code> 主要是为了注册一个帧同步信号的回调，包含了两个步骤：</p>\n<ul>\n<li>先根据传入的 callbackType 向对应类型的 CallbackQueue 中添加一个 Callback；</li>\n<li>然后根据是否延时判断是直接调用 <code>Choreographer#scheduleFrameLocked(now)</code> 或是延时后调用。</li>\n</ul>\n<h3 id=\"2-2-发起帧同步信号\"><a href=\"#2-2-发起帧同步信号\" class=\"headerlink\" title=\"2.2 发起帧同步信号\"></a>2.2 发起帧同步信号</h3><p>上文提到 Choreographer 一共有 5 种类型的帧同步信号回调，每一种类型的回调都是通过 CallbackQueue 链表存储的，<code>Choreographer#postCallback(...)</code> 就是为了注册回调：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Choreographer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Object action, Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Step 1: 创建 CallbackRecord，并按照时间顺序插入到对应类型的 CallbackQueue 中。</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * mCallbackQueues[callbackType] 取出的就是 callbackType 对应的 CallbackQueue，</span></span><br><span class=\"line\"><span class=\"comment\">         * CallbackQueue 是 CallbackRecord 链表，CallbackRecord 用于记录注册的 Callback</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Step 2: 发起帧同步信号的请求，在收到信号后按顺序回调 5 种 CallbackQueue 中的所有回调。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        scheduleFrameLocked(now);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Choreographer 注册绘制信号回调分为两步：</p>\n<ul>\n<li>创建一个 CallbackRecord 对象用于存储 ViewRootImpl 注册的回调，然后把新创建的 CallbackRecord 按照时间戳的顺序添加到对应的 <code>CALLBACK_TRAVERSAL</code> 类型的 CallbackQueue 中。</li>\n<li>向 FrameDisplayEventReceiver 发起一个帧同步信号的请求，并等待帧同步信号回调，然后再按顺序依次回调 5 种 CallbackQueue 中的所有回调。</li>\n</ul>\n<p>（1）创建 CallbackRecord 并插入 CallbackQueue：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Choreographer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallbackQueue</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> CallbackRecord mHead;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addCallbackLocked</span><span class=\"params\">(<span class=\"keyword\">long</span> dueTime, Object action, Object token)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建一个新的 CallbackRecord 节点，用于存储新增的 Callback，</span></span><br><span class=\"line\">            CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);</span><br><span class=\"line\">            CallbackRecord entry = mHead;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 entry == null，说明此时 mHead == null，说明 CallbackQueue 是一个空链表，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因此将 mHead 指向新创建的 CallbackRecord</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mHead = callback;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 此时 entry == mHead，</span></span><br><span class=\"line\">            <span class=\"comment\">// 则比较 mHead 的 dueTime 和新创建的 CallbackRecord 的 dueTime，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果新创建的 CallbackRecord 的 dueTime 更小，则插入到 mHead，</span></span><br><span class=\"line\">            <span class=\"comment\">// 把原来的 mHead 指向新创建的 CallbackRecord 的 next</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dueTime &lt; entry.dueTime) &#123;</span><br><span class=\"line\">                callback.next = entry;</span><br><span class=\"line\">                mHead = callback;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 否则如果新创建的 CallbackRecord 的 dueTime 不是最小的，</span></span><br><span class=\"line\">            <span class=\"comment\">// 就从 mHead 开始顺序遍历 CallbackQueue 链表，</span></span><br><span class=\"line\">            <span class=\"comment\">// 把新创建的 CallbackRecord 按 dueTime 从小到大的顺序插入到 CallbackQueue 中。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (entry.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dueTime &lt; entry.next.dueTime) &#123;</span><br><span class=\"line\">                    callback.next = entry.next;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                entry = entry.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            entry.next = callback;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）向 FrameDisplayEventReceiver 发起帧同步信号：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Choreographer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部类 FrameDisplayEventReceiver 继承自抽象类 DisplayEventReceiver</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FrameDisplayEventReceiver mDisplayEventReceiver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            mFrameScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Android 4.1 之后默认使用 VSync 信号。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果当前处于初始线程则直接调用 scheduleVsyncLocked()</span></span><br><span class=\"line\">                    scheduleVsyncLocked();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 否则通过 mHandler 发送消息到初始线程，再调用 scheduleVsyncLocked()。</span></span><br><span class=\"line\">                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                    <span class=\"comment\">// 由于 Choreographer 与 ViewRootImpl 处于同一线程，</span></span><br><span class=\"line\">                    <span class=\"comment\">// ViewRootImpl#scheduleTraversals() 时用屏障消息阻塞了同步消息，</span></span><br><span class=\"line\">                    <span class=\"comment\">// 所以需要把这条消息设置为异步消息。</span></span><br><span class=\"line\">                    msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Android 4.1 之前不使用 VSync 信号，则直接发送消息，调用 doFrame(...)</span></span><br><span class=\"line\">                Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class=\"line\">                <span class=\"comment\">// 同样需要设置为异步消息。</span></span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleVsyncLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrameHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_FRAME:</span><br><span class=\"line\">                doFrame(System.nanoTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class=\"line\">                doScheduleVsync();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doScheduleVsync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mFrameScheduled) &#123;</span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Choreographer 发起帧同步信号主要包括注册回调和发起信号两步：</p>\n<ul>\n<li>创建一个 CallbackRecord 用于存储回调，然后根据 <code>Choreographer#postCallback(...)</code> 传入的 callbackType，将创建的 CallbackRecord 按 dueTime 时间顺序插入到对应类型的 CallbackQueue 中。</li>\n<li>发起帧同步信号，并等待回调，根据 Android 版本分为两种方式：<ul>\n<li>Android 4.1 之前不使用 VSync 信号，则直接发送一条异步消息，调用 <code>Choreographer#doFrame()</code>。</li>\n<li>Android 4.1 之后默认使用 VSync 信号，则会调用 <code>FrameDisplayEventReceiver#scheduleVsync()</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-3-等待帧同步信号\"><a href=\"#2-3-等待帧同步信号\" class=\"headerlink\" title=\"2.3 等待帧同步信号\"></a>2.3 等待帧同步信号</h3><p>上文提到，Android 4.1 之前和之后，发起帧同步信号请求的方式不同：</p>\n<ul>\n<li>Android 4.1 之前直接调用了 <code>doFrame(...)</code>，内部根据当前时间、上一帧时间、帧率时间间隔判断是否需要回调。</li>\n<li>Android 4.1 之后则是通过发起下一个 VSync 信号监听的方式，调用 <code>FrameDisplayEventReceiver#scheduleVsync()</code>，由 Native 层通知下一帧 VSync 信号后再回调。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Choreographer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">DisplayEventReceiver</span></span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onVsync</span><span class=\"params\">(<span class=\"keyword\">long</span> timestampNanos, <span class=\"keyword\">long</span> physicalDisplayId, <span class=\"keyword\">int</span> frame)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// scheduleVsync() 是父类 DisplayEventReceiver 中的方法，</span></span><br><span class=\"line\">            <span class=\"comment\">// 调用后会向 Native 层发起 VSync 信号请求，</span></span><br><span class=\"line\">            <span class=\"comment\">// 当收到来自 SurfaceFlinger 的下一帧 VSync 信号后，</span></span><br><span class=\"line\">            <span class=\"comment\">// 就会回调这个 onVsync(...) 方法。</span></span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">// FrameDisplayEventReceiver 实现了 Runnable 接口，</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以这里创建的 Message 实际上是创建的 Runnable 类型的 Message，</span></span><br><span class=\"line\">            <span class=\"comment\">// 在 post 到 Choreographer 线程后就会回调 FrameDisplayEventReceiver#run()</span></span><br><span class=\"line\">            Message msg = Message.obtain(mHandler, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 此时 Choreographer / ViewRootImpl 的同步消息仍被屏障消息阻塞</span></span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            mHavePendingVsync = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 实际上，即使 Android 4.1 之后用 VSync 信号，最终仍然是调用 doFrame(...)</span></span><br><span class=\"line\">            doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisplayEventReceiver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleVsync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// Native 方法，向底层发起 VSync 信号请求</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，是否使用 VSync 信号的区别主要在于下一帧帧同步信号的接收方式：</p>\n<ol>\n<li>通过 <code>doFrame(...)</code> 中根据上一帧时间、当前时间、帧率间隔时间计算。</li>\n<li>接收来自 SurfaceFlinger 的 VSync 信号。</li>\n</ol>\n<p>这个区别只是体现在 Choreographer 如何知道需要下一帧帧同步，对于收到信号后回调到 ViewRootImpl，则最终都是通过 <code>doFrame(...)</code> 回调的。</p>\n<h3 id=\"2-4-回调帧同步信号\"><a href=\"#2-4-回调帧同步信号\" class=\"headerlink\" title=\"2.4 回调帧同步信号\"></a>2.4 回调帧同步信号</h3><p>根据上文的分析，Choreographer 在接收到帧同步信号后，最终都会通过 <code>doFrame(...)</code> 回调给 ViewRootImpl：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Choreographer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doFrame</span><span class=\"params\">(<span class=\"keyword\">long</span> frameTimeNanos, <span class=\"keyword\">int</span> frame)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 按顺序第 1 个回调 Input 类型的 Callback</span></span><br><span class=\"line\">            mFrameInfo.markInputHandlingStart();</span><br><span class=\"line\">            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\">            <span class=\"comment\">// 按顺序第 2, 3 个回调 Animation 类型的 Callback</span></span><br><span class=\"line\">            mFrameInfo.markAnimationsStart();</span><br><span class=\"line\">            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">            doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class=\"line\">            <span class=\"comment\">// 按顺序第 4 个回调 Traversal 类型的 Callback</span></span><br><span class=\"line\">            mFrameInfo.markPerformTraversalsStart();</span><br><span class=\"line\">            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\">            <span class=\"comment\">// 按顺序第 5 个回调 Commit 类型的 Callback</span></span><br><span class=\"line\">            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doCallbacks</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType, <span class=\"keyword\">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class=\"line\">        CallbackRecord callbacks;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对当前 callbackType 类型的 CallbackQueue 循环遍历，</span></span><br><span class=\"line\">            <span class=\"comment\">// 找出 dueTime 大于当前时间的第一个 CallbackRecord，</span></span><br><span class=\"line\">            <span class=\"comment\">// 也即在当前时间之后的所有 CallbackRecord 中，dueTime 最小（最早）的。</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为 CallbackQueue 是按照 dueTime「从小到大」（时间「从早到晚」）排序的，</span></span><br><span class=\"line\">            <span class=\"comment\">// 最早的 CallbackRecord 在 mHead 位置，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因此从这个方法返回的 callback 开始，之后所有的 callback 都是比当前时间更早的。</span></span><br><span class=\"line\">            callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class=\"line\">                    now / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callbacks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (CallbackRecord c = callbacks; c != <span class=\"keyword\">null</span>; c = c.next) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 遍历调用 dueTime 大于当前时间的所有 CallbackRecord#run()</span></span><br><span class=\"line\">                c.run(frameTimeNanos);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postFrameCallback</span><span class=\"params\">(FrameCallback callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果调用 Choreographer#postFrameCallback(FrameCallback)，</span></span><br><span class=\"line\">        <span class=\"comment\">// 则会注册一个 Animation 类型的 Callback，并且此时 token == FRAME_CALLBACK_TOKEN</span></span><br><span class=\"line\">        postFrameCallbackDelayed(callback, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postFrameCallbackDelayed</span><span class=\"params\">(FrameCallback callback, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">        postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class=\"line\">                callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallbackRecord</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> CallbackRecord next;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> dueTime;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Object action;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> Object token;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(<span class=\"keyword\">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据 token 的值判断 action 是 Runnable 还是 FrameCallback</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果是通过 postFrameCallback(FrameCallback) 注册的 Callback，</span></span><br><span class=\"line\">                <span class=\"comment\">// 则 token == FRAME_CALLBACK_TOKEN，action 是 FrameCallback 类型。</span></span><br><span class=\"line\">                ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则例如 ViewRootImpl 通过 postCallback(Runnable) 注册的 Callback，</span></span><br><span class=\"line\">                <span class=\"comment\">// 则 token == null，action 是 Runnable 类型。</span></span><br><span class=\"line\">                ((Runnable)action).run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ViewRootImpl 在 <code>scheduleTraversals()</code> 中调用了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 CallbackQueue#addCallbackLocked(...) 时会创建一个新的 CallbackRecord，</span></span><br><span class=\"line\"><span class=\"comment\">// CallbackRecord#action == mTraversalRunnable</span></span><br><span class=\"line\"><span class=\"comment\">// CallbackRecord#token == null</span></span><br><span class=\"line\">mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>所以在回调这个 <code>CallbackRecord#run()</code> 时 <code>token == null</code>，就会执行 <code>((Runnable)action).run()</code> 的逻辑，也就是执行 <code>ViewRootImpl#mTraversalRunnable#run()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doTraversal();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> TraversalRunnable mTraversalRunnable = <span class=\"keyword\">new</span> TraversalRunnable();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">            mTraversalScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 移除了屏障消息</span></span><br><span class=\"line\">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\">            <span class=\"comment\">// 调用 performTraversals()，真正开始绘制流程，包括 measure, layout, draw</span></span><br><span class=\"line\">            performTraversals();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时回调到 ViewRootImpl 之后，就会移除一开始在 <code>scheduleTraversals()</code> 中发送的屏障消息，然后调用 <code>performTraversals()</code> 正式开始绘制流程。</p>\n<p><strong>需要注意的是，移除屏障消息后，由于接下来的 <code>performTraversals()</code> 仍然在同一个线程的调用栈中，因此 ViewRootImpl 初始线程中原来被阻塞的同步消息，是在 <code>performTraversals()</code> 之后才执行的。</strong></p>\n<blockquote>\n<p>通过源码可知，<code>Choreographer.getInstance().postFrameCallback(FrameCallback)</code> 可以向 Choreographer 注册一个 Animation 类型的 VSync 回调，并在每一次收到来自 SurfaceFlinger 的 VSync 信号时回调。回调方法 <code>doFrame(long frameTimeNanos)</code> 携带的 <code>frameTimeNanos</code> 表示 Choreographer 收到本次 VSync 信号时的时间戳，因此可以通过比较两次 VSync 信号时间等方式获取帧率、绘制耗时等信息。</p>\n</blockquote>\n<h3 id=\"2-5-performTraversals开始绘制\"><a href=\"#2-5-performTraversals开始绘制\" class=\"headerlink\" title=\"2.5 performTraversals开始绘制\"></a>2.5 performTraversals开始绘制</h3><p>当 ViewRootImpl 收到了帧同步信号的渲染回调后，就会调用 <code>performTraversals()</code> 开始绘制 ViewTree：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        host.dispatchAttachedToWindow(mAttachInfo, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        performLayout(lp, mWidth, mHeight);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        performDraw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ViewRootImpl 会分别调用其顶层 View 的 <code>measure(...)</code>、<code>layout(...)</code>、<code>draw(...)</code> 方法，并逐层向下分发，每一层 View 都会判断：</p>\n<ul>\n<li>如果自己具有 <code>PFLAG_FORCE_LAYOUT</code> 标志，则 <code>measure(...)</code> 会回调 <code>onMeasure(...)</code>，<code>layout(...)</code> 会回调 <code>onLayout(...)</code>。</li>\n<li>如果自己具有 <code>PFLAG_DIRTY</code> 标志，则 <code>draw(...)</code> 会回调 <code>onDraw(...)</code>。</li>\n</ul>\n<blockquote>\n<p>在 Measure 阶段，<code>getMeasureWidth()</code> 是 View 测量自己的宽度，<code>getWidth()</code> 是 View 的父布局测量 View 的宽度。当 View 需要的宽度大于屏幕宽度时，<code>getMeasureWidth()</code> 得到的仍然是 View 需要的宽高，而 <code>getWidth()</code> 得到的是屏幕实际显示的宽度。</p>\n</blockquote>\n<p>其中，<code>performDraw()</code> 根据硬件绘制、软件绘制分为两种方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        performDraw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performDraw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> canUseAsync = draw(fullRedrawNeeded);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mAttachInfo.mThreadedRenderer != <span class=\"keyword\">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 硬件绘制</span></span><br><span class=\"line\">            mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 软件绘制</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!drawSoftware(...)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 软件绘制。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawSoftware</span><span class=\"params\">(Surface surface, AttachInfo attachInfo, <span class=\"keyword\">int</span> xoff, <span class=\"keyword\">int</span> yoff,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"keyword\">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Canvas canvas;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        canvas = mSurface.lockCanvas(dirty);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        surface.unlockCanvasAndPost(canvas);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 硬件绘制。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadedRenderer</span> <span class=\"keyword\">extends</span> <span class=\"title\">HardwareRenderer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class=\"line\">        updateRootDisplayList(view, callbacks);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updateRootDisplayList</span><span class=\"params\">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class=\"line\">        updateViewTreeDisplayList(view);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updateViewTreeDisplayList</span><span class=\"params\">(View view)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        view.updateDisplayListIfDirty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RenderNode <span class=\"title\">updateDisplayListIfDirty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">final</span> RecordingCanvas canvas = renderNode.beginRecording(width, height);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        draw(canvas);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        renderNode.endRecording();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ViewTree 依次绘制自己的试图，完成整个绘制流程。</p>\n<h3 id=\"2-6-View准确测量宽高\"><a href=\"#2-6-View准确测量宽高\" class=\"headerlink\" title=\"2.6 View准确测量宽高\"></a>2.6 View准确测量宽高</h3><p>当一个 View 被加载时如果想要正确获取 View 的宽高，通常会通过 <code>View#post(Runnable)</code> 的方式，在回调中获取，而这种方式之所以有效，正是因为 <code>ViewRootImpl#scheduleTraversals()</code> 中的屏障消息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">post</span><span class=\"params\">(Runnable action)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> attachInfo.mHandler.post(action);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        getRunQueue().post(action);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> HandlerActionQueue <span class=\"title\">getRunQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRunQueue == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mRunQueue = <span class=\"keyword\">new</span> HandlerActionQueue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mRunQueue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchAttachedToWindow</span><span class=\"params\">(AttachInfo info, <span class=\"keyword\">int</span> visibility)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRunQueue != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mRunQueue.executeActions(info.mHandler);</span><br><span class=\"line\">            mRunQueue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用 <code>View#post(Runnable)</code> 时会先判断 View 是否已经具有 AttachInfo：</p>\n<ul>\n<li>如果有则说明该 View 已经被关联到 Window 上了，则直接通过 AttachInfo 获取 ViewRootImpl 的 Handler 并向 ViewRootImpl 线程发送一条同步消息，由该消息回调 post 的 Runnable。</li>\n<li>否则说明 View 还没有被关联到 Window 上，也可以理解为 Window 还未创建完毕，则把 Runnable 添加到 View 持有的一个队列中，等待 View 被关联到 Window 之后（对应 ViewRootImpl 逐层分发 <code>dispatchAttachedToWindow(...)</code>），再一次性把队列中所有的 Runnable 都已同步消息发送到 ViewRootImpl 线程中。</li>\n</ul>\n<p><code>View#post(Runnable)</code> 通过这种方式，确保了 Runnable 始终在 Window 已经创建并与 View 关联后，才在 ViewRootImpl 线程中被回调。</p>\n<ul>\n<li>当 Window 被创建初始化时，<code>WindowManager#addView(...)</code> 中调用了 <code>ViewRootImpl#setView(...)</code>，其内部调用了 <code>ViewRootImpl#requestLayout()</code>，并触发 <code>ViewRootImpl#scheduleTraversals()</code>。</li>\n<li>当 Window 已经创建完毕并且已经与 View 关联后，每一次 View 发生 UI 的改变，都会调用 <code>invalidate()</code> 或 <code>requestLayout()</code>，并且最终都会触发 <code>ViewRootImpl#scheduleTraversals()</code>。</li>\n</ul>\n<p>综上所述，不论 Window 处于哪种状态，只要 UI 有变更，<code>View#post(Runnable)</code> 的 Runnable 都会被 <code>scheduleTraversals()</code> 中发送的屏障消息阻塞，并在 ViewRootImpl 收到下一帧 VSync 信号、调用 <code>performTraversals()</code> 完成下一帧的绘制之后，才移除屏障消息并依次执行这些同步消息中的 Runnable，所以这些 Runnable 执行的时候，一定能保证当前帧已经绘制完毕，绘制完毕意味着 View 已经被 Measure，所以获取的宽高是正确的。</p>\n<p>不过，<code>View#post(Runnable)</code> 在 Window 初次创建时的流程与 UI 发生变更时的流程有略微差别。</p>\n<ul>\n<li>当 Window 是已经创建完毕并与 View 关联后，则 View 已经具有 AttachInfo，因此 post 的 Runnable 会直接发送到 ViewRootImpl 线程的同步消息中，如果 UI 有变更，则会被屏障消息阻塞，等到下一帧绘制完毕后回调。需要注意的是，同步消息被阻塞并不意味着线程被阻塞，即使同步消息被阻塞，依旧可以继续发送消息，只是 Looper 不会取出消息并回调。</li>\n<li>当 Window 被首次创建和初始化，此时还未与 View 关联。在 <code>ViewRootImpl#setView(...)</code> 阶段，会调用一次 <code>requestLayout()</code>，并绘制第一帧，但此时 View 尚不具有 AttachInfo，Runnable 仍被存在 RunQueue 中。然后在 <code>performTraversals()</code> 绘制完首帧后，由于 <code>mFirst == true</code> 才会调用 <code>host.dispatchAttachedToWindow(mAttachInfo, 0)</code> 将 AttachInfo 分发给各个 View，此时 View 才将 RunQueue 中的 Runnable 再次发送到 ViewRootImpl 线程，因此需要在第二帧绘制后，才能回调 Runnable。</li>\n</ul>\n<h3 id=\"2-7-Activity首帧监控\"><a href=\"#2-7-Activity首帧监控\" class=\"headerlink\" title=\"2.7 Activity首帧监控\"></a>2.7 Activity首帧监控</h3><p>通过上述分析结合 Activity 启动流程，即可知道 Activitiy 首帧的渲染时机以及对应的监控方式：</p>\n<ul>\n<li><code>onCreate()</code> 中使用 <code>View#post(Runnable)</code>，但回调时只代表调用的这个 View 开始绘制，并不是首帧渲染完成。<ul>\n<li>改进方案：给 DecorView 添加一个 1 像素的 View，使得该 View 称为 DecorView 中最后一个子 View，然后在该 View 的 <code>onDraw()</code> 中通过 <code>Choreographer.getInstance().postFrameCallback(Runnable)</code> 监听下一个 VSync 信号，因为 VSync 只在需要绘制的时候才会触发，绘制一帧回调一次，所以在 <code>onDraw()</code> 里面确保已经绘制完成，然后下一次 VSync 信号回调的时候表示即将开始下一次绘制，此时的时间就能近似认为是首帧绘制完成的时间。</li>\n</ul>\n</li>\n<li>给 DecorView 添加 <code>addOnDrawListener(OnDrawListener)</code>，DecorView 开始绘制时会回调，但是此时 DecorView 内的所有子 View 都还没有开始绘制，并不能代表整个 Activity 绘制完成，只是在 View 很少的时候时间比较接近。<ul>\n<li>改进方案：在 DecorView 的 OnDrawListener 回调中重新 post 一个新的回调，则会在当前帧绘制完成后、下一帧即将开始绘制之前回调。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-Surface机制\"><a href=\"#3-Surface机制\" class=\"headerlink\" title=\"3. Surface机制\"></a>3. Surface机制</h2><p>Android 中的渲染和绘制，最终是通过 Surface 承载的，Surface 是一个真正用于渲染像素的区域，每个 Window 都有自己的 Surface，保存在 Window 的 ViewRootImpl 中，一个 App 可以有多个 Window，因此可以拥有多个 Surface，由 SurfaceFlinger 承担统一管理以及合成这些 Surface 的职责。</p>\n<p>ViewRootImpl 在 <code>performTraversals()</code> 绘制流程的 <code>draw()</code> 阶段，通过 <code>surface.lock()</code> 获取当前 Window 的 Surface 的 Canvas，然后把 Canvas 分发到每个 View，每个 View 自己绘制完之后再分发到自己的子 View，所以实际上一个 Window 内 ViewTree 中所有 View 都会共同渲染到所在 Window 的 Surface 上。</p>\n<p>Window、Surface、SurfaceFlinger 的关系大致如下图所示：</p>\n<p><img data-src=\"./surface_and_surfaceflinger.png\" alt=\"Window、Surface、SurfaceFlinger 的关系\" title=\"@ASSET\"></p>\n<ul>\n<li>当 App 启动并创建一个 Window 后，ViewRootImpl 向 WMS 通知该 Window 的 Surface，WMS 判断 SurfaceFlinger 中是否已经存有该 Window 对应的 Layer，如果没有则在 SurfaceFlinger 中注册。注册的时候首先会创建一个与 App 一一对应的 Binder 代理对象 <code>Client</code>，用于 App 与 SurfaceFlinger 通信。</li>\n<li>当 App 需要渲染的时候，就会通过 Client 请求 SurfaceFlinger，把需要绘制的区域、位置等元数据发送给 SurfaceFlinger。由于 App 可能存在很多个 Surface，所以为了增强数据通信的性能，SurfaceFlinger 为每一个 App 创建了一块共享内存 SurfaceClient，App 直接把需要渲染的 UI 元数据直接写入 SurfaceClient，SurfaceFlinger 直接从 SurfaceClient 读取，避免了内核多次拷贝数据。</li>\n<li>每个 App 在 SurfaceFlinger 中都有自己对应的 SurfaceClient 共享内存区域，而 SerfaceClient 在每个 App 对应的 SurfaceClient 中各维护了一个 SharedBufferStack 的数组，长度为 31。</li>\n<li>每一个 SharedBufferStack 对应一个实际的 Surface，SharedBufferStack 的意义就是用作渲染缓冲区。常见的 UI 刷新模型采用的是双缓冲，一个 BackBuffer 一个 FrontBuffer，显示屏在读取渲染 FrontBuffer 时，UI 元素可以同时向 BackBuffer 写入下一部分需要渲染的数据，然后在 BackBuffer 写入完成后，再交换两个缓冲区，使得原来的 BackBuffer 变为 FrontBuffer，显示屏读取新的 FrontBuffer 渲染显示。而 SharedBufferStack 就是扩展了这个缓冲模型，使得一个 Surface 可以具有 2 个以上的缓冲区，Android 2.3 中 SharedBufferStack 有 2 个缓冲区，Android 4.1 中 SharedBufferStack 有 3 个缓冲区。</li>\n<li>一个 SharedBufferStack 中的结构包括：<ul>\n<li>多个缓冲区 Buffer：每一个 Buffer 保存的就是需要渲染的 UI 的元数据，但这些元数据并不包含具体需要渲染的 UI 数据，而是通过指向一个 GaphicBuffer，由 GaphicBuffer 保存了所有实际渲染的 UI 数据，当 SurfaceFlinger 真正绘制渲染的时候，就会通过 Buffer 找到指向的 GaphicBuffer，从 GaphicBuffer 中取出真实的 UI 数据来渲染。GraphicBuffer 中包含了一个 buffer_handle_t 对象用于描述实际渲染数据的缓冲区 ，而这个缓冲区是在 HAL 层的 Gralloc 模块在系统帧缓冲区 FrameBuffer 或者匿名共享内存 ASHMEM (Anonymous Shared Memory) 中分配的。</li>\n<li>两个计数器：<ul>\n<li>available 表示有几个可供写入的空闲缓冲区。</li>\n<li>queued 表示有几个已经写入等待被读取渲染的缓冲区。</li>\n</ul>\n</li>\n<li>三个指针：<ul>\n<li>head 和 tail 标记了可供写入的空闲 Buffer 的范围。</li>\n<li>queue_head 标记了已准备好的可供读取渲染的 Buffer 的头部。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Linux 中所有的设备都通过 <strong>主设备名</strong> 和 <strong>从设备名</strong> 来唯一定位。Linux 在启动时会创建一个类别为 <code>graphics</code>、名叫 <code>fb0</code> 的设备，用来描述系统中的第一个 <strong>帧缓冲区</strong>，也就是第一个显示屏。其中 <code>fb (Frame Buffer)</code> 是主设备名，<code>0</code> 是从设备名，系统必须至少具有一个显示屏，所以 <code>fb0</code> 设备必定存在，Android 基于 Linux 从内核上是支持多显示屏的，但是 Android 在实现上只使用一个显示屏。</p>\n<p>因此由于 buffer_handle_t 在 FrameBuffer 中分配，当 SurfaceFlinger 把实际的渲染数据写入 buffer_handle_t 后，也就相当于渲染到屏幕上。</p>\n<hr>\n<h2 id=\"4-SurfaceView原理\"><a href=\"#4-SurfaceView原理\" class=\"headerlink\" title=\"4. SurfaceView原理\"></a>4. SurfaceView原理</h2><p>SurfaceView 与 普通 View 不同的地方在于：</p>\n<ul>\n<li>一个 Window 下只有一个 ViewRootImpl，ViewRootImpl 持有 DecorView，DecorView 作为 ViewTree 的顶层 View，整个 ViewTree 中只有 ViewRootImpl 中持有一个 Surface 对象。</li>\n<li>而 SurfaceView 拥有一个自己的 Surface。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mFirst) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 首帧绘制时，从 DecorView 逐层向下分发 AttachInfo，</span></span><br><span class=\"line\">            <span class=\"comment\">// 并回调 View#onAttachedToWindow()</span></span><br><span class=\"line\">            host.dispatchAttachedToWindow(mAttachInfo, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewVisibilityChanged) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从 DecorView 开始逐层向下分发，</span></span><br><span class=\"line\">            <span class=\"comment\">// 并回调 View#onWindowVisibilityChanged(int)</span></span><br><span class=\"line\">            host.dispatchWindowVisibilityChanged(viewVisibility);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">        performLayout(lp, mWidth, mHeight);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 收集汇总所有子 View 调用 requestTransparentRegion(View) 记录的需要透明的区域。</span></span><br><span class=\"line\">        host.gatherTransparentRegion(mTransparentRegion);</span><br><span class=\"line\">        <span class=\"comment\">// 将需要透明的区域汇总后通知给 WMS，WMS 再发送给 SurfaceFlinger。</span></span><br><span class=\"line\">        mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        performDraw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestTransparentRegion</span><span class=\"params\">(View child)</span> </span>&#123;</span><br><span class=\"line\">        checkThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mView == child) &#123;</span><br><span class=\"line\">            mView.mPrivateFlags |= View.PFLAG_REQUEST_TRANSPARENT_REGIONS;</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchAttachedToWindow</span><span class=\"params\">(AttachInfo info, <span class=\"keyword\">int</span> visibility)</span> </span>&#123;</span><br><span class=\"line\">        onAttachedToWindow();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchWindowVisibilityChanged</span><span class=\"params\">(<span class=\"meta\">@Visibility</span> <span class=\"keyword\">int</span> visibility)</span> </span>&#123;</span><br><span class=\"line\">        onWindowVisibilityChanged(visibility);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewGroup</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span>, <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestTransparentRegion</span><span class=\"params\">(View child)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            child.mPrivateFlags |= View.PFLAG_REQUEST_TRANSPARENT_REGIONS;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mParent.requestTransparentRegion(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SurfaceView 重写了 View 中的部分方法，使其可以单独控制自己的 Surface 以及可见区域：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SurfaceView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    IWindowSession mSession;</span><br><span class=\"line\">    <span class=\"comment\">// SurfaceView 自己的 Surface</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Surface mSurface = <span class=\"keyword\">new</span> Surface();</span><br><span class=\"line\">    <span class=\"comment\">// MyWindow 是一个 IWindow 类型的 Binder 对象</span></span><br><span class=\"line\">    MyWindow mWindow;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onAttachedToWindow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onAttachedToWindow();</span><br><span class=\"line\">        <span class=\"comment\">// 逐层向上递归，请求父类把 SurfaceView 所在区域设置为透明，</span></span><br><span class=\"line\">        <span class=\"comment\">// 直到递归到 ViewRootImpl</span></span><br><span class=\"line\">        mParent.requestTransparentRegion(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 持有 IWindowSession，就能与 WMS 通信</span></span><br><span class=\"line\">        mSession = getWindowSession();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onWindowVisibilityChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> visibility)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onWindowVisibilityChanged(visibility);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        updateWindow(<span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updateWindow</span><span class=\"params\">(<span class=\"keyword\">boolean</span> force, <span class=\"keyword\">boolean</span> redrawNeeded)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        mSurfaceLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通知 WMS 对 SurfaceView 的 Surface 重布局，</span></span><br><span class=\"line\">            <span class=\"comment\">// WMS 检查该 Surface 是否已经在 SurfaceFlinger 中注册了 Layer，</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果还没有，则注册一个与该 Surface 对应的 Layer，</span></span><br><span class=\"line\">            <span class=\"comment\">// 注册了独立的 Layer 后，SurfaceView 及所属 Window 的 Surface 独立绘制，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因此 SurfaceView 的绘制和更新不受其他 View 的影响，从而提高了性能。</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> relayoutResult = mSession.relayout(</span><br><span class=\"line\">                mWindow, mLayout, mWidth, mHeight,</span><br><span class=\"line\">                    visible ? VISIBLE : GONE, <span class=\"keyword\">false</span>, mWinFrame, mContentInsets,</span><br><span class=\"line\">                    mVisibleInsets, mConfiguration, mSurface);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            mSurfaceLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>SurfaceView 在 SurfaceFlinger 中的 Layer 的 Z-Order 位于所属 Window 的 Layer 的下方，所以 SurfaceView 才需要在 onAttachedToWindow() 中调用 mParent.requestTransparentRegion(this) 让 Window 对应 Surface 的这些区域变为透明，否则会被遮盖。但是这个请求设置为透明，设置的是 Window 对应 Surface 的区域，而不是 ViewGroup 或 ViewGroup 包含的 View，它们是否透明依然是由 <code>onDraw(Canvas)</code> 决定的，<code>mParent.requestTransparentRegion(this)</code> 仅仅只是为了把 SurfaceView 所在的 Rect 一层层传递到 ViewRootImpl，并由 ViewRootImpl 收集汇总而已。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>View 的绘制流程：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/59b35102ce81\" title=\"@LINK\">Android中老生常谈的ViewRootImpl的scheduleTraversals()到底做了什么？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/352843740\" title=\"@LINK\">谈谈 Android 渲染机制：如何绘制并显示一帧图像？</a></li>\n<li><a href=\"https://blog.csdn.net/a785722173/article/details/112705044\" title=\"@LINK\">浅析丢帧检测机制上篇浅析丢帧检测机制上篇</a></li>\n</ul>\n<p>Android Surface 机制：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/luoshengyang/article/details/8661317\" title=\"@LINK\">Android视图SurfaceView的实现原理分析</a></li>\n<li><a href=\"https://blog.csdn.net/luoshengyang/article/details/7846923\" title=\"@LINK\">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a></li>\n<li><a href=\"https://blog.csdn.net/luoshengyang/article/details/8010977\" title=\"@LINK\">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a></li>\n<li><a href=\"https://www.cnblogs.com/wytiger/p/5693569.html\" title=\"@LINK\">SurfaceView, TextureView, SurfaceTexture等的区别</a></li>\n<li><a href=\"https://www.jianshu.com/p/90a75b9b7115\" title=\"@LINk\">浅谈SurfaceView与GLSurfaceView</a></li>\n<li><a href=\"https://www.jianshu.com/p/b7eb74c1a1b7\" title=\"@LINK\">Surface 与 SurfaceFlinger 之间的关系</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","渲染","绘制","VSync","Surface","Texture"]},{"title":"Android-Router路由框架","url":"/post/android/android-router/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Router路由框架实战\"><a href=\"#Android-Router路由框架实战\" class=\"headerlink\" title=\"Android-Router路由框架实战\"></a>Android-Router路由框架实战</h1><h2 id=\"1-Router框架简介\"><a href=\"#1-Router框架简介\" class=\"headerlink\" title=\"1. Router框架简介\"></a>1. Router框架简介</h2><p>对于一个大型项目来说，双向/循环依赖的场景非常常见，因此 Router 几乎是必备的（或是作为核心通信工具）。简单来说，Router 是基于 <strong>中介者模式</strong> 的组件间通信框架，其定义了组件的输入和输出标准，使得通信双方从「组件 - 组件」解耦为「组件 - Router」。</p>\n<blockquote>\n<p>一个典型的双向依赖场景：假设一个项目包含 module_user、module_util 等 Module。（1）当用户登录时，module_user 需要依赖 module_util 使用某些工具；（2）而工具模块 module_util 中网络组件又需要使用 module_user 的用户信息鉴权。</p>\n<ul>\n<li>如果使用传统的解决方案，无外乎两个原则：减小模块颗粒度、抽象公共逻辑。例如抽象出一个独立的 module_userinfo 作为底层公共依赖。虽然同样可以解决问题，但当越来越多的 Module 出现互相依赖时，这种改造的复杂度可以说是灾难级的。</li>\n<li>使用 Router 框架，则只需要 module_user 定义用户信息的输出 <code>Router.set(&quot;userInfo&quot;, userInfo)</code>；module_util 根据约定的方式读取 <code>Router.get(&quot;userInfo&quot;)</code> 即可。</li>\n</ul>\n<p>当然该例只是为了表示 Router 的核心思路，实际的交互方式需要根据项目自定义。</p>\n</blockquote>\n<p>目前应用较普遍的是阿里开源的 ARouter 框架。</p>\n<h3 id=\"1-1-ARouter的基本原理\"><a href=\"#1-1-ARouter的基本原理\" class=\"headerlink\" title=\"1.1 ARouter的基本原理\"></a>1.1 ARouter的基本原理</h3><p>ARouter 最开始是为了页面跳转之间解耦，本质上它提供了通过 String 的「路径 Path」对应到 Activity / Fragment 的路由表。其核心是通过 APT 在编译时自动检索添加了 <code>@Route(path=&quot;/XXX/XXX&quot;)</code> 注解的 Activity，并以对应的 Path 为 Key 生成 Map，然后在运行时根据 Map 存储的路由信息跳转。ARouter 要求 Path 必须包括至少两级，例如：<code>/main/sub</code>，将 <code>main</code> 称为主路径；<code>sub</code> 称为子路径。一个主路径可以包括多个子路径，例如：<code>/main/sub</code>, <code>/main/sub2</code> 等。</p>\n<p>当项目很庞大或页面数量很多时就会生成一个巨大的路由表，为此 ARouter 做了 <strong>分段懒加载</strong> 的优化，即运行时不会立即将所有路由信息都加载进内存，而是在发起一个路由请求时，先读取缓存，如果缓存没有再懒加载目标主路径下的所有子路由信息。</p>\n<h3 id=\"1-2-ARouter编译时处理\"><a href=\"#1-2-ARouter编译时处理\" class=\"headerlink\" title=\"1.2 ARouter编译时处理\"></a>1.2 ARouter编译时处理</h3><p>ARouter 在编译时会通过 APT 生成两个表：</p>\n<p>（1）对每个应用了 ARouter APT 的 Module，检索所有添加了 <code>@Route</code> 注解的页面组件（Activity / Fragment），并在 Module 下生成每个具体的 Path 对应页面的表 <code>atlas</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// module_splash 目录下的 ADSActivity 会生成以下路由表：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Group_splash</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/splash/ads&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, ADSActivity.class, <span class=\"string\">&quot;/splash/ads&quot;</span>, <span class=\"string\">&quot;splash&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// module_user 目录下的 LoginActivity 和 RegisterActivity 会生成以下路由表：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Group_user</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/user/login&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, LoginActivity.class, <span class=\"string\">&quot;/user/login&quot;</span>, <span class=\"string\">&quot;user&quot;</span>));</span><br><span class=\"line\">        atlas.put(<span class=\"string\">&quot;/user/register&quot;</span>, RouteMeta.build(RouteMeta.Type.ACTIVITY, RegisterActivity.class, <span class=\"string\">&quot;/user/register&quot;</span>, <span class=\"string\">&quot;user&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）将所有路由信息生成主路径对应每个实际路由表 <code>atlas</code> 的分段表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EaseRouter_Root_app</span> <span class=\"keyword\">implements</span> <span class=\"title\">IRouteRoot</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadInto</span><span class=\"params\">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class=\"line\">        routes.put(<span class=\"string\">&quot;slpash&quot;</span>, EaseRouter_Group_splash.class);</span><br><span class=\"line\">        routes.put(<span class=\"string\">&quot;user&quot;</span>, EaseRouter_Group_user.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，不论是具体的路由信息表还是主路径索引的分段表，都实现了 <code>IRouteRoot</code> 接口。</p>\n<h3 id=\"1-3-ARouter运行时分段懒加载\"><a href=\"#1-3-ARouter运行时分段懒加载\" class=\"headerlink\" title=\"1.3 ARouter运行时分段懒加载\"></a>1.3 ARouter运行时分段懒加载</h3><p>ARouter 会在运行时收到路由请求后再懒加载主路径对应的分段表：</p>\n<p>（1）初始化 <code>ARouter.init();</code> 时，ARouter 会开启一个子线程扫描 apk 中的所有 dex 文件，遍历当前包名下所有实现了 <code>IRouteRoot</code> 接口的类，并存进一个 className 集合中。</p>\n<p>（2）通过 <code>ARouter.getInstance().build(&quot;/XXX/XXX&quot;).navigation();</code> 请求路由到指定 Path 对应的 Activity。</p>\n<p>（3）尝试从缓存中读取对应的 Activity，如果命中缓存的路由信息，则直接定位并启动目标 Activity。</p>\n<p>（4）如果未命中缓存，说明该路由对应所在的整个路由表都没有加载。假设目标路由为：<code>/user/register</code>，则 <code>EaseRouter_Group_user</code> 加载 <code>atlas</code> 时，会同时把当前主路径，也即 <code>user</code> 下的所有路由信息都加载，所以如果找不到 <code>/user/register</code>，就说明整个 <code>user</code> 都没有加载，则根据目标路由的主路径 <code>user</code> 加载所有 <code>user</code> 下的路由信息。</p>\n<p>（5）将所有主路径为 <code>user</code> 的路由信息加载后，就能通过 <code>routes.get(&quot;user&quot;);</code> 获取到 <code>EaseRouter_Group_user</code>，然后再通过 <code>atlas.get(&quot;/user/register&quot;)</code> 获取到 <code>RegisterActivity</code>。</p>\n<h3 id=\"1-4-ARouter的局限性\"><a href=\"#1-4-ARouter的局限性\" class=\"headerlink\" title=\"1.4 ARouter的局限性\"></a>1.4 ARouter的局限性</h3><p>ARouter 使得页面间的跳转不再依赖拿到对应的类，只需要 String 类型的路由信息即可，但也带来了以下问题：</p>\n<ul>\n<li>通过 String 类型发起的路由请求是单向的，且只能传递可序列化的数据进行通信。</li>\n<li>路由信息表需要统一管理，以避免出现重复、不规范的问题。</li>\n</ul>\n<p>此外，ARouter 对跳转的解耦，指的是通信双方没有直接依赖，但所有子 Module 的依赖链仍需满足可达性（该规则是合理的，其他框架也不会解决这个问题）。</p>\n<blockquote>\n<p>Gradle 在构建 App 时，如果一个 Module 的依赖链无法到达构建目标 Module，则打包时会忽略该 Module，以减小 APK 包大小和简化资源，但该规则是合理的。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-自定义Router的思路\"><a href=\"#2-自定义Router的思路\" class=\"headerlink\" title=\"2. 自定义Router的思路\"></a>2. 自定义Router的思路</h2><p>在页面跳转的路由中 ARouter 主要作为一个单向驱动框架：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ComponentA --(Router)--&gt; ComponentB</span><br></pre></td></tr></table></figure>\n\n<p>通过定义不同的参数可以细分请求类型，但这会使得路由表变得非常复杂。为了使得 Router 的效果兼具解耦和便捷性，可以梳理一下期望 Router 实现的能力：</p>\n<ul>\n<li>组件间保持解耦，不具有依赖、不关心实现；</li>\n<li>组件不一定非要是 Android 原生四大组件；</li>\n<li>组件的管理和生命周期尽可能自动化，减少学习成本；</li>\n<li>组件间的通信尽可能灵活；</li>\n<li>组件的访问需要考虑跨线程和跨进程的情况；</li>\n</ul>\n<p>这些能力最终可以总结为 3 点：解耦和隔离、灵活访问、自动化管理。</p>\n<h3 id=\"2-1-解耦和隔离\"><a href=\"#2-1-解耦和隔离\" class=\"headerlink\" title=\"2.1 解耦和隔离\"></a>2.1 解耦和隔离</h3><p><strong>面向接口编程</strong> 恰好满足这两个条件，因此可以将 Router 设计为 <strong>接口间的通信工具</strong>。</p>\n<p>（1）组件的定义</p>\n<p>定义一个顶层组件可以使用接口基类或抽象基类（父类）两种方式，使用接口基类则可以避免无法多继承的问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义组件的接口基类，所有实现了这个接口或其子类接口的实现类都可以作为组件。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseServiceInterface</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）组件的实现</p>\n<p>每个模块都可以根据其功能定义自己的子接口，以 Setting 模块为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义一个 Setting 模块的 Router 组件接口，需要继承自 IBaseServiceInterface。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">SettingServiceInterface</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setB</span><span class=\"params\">(String param1, Object param2)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现对应的组件接口。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SettingServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">SettingServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callA</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callB</span><span class=\"params\">(String param1, Object param2)</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-灵活访问\"><a href=\"#2-2-灵活访问\" class=\"headerlink\" title=\"2.2 灵活访问\"></a>2.2 灵活访问</h3><p>用一个公共的 module_base 存放所有 Module 的 Service 或 Event 等的接口，而对应的实现类则闭环在各个 Module 内，Module 间借助 module_base 内定义的公开的接口通信。</p>\n<p>例如上文的 <code>SettingServiceInterface</code> 则存放在 module_base 中，而 <code>SettingServiceImpl</code> 则位于 module_setting 中，当其他模块想要访问 Setting 模块时，即可通过接口访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此为示意代码，还需考虑如何建立接口与实现类的映射关系。</span></span><br><span class=\"line\">SettingServiceInterface settingService = MyRouter.getSettingService();</span><br><span class=\"line\">settingService.callA();</span><br><span class=\"line\">settingService.callB(<span class=\"string\">&quot;param1&quot;</span>, <span class=\"keyword\">new</span> Object());</span><br></pre></td></tr></table></figure>\n\n<p>这样最大的好处就是：不再需要预先定义很多不同的路由表参数，直接通过接口调用近似等同于直接访问其他类，但实际上类的实现是隐藏且隔离的。</p>\n<h3 id=\"2-3-自动化管理\"><a href=\"#2-3-自动化管理\" class=\"headerlink\" title=\"2.3 自动化管理\"></a>2.3 自动化管理</h3><p>基于面向接口的设计模式下，可以通过 Map 记录组件接口与实现类的映射关系；为了使得所有组件可以自由访问，则需要通过 module_base 统一提供组件的接口。</p>\n<h4 id=\"2-3-1-自动映射接口与实现类\"><a href=\"#2-3-1-自动映射接口与实现类\" class=\"headerlink\" title=\"2.3.1 自动映射接口与实现类\"></a>2.3.1 自动映射接口与实现类</h4><p>找出接口与实现类映射关系的方式有运行时和编译时两种，考虑到效率和对性能的影响，选择编译时的方式。</p>\n<p>（1）运行时映射：</p>\n<ul>\n<li>通过当前线程的 <code>ClassLoader#getResource(...)</code> 扫描接口所在工作目录；</li>\n<li>通过 URL 截取工作目录中 Java 资源文件的相对目录，转换为包名；</li>\n<li>过滤所有 <code>.class</code> 文件，分别根据相对路径转换为全限定类名；</li>\n<li>过滤所有 <code>.jar</code> 文件，通过 <code>JarFile#entries(...)</code> 扫描 Jar 包内所有文件并通过 <code>Enumeration</code> 遍历所有类的全限定类名；</li>\n<li>根据收集的全限定类名反射实例化，并判断是否实现指定接口；</li>\n</ul>\n<p>（2）编译时映射（手动注册）：</p>\n<ul>\n<li>Router 对外提供注册接口，用于映射组件的接口和实现类；</li>\n<li>在每个组件中调用 Router 手动注册映射关系，并在合适的时机手动调用每个组件的注册；</li>\n</ul>\n<p>（3）编译时映射（自动注册）：</p>\n<ul>\n<li>Router 对外提供注册接口，用于映射组件的接口和实现类；</li>\n<li>APT 可以在编译阶段获取项目中使用了特定注解的类、方法、变量等元素，因此可以通过自定义注解 + APT 自动生成注册代码，并在合适的时机手动调用注册；</li>\n</ul>\n<h4 id=\"2-3-2-自动集成组件的接口\"><a href=\"#2-3-2-自动集成组件的接口\" class=\"headerlink\" title=\"2.3.2 自动集成组件的接口\"></a>2.3.2 自动集成组件的接口</h4><p>虽然使用 module_base 可以达到灵活访问的目的，但会导致几个痒点：</p>\n<ul>\n<li>开发人员需要理解并依靠自觉来遵循框架的规则，难以开箱即用、也难以约束代码规范。</li>\n<li>代码迁移时需要分别从 module_base 中迁移接口、再从业务 Module 中迁移实现类。</li>\n</ul>\n<p>因此还需要利用一些工具自动获取组件的接口并拷贝一份到 module_base 下，保持拷贝类的类名、包名等信息一致，这样每个 Module 的逻辑都能完全独立在本 Module 内。</p>\n<h4 id=\"2-3-3-自动管理组件的生命周期\"><a href=\"#2-3-3-自动管理组件的生命周期\" class=\"headerlink\" title=\"2.3.3 自动管理组件的生命周期\"></a>2.3.3 自动管理组件的生命周期</h4><p>因为 Router 需要考虑每个组件的接口与对应实现类通过何种方式映射、以及在什么时机注册。</p>\n<hr>\n<h2 id=\"3-自动拷贝接口的错误尝试\"><a href=\"#3-自动拷贝接口的错误尝试\" class=\"headerlink\" title=\"3. 自动拷贝接口的错误尝试\"></a>3. 自动拷贝接口的错误尝试</h2><p>上文 Router 的效果中，如何通过接口通信、如何确定接口与实现类的映射关系、在什么时机初始化实现类等都可以根据业务层自由设计，而难点之一就是：<strong>如何将每个组件的接口自动拷贝至 module_base 公开给其他组件</strong>。</p>\n<p>需要注意的是，因为仅拷贝组件的接口，所以需要识别出哪些类具有特定的注解（如 <code>@Router</code>）并且继承自接口基类（如 <code>BaseServiceInterface</code>）。</p>\n<h3 id=\"3-1-踩坑1：完全依赖APT\"><a href=\"#3-1-踩坑1：完全依赖APT\" class=\"headerlink\" title=\"3.1 踩坑1：完全依赖APT\"></a>3.1 踩坑1：完全依赖APT</h3><p>因为 APT 本身处理的就是具有指定注解的类，而拷贝组件的接口又恰好需要判断是否具有指定的接口，需求和能力不谋而合，因此首先想到的方案就是能否在 APT 生成映射关系的同时将已经过滤出来的组件接口拷贝至 module_base。</p>\n<h4 id=\"3-1-1-拷贝注解类的源文件\"><a href=\"#3-1-1-拷贝注解类的源文件\" class=\"headerlink\" title=\"3.1.1 拷贝注解类的源文件\"></a>3.1.1 拷贝注解类的源文件</h4><p>（1）通过 APT 获取源文件所在的路径</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">generate</span><span class=\"params\">(Element classElement)</span> </span>&#123;</span><br><span class=\"line\">    String sourceFileName = ((ClassSymbol) classElement).sourcefile.getName();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> File copiedSourceFile = <span class=\"keyword\">new</span> File(sourceFileName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）获取目标拷贝目录</p>\n<p>在本例中希望将类拷贝至 module_base，并且希望开发人员只会改动源文件而不是拷贝的文件，因此拷贝的文件就应该位于 Build 目录下，Clean 时自动删除、Rebuild 时重新生成。Gradle 中可以通过 <code>project.buildDir.absolutePath</code> 获取 Android-Library 的 Build 目录，但 module_processor 中的 Java 代码如何读取到呢？</p>\n<ul>\n<li><strong>通过 BuildConfig，不可行</strong>。</li>\n</ul>\n<blockquote>\n<p>在本例场景下，module_base 作为公共 Module 一定会包括 Android 相关特性，所以 module_base 一定只能是 Android-Livrary。</p>\n<p>而 module_processor 作为 AnnotationProcessor 是一个纯 Java-Library，不能依赖 module_base，就无法访问 module_base 的 BuildConfig。</p>\n</blockquote>\n<ul>\n<li><strong>通过环境变量，可行但不合适</strong>。</li>\n</ul>\n<blockquote>\n<p>既然无法通过依赖的方式获取，就考虑具有全局性的方式，例如环境变量。利用环境变量设置共享信息在 Android 开发中非常常见，例如 Keystore 的密钥、存储位置；多渠道打包时的 AppKey、组件化构建时的构建模式等等，尤其在有云端构建机的时候，环境变量使用的更为频繁。环境变量中的数据通常是一些固定的常量，使用环境变量设置全局信息的优点很明显：</p>\n<ul>\n<li>数据获取与代码无关，只需要设置在每个设备的本地即可，即便代码泄漏也不会泄漏环境变量中的敏感数据。</li>\n<li>数据修改与代码无关，只需要修改环境变量，则构建时会自动获取到新的环境变量，而不需要修改代码。</li>\n</ul>\n<p>但在本例中 module_base 的路径并不需要上述特性，且项目在不同设备中的路径都是不一样的，因此通过环境变量指定 module_base 的路径是可行、但并不合适的。</p>\n</blockquote>\n<ul>\n<li><strong>通过 SystemProperty，可行</strong>。</li>\n</ul>\n<blockquote>\n<p>SystemProperty 的特性有：</p>\n<ul>\n<li>与 JVM 运行时有关，每一次启动 JVM 都会重新初始化 SystemProperty。</li>\n<li>更新时效性高，在同一个 JVM 实例中，只要设置了 SystemProperty，随后就能立即获取到。与之相比，环境变量在大多数情况下需要重启 JVM 才能刷新。</li>\n<li>与环境变量具有同样的全局可见性。</li>\n</ul>\n<p>某些场景下，由于 SystemProperty 与 JVM 实例相关所以无法保存一些永久化的数据，会被视作 SystemProperty 的一个缺点；但本例中 module_base 的路径在任何一次构建时都有可能发生改变，因此恰好需要这种运行时机制。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 module_base 的 Gradle 中存入 Build 路径：</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">&quot;build_dir_path_base&quot;</span>, <span class=\"string\">&quot;$&#123;project.projectDir.absolutePath&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 Processor 的 Java 代码中获取：</span></span><br><span class=\"line\">String buildDirPath = System.getProperty(<span class=\"string\">&quot;build_dir_path_base&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>（3）从源文件拷贝至目标路径</p>\n<p>通过上述方式 Processor 已经可以获取到 module_base 的 Build 目录，接下来就是将源文件拷贝至目标目录下。拷贝时还需要注意创建与源文件一致的的 Package 路径：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略具体的源文件类型判断，假设此方法输入的均为已被过滤后需要拷贝的源文件。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">generate</span><span class=\"params\">(Element classElement)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// module_base 的 Build 目录路径：</span></span><br><span class=\"line\">    String buildDirPath = System.getProperty(<span class=\"string\">&quot;build_dir_path_base&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 统一将源文件拷贝至 module_base/build/generated/source/router/ 目录：</span></span><br><span class=\"line\">    buildDirPath += File.separator + <span class=\"string\">&quot;generated&quot;</span> + File.separator + <span class=\"string\">&quot;source&quot;</span></span><br><span class=\"line\">            + File.separator + <span class=\"string\">&quot;router&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 源文件的包名和类名：</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String packageName = classElement.getEnclosingElement().toString();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String className = classElement.getSimpleName().toString();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 源文件的文件名：</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String srcFileName = ((ClassSymbol) classElement).sourcefile.getName();</span><br><span class=\"line\">    <span class=\"comment\">// 检验源文件合法性，这里有个细节：</span></span><br><span class=\"line\">    <span class=\"comment\">// 正常情况下 srcFileName 是源文件的绝对路径，例如：</span></span><br><span class=\"line\">    <span class=\"comment\">//     &quot;/DemoProject/priv/demo/DemoClass.java&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// 但将 DemoClass 拷贝到 module_base 后，拷贝文件中也会包含 @Router 注解，</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 module_base 依赖 module_processor 会导致拷贝的文件也触发 Processor，似乎是无限循环，</span></span><br><span class=\"line\">    <span class=\"comment\">// 但实际上拷贝至 module_base 中的 DemoClass 如果获取 srcFileName 会返回裸文件名，例如：</span></span><br><span class=\"line\">    <span class=\"comment\">//     &quot;DemoClass.java&quot;</span></span><br><span class=\"line\">    <span class=\"comment\">// 因此拷贝文件的 srcFileName 生成的 File 对象调用 exists() 返回是 false，</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以也变相避免了重复生成的问题，但不确定这是否符合期望，因此需要考虑使用更稳定的过滤方式。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> File srcFile = <span class=\"keyword\">new</span> File(srcFileName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!srcFile.exists()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将包名中的 . 替换为当前文件系统中的路径分隔符：</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String packageDir = packageName.replace(<span class=\"string\">&#x27;.&#x27;</span>, File.separatorChar);</span><br><span class=\"line\">    <span class=\"comment\">// 将 module_base 的 Build 目录与源文件的包名、类名拼接成最终目标文件的绝对路径：</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String targetClassPath = buildDirPath + File.separator</span><br><span class=\"line\">            + packageDir + File.separator + className + <span class=\"string\">&quot;.java&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果目录不存在则创建目录：</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> File targetEventFile = <span class=\"keyword\">new</span> File(targetClassPath);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!targetEventFile.exists()) &#123;</span><br><span class=\"line\">        targetEventFile.mkdirs();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 开始复制文件</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 借助 Java 8 的 NIO 工具完成复制：</span></span><br><span class=\"line\">        Files.copy(srcEventFile.toPath(), targetEventFile.toPath(), StandardCopyOption.REPLACE_EXISTING);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假设有一个 DemoClass 类位于 <code>module_util/priv/demo/DemoClass.java</code> 并添加了 <code>@Router</code> 注解，Rebuild 项目发现 DemoClass 确实成功复制到了 <code>module_base/build/generated/source/router/priv/demo/DemoClass.java</code>！</p>\n<h4 id=\"3-1-2-导入拷贝的类\"><a href=\"#3-1-2-导入拷贝的类\" class=\"headerlink\" title=\"3.1.2 导入拷贝的类\"></a>3.1.2 导入拷贝的类</h4><p>通过上文的方式拷贝源文件后却发现 <strong>module_base 中拷贝的类无法被任何一个类导入</strong>，是因为默认情况下，Library 在 Gradle 中只有一个源文件目录：</p>\n<blockquote>\n<p>对比观察这个 Build 生成的目录结构和正常的目录结构：</p>\n<p><img data-src=\"./build_dir_not_as_package.png\" alt=\"Build 下的目录无法识别为包路径\" title=\"@ASSET\"></p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果没有显式指定，则默认配置即为：</span></span><br><span class=\"line\">sourceSets &#123;</span><br><span class=\"line\">    main &#123;</span><br><span class=\"line\">        jni.srcDirs = []</span><br><span class=\"line\">        jniLibs.srcDir [<span class=\"string\">&quot;libs&quot;</span>]</span><br><span class=\"line\">        <span class=\"comment\">// Java 源文件默认只包含 module/src/main/java/ 目录下的</span></span><br><span class=\"line\">        java.srcDirs = [<span class=\"string\">&#x27;src/main/java/&#x27;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此只需要在 module_base 的 Gradle 中将生成的类所在目录也添加到 Java 源文件目录中即可：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 追加源文件目录：</span></span><br><span class=\"line\">android.sourceSets.main.java.srcDirs += [<span class=\"string\">&#x27;build/generated/source/router/&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以考虑封装至 base.gradle 中，并被其他所有 Module 的 Gradle 应用：</span></span><br><span class=\"line\"><span class=\"comment\">// apply from: &quot;$&#123;project.rootDir&#125;/xxx/base.gradle&quot;</span></span><br><span class=\"line\">project.ext.asBaseModule = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加 Java 源文件目录：</span></span><br><span class=\"line\">    android.sourceSets.main.java.srcDirs += [<span class=\"string\">&#x27;build/generated/source/router/&#x27;</span>]</span><br><span class=\"line\">    <span class=\"comment\">// 将作为 BaseModule 的 Build 目录绝对路径存入 SystemProperty：</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> buildDirPath = <span class=\"string\">&quot;$&#123;project.buildDir.absolutePath&#125;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buildDirPath != <span class=\"literal\">null</span> &amp;&amp; !buildDirPath.trim().isEmpty()) &#123;</span><br><span class=\"line\">        System.setProperty(<span class=\"string\">&quot;build_dir_path_base&quot;</span>, buildDirPath)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样如果想让某个 Module 作为 BaseModule，只需要在其 Gradle 中调用这个方法即可：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">apply <span class=\"attr\">from:</span> <span class=\"string\">&quot;$&#123;project.rootDir&#125;/xxx/base.gradle&quot;</span></span><br><span class=\"line\">project.ext.asBaseModule()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-1-3-Javac编译任务异常\"><a href=\"#3-1-3-Javac编译任务异常\" class=\"headerlink\" title=\"3.1.3 Javac编译任务异常\"></a>3.1.3 Javac编译任务异常</h4><p>（1）Javac 编译不通过</p>\n<p>通过上述方法编译后已经能成功将所有添加了 <code>@Router</code> 注解的源文件拷贝至 module_base 中，但假如：</p>\n<ul>\n<li>在 module_util 中定义了一个 <code>priv.demo.DemoClass</code>，编译后在 module_base 中生成拷贝的 DemoClass</li>\n<li>在 module_app 中导入并使用拷贝的 DemoClass，Clean + Rebuild</li>\n</ul>\n<p>Rebuild 时 module_app 的 Javac 任务就会抛出错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: package priv.demo does not exist</span><br></pre></td></tr></table></figure>\n\n<p>原因其实也很简单，由于 Clean 时删除了 module_base 的 Build 目录，此时 DemoClass 还未拷贝至 module_base 中，<strong>Processer 作为 Javac 的一个工具，执行在 Javac 的语法通过性检测之后</strong>，自然会找不到对应 Package 和类。但由于 Gradle 并行执行任务，实际上在 module_app 的 Javac 抛出异常后，其他 Module 构建还在继续运行并成功拷贝 DemoClass，因此如果在编译失败后 <strong>不 Clean 直接再次构建，又能成功完成</strong>。</p>\n<p>（2）尝试延迟 Javac 任务</p>\n<p>能不能让 module_base 的 Javac 任务运行在所有其他 Module 的 Javac 之前？这样是不是就能在其他 Module Javac 之前将所有需要拷贝的源文件准备好？修改 <code>base.gradle</code>：</p>\n<blockquote>\n<p>与 <code>dependsOn</code> 类似的还有 <code>mustRunAfter</code>，相关区别可以另行查阅。</p>\n</blockquote>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断某个 Task 是否是 Javac 任务</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isJavacTask(Task task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (task.name.startsWith(<span class=\"string\">&quot;compile&quot;</span>) &amp;&amp; task.name.endsWith(<span class=\"string\">&quot;JavaWithJavac&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 module_base 中所有 Javac 相关的 Task 保存在一个 Set 中：</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> baseModuleJavacTaskSet = <span class=\"keyword\">new</span> HashSet&lt;Task&gt;()</span><br><span class=\"line\">project(<span class=\"string\">&#x27;:module_base&#x27;</span>).tasks.all &#123; task -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isJavacTask(task)) &#123;</span><br><span class=\"line\">        baseModuleJavacTaskSet.add(task)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历构建时的所有 Task，</span></span><br><span class=\"line\"><span class=\"comment\">// 除了 module_base 以外，其他 Module 的 Javac 都在 module_base 的 Javac 之后执行：</span></span><br><span class=\"line\">tasks.whenTaskAdded &#123; task -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((task.project == project(<span class=\"string\">&#x27;:module_base&#x27;</span>))) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isJavacTask(task)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Task <span class=\"attr\">eachBaseModuleJavacTask :</span> baseModuleJavacTaskSet) &#123;</span><br><span class=\"line\">            task.dependsOn eachBaseModuleJavacTask</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">project.ext.asBaseModule = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加 Java 源文件目录：</span></span><br><span class=\"line\">    android.sourceSets.main.java.srcDirs += [<span class=\"string\">&#x27;build/generated/source/router/&#x27;</span>]</span><br><span class=\"line\">    <span class=\"comment\">// 将作为 BaseModule 的 Build 目录绝对路径存入 SystemProperty：</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> buildDirPath = <span class=\"string\">&quot;$&#123;project.buildDir.absolutePath&#125;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buildDirPath != <span class=\"literal\">null</span> &amp;&amp; !buildDirPath.trim().isEmpty()) &#123;</span><br><span class=\"line\">        System.setProperty(<span class=\"string\">&quot;build_dir_path_base&quot;</span>, buildDirPath)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）延迟 Javac 会导致重复生成 BuildConfig</p>\n<p>将其他 Module 的 Javac 都依赖于 module_base 的 Javac 后，重新 Sync、Rebuild，这次 Javac 抛出了另一个异常：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/DemoProject/module_base/build/generated/<span class=\"built_in\">source</span>/router/buildConfig/debug/priv/demo/BuildConfig.java:6:error: duplicate class: priv.demo.BuildConfig</span><br><span class=\"line\">public final class BuildConfig &#123;</span><br><span class=\"line\">             ^</span><br><span class=\"line\">1 error</span><br><span class=\"line\"></span><br><span class=\"line\">FAILURE: Build failed with an exception.</span><br><span class=\"line\"></span><br><span class=\"line\">* What went wrong:</span><br><span class=\"line\">Execution failed <span class=\"keyword\">for</span> task <span class=\"string\">&#x27;:module_base:compileDebugJavaWithJavac&#x27;</span>.</span><br><span class=\"line\">&gt; Compilation failed; see the compiler error output <span class=\"keyword\">for</span> details.</span><br></pre></td></tr></table></figure>\n\n<p>异常提示 module_base 下存在重复（包名与类名均相同）的类 BuildConfig。这就奇怪了，上文中所有的改动都没有操作 BuildConfig，为什么会导致 BuildConfig 重复呢？根据日志点进对应的 BuildConfig 类中查看 AndroidStudio 的提示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Duplicate class found <span class=\"keyword\">in</span> the file <span class=\"string\">&#x27;/DemoProject/module_base/build/generated/source/buildConfig/release/priv/demo/BuildConfig.java&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>错误提示同时生成了 Debug 的 <code>BuildConfig</code> 和 Release 的 <code>BuildConfig</code>，由于包名和类名都相同且在同一个 Module 下所以抛出了该异常。这更让我感到困惑，明明是通过 <code>assembleDebug</code> 任务构建的，为什么会生成 Release 的 BuildConfig 呢？</p>\n<p>其实是因为 <code>compileDebugJavaWithJavac</code> 和 <code>compileReleaseJavaWithJavac</code> 都匹配了 Javac 的任务名，导致 <code>baseModuleJavacTaskSet</code> 中同时保存了两个任务。因此只需要修改判断 Javac 以及 <code>depensOn</code> 的逻辑，区分 Debug 和 Release 即可，将 <code>base.gradle</code> 整理和优化后，大致如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// base.gradle</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 分别判断是否 Debug / Release 模式的 Javac 任务：</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isDebugJavacTask(Task task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (isJavacTask(task) &amp;&amp; task.name.toLowerCase().contains(<span class=\"string\">&quot;debug&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> isReleaseJavacTask(Task task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (isJavacTask(task) &amp;&amp; task.name.toLowerCase().contains(<span class=\"string\">&quot;release&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">def</span> isJavacTask(Task task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (task.name.startsWith(<span class=\"string\">&quot;compile&quot;</span>) &amp;&amp; task.name.endsWith(<span class=\"string\">&quot;JavaWithJavac&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用于组件化时判断当前壳 Module 是否为正在构建的壳工程的 Module：</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isBuildingCurrentShell() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gradle.startParameter.currentDir.toString().contains(project.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 记录每一个 Module 的绝对路径，以备后续使用</span></span><br><span class=\"line\">task setModulePath(<span class=\"attr\">type:</span> Exec) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">def</span> modulePathKey = <span class=\"string\">&quot;module_path_$&#123;project.name&#125;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> modulePathValue = <span class=\"string\">&quot;$&#123;project.projectDir.absolutePath&#125;&quot;</span></span><br><span class=\"line\">    System.setProperty(modulePathKey, modulePathValue)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// module_base 调用此方法即可保存其 Build 目录、以及将该目录添加到 Java 源文件目录中：</span></span><br><span class=\"line\">project.ext.asBaseModule = &#123;</span><br><span class=\"line\">    android.sourceSets.main.java.srcDirs += [<span class=\"string\">&#x27;build/generated/source/&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">def</span> baseModulePath = <span class=\"string\">&quot;$&#123;project.buildDir.absolutePath&#125;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (baseModulePath != <span class=\"literal\">null</span> &amp;&amp; !baseModulePath.trim().isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">def</span> baseModuleGeneratedPath = <span class=\"string\">&quot;$&#123;baseModulePath&#125;$&#123;File.separator&#125;generated&quot;</span></span><br><span class=\"line\">        System.setProperty(<span class=\"string\">&quot;base_generated_path&quot;</span>, baseModuleGeneratedPath)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// module_base 的 Projcet 对象：</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> baseModuleProject = project(<span class=\"string\">&#x27;:base_module&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断一个 Task 是否是 module_base 中的 Task：</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> isTaskFromBaseModule(Task task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (task.project == project(<span class=\"string\">&#x27;:base_module&#x27;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据 Debug 和 Release 模式分别保存 module_base 的 Javac 任务：</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> baseModuleDebugJavacTaskSet = <span class=\"keyword\">new</span> HashSet&lt;Task&gt;()</span><br><span class=\"line\"><span class=\"keyword\">def</span> baseModuleReleaseJavacTaskSet = <span class=\"keyword\">new</span> HashSet&lt;Task&gt;()</span><br><span class=\"line\">baseModuleProject.tasks.all &#123; task -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDebugJavacTask(task)) &#123;</span><br><span class=\"line\">        baseModuleDebugJavacTaskSet.add(task)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isReleaseJavacTask(task)) &#123;</span><br><span class=\"line\">        baseModuleReleaseJavacTaskSet.add(task)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据 Debug 和 Release 模式分别延迟其他 Module 的 Javac 任务：</span></span><br><span class=\"line\">tasks.whenTaskAdded &#123; task -&gt;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isTaskFromBaseModule(task)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDebugJavacTask(task)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Task <span class=\"attr\">eachBaseModuleDebugJavacTask :</span> baseModuleDebugJavacTaskSet) &#123;</span><br><span class=\"line\">            task.dependsOn eachBaseModuleDebugJavacTask</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isReleaseJavacTask(task)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Task <span class=\"attr\">eachBaseModuleReleaseJavacTask :</span> baseModuleReleaseJavacTaskSet) &#123;</span><br><span class=\"line\">            task.dependsOn eachBaseModuleReleaseJavacTask</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次重新构建，不再生成重复的 BuildConfig 类了，但是依然无法解决 Clean 后下次编译 Javac 语法检测不通过的问题。</p>\n<h4 id=\"3-1-4-完全依赖APT失败总结\"><a href=\"#3-1-4-完全依赖APT失败总结\" class=\"headerlink\" title=\"3.1.4 完全依赖APT失败总结\"></a>3.1.4 完全依赖APT失败总结</h4><p>经过实践，想要完全依赖 APT 似乎难以实现理想的效果，主要是因为理解错了 Processor 和 Javac 的关系：</p>\n<ul>\n<li>Processor 作为 Javac 的一个编译工具，执行在 Javac 检查语法通过性之后。</li>\n<li>每个 Module 都会独立 Javac，并且需要自行声明 <code>annotationProcessor</code> 来触发 Processor 处理本 Module 内的注解。</li>\n<li>因此提前执行 module_base 的 Javac 只会处理 module_base 的注解，其他 Module 中的注解仍然需要在它们 Javac 之后才处理，因此无法规避 Javac 的语法通过性检测。</li>\n</ul>\n<h3 id=\"3-2-踩坑2：Plugin重新编译\"><a href=\"#3-2-踩坑2：Plugin重新编译\" class=\"headerlink\" title=\"3.2 踩坑2：Plugin重新编译\"></a>3.2 踩坑2：Plugin重新编译</h3><p>完全依赖 APT 无法完成的主要原因在于 Processor 发生在 Javac 之后，因此就需要考虑一个能更早生效的机制，而 Plugin 可以执行在编译开始前，最早可以执行在 Gradle 同步时期，因此可以满足编译时序的要求。</p>\n<p>该思路分为三个步骤：</p>\n<ul>\n<li>遍历所有 Java 文件；</li>\n<li>编译 Java 文件，判断接口、注解等是否满足条件；</li>\n<li>将满足条件的 Java 文件拷贝至 module_base 下；</li>\n</ul>\n<p>以拷贝 Service 的接口为例，Plugin 设计如下：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterSharePlugin</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;File&gt; srcJavaFileSet;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;File&gt; serviceInterfaceJavaFileSet;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 遍历所有 Java 文件。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> loadJavaFile(Project project) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将 Java 文件编译为 Class 文件。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> compileJavaFile() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 读取编译后的 Class，判断是否满足条件。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> filterClass() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将满足条件的 Class 对应的 Java 文件拷贝至 module_base。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> copyJavaFile() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-1-收集Java类\"><a href=\"#3-2-1-收集Java类\" class=\"headerlink\" title=\"3.2.1 收集Java类\"></a>3.2.1 收集Java类</h4><p>收集 Java 类比较简单，就是文件遍历和后缀判断，不过有一个小细节：并不是 Project 下的所有 Java 文件都需要收集和判断的，因为可能在 Build 目录、也可能是多渠道打包时其他构建目录下的文件，因此需要通过读取当前构建配置下的 Jara 源文件目录：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Set&lt;File&gt; srcJavaFileSet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> loadJavaFile(Project project) &#123;</span><br><span class=\"line\">    TestedExtension extension = getAndroidConfigFromProject(project)</span><br><span class=\"line\">    extension.sourceSets.main.java.srcDirs.each &#123; File eachDir -&gt;</span><br><span class=\"line\">        iteratorFiles(eachDir &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isJavaFile(it)) &#123;</span><br><span class=\"line\">                srcJavaFileSet.add(it)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取 Project 的 android&#123;&#125; 配置块。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> TestedExtension getAndroidConfigFromProject(Project project) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试作为 Application 获取：</span></span><br><span class=\"line\">    AppExtension applicationModuleAndroidConfig = project.getExtensions().findByType(AppExtension.<span class=\"keyword\">class</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationModuleAndroidConfig != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> applicationModuleAndroidConfig</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试作为 Library 获取：</span></span><br><span class=\"line\">    LibraryExtension libraryModuleAndroidConfig = project.getExtensions().findByType(LibraryExtension.<span class=\"keyword\">class</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (libraryModuleAndroidConfig != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> libraryModuleAndroidConfig</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 递归遍历目录下的所有文件。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> iteratorFiles(File srcFile, <span class=\"meta\">@ClosureParams</span>(FirstParam) Closure closure) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (srcFile.isFile()) &#123;</span><br><span class=\"line\">        closure(srcFile)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (srcFile.isDirectory()) &#123;</span><br><span class=\"line\">        srcFile.listFiles().each &#123;</span><br><span class=\"line\">            iteratorFiles(it, closure)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> isJavaFile(File file) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (file != <span class=\"literal\">null</span></span><br><span class=\"line\">            &amp;&amp; file.name != <span class=\"literal\">null</span></span><br><span class=\"line\">            &amp;&amp; file.name.length &gt;= <span class=\"number\">5</span></span><br><span class=\"line\">            &amp;&amp; file.name.substring(file.name.length - <span class=\"number\">5</span>).toLowerCase() == <span class=\"string\">&quot;.java&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-2-Plugin编译Java类\"><a href=\"#3-2-2-Plugin编译Java类\" class=\"headerlink\" title=\"3.2.2 Plugin编译Java类\"></a>3.2.2 Plugin编译Java类</h4><p>假设项目中有以下两个接口：</p>\n<p>（1）<code>DemoServiceInterface</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> priv.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> androidx.lifecycle.Lifecycle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> priv.base.BaseServiceInterface;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DemoServiceInterface</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onEventReceived</span><span class=\"params\">(Lifecycle.Event event)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）<code>BlankInterface</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> priv.demo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个空的接口。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BlankInterface</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前一步收集了所有工作路径下的 Java 文件，假设上例两个接口都符合条件（仅为了问题说明，实际项目中设置的条件通常是要求接口继承自 <code>BaseServiceInterface</code> 且实现类添加了 <code>@Route</code> 注解才符合），都需要拷贝至 module_base 中，接下来将 Java 文件编译为 Class，并判断其是否为需要被拷贝的文件：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Set&lt;File&gt; srcJavaFileSet;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Set&lt;File&gt; serviceInterfaceJavaFileSet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> compileJavaFile() &#123;</span><br><span class=\"line\">    srcJavaFileSet.each &#123; eachJavaFile -&gt;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 Compiler 编译本地 Java 文件：</span></span><br><span class=\"line\">        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler()</span><br><span class=\"line\">        <span class=\"comment\">// 仅当返回值为 0 时表示编译通过。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> compileResulte = compiler.run(<span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, eachJavaFile.getAbsolutePath())</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ✅ 如果是 BlankInterface.java 则可以编译通过；</span></span><br><span class=\"line\">        <span class=\"comment\">// ❌ 如果是 DemoServiceInterface 则 compileResulte 返回值为 1 且抛出异常；</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 编译成 Class 后，再通过 ClassLoader 加载进内存：</span></span><br><span class=\"line\">        URL[] javaFileUrlArray = <span class=\"keyword\">new</span> URL[] &#123; eachJavaFile.toURI().toURL() &#125;</span><br><span class=\"line\">        ClassLoader classLoader = URLClassLoader.newInstance(javaFileUrlArray)</span><br><span class=\"line\">        Class&lt;?&gt; eachJavaClass = Class.forName(getClassPathFromJavaFile(eachJavaFile), true, classLoader)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断加载出来的 Class 是否符合条件，如果符合则记录起来，用于后续拷贝至 module_base：</span></span><br><span class=\"line\">        if (isTargetClass(eachJavaClass)) &#123;</span><br><span class=\"line\">            serviceInterfaceJavaFileSet.add(eachJavaFile)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private String getClassPathFromJavaFile(File javaFile) &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private boolean isTargetClass(Class&lt;?&gt; compiledClass) &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而这段代码实际上只有 <code>BlankInterface.java</code> 才能被编译通过，编译 <code>BaseServiceInterface.java</code> 时会抛出以下异常：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/Project/module_demo/src/main/java/priv/demo/DemoServiceInterface.java:3: error: package androidx.lifecycle does not exist</span><br><span class=\"line\">import androidx.lifecycle.Lifecycle;</span><br><span class=\"line\">                         ^</span><br><span class=\"line\"></span><br><span class=\"line\">/Project/module_demo/src/main/java/priv/demo/DemoServiceInterface.java:4: error: package priv.base does not exist</span><br><span class=\"line\">import priv.base.BaseServiceInterface;</span><br><span class=\"line\">                ^</span><br><span class=\"line\"></span><br><span class=\"line\">/Project/module_demo/src/main/java/priv/demo/DemoServiceInterface.java:6: error: cannot find symbol</span><br><span class=\"line\">public interface DemoServiceInterface extends BaseServiceInterface &#123;</span><br><span class=\"line\">                                              ^</span><br><span class=\"line\">  symbol: class BaseServiceInterface</span><br><span class=\"line\"></span><br><span class=\"line\">/Project/module_demo/src/main/java/priv/demo/DemoServiceInterface.java:7: error: package Lifecycle does not exist</span><br><span class=\"line\">    void onEventReceived(Lifecycle.Event event);</span><br><span class=\"line\">                                  ^</span><br><span class=\"line\">4 errors</span><br><span class=\"line\"></span><br><span class=\"line\">FAILURE: Build failed with an exception.</span><br></pre></td></tr></table></figure>\n\n<p>这是因为 <code>DemoServiceInterface.java</code> 依赖的类并没有被 Compile，因此其编译时在工作目录下读取不到 <code>import</code> 的内容。</p>\n<h4 id=\"3-2-3-Plugin重编译方案失败总结\"><a href=\"#3-2-3-Plugin重编译方案失败总结\" class=\"headerlink\" title=\"3.2.3 Plugin重编译方案失败总结\"></a>3.2.3 Plugin重编译方案失败总结</h4><ul>\n<li>由于 Router 是一个通用框架，因此需要被拷贝的类可能会具有各种各样的依赖，针对每个依赖都递归编译是不现实的；</li>\n<li>该方案从一开始就不合理，因为其会导致大量类被编译多次，这对一个大型项目的编译速度堪称毁灭性打击。</li>\n</ul>\n<hr>\n<h2 id=\"4-实现自定义Router\"><a href=\"#4-实现自定义Router\" class=\"headerlink\" title=\"4. 实现自定义Router\"></a>4. 实现自定义Router</h2><p>通过上文分析可以明确自定义 Router 需要实现以下目标：</p>\n<ul>\n<li>通过 APT 自动收集符合条件的接口及实现类映射。</li>\n<li>通过 Transform 自动注册映射。</li>\n</ul>\n<h3 id=\"4-1-APT自动收集接口与实现类的映射\"><a href=\"#4-1-APT自动收集接口与实现类的映射\" class=\"headerlink\" title=\"4.1 APT自动收集接口与实现类的映射\"></a>4.1 APT自动收集接口与实现类的映射</h3><h3 id=\"4-2-Transform自动注册映射\"><a href=\"#4-2-Transform自动注册映射\" class=\"headerlink\" title=\"4.2 Transform自动注册映射\"></a>4.2 Transform自动注册映射</h3><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p>ARouter：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/c57214448c7f\" title=\"@LINK\">Android路由框架ARouter的集成、基本使用以及踩坑全过程</a></li>\n<li><a href=\"https://www.jianshu.com/p/857aea5b54a8\" title=\"@LINK\">ARouter原理剖析及手动实现</a></li>\n</ul>\n<p>Gradle：</p>\n<ul>\n<li><a href=\"https://mayope.net/blog/2020/07/25/gradle_plugin_parameterized/\" title=\"@LINK\">ADDING PARAMETERS TO A GRADLE PLUGIN</a></li>\n<li><a href=\"https://discuss.gradle.org/t/gradle-plugin-with-reflections/22690\" title=\"@LINK\">Gradle plugin with reflections</a></li>\n<li><a href=\"https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven\" title=\"@LINK\">Maven Publish Plugin</a></li>\n<li><a href=\"https://stackoverflow.com/questions/44310572/how-to-build-some-java-files-to-one-jar-using-gradle-java-plugin\" title=\"@LINK\">How to build some java files to one jar using gradle java-plugin?</a></li>\n</ul>\n<p>其他：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/y_hai_yang/article/details/82701120\" title=\"@LINK\">使用ASTParser(抽象语法树)获取类属性注释</a></li>\n<li><a href=\"https://www.cnblogs.com/wangzhen-fly/p/11002814.html\" title=\"@LINK\">获取Java接口的所有实现类</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2946338/how-do-i-programmatically-compile-and-instantiate-a-java-class/2946402#2946402\" title=\"@LINK\">How do I programmatically compile and instantiate a Java class?</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","Router","ARouter","路由"]},{"title":"Android-Service","url":"/post/android/android-service/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Service\"><a href=\"#Android-Service\" class=\"headerlink\" title=\"Android-Service\"></a>Android-Service</h1><h2 id=\"1-Service的状态和种类\"><a href=\"#1-Service的状态和种类\" class=\"headerlink\" title=\"1. Service的状态和种类\"></a>1. Service的状态和种类</h2><p>Service 分为 <code>Started</code> 和 <code>Bound</code> 两种状态（可共存），以及 <code>Foreground</code> 和 <code>Background</code> 两种类型。</p>\n<h3 id=\"1-1-Service的启动和绑定状态\"><a href=\"#1-1-Service的启动和绑定状态\" class=\"headerlink\" title=\"1.1 Service的启动和绑定状态\"></a>1.1 Service的启动和绑定状态</h3><p>Service 可以通过 <code>start</code> 和 <code>bind</code> 两种方法启动。</p>\n<ul>\n<li><code>startService()</code> 后该 Service 即变为 <code>Stared</code> 状态，处于后台运行中，与启动它的 Activity 生命周期无关，除非手动 <code>stopService(Intent)</code> 或 Service 内部调用自己的 <code>stopSelf()</code> 终止，或被 Android 系统回收。</li>\n<li><code>bindService()</code> 后该 Service 为 <code>Bound</code> 状态，主要提供 C / S 接口，允许组件与 Service 通信或跨进程通信，生命周期与启动它的宿主绑定，宿主销毁时会自动解除与 Service 的绑定，当 <code>Bound</code> 状态的 Service 没有被任何宿主绑定时，就会销毁该 Service。</li>\n</ul>\n<p>Service 可以同时处于 <code>Started</code> 状态和 <code>Bound</code> 状态，也即 Service 通过一种方式启动后，仍然可以被其他宿主通过另一种方式连接（但不会重新启动）。当 Service 同时处于 <code>Started</code> 和 <code>Bound</code> 状态时，Service 的生命周期同时受到两种状态的影响，仅当两种状态都断开时，Service 才会销毁，也即：必须被 <code>stopService()</code> 并且被 <code>unbindService()</code> 后，Service 才会销毁。</p>\n<h3 id=\"1-2-Service的前台和后台\"><a href=\"#1-2-Service的前台和后台\" class=\"headerlink\" title=\"1.2 Service的前台和后台\"></a>1.2 Service的前台和后台</h3><p>Service 可以在后台执行长时间而无界面的操作，且默认处于主进程的主线程中。</p>\n<ul>\n<li><p>BackGround Service：用户不可感知的后台操作，如监控、轮询拉取等。</p>\n<ul>\n<li>默认情况下，不论通过 <code>start</code> 还是 <code>bind</code> 启动的 Service 都是后台 Service。后台 Service 对用户不可感知，但内存优先级较低，在内存不足时会被系统杀死（根据 Service 的参数可以指定是否需要在内存空闲后重新启动），最大允许 200 秒（<code>ActiveServices#SERVICE_BACKGROUND_TIMEOUT</code>）卡顿时间，超出则会抛出 ANR。</li>\n</ul>\n</li>\n<li><p>Foreground Service：执行一些用户可感知的操作，如 Audio 播放。</p>\n<ul>\n<li><p>可以通过调用 <code>Service#startForeground(int id, Notification notification)</code> 将一个 Service 设为前台 Service，其中 Notification 不能为 <code>null</code> 否则会抛出异常，因此 ForegroundService 强制要求在通知栏显示一个服务图标，但内存优先级高，即使内存不足也不会被系统杀死，最大允许 20 秒（<code>ActiveServices#SERVICE_TIMEOUT</code>）卡顿时间，超出则会抛出 ANR。</p>\n</li>\n<li><p>在 API 26 (Android 8.0) 以上可以直接通过 <code>startForegroundService()</code> 启动一个 ForegroundService，但在 ForegroundService 启动后需要在 10 秒（<code>ActiveServices#SERVICE_START_FOREGROUND_TIMEOUT</code>）内调用 <code>startForeground()</code>，否则会抛出 ANR。</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-Service生命周期\"><a href=\"#2-Service生命周期\" class=\"headerlink\" title=\"2. Service生命周期\"></a>2. Service生命周期</h2><p>所有 Service 都必须在 Manifest 内声明注册：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;service</span><br><span class=\"line\">    android:name=<span class=\"string\">&quot;.DemoService&quot;</span></span><br><span class=\"line\">    android:exported=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    android:process=<span class=\"string\">&quot;:demo&quot;</span></span><br><span class=\"line\">    android:isolatedProcess=<span class=\"string\">&quot;false&quot;</span></span><br><span class=\"line\">    android:enabled=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\">    &gt;</span><br><span class=\"line\">    &lt;intent-filter&gt;</span><br><span class=\"line\">        &lt;action android:name=<span class=\"string\">&quot;service.DemoService&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/service&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>exported</code>: 是否能被其他 App 隐式启动（通过指定 Intent 的 ActionName 启动），当没有指定 <code>Intent-Filter</code> 时默认值为 <code>false</code>，指定了 <code>Intent-Filter</code> 时默认值为 <code>true</code>。</p>\n</li>\n<li><p><code>process</code>: 指定进程，默认情况下 Service 运行在主进程的主线程中，可以通过指定 <code>process</code> 属性分配独立进程。</p>\n</li>\n<li><p><code>isolatedProcess</code>: 是否运行在一个 <strong>没有任何权限</strong> 的特殊进程中，通常用于一些沙盒任务。</p>\n</li>\n<li><p><code>enabled</code>: 是否启用这个 Service (系统是否能实例化这个 Service)，默认为 <code>true</code>，当设置为 <code>false</code> 时，相当于在 Manifest 中移除该 Service 的标签。</p>\n<ul>\n<li>关于 <code>enabled</code> 属性有个很常见的问题就是：如果想要不启用这个 Service，为何要在 Manifest 中声明又禁用呢？直接不写这个 Service 或者不在 Manifest 中声明不就行了吗？实际上这个属性更多用在外部依赖上，例如项目依赖了一个 Module，但是又想禁用 Module 中的某个 Service，则可以在项目 Manifest 中禁用该 Service，然后 Manifest 合并后就会禁用该 Service，理论上四大组件都可以通过这个方式禁用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-1-Start方式启动Service\"><a href=\"#2-1-Start方式启动Service\" class=\"headerlink\" title=\"2.1 Start方式启动Service\"></a>2.1 Start方式启动Service</h3><p>以 start 方式启动 Service：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(context, DemoService.class);</span><br><span class=\"line\">startService(intent);</span><br><span class=\"line\">stopService(intent);</span><br></pre></td></tr></table></figure>\n\n<p>需要注意：</p>\n<ul>\n<li><code>Service#stopSelf()</code> 和 <code>Service#stopSelfResult(int startId)</code> 的效果等同于 <code>Context#stopService(Intent)</code>。</li>\n<li>仅被 Start 启动而没有被任何 Client Bind 的后台 Service，将在 App 进入后台 1 分钟后被 Kill。</li>\n</ul>\n<h3 id=\"2-2-Bind方式启动Service\"><a href=\"#2-2-Bind方式启动Service\" class=\"headerlink\" title=\"2.2 Bind方式启动Service\"></a>2.2 Bind方式启动Service</h3><p>如果通过 bind 方式绑定 Service，在 Service 中返回 IBinder 类的实例，则 Client 就能通过 Binder 的方式与 Service 通信。</p>\n<blockquote>\n<p>虽然默认情况下 Service 运行在主进程的主线程当中，但 Service 本身是支持跨进程的，所以 Android 选择了 Binder 作为通信方式。</p>\n</blockquote>\n<h3 id=\"2-3-Service生命周期\"><a href=\"#2-3-Service生命周期\" class=\"headerlink\" title=\"2.3 Service生命周期\"></a>2.3 Service生命周期</h3><p>Service 中常见的生命周期回调如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 只有当 Service 第一次被启动的时候才回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 生命周期中，不论如何 onCreate() 都只会回调一次。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被调用 Start 时回调。</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 运行过程中，被多次 Start 时会多次回调。</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> intent 正常 Start 启动 Service 时，Intent 即为 Start 时传入的 Intent。</span></span><br><span class=\"line\"><span class=\"comment\">     *               当 Service 被系统杀死后，如果重新启动，则传入的 intent 与该方法的返回值有关。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> flags 该 Service 启动时的参数，通常用于判断该 Service 被 Start 的原因。</span></span><br><span class=\"line\"><span class=\"comment\">     *              - 0: 表示 Service 是正常启动；</span></span><br><span class=\"line\"><span class=\"comment\">     *              - START_FLAG_REDELIVERY: 表示 Service 是由于被系统杀死，并在内存充足后被系统重新启动。</span></span><br><span class=\"line\"><span class=\"comment\">     *                仅当该方法返回值为 START_REDELIVER_INTENT 时生效。</span></span><br><span class=\"line\"><span class=\"comment\">     *              - START_FLAG_RETRY: 表示 Service 是由于该方法没有正常返回，系统重试。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> startId 表明一个启动 ID，通常与 stopSelfResult(int startId) 搭配使用，</span></span><br><span class=\"line\"><span class=\"comment\">                      在 Service 重启或重试后，避免早前的 stopSelfResult() 请求将后来启动的 Service 停止。</span></span><br><span class=\"line\"><span class=\"comment\">     *                例如：onStartCommand(intent, flags, 5) 启动的 Service，将无法被 stopSelfResult(4) 停止。</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 有三种典型取值，代表了 Service 被 Start 后，如果被系统杀死，后续的行为。</span></span><br><span class=\"line\"><span class=\"comment\">     *         - START_STICKY: 表示内存充足后需要重新启动，但传入的 intent == null，除非有 Intent 队列，例如 PendingIntent。</span></span><br><span class=\"line\"><span class=\"comment\">     *         - START_NOT_STICKY: 表示内存充足后也不重新启动。</span></span><br><span class=\"line\"><span class=\"comment\">     *         - START_REDELIVER_INTENT: 表示内存充足后需要重新启动，并且把上一次 Start 时使用的 Intent 再重新传入。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent, flags, startId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被首次 Bind 时回调，被 Start 启动时不会回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 生命周期中，不论如何 onBind() 都只会回调一次。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 在被销毁前，生命周期中只会在第一次被 Client 绑定时回调 onBind()，</span></span><br><span class=\"line\"><span class=\"comment\">     * 之后不论 Client 如何解绑并重新绑定，只要 Service 没有被销毁重启，都不会再次回调 onBind()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被重新 Bind 时回调，仅当 onUnbind() 返回 true 时生效。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 仅当：</span></span><br><span class=\"line\"><span class=\"comment\">     * - Service 从 Bound 的状态下被所有 Client Unbind，</span></span><br><span class=\"line\"><span class=\"comment\">     * - 并且 onUnbind() 返回 true，</span></span><br><span class=\"line\"><span class=\"comment\">     * - 并且 Service 未被销毁（即同时处于 Started 状态），</span></span><br><span class=\"line\"><span class=\"comment\">     * 则下一次被 Bind 时才会回调 onRebind()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onRebind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onRebind(intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 被所有 Client Unbind，或者被最后一个 Context.BIND_AUTO_CREATE 模式的 Client Unbind 后回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要注意：</span></span><br><span class=\"line\"><span class=\"comment\">     * - 如果 Service 被多个 Client Bind，只要所有 Context.BIND_AUTO_CREATE 模式的 Client Unbind 就会回调 onUnbind()，</span></span><br><span class=\"line\"><span class=\"comment\">     *   此时其他模式的 Client 就会收到 ServiceConnection#onServiceDisconnected() 回调。</span></span><br><span class=\"line\"><span class=\"comment\">     * - 否则当所有 Client Unbind 后才会触发该回调，且都不会收到 ServiceConnection#onServiceDisconnected() 回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 当首次从 Bound 状态下被所有以 Context.BIND_AUTO_CREATE 模式 Bind 的 Client Unbind 时会回调，</span></span><br><span class=\"line\"><span class=\"comment\">     * 之后被重新 Bind 和 Unbind，是否回调依赖上一次 onUnbind() 的返回值：</span></span><br><span class=\"line\"><span class=\"comment\">     * - 如果上一次返回 false，则下一次被 Client Bind 时不会回调 onRebind()，且被所有 Client Unbind 后也不会回调 onUnbind()。</span></span><br><span class=\"line\"><span class=\"comment\">     * - 如果上一次返回 true，则下一次被 Client Bind 时会回调 onRebind()，且被所有 Clinet Unbind 后会也回调 onUnbind()。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onUnbind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onUnbind(intent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 真正被销毁时回调。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 生命周期中，不论如何 onDestroy() 都只会回调一次。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时处于 <code>Started</code> 和 <code>Bound</code> 状态下的 Service，在被 Stop 并且 <code>onUnbind()</code> 后才会销毁。需要注意的是，Service 的 <code>onUnbind()</code> 有两种触发方式，只要满足其中任意一条就会触发 <code>onUnbind()</code> 回调：</p>\n<ul>\n<li><p>所有 <code>Context.BIND_AUTO_CREATE</code> 模式 Bind 的 Client 均已 Unbind。</p>\n<p>此时其他模式 Bind 的 Client 会收到 <code>ServiceConnection#onServiceDisconnected()</code> 回调，视为其他 Client 异常断开。</p>\n</li>\n<li><p>所有 Client 都不是 <code>Context.BIND_AUTO_CREATE</code> 模式，且都已 Unbind。</p>\n<p>此时所有 Client 都不会收到 <code>ServiceConnection#onServiceDisconnected()</code> 回调，视为正常断开。</p>\n</li>\n</ul>\n<p>一个 Service 不论是否已经启动，都可以被多次 Start、Stop 和 Bind，Start 和 Stop 的次数不必须匹配，但 Unbind 的次数必须匹配 Bind 的次数，如果 Client 与 Service 不存在绑定关系，则调用 Unbind 会抛出异常。</p>\n<hr>\n<h2 id=\"3-Client与Service通信\"><a href=\"#3-Client与Service通信\" class=\"headerlink\" title=\"3. Client与Service通信\"></a>3. Client与Service通信</h2><p>如果 Client 需要与 Service 通信，则必须通过 <code>bind</code> 方式与目标 Service 绑定连接。</p>\n<h3 id=\"3-1-通过Binder持有Service\"><a href=\"#3-1-通过Binder持有Service\" class=\"headerlink\" title=\"3.1 通过Binder持有Service\"></a>3.1 通过Binder持有Service</h3><p>Client 直接持有 Service 实例对象通信，原理是：</p>\n<ul>\n<li>利用 Binder 跨进程通信的方式，直接在 Client 中拿到 Service 的 Binder 对象。</li>\n<li>然后从 ServiceBinder 中获取 Service 实例对象，相当于把 Service 的实例对象跨进程传到了 Client 进程中。</li>\n<li>Client 持有了 Service 实例对象，即可直接操作 Service。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接操作 Binder 对象的方式。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoBinder</span> <span class=\"keyword\">extends</span> <span class=\"title\">Binder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过 Binder 返回 Service 实例，使得外部可以持有该 Service 对象并与之通信</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> DemoService <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> DemoService.<span class=\"keyword\">this</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DemoBinder(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 可以由外部调用的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        bindService(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, DemoService.class), <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">                DemoBinder demoBinder = (DemoBinder) service;</span><br><span class=\"line\">                <span class=\"comment\">// 持有 DemoService 的实例对象，并调用 Service 的公有方法。</span></span><br><span class=\"line\">                demoBinder.getService().work(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123; <span class=\"comment\">/* 仅当异常 Unbind 时才回调 */</span> &#125;</span><br><span class=\"line\">        &#125;, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-通过Messenger发送消息\"><a href=\"#3-2-通过Messenger发送消息\" class=\"headerlink\" title=\"3.2 通过Messenger发送消息\"></a>3.2 通过Messenger发送消息</h3><p>Client 和 Service 通过互相持有对方的 Messenger 通信，原理是：</p>\n<ul>\n<li>Client 和 Service 各自通过 Handler 构造各自的 Messenger，则各自的 Messenger 都可以通过 Handler 接收消息。</li>\n<li>Service 在 <code>onBind()</code> 中返回 <code>serviceMessenger.getBinder()</code>，相当于返回 Service 进程的 Binder。</li>\n<li>然后 Client 在成功连接 Service 后，通过 Service 返回的 Binder 构造并持有 Service 的 Messenger，也就相当于能向 Service 的 Handler 发送消息。</li>\n<li>此时 Service 还不能向 Client 发送消息，所以 Client 需要首先向 Service 发送一条消息，在消息中指定 <code>replyTo</code> 为 Client 自己的 messenger。</li>\n<li>则 Service 收到这条消息后，就能通过消息的 <code>replyTo</code> 取出并持有 Client 的 Messenger，也就相当于能向 Client 的 Handler 发送消息。</li>\n<li>此时 Client 和 Service 都互相持有了对方的 Messenger，就可以互相发送消息。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过 Messenger 发送消息。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Service</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MSG_ON_BIND = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Service 自己的 Handler，用于处理来自 Client 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handler serviceHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> MSG_ON_BIND: &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过接收 Client 发送过来的消息，从消息中获取 Client 的 Messenger。</span></span><br><span class=\"line\">                    clientMessenger = msg.replyTo;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Client 的 Messenger，用于向 Client 发送消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger clientMessenger;</span><br><span class=\"line\">    <span class=\"comment\">// Service 自己的 Messenger，用于接收来自 Client 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Messenger serviceMessenger = <span class=\"keyword\">new</span> Messenger(serviceHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">onBind</span><span class=\"params\">(Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回 Service 的 Messenger，持有方就能向 Service 发送消息。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> serviceMessenger.getBinder();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Service 通过 Client 的 Messenger 向 Client 发送消息通信。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendToClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (clientMessenger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            clientMessenger.send(Message.obtain());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Client 自己的 Handler，用于处理来自 Service 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handler clientHandler = <span class=\"keyword\">new</span> Handler(Looper.getMainLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理来自 Service 发送的消息</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Client 自己的 Messenger，用于接收来自 Service 的消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Messenger clientMessenger = <span class=\"keyword\">new</span> Messenger(clientHandler);</span><br><span class=\"line\">    <span class=\"comment\">// Service 的 Messenger，用于向 Service 发送消息。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Messenger serviceMessenger;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        bindService(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, DemoService.class), <span class=\"keyword\">new</span> ServiceConnection() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceConnected</span><span class=\"params\">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 通过 Service 的 Binder 来构造 Service 的 Messenger。</span></span><br><span class=\"line\">                serviceMessenger = <span class=\"keyword\">new</span> Messenger(service);</span><br><span class=\"line\">                <span class=\"comment\">// 先向 Service 发送一条消息，通过 Msg.replyTo 把 Client 自己的 Messenger 传过去，</span></span><br><span class=\"line\">                <span class=\"comment\">// 这样 Service 才能拿到 Client 的 Messenger，才能向 Client 发送消息。</span></span><br><span class=\"line\">                Message onBindMsg = Message.obtain();</span><br><span class=\"line\">                onBindMsg.what = DemoService.MSG_ON_BIND;</span><br><span class=\"line\">                onBindMsg.replyTo = clientMessenger;</span><br><span class=\"line\">                serviceMessenger.send(onBindMsg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onServiceDisconnected</span><span class=\"params\">(ComponentName name)</span> </span>&#123; <span class=\"comment\">/* 仅当异常 Unbind 时才回调 */</span> &#125;</span><br><span class=\"line\">        &#125;, Context.BIND_AUTO_CREATE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Client 通过 Service 的 Messenger 向 Service 发送消息通信。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendOnBindToService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (serviceMessenger != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            serviceMessenger.send(Message.obtain());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-其他方式\"><a href=\"#3-3-其他方式\" class=\"headerlink\" title=\"3.3 其他方式\"></a>3.3 其他方式</h3><p>除了使用 Binder 方式以外，Activity 与 Service 之间的通信还能通过 BroadCastReceiver 以及 EventBus 的方式实现。</p>\n<hr>\n<h2 id=\"4-高版本Service的限制\"><a href=\"#4-高版本Service的限制\" class=\"headerlink\" title=\"4. 高版本Service的限制\"></a>4. 高版本Service的限制</h2><p>从 API 21 (Android 5.0) 开始，Google 全面禁止了隐式启动 Service，仅允许显式启动 Service，不论目标 Service 是否处于同一个 App 内，都需要指定目标 Service 所在 App 的包名以及该 Service 的全路径。隐式启动 Service 将会抛出异常，该限制主要是为了避免 App 恶意唤起后台服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Service Intent must be explicit</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>隐式启动 Service 是指仅通过 ActionName 启动 Service，即使可能存在多个 Service 的 ActionName 重复。API 21 之后，必须使用显式启动，否则会抛出异常，</p>\n</blockquote>\n<p>从 API 26 (Android 8) 开始，Google 针对资源控制限制了后台服务，处于后台的 App 将不允许后台 Service 再直接通过 <code>startService()</code> 方式启动另一个后台 Service。此前 Service 需要启动后再调用 <code>Service#startForeground()</code> 才能将 Service 设为前台服务，而不论通过 Start 还是 Bind 启动的 Service 默认都作为后台服务，因此 API 26 提供了一个新的 Api <code>startForgroundService()</code> 来直接启动一个默认前台服务。</p>\n<ul>\n<li>由于指定了启动的是前台服务，因此其会在内部调用 <code>ActiveServices.setServiceForegroundInnerLocked()</code> Post 了一个延时消息，必须在 10s 内调用 <code>Service#startForeground()</code>，其内部 Remove 了该延时消息，否则该延时消息就会抛出 ANR。</li>\n<li>并且如果 <code>Service#startForeground(int id, Notification notification)</code> 中 <code>id == 0</code> 或 <code>notification == null</code> 都会抛出 <code>Null Notification</code> 异常，因此启动前台服务一定会创建一个通知提醒用户。</li>\n</ul>\n<p>后台 Service 不能直接 Start 另一个后台 Service，这条规则受到 App 前后台策略的影响：</p>\n<ul>\n<li>处于前台的 App 可以自由启动前台或后台 Service。</li>\n<li>进入后台的 App 在一段时间窗内（数分钟）仍然可以自由启动创建前台或后台 Service，在时间窗结束后系统将会停止 App 的后台 Service。</li>\n</ul>\n<p>但 Android 对 App 是否前台的判断，并非是简单地判断是否存在前台 Activity。Google 文档中指出，一个 App 如果满足以下几点，则被视为处于前台：</p>\n<ul>\n<li>具有可见 Activity</li>\n<li>具有前台 Service</li>\n<li>被另一个前台 App 关联（被另一个前台应用 Bind Service 或使用了 ContentProvider），例如：<ul>\n<li>IME</li>\n<li>壁纸 Service</li>\n<li>通知监听</li>\n<li>语音或文本服务</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1-Service保活\"><a href=\"#4-1-Service保活\" class=\"headerlink\" title=\"4.1 Service保活\"></a>4.1 Service保活</h3><p>随着高版本 Android 对后台策略逐步收紧，理论上已经没有 100% 保活的方式，API 26 以上 Service 保活的思路主要就是两个 Service 互相启动并绑定；</p>\n<ul>\n<li>AService：<ul>\n<li>首先由某个前台 Activity Start 一个 AService。</li>\n<li>AService 的 <code>onStartCommand()</code> 返回 <code>START_STICKY</code>。</li>\n<li>AService Start 和 Bind BService。</li>\n<li>AService 在 <code>onDestroy()</code> 中再次 Start 和 Bind BService。</li>\n</ul>\n</li>\n<li>BService：<ul>\n<li>BService 的 <code>onStartCommand()</code> 同样返回 <code>START_STICKY</code>。</li>\n<li>BService 被启动后，Start 和 Bind AService。</li>\n<li>BService 在 <code>onDestroy()</code> 中再次 Start 和 Bind AService。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>AService 和 BService 都需要在 <code>onStartCommand()</code> 中返回 <code>START_STICKY</code>，这样其中一个 Service 由于内存被系统杀死后，仍有机会被重启并继续拉活对方。</p>\n<p>由于后台 Service 如果仅被 Start 而没有被 Bind，会在 App 置入后台 1 分钟后被 Kill，所以 Service 互相拉活时，需要同时 Start 和 Bind 对方。</p>\n<p>由于高版本禁止从后台启动任何后台服务，所以在 AService 和 BService 互相 Start 时需要判断版本，API 26 以上需要 <code>startForegroundService()</code>。</p>\n</blockquote>\n<h3 id=\"4-2-几乎不可见的Activity\"><a href=\"#4-2-几乎不可见的Activity\" class=\"headerlink\" title=\"4.2 几乎不可见的Activity\"></a>4.2 几乎不可见的Activity</h3><p>主要思路是在 <code>Activity#onCreate()</code> 中将 Activity 设置为只有一个像素大小的透明的背景。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    Window activityWindow = getWindow();</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 不可点击：</span></span><br><span class=\"line\">    activityWindow.addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 不关心外界触摸事件：</span></span><br><span class=\"line\">    activityWindow.addFlags(WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH);</span><br><span class=\"line\">    <span class=\"comment\">// 设置 DecorView 为全屏状态</span></span><br><span class=\"line\">    View decorView = activityWindow.getDecorView();</span><br><span class=\"line\">    decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);</span><br><span class=\"line\">    <span class=\"comment\">// 设置状态栏透明不可见：</span></span><br><span class=\"line\">    activityWindow.setStatusBarColor(Color.TRANSPARENT);</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 位于左上角：</span></span><br><span class=\"line\">    activityWindow.setGravity(Gravity.START | Gravity.TOP);</span><br><span class=\"line\">    WindowManager.LayoutParams params = activityWindow.getAttributes();</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 相对 Gravity 横纵坐标偏移均为 0：</span></span><br><span class=\"line\">    params.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    params.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置 Window 的宽和高均为 1 像素：</span></span><br><span class=\"line\">    params.height = <span class=\"number\">1</span>;</span><br><span class=\"line\">    params.width = <span class=\"number\">1</span>;</span><br><span class=\"line\">    activityWindow.setAttributes(params);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Android"],"tags":["Android","四大组件","Service","前台服务","后台服务"]},{"title":"Android-SharedPreference","url":"/post/android/android-sharedpreference/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-SharedPreference\"><a href=\"#Android-SharedPreference\" class=\"headerlink\" title=\"Android-SharedPreference\"></a>Android-SharedPreference</h1><p>Android 中获取 SharedPreferences 的方式有 3 种：</p>\n<p>（1）Context 中的 <code>getSharedPreferences(String name, int mode)</code></p>\n<p>name 用于指定 SharedPreference 的文件名，如果不存在则创建。mode 用于指定操作模式，有以下几种选择：</p>\n<ul>\n<li>Context.MODE_PRIVATE：只能被本应用程序读、写。</li>\n<li>Context.MODE_WORLD_READABLE：能被其他应用程序读，但不能写（Android 4.2 已弃用）。</li>\n<li>Context.MODE_WORLD_WRITEABLE：能被其他应用程序读、写（Android 4.2 已弃用）。</li>\n<li>Context.MODE_APPEND：检查文件是否存在，存在则追加内容，否则创建新文件。</li>\n</ul>\n<p>（2）Activity 中的 <code>getPreferences(int mode)</code><br>与 <code>getSharedPreferences()</code> 类似，但自动将当前活动的类名作为 SharedPreferences 的文件名。</p>\n<p>（3）PreferenceManager 中的 <code>getDefaultSharedPreferences(Context context)</code><br> 这是一个静态方法，自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。</p>\n<hr>\n<h2 id=\"待整理\"><a href=\"#待整理\" class=\"headerlink\" title=\"待整理\"></a>待整理</h2><p>SP的本质是HashMap，存储的是键值对数据，在本地存储中以xml文件的形式保存。</p>\n<p>SP本身是线程安全的，读写都用synchronized锁住了，但由于每次修改都会生成一个EditorImpl对象，因此最好是批量处理，最后统一提交。</p>\n<p>提交时有两种方案，commit在UI线程，apply在子线程，使用commit如果耗时太长超过5s，会导致ANR，使用commit，如果提交时关闭Activity，会检查一个工作任务队列sPendingWorkFinishers中的任务是否全部完成，如果有未完成的任务，就会一直等待，所以如果commit太大量的数据导致Activity结束时等待超过5s，一样会导致ANR。</p>\n<p>由于读取本地文件的性能开销很大，所以SP读取数据后，会一直保存在内存，因此如果存放了过大的数据，会导致频繁GC甚至OOM。</p>\n<p>如果SP数据较多，频繁读取的数据和非频繁读取的数据最好分成不同的SP文件。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/f409031mn/article/details/89614024\" title=\"@LINK\">SharedPreferences的分析与实践</a></li>\n<li><a href=\"https://www.jianshu.com/p/4022b36ad7b2\" title=\"@LINK\">MMKV（一）了解原理</a></li>\n<li><a href=\"https://blog.csdn.net/mymolit/article/details/82854674\" title=\"@LINK\">MMKV整理学习</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1354199\" title=\"@LINK\">MMKV for Android 多进程设计与实现</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","五大存储","SharedPreference"]},{"title":"Android-触摸事件","url":"/post/android/android-touch_event/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-触摸事件\"><a href=\"#Android-触摸事件\" class=\"headerlink\" title=\"Android-触摸事件\"></a>Android-触摸事件</h1><h2 id=\"1-读取触摸事件\"><a href=\"#1-读取触摸事件\" class=\"headerlink\" title=\"1. 读取触摸事件\"></a>1. 读取触摸事件</h2><p>Android 触摸事件属于输入事件的一种，因此也是通过输入事件读取的。</p>\n<p>SystemService 进程启动后，在 <code>startOtherServices()</code> 中几乎同时启动了 InputManagerService 和 WindowManagerService：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">startOtherServices</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    inputManager = <span class=\"keyword\">new</span> InputManagerService(context);</span><br><span class=\"line\">    <span class=\"comment\">// WMS 持有了 IMS：</span></span><br><span class=\"line\">    wm = WindowManagerService.main(context, inputManager,</span><br><span class=\"line\">            mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class=\"line\">            !mFirstBoot, mOnlyCore);</span><br><span class=\"line\">    ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class=\"line\">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h2 id=\"2-分发触摸事件\"><a href=\"#2-分发触摸事件\" class=\"headerlink\" title=\"2. 分发触摸事件\"></a>2. 分发触摸事件</h2><p>触摸事件机制主要分为两个步骤：事件读取、事件分发；其中事件分发又可以按照「从 IMS 分发到 Window」和「从 Window 分发到 View」两个流程。</p>\n<h3 id=\"2-1-IMS分发至Window\"><a href=\"#2-1-IMS分发至Window\" class=\"headerlink\" title=\"2.1 IMS分发至Window\"></a>2.1 IMS分发至Window</h3><h3 id=\"2-2-Window分发至View\"><a href=\"#2-2-Window分发至View\" class=\"headerlink\" title=\"2.2 Window分发至View\"></a>2.2 Window分发至View</h3><p>IMS 在启动后会创建两个线程，一个负责不断读取、一个负责不断分发：</p>\n<ul>\n<li>读取线程 InputReaderThread 通过基于 Linux 内核 inotify 和 epoll 机制的 EventHub 监听设备的插拔、触摸、按钮等事件，主要面向的是 <code>dev/input/</code> 下的设备节点，例如 <code>dev/input/event0</code> 对应的就是输入事件，EventHub 调用 <code>getEvents()</code> 获取各种输入事件，然后调用 <code>processEventLocked()</code> 将输入事件封装成 RawEvent，然后向分发线程发送一条 Message。</li>\n<li>分发线程 InputDispatcher 是典型的 Looper 线程，基于 Native 的 Handler 机制阻塞等待事件，当 InputReaderThread 调用 InputDispatcher 对象的 <code>mQueuedListener.flush()</code> 后，InputDispatcher 就调用 <code>dispatchOnceInnerLocked()</code> 进行事件分发。</li>\n</ul>\n<p>每当添加一个 Window 时都会调用 <code>WindowManagerImpl#addView(...)</code>，会计算窗口的大小以及 Z-Order (type) 属性，最终通过 WMS 记录到 SurfaceFlinger 中，SF 中 WindowList 记录了所有 Window 的信息，包括 Window 的显示范围、颜色格式、对应的实例等，因此当 InputDispatcher 分发事件时，首先调用 <code>findTouchedWindowTargetsLocked()</code> 请求 SF 查找对应的 Window，SF 遍历 WindowList 判断 Window 的范围、Z-Order 等找到目标 Window，然后通过 Socket 把对应的输入事件发送到应用进程的目标 Window 的 ViewRootImpl，ViewRootImpl 在 <code>setView(...)</code> 中调用 <code>mWindowSession.addToDisplay(...)</code> 创建了一个 Socket 连接并开启了 Input 通道 <code>mInputChannel</code>，然后把这个 Socket 添加到 Native 层 Looper 的 epoll 数组中，这样只要收到 IMS 发来的事件就会唤醒 Native Looper，然后在封装成 Java 层对象 InputEvent，然后回调到 Java 层 ViewRootImpl 内部类 <code>ViewPostImeInputStage#processPointerEvent(QueuedInputEvent)</code>，ViewRootImpl 调用 DecorView 重写的 <code>dispatchTouchEvent(...)</code> 方法，DecorView 优先将 TouchEvent 回调给注册的 WindowCallback，PhoneWindow 和 Activity 都注册了 WindowCallback，因此 TouchEvent 会优先派发给 PhoneWindow 和 Activity，如果它们不处理，则会调用 <code>mDecor.superDispatchTouchEvent(event);</code> 把触摸事件再回调到 DecorView，然后 DecorView 继续调用 <code>super.dispatchTouchEvent(event);</code> 回到 <code>ViewGroup#dispatchTouchEvent(MotionEvent)</code>，ViewRootImpl 没有重写这个方法，所以就会按照 ViewTree 的层级，再从 DecorView 的 <code>onDispatchEvent()</code> 开始逐层向下分发。</p>\n<p>Android 的触摸事件有两个方向，一个是向下分发（子控件），一个是向上传递（父控件），onInterceptTouchEvent 表示是否拦截向下分发，返回 true 则子控件不会响应触摸事件，返回 false 则子控件的 onInterceptTouchEvent 被调用。onTouchEvent 表示是否处理事件，返回 true 则表示触摸事件在该 View 处理，不再向上传递。通常，ViewGroup 的 onInterceptTouchEvent 返回 false，onTouchEvent 返回 false，子 View 如果不是 ViewGroup，则没有 onInterceptTouchEvent 方法，onTouchEvent 返回 true，需要处理事件的子 View 如果在 ACTION_DOWN 时 onTouchEvent 不返回 true，表示没有消费 ACTION_DOWN，则将无法响应 ACTION_MOVE 和 ACTION_UP。</p>\n<ul>\n<li>ViewRootImpl接受事件吗</li>\n</ul>\n<p>接收。事件的传递顺序：硬件（屏幕）、ViewRootImpl、DecorView、PhoneWindow、Activity。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/f05d6b05ba17\" title=\"@LINK\">十分钟了解Android触摸事件原理（InputManagerService）</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","触摸事件"]},{"title":"Android子线程到底能否更新UI——可能是最全面的解析","url":"/post/android/android-ui_thread/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android子线程到底能否更新UI——可能是最全面的解析\"><a href=\"#Android子线程到底能否更新UI——可能是最全面的解析\" class=\"headerlink\" title=\"Android子线程到底能否更新UI——可能是最全面的解析\"></a>Android子线程到底能否更新UI——可能是最全面的解析</h1><p>前言：Android 开发中有这么一条“潜规则”：「一个 App 的主线程就是 UI 线程，子线程不能更新 UI」。绝大部分情况下，我们在需要处理 UI 逻辑时，都会自觉地放在主线程操作，但是为什么会有这么一条“铁律”，其原因是什么，以及这条“铁律”就一定正确吗？带着这些疑问我在度娘和 StackOverFlow 上搜了一遍，绝大部分分析都止于「子线程更新 UI 会抛出异常的逻辑在哪」，所以我决定自己探索一遍，并写下这篇截止到目前，【可能】是最全面的一篇分析。</p>\n<p>当然，这篇文章不会深入到屏幕渲染、线程调度等等这样的层面，其重点在于从源码的角度论证：「子线程到底能不能更新 UI」，本文默认读者已有初级 Android 基础。</p>\n<hr>\n<h2 id=\"1-子线程更新UI异常\"><a href=\"#1-子线程更新UI异常\" class=\"headerlink\" title=\"1. 子线程更新UI异常\"></a>1. 子线程更新UI异常</h2><p>下面这段代码，是很典型的子线程更新 UI 的操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        tvNewThreadText.setText(<span class=\"string\">&quot;子线程内更新 UI&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码运行会抛出异常：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure>\n\n<p>为什么子线程不能更新 UI 呢？这就需要从 3 个方面解释。</p>\n<h3 id=\"1-1-设计思想\"><a href=\"#1-1-设计思想\" class=\"headerlink\" title=\"1.1 设计思想\"></a>1.1 设计思想</h3><p>首先不得不提到，子线程更新 UI 会抛出异常肯定是 Android 有意为之，但 Android 为什么要这么设计呢？</p>\n<p>这是因为，人眼感到【流畅】需要满足帧率大于等于 60 Fps，对应的也就是约等于 16 毫秒一帧，Android 为了让交互和显示足够流畅，就需要尽可能保证这个帧率，尤其在现在高刷屏普及的时代，就需要尽可能缩短每一帧的渲染时间。因为频繁的加锁和锁释放会带来很大的内存开销，很可能会延长每一帧的渲染时间，因此对于 UI 更新的操作，是没有加锁的。但如果不加锁，在出现并发问题时，系统如何确保下一帧画面到底应该渲染成什么样呢？</p>\n<p>所以，Android 系统为了避免这个问题，就从源码层限制了其他线程更新 UI，以兼顾 UI 更新的效率和并发安全性。</p>\n<h3 id=\"1-2-异常原因\"><a href=\"#1-2-异常原因\" class=\"headerlink\" title=\"1.2 异常原因\"></a>1.2 异常原因</h3><p>解释完设计思想，就要老生常谈分析一下抛出异常的直接原因了。</p>\n<p>首先有一个基础：View 在更新时，是将自己测量并绘制，但这个绘制并不是一旦 View 完成初始化、或者调用更新时就马上绘制，而是发起一个屏幕同步 Sync 请求，等待下一次屏幕刷新时，再绘制到屏幕上。</p>\n<p>而这个 View 发起绘制请求的命令，就是 UI 更新都离不开的：<code>requestLayout()</code>。</p>\n<p>就以 <code>TextView.setText(...)</code> 为例，顺着 <code>setText(...)</code> 的源码一路点进去，直到下面这个方法（省略其他代码）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForRelayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 关键就是这个 requestLayout()：</span></span><br><span class=\"line\">        requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再点进 requestLayout() 源码：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 每个 View 都逐级调用上层父 View 的 requestLayout，最上层的父 View 就是 ViewRootImpl</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class=\"line\">            mParent.requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，每个 View 都会一层层请求自己的父布局调用 <code>requestLayout()</code>，而最最上层的父布局，就是一个 ViewRootImpl，它也实现了 <code>ViewParent</code> 接口。而在 ViewRootImpl 内，<code>requestLayout()</code> 的实现是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"comment\">// 注意这个方法是关键</span></span><br><span class=\"line\">            checkThread();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 看看源码</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">checkThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 就是在这里判断了线程</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CalledFromWrongThreadException(</span><br><span class=\"line\">                    <span class=\"string\">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这一步就清晰明了了，因为 <code>Thread.currentThread()</code> 是子线程，而 <code>mThread</code> 是主线程，所以在这里抛出了异常。</p>\n<p>【但是！】这个判断有个很大的问题，因为它的判断是 <code>mThread != Thread.currentThread()</code>，而 <code>mThread</code> 是在这个 ViewRootImpl 的构造方法里面存入的，因此这个判断本质上比较的是：当前线程与「ViewRootImpl 初始化时的线程」是否相同，而不是当前线程与「主线程」是否相同，并且这里抛出的异常说明也是「the original thread」而不是「the main thread」，所以我们常说的「子线程不能更新 UI」，实际上是：</p>\n<p>一个线程初始化了 ViewRootImpl 后，其 UI 不能被其他线程更新！而这两个线程，和是不是主线程并没有关系！</p>\n<hr>\n<h2 id=\"2-Activity视图加载流程\"><a href=\"#2-Activity视图加载流程\" class=\"headerlink\" title=\"2. Activity视图加载流程\"></a>2. Activity视图加载流程</h2><p>现在知道了线程能否更新 UI 主要看这个 UI 所处的最上层 ViewRootImpl 是否由同一个线程初始化，那么 ViewRootImpl 是怎么初始化的呢？又是在什么时候初始化的呢？</p>\n<p>既然 ViewRootImpl 是最上层布局，那不妨从 Activity 启动加载开始：<a href=\"/post/android/android-activity\" title=\"@LINK\">Android-Activity深入理解</a>。</p>\n<hr>\n<h2 id=\"3-ViewRootImpl线程的定义\"><a href=\"#3-ViewRootImpl线程的定义\" class=\"headerlink\" title=\"3. ViewRootImpl线程的定义\"></a>3. ViewRootImpl线程的定义</h2><p>通过 <a href=\"/post/android/android-activity\" title=\"@LINK\">Android-Activity深入理解</a>，可以知道：</p>\n<ul>\n<li>ViewRootImpl 判断线程时依据的 <code>mThread</code> 就是创建并初始化 ViewRootImpl 时的所在线程。</li>\n<li><code>setContentView(...)</code> 之后 Activity 视图的加载流程，主要包括对 DecorView、subDecor、以及 mContentParent 的加载和持有逻辑。</li>\n</ul>\n<p>但是！结合上面这两条来看，就会发现两个结论：</p>\n<ul>\n<li>在 <code>setContentView(...)</code> 中，虽然也有判断 Window、DecorView、subDecor 等是否创建以及立即创建的逻辑，但并没有对 ViewRootImpl 的操作逻辑！！！也就是说，调用 <code>setContentView(...)</code> 时所处的线程并不能决定 ViewRootImpl 的初始线程，也就无法决定哪个线程可以更新 UI！</li>\n<li>从 Activity 的加载流程 2.2.1 部分来看，决定 ViewRootImpl 初始线程的，似乎只有 <code>handleResumeActivity(...)</code>，而不论 startActivity 是否在子线程中调用，一个 Activity 都是通过 AMS 管理的，<code>handleResumeActivity(...)</code> 的调用都会发生在 ActivityThread 中，ActivityThread 又处在主线程中。</li>\n</ul>\n<p><strong>这两个结论说明：不论 startActivity 是否在子线程中调用，也不论一个 Activity 的 <code>setContentView(...)</code> 是否在子线程中调用，都无法影响到 Activity 是在 ActivityThread 这个主线程中加载的，所以尽管 ViewRootImpl 比较的线程是【初始线程】与当前线程，但在 Activity 常规加载流程中，ViewRootImpl 总是在主线程初始化的，所以在大部分情况下，子线程的确无法更新 UI。</strong></p>\n<hr>\n<h2 id=\"4-子线程绝对不能更新UI吗？\"><a href=\"#4-子线程绝对不能更新UI吗？\" class=\"headerlink\" title=\"4. 子线程绝对不能更新UI吗？\"></a>4. 子线程绝对不能更新UI吗？</h2><p>在上面第 3 部分，我做了一个结论，表明「大部分情况下，子线程的确无法更新 UI」，但请注意原画中的「常规加载流程」，以及「大部分情况下」这两个关键词。</p>\n<p>先写结论：<strong>实际上，子线程可以更新 UI。</strong></p>\n<p>在这里我又再一次推倒了前面的结论，因为我们已经知道，只要能让 ViewRootImpl 在子线程中初始化，就能在该子线程中更新 UI。虽然通常初始化 ViewRootImpl 的动作会被 ActivityThread 自动完成，但实际上仍有方法手动创建。</p>\n<h3 id=\"4-1-手动触发ViewRootImpl的初始化\"><a href=\"#4-1-手动触发ViewRootImpl的初始化\" class=\"headerlink\" title=\"4.1 手动触发ViewRootImpl的初始化\"></a>4.1 手动触发ViewRootImpl的初始化</h3><p>从前文可以知道，ViewRootImpl 的初始化发生在 <code>ActivityThread.handleResumeActivity(...)</code> 中，并且发生在初始化 Window 和 DecorView 之后调用 <code>mWindow.addView(DecorView, LayoutParams)</code> 时。那就可以想个办法，在 onCreate 阶段就手动初始化 PhoneWindow，手动触发 <code>mWindow.addView(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\"></span><br><span class=\"line\">    HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">    newThread.start();</span><br><span class=\"line\">    Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">            tvNewThreadText = <span class=\"keyword\">new</span> TextView(DemoActivity.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            WindowManager.LayoutParams windowLP = <span class=\"keyword\">new</span> WindowManager.LayoutParams(</span><br><span class=\"line\">                    <span class=\"number\">200</span>,  <span class=\"comment\">// width</span></span><br><span class=\"line\">                    <span class=\"number\">50</span>,   <span class=\"comment\">// height</span></span><br><span class=\"line\">                    <span class=\"number\">100</span>,  <span class=\"comment\">// x position</span></span><br><span class=\"line\">                    <span class=\"number\">100</span>,  <span class=\"comment\">// y position</span></span><br><span class=\"line\">                    WindowManager.LayoutParams.FIRST_SUB_WINDOW,  <span class=\"comment\">// type</span></span><br><span class=\"line\">                    WindowManager.LayoutParams.TYPE_TOAST,        <span class=\"comment\">// flag</span></span><br><span class=\"line\">                    PixelFormat.OPAQUE                            <span class=\"comment\">// format</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">            WindowManager windowManager = MainActivity.<span class=\"keyword\">this</span>.getWindowManager();</span><br><span class=\"line\">            <span class=\"comment\">// 实际上就是把这个 TextView 作为 DecorView 传递给 WindowManager 加载</span></span><br><span class=\"line\">            windowManager.addView(tvNewThreadText, windowLP);</span><br><span class=\"line\">            tvNewThreadText.setText(<span class=\"string\">&quot;子线程内更新 UI&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实践证明：通过手动初始化 Window 并添加 View，的确可以在子线程中更新 UI，且该方法适用于所有 View。</p>\n<h3 id=\"4-2-避开ViewRootImpl的检查\"><a href=\"#4-2-避开ViewRootImpl的检查\" class=\"headerlink\" title=\"4.2 避开ViewRootImpl的检查\"></a>4.2 避开ViewRootImpl的检查</h3><p>从文章最开始对 <code>TextView#setText(...)</code> 的源码分析可知，子线程中更新 UI 会抛出异常在于更新 UI 时，View 会逐级向上层父 View 调用 <code>requestLayout()</code>，直到最上层的 <code>ViewRootImpl#requestLayout()</code> 判断了线程。但在后面 Activity 加载流程的分析中又发现，ViewRootImpl 是在 <code>handleResumeActivity()</code> 时初始化的，也就是说，在 Activity 处于 onCreate 生命周期时，ViewRootImpl 根本都还没有初始化，此时如果 TextView 更新 UI，则在逐级向上层调用父 View 的 <code>requestLayout()</code> 时，到了 ViewRootImpl 就会因为 <code>mParent == null</code> 而跳过了。</p>\n<p>Show me the code:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">    setContentView(R.layout.activity_demo);</span><br><span class=\"line\"></span><br><span class=\"line\">    tvNewThreadTitle = findViewById(R.id.tvNewThreadTitle);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            tvNewThreadTitle.setText(<span class=\"string\">&quot;子线程修改后的 Text&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实践证明：通过避开 ViewRootImpl 的检查，的确也可以在子线程中更新 UI，且该方法适用于所有 View。</p>\n<h3 id=\"4-3-针对TextView避开重绘\"><a href=\"#4-3-针对TextView避开重绘\" class=\"headerlink\" title=\"4.3 针对TextView避开重绘\"></a>4.3 针对TextView避开重绘</h3><p>4.1 和 4.2 中的两个方法，是对所有 View 更新 UI 都适用的，但对于 TextView，还有一种方式，就是避开重绘。</p>\n<p>首先看下这样一个布局（省略部分）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;TextView</span><br><span class=\"line\">    <span class=\"attr\">android</span>:id=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_width=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:layout_height=<span class=\"string\">&quot;wrap_content&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">android</span>:text=<span class=\"string\">&quot;初始 TextView&quot;</span></span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/btUpdate&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;100dp&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;在子线程更新 UI&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>通过 Activity 加载（省略部分）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();</span><br><span class=\"line\"></span><br><span class=\"line\">    btUpdate.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    tvNewThreadTitle.setText(<span class=\"string\">&quot;修改后的 Text&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>点击 Button 时，会开启一个子线程并在子线程中更新 TextView。</p>\n<p>毫无疑问这段代码 Crash 了，原因和文首说明的一样，因为 ViewRootImpl 在主线程中初始化，因此子线程无法更新 UI。</p>\n<p>但！如果把布局中 TextView 的宽度改为精确值或 <code>match_parent</code>，Activity 中的代码不变：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--布局中把 TextView 的宽度改为精确值或 match_parent--&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;200dp&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;初始 TextView&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">......</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Activity 中的代码逻辑不变，仍然是在点击时开启子线程并在子线程中更新 TextView</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onResume();</span><br><span class=\"line\"></span><br><span class=\"line\">    btUpdate.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    tvNewThreadTitle.setText(<span class=\"string\">&quot;修改后的 Text&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次运行发现居然没有 Crash，子线程成功更新了 UI！这难道又要再次推翻之前的结论吗？</p>\n<p>再重新翻一下 <code>TextView#setText(...)</code> 的源码，这一次仔细看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步可以理解成，把传进来的 text 存入到 TextView 的成员变量中</span></span><br><span class=\"line\">        setTextInternal(text);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForRelayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// If we have a fixed width, we can just swap in a new text layout</span></span><br><span class=\"line\">        <span class=\"comment\">// if the text height stays the same or if the view height is fixed.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mLayoutParams.width != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">                || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth))</span><br><span class=\"line\">                &amp;&amp; (mHint == <span class=\"keyword\">null</span> || mHintLayout != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Static width, so try making a new text layout.</span></span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// In a fixed-height view, so use our new text layout.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mLayoutParams.height != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">                        &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                    autoSizeText();</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                    <span class=\"comment\">// ----- 重点：return 了 -----</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Dynamic height, but height has stayed the same,</span></span><br><span class=\"line\">                <span class=\"comment\">// so use our new text layout.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mLayout.getHeight() == oldht</span><br><span class=\"line\">                        &amp;&amp; (mHintLayout == <span class=\"keyword\">null</span> || mHintLayout.getHeight() == oldht)) &#123;</span><br><span class=\"line\">                    autoSizeText();</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                    <span class=\"comment\">// ----- 重点：return 了 -----</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// ----- 如果走到这里，就会触发 requestLayout，导致判断 ViewRootImpl 线程 -----</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// We lose: the height has changed and we have a dynamic height.</span></span><br><span class=\"line\">            <span class=\"comment\">// Request a new view layout using our new text layout.</span></span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ----- 如果走到这里，就会触发 requestLayout，导致判断 ViewRootImpl 线程 -----</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Dynamic width, so we have no choice but to request a new</span></span><br><span class=\"line\">            <span class=\"comment\">// view layout with a new text layout.</span></span><br><span class=\"line\">            nullLayouts();</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看源码可以发现，在 <code>checkForRelayout()</code> 之前，先通过 <code>setTextInternal(text);</code> 把 text 存入了成员变量，然后才会调用 <code>checkForRelayout()</code> 检查线程。</p>\n<p>通过上文已经知道，如果调用了 <code>requestLayout()</code>，就会导致 ViewRootImpl 判断线程。而 <code>TextView#checkForRelayout()</code> 中，<code>requestLayout()</code> 之前有两个 <code>return</code> 的机会（已在代码注释中标出），接下来就是看看如何才能触发这两个 <code>return</code>！</p>\n<p>（1）首先是最外层的 <code>if</code> 判断必须要满足的条件，否则 <code>else</code> 中一定会走到 <code>requestLayout</code>。这个最外层的 <code>if</code> 条件是（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    (</span><br><span class=\"line\">        mLayoutParams.width != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">        || (mMaxWidthMode == mMinWidthMode &amp;&amp; mMaxWidth == mMinWidth)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    &amp;&amp; (mHint == <span class=\"keyword\">null</span> || mHintLayout != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &amp;&amp; (mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight() &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>简单来说，这三个条件均满足就表示 TextView 的宽度是固定值且大于 0，也就是宽度是不需要重新测绘的。这也是为什么当 TextView 的宽度设置为 <code>wrap_content</code> 时，子线程更新 TextView 会抛出异常的原因，因为这个最外层的 <code>if</code> 不满足而走到了 <code>else</code> 中。</p>\n<p>（2）接着是第二层的 <code>if</code> 判断也必须要满足条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (mEllipsize != TextUtils.TruncateAt.MARQUEE)</span><br></pre></td></tr></table></figure>\n\n<p>这个判断满足时表示 TextView 不是跑马灯效果的状态。这个很好理解，因为跑马灯效果是需要一直刷新 UI 的。</p>\n<p>（3）然后是第一个可能 <code>return</code> 的条件（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    mLayoutParams.height != LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">    &amp;&amp; mLayoutParams.height != LayoutParams.MATCH_PARENT</span><br><span class=\"line\">) </span><br></pre></td></tr></table></figure>\n\n<p>代码很好懂，如果高度既不是 <code>wrap_content</code> 又不是 <code>match_parent</code>，那就只能是精确高度了，这也就表示高度也不需要重新测绘。</p>\n<p>（4）最后是第二个可能 <code>return</code> 的条件（为了更加直观调整了缩进）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (</span><br><span class=\"line\">    mLayout.getHeight() == oldht</span><br><span class=\"line\">    &amp;&amp; (</span><br><span class=\"line\">        mHintLayout == <span class=\"keyword\">null</span></span><br><span class=\"line\">        || mHintLayout.getHeight() == oldht</span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>代码依然很好懂，如果新的高度和久的高度一致，也表示高度不需要重新测绘。</p>\n<p>综合上述的（1）、（2）、（3）、（4）可以得出结论：如果一个 TextView 的内容被改变了，但是新 TextView 的高度和宽度都不会发生变化，并且也不是跑马灯效果模式，也即 TextView 不需要重新测绘，则不需要调用 requestLayout，也就不会走到 ViewRootImpl 判断线程的地方！</p>\n<p>这里需要注意的是：宽度和高度必须同时都是固定值（精确值或 <code>match_parent</code>）才不会发生重绘。上面测试代码中，TextView 的高度为 <code>wrap_content</code> 却没问题的原因，是更新内容时能在一行内显示完全，因此高度没有发生变化，走进了条件（4）中的 <code>return</code>。如果把 TextView 改成宽度为很小的值、高度为自适应，然后子线程中 set 一个很长的文本，使得 TextView 会因为换行导致高度发生变化，则也是会抛出异常的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!--布局中把 TextView 的宽度设为很小的值，高度为自适应，然后子线程中 set 一个很长的文本使其换行导致高度变化，会抛出异常--&gt;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">TextView</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:id</span>=<span class=\"string\">&quot;@+id/tvNewThreadTitle&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">&quot;10dp&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">&quot;wrap_content&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">android:text</span>=<span class=\"string\">&quot;初始 TextView&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Button</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">......</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>因此 TextView 的 UI 更新方式可以总结为两种：</p>\n<ul>\n<li>如果更新后宽度或高度会发生变化，或者是跑马灯效果模式，则立即逐级向父 View 请求重绘一次，并在绘制时绘制出新的文本。</li>\n<li>否则就把把需要更新的文本存在 TextView 内，等下一次屏幕刷新的时候顺便就绘制成新的文本。</li>\n</ul>\n<p>实践证明：针对 TextView，通过避免重绘，的确可以实现子线程更新 UI，但仅针对 TextView 或类似有跳过重绘逻辑的 View。</p>\n<h3 id=\"4-4-使用SurfaceView-TextureView\"><a href=\"#4-4-使用SurfaceView-TextureView\" class=\"headerlink\" title=\"4.4 使用SurfaceView/TextureView\"></a>4.4 使用SurfaceView/TextureView</h3><p>SurfaceView 算是正儿八经使用子线程更新 UI 的例子了，也是其最大的优点。SurfaceView 的画面渲染主要是通过其持有的一个 <code>Surface</code> 类型的 <code>mSurface</code> 对象实现的，这个 <code>Surface</code> 并不是一个 View 的子类，因此其更新并不收到 View 更新中 <code>checkThread()</code> 的限制。简单来说，SurfaceView 可以在子线程中更新 UI 的原理是因为其渲染的目标并不是一个 View。</p>\n<p>当然，实际上 SurfaceView / TextureView 的原理远不止这么简单，本文主要聚焦于子线程更新 UI 的可行性，所以不对 SurfaceView / TextureView 的原理深入解析，相关解析也在计划中，感兴趣的读者可以关注后续更新。</p>\n<h3 id=\"4-5-特例Toast\"><a href=\"#4-5-特例Toast\" class=\"headerlink\" title=\"4.5 特例Toast\"></a>4.5 特例Toast</h3><p>Toast 作为 Android 系统级别的 UI 组件，甚至与 Activity 生命周期都无关，常见的例子就是如果一个 App 正在弹 Toast 的时候出现 Crash 或者手动杀掉了，Toast 还是能正常显示的。</p>\n<h4 id=\"4-5-1-Toast可以跨线程显示\"><a href=\"#4-5-1-Toast可以跨线程显示\" class=\"headerlink\" title=\"4.5.1 Toast可以跨线程显示\"></a>4.5.1 Toast可以跨线程显示</h4><p>实际上 Toast 的显示除了和 Activity 无关之外，也和线程无关，下面这段代码执行不会抛出异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(NewThreadActivity.<span class=\"keyword\">this</span>, <span class=\"string\">&quot;子线程中的Toast&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>同时抛出一个注意事项：如果需要在子线程中 Toast，则该子线程必须初始化 Looper，因此需要使用 HandlerThread 或者在子线程中手动调用 Looper 的初始化：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接在未初始化 Looper 的子线程中 Toast 会抛出异常</span></span><br><span class=\"line\"><span class=\"comment\">// RuntimeException: Can&#x27;t toast on a thread that has not called Looper.prepare()</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;未初始化Looper的子线程Toast会报错&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以使用 HandlerThread，或者手动初始化 Looper</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepare();</span><br><span class=\"line\">        Toast.makeText(context, <span class=\"string\">&quot;已初始化Looper的子线程可以正确Toast&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p>Toast 本质上也是一种 View，因此是可以通过 <code>toast.setView(View)</code> 来自定义 Toast 样式的，那既然 Toast 是 View，为什么可以在子线程显示呢？老办法，看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(Context context, CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> makeText(context, <span class=\"keyword\">null</span>, text, duration);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Make a standard toast to display using the specified looper.</span></span><br><span class=\"line\"><span class=\"comment\">     * If looper is null, Looper.myLooper() is used.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"meta\">@NonNull</span> CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        Toast result = <span class=\"keyword\">new</span> Toast(context, looper);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs an empty Toast object.  If looper is null, Looper.myLooper() is used.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@hide</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Toast</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper)</span> </span>&#123;</span><br><span class=\"line\">        mContext = context;</span><br><span class=\"line\">        mTN = <span class=\"keyword\">new</span> TN(context.getPackageName(), looper);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TN</span> <span class=\"keyword\">extends</span> <span class=\"title\">ITransientNotification</span>.<span class=\"title\">Stub</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        TN(String packageName, <span class=\"meta\">@Nullable</span> Looper looper) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (looper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Use Looper.myLooper() if looper is not specified.</span></span><br><span class=\"line\">                looper = Looper.myLooper();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (looper == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(</span><br><span class=\"line\">                            <span class=\"string\">&quot;Can&#x27;t toast on a thread that has not called Looper.prepare()&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到：</p>\n<ul>\n<li>默认情况下三参数的 <code>Toast.makeText(...)</code> 会调用四参数的重载方法，并且传入的 looper 参数是 <code>null</code></li>\n<li>四参数的方法中，<code>new</code> 了一个 Toast 实例</li>\n<li>查看对应的 Toast 构造方法发现，又用传入的 looper 作为构造函数参数 <code>new</code> 了一个 <code>TN</code> 类的实例</li>\n<li>再查看 TN 的构造方法发现，如果传入的 looper 为 <code>null</code>，就直接用当前调用线程的 Looper</li>\n</ul>\n<p>简言之，<code>Toast.makeText(...)</code> 是直接使用调用的线程作为显示线程的，这就可以直接验证上文说的 Toast 的两个特性：</p>\n<ul>\n<li>Toast 可以在子线程显示，因为 <code>Toast.makeText(...)</code> 内部在调用时每次都使用当前线程作为显示线程，因此实际上不存在跨线程的问题。</li>\n<li>Toast 要求线程初始化 Looper 否则在 <code>new TN(...)</code> 的时候就会因为拿不到 looper 抛出异常。</li>\n</ul>\n<h4 id=\"4-5-2-Toast不能跨线程更新\"><a href=\"#4-5-2-Toast不能跨线程更新\" class=\"headerlink\" title=\"4.5.2 Toast不能跨线程更新\"></a>4.5.2 Toast不能跨线程更新</h4><p>看到这个小标题别慌，Toast 可以在子线程中显示是毫无疑问的，但是有一种情况下，Toast 也会抛出 <code>CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</code> 异常，就是更新内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Toast generalToast;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在子线程中弹一个 Toast，并把这个 Toast 持久化到成员变量</span></span><br><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        generalToast = Toast.makeText(NewThreadActivity.<span class=\"keyword\">this</span>, <span class=\"string\">&quot;子线程中创建并显示的Toast&quot;</span>, Toast.LENGTH_LONG);</span><br><span class=\"line\">        generalToast.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 确保子线程已经弹了 Toast 之后，也就是 generalToast 已经初始化，再在主线程更新 generalToast 的内容</span></span><br><span class=\"line\">btUpdateInMainThread.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (generalToast != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            generalToast.setText(<span class=\"string\">&quot;在主线程更新子线程创建的Toast的内容&quot;</span>);</span><br><span class=\"line\">            generalToast.show();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>运行发现报错了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br></pre></td></tr></table></figure>\n\n<p>为什么 <code>Toast.makeText(...)</code> 不限制线程，但 <code>toast.setText(...)</code> 又限制线程呢？再仔细看看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Toast</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Toast <span class=\"title\">makeText</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@Nullable</span> Looper looper,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"meta\">@NonNull</span> CharSequence text, <span class=\"meta\">@Duration</span> <span class=\"keyword\">int</span> duration)</span> </span>&#123;</span><br><span class=\"line\">        Toast result = <span class=\"keyword\">new</span> Toast(context, looper);</span><br><span class=\"line\"></span><br><span class=\"line\">        LayoutInflater inflate = (LayoutInflater)</span><br><span class=\"line\">                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class=\"line\">        View v = inflate.inflate(com.android.internal.R.layout.transient_notification, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);</span><br><span class=\"line\">        tv.setText(text);</span><br><span class=\"line\"></span><br><span class=\"line\">        result.mNextView = v;</span><br><span class=\"line\">        result.mDuration = duration;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mNextView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;This Toast was not created with Toast.makeText()&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TextView tv = mNextView.findViewById(com.android.internal.R.id.message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tv == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;This Toast was not created with Toast.makeText()&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tv.setText(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来在 <code>Toast.makeText(...)</code> 时，Toast 会使用当前线程作为该 Toast 的消息处理 Looper，然后使用系统的 Inflater 服务去加载一个 <code>com.android.internal.R.layout.transient_notification</code> 的布局作为 Toast 的根布局，其中具有一个 TextView 元素，使用该 TextView 元素承载需要显示的文字。</p>\n<p>当调用 <code>toast.setText(...)</code>  时，TextView 就会像文首提到的方式，一层层向上通知更新，因此如果线程与 toast 在初始化时的线程不一致，自然会抛出异常。</p>\n<h3 id=\"4-6-捕获异常\"><a href=\"#4-6-捕获异常\" class=\"headerlink\" title=\"4.6 捕获异常\"></a>4.6 捕获异常</h3><p>上述的在子线程更新 UI 的方式，都是通过避开已知会抛出异常的情况（SurfaceView 相当于直接不检查）实现的。还有一种更新 UI 的方式最为简单粗暴，就是捕获异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">HandlerThread newThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">&quot;NewThread&quot;</span>);</span><br><span class=\"line\">newThread.start();</span><br><span class=\"line\">Handler newThreadHandler = <span class=\"keyword\">new</span> Handler(newThread.getLooper()) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            tvNewThreadTitle.setText(<span class=\"string\">&quot;子线程中更新UI并捕获异常&quot;</span>);</span><br><span class=\"line\">            ivImage.setImageResource(R.drawable.ic_launcher_foreground);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception ignore)&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">newThreadHandler.sendEmptyMessage(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这段代码当然不会抛出异常，并且 TextView 也确实能更新文本内容，但是 ImageView 却没有任何反应。对比一下 <code>TextView#setText(...)</code> 和 <code>ImageView#setImageResource(...)</code> 的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(CharSequence text, BufferType type, <span class=\"keyword\">boolean</span> notifyBefore, <span class=\"keyword\">int</span> oldlen)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步可以理解成，把传进来的 text 存入到 TextView 的成员变量中</span></span><br><span class=\"line\">        setTextInternal(text);</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            checkForRelayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageView</span> <span class=\"keyword\">extends</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageResource</span><span class=\"params\">(<span class=\"meta\">@DrawableRes</span> <span class=\"keyword\">int</span> resId)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) &#123;</span><br><span class=\"line\">            requestLayout();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过看源码发现：</p>\n<ul>\n<li><code>TextView#setText(...)</code> 是先通过 <code>setTextInternal(...)</code> 把 text 存入到成员变量，然后再调用 <code>checkForRelayout()</code> 检查是否需要重绘，如果需要的话才调用 <code>requestLayout()</code>，检查线程也就发生在 <code>ViewRootImpl#requestLayout()</code> 中。所以即使 <code>ViewRootImpl#requestLayout()</code> 抛出了异常，也不会影响到 <code>setTextInternal(...)</code> 已经把 text 存下来了，那只需要等待下一次屏幕刷新即可把文本刷新上去。</li>\n<li><code>ImageView#setImageResource(...)</code> 是先通过 <code>requestLayout()</code> 请求更新，并在 <code>ViewRootImpl#requestLayout()</code> 中检查了线程，只有未抛出异常时，才会走到 <code>invalidate()</code> 并重绘，否则抛出异常则会中断跳出方法。</li>\n</ul>\n<p>所以，通过捕获异常的方式，只能针对类似于 TextView 这种，可以在检查线程前先做更新 / 缓存的 View，其他 View 则尽管不会抛出异常，也无法更新 UI，所以捕获异常属于一种“骚操作”，是极为不建议使用的。</p>\n<hr>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><p>概括一下本文内容：</p>\n<ul>\n<li>Android 中视图的顶点都是 Window，显示视图的根基就是需要有一个可用的 Window</li>\n<li>Window 持有 DecorView</li>\n<li>Window 在创建并持有 DecorView 时会初始化 ViewRootImpl 时的当前线程会作为 ViewRootImpl 持有的初始化线程</li>\n<li>DecorView 加载 subDecor</li>\n<li>用 subDecor 承载 Activity 的 layout</li>\n<li>更新 View 时，如果需要重绘，会逐级调用父 View 的 <code>requestLayout()</code>，最上层的父 View 就是 ViewRootImpl，在 <code>ViewRootImpl#requestLayout()</code> 中判断了当前线程与初始化线程是否相同，如果不相同则抛出异常</li>\n<li>有几种方式是可以在子线程更新 UI 的：</li>\n<li>手动触发 ViewRootImpl 初始化：也就是手动创建 Window 并添加 DecorView。</li>\n<li>避开 ViewRootImpl 的检查：针对 TextView 这类先缓存再判断的 View 可以通过避开重绘等待下一次屏幕刷新时显示已缓存的内容来刷新 UI。</li>\n<li>使用 SurfaceView / TextureView。</li>\n<li>显示 Toast：Toast 的创建每次都会使用当前线程初始化，因此显示 Toast 不受跨线程的影响。但不能对其他线程的 Toast 实例对象调用 <code>Toast#setText(...)</code>，否则就相当于子线程更新 UI。</li>\n<li>捕获异常：针对 TextView 这类先缓存再判断的 View，可以更新 UI。但其他 View 通常会先检查线程再重绘，就会导致检查的那一步抛出异常，虽然捕获了不会 Crash，但也会中断重绘逻辑导致无法刷新。</li>\n</ul>\n","categories":["Android"],"tags":["Android","子线程","UI线程"]},{"title":"Android-View Background","url":"/post/android/android-view_background/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-View-Background\"><a href=\"#Android-View-Background\" class=\"headerlink\" title=\"Android-View Background\"></a>Android-View Background</h1><h2 id=\"1-View的圆角\"><a href=\"#1-View的圆角\" class=\"headerlink\" title=\"1. View的圆角\"></a>1. View的圆角</h2><h3 id=\"1-1-通过Background实现圆角\"><a href=\"#1-1-通过Background实现圆角\" class=\"headerlink\" title=\"1.1 通过Background实现圆角\"></a>1.1 通过Background实现圆角</h3><p>实现圆角最常见的方式是通过 Background 设置 <code>radius</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">shape</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">corners</span> <span class=\"attr\">android:radius</span>=<span class=\"string\">&quot;10dp&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>该方案可以裁切 Background 的渲染范围，对于 <code>Button</code> 之类内容距离边距有一定距离的 View 该方案最简单，但在 <code>Layout</code>、<code>ImageView</code> 等内容很可能会铺满边距的 View 上，会发现 Foreground（例如子 View、Image 等）不会被裁剪，仍然会渲染在圆角区域：</p>\n<p><img data-src=\"./view_content_exceed_background.png\" alt=\"View 背景超出圆角边界\" title=\"@ASSET\"></p>\n<h3 id=\"1-2-通过Outline实现圆角\"><a href=\"#1-2-通过Outline实现圆角\" class=\"headerlink\" title=\"1.2 通过Outline实现圆角\"></a>1.2 通过Outline实现圆角</h3>","categories":["Android"],"tags":["Android","View","Background","RoundCorner","圆角"]},{"title":"Java-finally关键字","url":"/post/java/java-finally/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-finally关键字\"><a href=\"#Java-finally关键字\" class=\"headerlink\" title=\"Java-finally关键字\"></a>Java-finally关键字</h1><h2 id=\"1-finally和return的执行顺序\"><a href=\"#1-finally和return的执行顺序\" class=\"headerlink\" title=\"1. finally和return的执行顺序\"></a>1. finally和return的执行顺序</h2><p>一句话总结：当 <code>try - catch</code> 中使用 <code>break</code> 或 <code>return</code> 返回时，<code>finally</code> 会执行，当调用了 <code>System.exit(0)</code> 退出时，由于直接终止了 JVM，因此 <code>finally</code> 不会执行。</p>\n<p>在 try - catch 中的 return 语句执行之后、方法返回之前，程序会将 return 的返回值写入内存中，然后等待 finally 语句执行完，如果在 finally 代码块中，只改变了引用（例如对变量重新赋值），由于 return 时已经将返回值写入了内存中，则不会改变，而如果是改变了同一个变量的值，则会改变。如果 finally 中包含 return 语句，则会覆盖原本的return。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">20</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 10。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        i = <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 20。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> StringBuilder <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">&quot;AAA&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> sb.append(<span class=\"string\">&quot;BBB&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;CCC&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(getValue());</span><br></pre></td></tr></table></figure>\n\n<p>输出 &quot;AAABBBCCC&quot;。</p>\n","categories":["Java"],"tags":["Java","finally"]},{"title":"Android-Window机制","url":"/post/android/android-window/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Android-Window机制\"><a href=\"#Android-Window机制\" class=\"headerlink\" title=\"Android-Window机制\"></a>Android-Window机制</h1><h2 id=\"1-Window的表现形式\"><a href=\"#1-Window的表现形式\" class=\"headerlink\" title=\"1. Window的表现形式\"></a>1. Window的表现形式</h2><h3 id=\"1-1-什么是Window\"><a href=\"#1-1-什么是Window\" class=\"headerlink\" title=\"1.1 什么是Window\"></a>1.1 什么是Window</h3><p>在大部分 PC 操作系统中，Window 指的是一个可视化的窗口区域。例如在 MacOS、Linux、Windows 系统中，可视化内容的 Window 通常包含（并非必须）「关闭按钮」、「最小化」、「最大化」，这个 Window 是由操作系统分配的且具有 UI（例如边框、按钮、标题等），限定了内容显示的区域，可视化的内容在渲染时只需要相对给定的 Window 渲染和绘制，因此提供给了用户自由操作的空间。</p>\n<h3 id=\"1-2-Android中的Window\"><a href=\"#1-2-Android中的Window\" class=\"headerlink\" title=\"1.2 Android中的Window\"></a>1.2 Android中的Window</h3><p>在 Android 中，Window 更多只是一种抽象的概念：<strong>一组 View 的集合</strong>，因为 Android 中的 Window 并没有实际的 UI。在源码中有 <code>Window</code>, <code>PhoneWindow</code>, <code>ViewManager</code>, <code>WindowManager</code>, <code>WindowManagerImpl</code>, <code>WindowManagerGlobal</code> 等与 Window 相关的类，但这些都不是 Window 实体。</p>\n<p>Android 中 Window 和 View 的关系就像「组织」和「个体」的关系，一群相似的个体可以组成一个集体并对外具有一定属性、功能，但「组织」只是一个概念上的集合，并不是一个实际存在的东西。</p>\n<hr>\n<h2 id=\"2-Window属性\"><a href=\"#2-Window属性\" class=\"headerlink\" title=\"2. Window属性\"></a>2. Window属性</h2><p>Window 有 3 个重要属性：</p>\n<ul>\n<li>type</li>\n<li>flags</li>\n<li>solfInputMode</li>\n</ul>\n<h3 id=\"2-1-Type\"><a href=\"#2-1-Type\" class=\"headerlink\" title=\"2.1 Type\"></a>2.1 Type</h3><p>由于 Android 中 Window 是对一组 View 集合的描述，不同应用有不同的 Window，同一个应用也可能有多个 Window，所以需要用一种优先级表示 Window 的显示层级，在 Android 中使用 <code>type</code> 表示 Window 的类型，实际上是通过 <code>type</code> 的大小表示 Window 的优先级，值越大则在屏幕上显示位置越上层，会覆盖低层级的 Window：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span>.<span class=\"title\">LayoutParams</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> type;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 应用的主窗口层级范围 1 ~ 99</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FIRST_APPLICATION_WINDOW = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LAST_APPLICATION_WINDOW = <span class=\"number\">99</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 应用子窗口（例如 Dialog）层级范围 1000 ~ 1999</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FIRST_SUB_WINDOW = <span class=\"number\">1000</span>;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LAST_SUB_WINDOW = <span class=\"number\">1999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 系统窗口层级范围 2000 ~ 2999</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FIRST_SYSTEM_WINDOW     = <span class=\"number\">2000</span>;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> LAST_SYSTEM_WINDOW      = <span class=\"number\">2999</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Flags\"><a href=\"#2-2-Flags\" class=\"headerlink\" title=\"2.2 Flags\"></a>2.2 Flags</h3><p>Flags 用于指定 Window 在不同场景下的处理方式，包括样式（全屏、背景等）、显示模式（是否允许锁屏、是否允许超出屏幕等）、触摸事件处理逻辑（是否接受触摸响应、是否将外部触摸事件传递到下层窗口等）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span>.<span class=\"title\">LayoutParams</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 所有 Flag 枚举</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FLAG_XXX = xxxxx;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-SoftInputMode\"><a href=\"#2-3-SoftInputMode\" class=\"headerlink\" title=\"2.3 SoftInputMode\"></a>2.3 SoftInputMode</h3><p>SoftInputMode 决定了 Window 在弹出软键盘时的逻辑，实际上软键盘也是一种 Window，但因为比较特殊所以专门用了一个属性来控制：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span>.<span class=\"title\">LayoutParams</span> <span class=\"keyword\">implements</span> <span class=\"title\">Parcelable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> softInputMode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 所有 SoftInputMode 枚举</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SOFT_INPUT_XXX = xxxxx;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-创建Window\"><a href=\"#3-创建Window\" class=\"headerlink\" title=\"3. 创建Window\"></a>3. 创建Window</h2><h3 id=\"3-1-指定用于创建Window的View\"><a href=\"#3-1-指定用于创建Window的View\" class=\"headerlink\" title=\"3.1 指定用于创建Window的View\"></a>3.1 指定用于创建Window的View</h3><p>在创建一个 Window 时，例如在 Activity 手动调用 <code>getWindowManager().addView(...)</code>，或是 <code>Dialog#show</code>，本质上都是调用了 WindowManager 实现类的 <code>WindowManagerImpl#addView</code> 方法，实际上 <code>WindowManagerImpl</code> 内的方法都只是对入参做了一些校验和预处理，最终都是通过桥接模式调用单例的 <code>WindowManagerGlobal</code> 实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        applyDefaultToken(params);</span><br><span class=\"line\">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 单例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> WindowManagerGlobal <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sDefaultWindowManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                sDefaultWindowManager = <span class=\"keyword\">new</span> WindowManagerGlobal();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sDefaultWindowManager;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实际创建 Window</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (...) &#123;</span><br><span class=\"line\">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        View panelParentView = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\"></span><br><span class=\"line\">            mViews.add(view);</span><br><span class=\"line\">            mRoots.add(root);</span><br><span class=\"line\">            mParams.add(wparams);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// do this last because it fires off messages to start doing things</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>WindowManagerGlobal#addView(...)</code> 主要做了五件事：</p>\n<ul>\n<li>校验入参；</li>\n<li>如果 <code>parentWindow != null</code> 说明需要创建 SubWindow，则 SubWindow 需要继承部分 parentWindow 的属性；</li>\n<li>创建 ViewRootImpl；</li>\n<li>把用于创建 Window 的 View、ViewRootImpl、应用到 Window 的 LayoutParams 分别存入三个列表，这三个列表总是等长的，三列表中同一下标对应的三个对象均指向了同一个 Window；</li>\n<li>将用于创建 Window 的 View 以及 LayoutParams 传入 ViewRootImpl，由 ViewRootImpl 实际创建 Window。</li>\n</ul>\n<p>这里也能看出，每次创建 Window 时都会先创建一个 ViewRootImpl，而真正创建 Window 的步骤其实就在 ViewRootImpl 内，并不是 WindowManager 也不是 PhoneWindow，ViewRootImpl 与创建的 Window 是一一对应的。</p>\n<h3 id=\"3-2-ViewRootImpl创建Window\"><a href=\"#3-2-ViewRootImpl创建Window\" class=\"headerlink\" title=\"3.2 ViewRootImpl创建Window\"></a>3.2 ViewRootImpl创建Window</h3><p>ViewRootImpl 在构造方法中通过单例的 WindowManagerGlobal 获取了一个单例的 IWindowSession 对象，用于在 <code>ViewRootImpl#setView(...)</code> 中真正创建 Window：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewParent</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> IWindowSession mWindowSession;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ViewRootImpl</span><span class=\"params\">(Context context, Display display)</span> </span>&#123;</span><br><span class=\"line\">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定了初始化时的线程</span></span><br><span class=\"line\">        mThread = Thread.currentThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 传入的 view 就是 DecorView。</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mView = view;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">                <span class=\"comment\">// 调用 WindowSession#addToDisplay(...)，才是真正创建了一个 Window。</span></span><br><span class=\"line\">                res = mWindowSession.addToDisplay(...);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> IWindowSession sWindowSession;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IWindowSession <span class=\"title\">getWindowSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sWindowSession == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    IWindowManager windowManager = getWindowManagerService();</span><br><span class=\"line\">                    sWindowSession = windowManager.openSession(...);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sWindowSession;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这也能看出，WindowManagerGlobal 和 IWindowSession 都是应用内单例的；</p>\n<ul>\n<li><p>WindowManagerGlobal 是一个工具类，用于维护和提供一系列与 Window 相关的资源，例如在 <code>addView(...)</code> 中就创建并维护了 View、ViewRootImpl、LayoutParams，而 <code>getWindowSession(...)</code> 则维护并提供 IWindowSession 对象，但 WindowManagerGlobal 本身并不承担创建 Window 的责任，是一个纯粹的工具类。</p>\n</li>\n<li><p>IWindowSession 包含了一系列与 WindowManagerService 的交互逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Session</span> <span class=\"keyword\">extends</span> <span class=\"title\">IWindowSession</span>.<span class=\"title\">Stub</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBinder</span>.<span class=\"title\">DeathRecipient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> WindowManagerService mService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">addToDisplay</span><span class=\"params\">(...)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mService.addWindow(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>所以，关于 Window、PhoneWindow、ViewManager、WindowManager、WindowManagerImpl、WindowManagerGlobal、ViewRootImpl 的关系可以总结如下：</p>\n<ul>\n<li>首先在 <code>Activity#attach(...)</code> 阶段先创建 <code>new PhoneWindow(...)</code>；</li>\n<li>然后通过 <code>PhoneWindow#setWindowManager(...)</code> 的内部创建出来一个 WindowManagerImpl；</li>\n<li>所有创建 Window 的地方，不论是 Activity、Dialog、还是 PopupWindow，最终都会调用 <code>WindowManagerImpl#addView(...)</code>；</li>\n<li>WindowManagerImpl 则调用单例的 <code>WindowManagerGlobal#addView(...)</code>；</li>\n<li>WindowManagerGlobal 创建 <code>new ViewRootImpl(...)</code>；</li>\n<li>ViewRootImpl 通过 <code>setView(...)</code> 持有了用于创建 Window 的 View，以及指定 Window 属性的 LayoutParams，因此 <strong>ViewRootImpl 负责连接 View 和 Window</strong>；</li>\n<li>ViewRootImpl 从 WindowManagerGlobal 中获取单例的 IWindowSession，调用 <code>IWindowSession#addToDisplay(...)</code>；</li>\n<li>IWindowSession 调用 WMS 完成最终的 Window 创建，因此 <strong>IWindowSession 负责连接 ViewRootImpl 和 WMS</strong>。</li>\n</ul>\n<blockquote>\n<p>除了创建窗口，WindowManagerImpl 还能通过 <code>updateView(...)</code> 和 <code>removeView(...)</code> 更新及移除 Window。</p>\n</blockquote>\n<hr>\n<h2 id=\"4-PhoneWindow和ViewRootImpl\"><a href=\"#4-PhoneWindow和ViewRootImpl\" class=\"headerlink\" title=\"4. PhoneWindow和ViewRootImpl\"></a>4. PhoneWindow和ViewRootImpl</h2><h3 id=\"4-1-PhoneWindow不是Window\"><a href=\"#4-1-PhoneWindow不是Window\" class=\"headerlink\" title=\"4.1 PhoneWindow不是Window\"></a>4.1 PhoneWindow不是Window</h3><p>通过上文分析会发现，创建 Window 最终都是通过 <code>WindowManagerImpl#addView(...)</code> 实现的，而 WindowManagerImpl 又是在 <code>PhoneWindow#setWindowManager(...)</code> 中创建的，那为什么 PhoneWindow 不是一个实际的 Window 呢？这个问题需要从两个方面考虑：</p>\n<p>（1）PhoneWindow 与 Window 并不是一一对应关系：</p>\n<p>首先，PhoneWindow 和实际显示在屏幕上的 Window 并不是一一对应的关系。尽管在 Activity 启动流程中创建了一个 <code>new PhoneWindow(...)</code>，但例如 PopupWindow、或是手动调用 <code>getWindowManager().addView(...)</code> 创建一个 Window 时，都并没有创建 PhoneWindow，而且它们最终都是用这个 Activity 的 WindowManagerImpl 来创建的，与 Activity 创建的 PhoneWindow 并没有直接关系。即便是 Dialog 在构造方法中创建了属于自己的 PhoneWindow 对象，但 <code>show()</code> 的时候用到的 WindowManagerImpl 也是通过 <code>mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</code> 从传入的 Context 中获取的，而创建 Dialog 传入的 Context 又几乎肯定是 Activity，所以实际上这些创建 Window 的过程，仅仅只和 WindowManagerImpl 有关，与 PhoneWindow 并没有什么关系。</p>\n<p>（2）PhoneWindow 并没有与 WMS 的交互：</p>\n<p>Android 对 Window 真正的创建、更新、和移除，都是通过 IWindowSession 调用 WindowManagerService 实现的；反之 WMS 也是通过 IWindowSession 来分配、调度、以及管理实际的 Window。而每个 App 只有一个单例的 IWindowSession，保存在同样单例的 WindowManagerGlobal 中，只有 ViewRootImpl 获取并操作了 IWindowSession，而 ViewRootImpl 又是 WindowManagerImpl 每次调用 <code>addView(...)</code> 时创建的，因此这个与 WMS 交互的过程同样与 PhoneWindow 无关。</p>\n<h3 id=\"4-2-PhoneWindow的意义\"><a href=\"#4-2-PhoneWindow的意义\" class=\"headerlink\" title=\"4.2 PhoneWindow的意义\"></a>4.2 PhoneWindow的意义</h3><p>上文中提到，Activity 在 <code>attach(...)</code> 时创建了自己的 PhoneWindow，而 Dialog 也在构造方法中创建了自己的 PhoneWindow，乍一看似乎 PhoneWindow 就是一个实际的 Window，当然通过上文也已经知道并非如此。PhoneWindow 与 Window 的关系，非常类似于 Socket 与 TCP / UDP 的关系：</p>\n<ul>\n<li>TCP / UDP 都是实际上的传输层协议，但 Socket 既不参与实际数据协议的转换（传输层）、又不负责维护设备之间的通信信道（会话层，Socket 虽然可以建立连接，但 Socket 只是帮忙发起了请求，本质上这条连接并不是 Socket 维护的，而是操作系统维护的）、也不负责传输数据的编解码（表示层），因为 Socket 并不属于 OSI 模型中的任何一层，Socket 只是对 TCP / UDP 的封装而并不参与到实际网络传输中的缓解，应该把 Socket 看成一个工具。</li>\n<li>而 PhoneWindow 与 Window 的关系也是同理：<ul>\n<li>PhoneWindow 维护了与 Window 相关的资源，例如 WindowManager、Type 属性、Flags 属性、SoftInputMode 属性等；</li>\n<li>并提供了一系列与 Window 相关的工具方法，例如加载 DecorView、设置 Title、获取实际 Window 的一些状态等；</li>\n<li>封装了对 DecorView、SubDecor 的加载；</li>\n<li>当需要改变 Window 的属性时，实际上是把对应的属性设置到 PhoneWindow 中，然后由 ViewRootImpl 请求 WMS 后读取并按照对应的属性设置 Window。</li>\n</ul>\n</li>\n</ul>\n<p>当然上文也提到，Dialog 会在构造方法中创建自己的 PhoneWindow，这是因为 Dialog 是一个很灵活的组件，本质上 Dialog 其实就是另一个 Window，但开发人员对 Dialog 的 Window 有很大的自定义需求，经常需要修改 Window 的属性，因此 Dialog 对创建出来的 Window 资源做了一层封装，放在自己的 PhoneWindow 中，而对于 PopupWindow 或手动调用 <code>getWindowManager().addView(...)</code> 创建的 Window，只是 Google 没有提供获取 Window 并修改属性的 API 而已。</p>\n<h3 id=\"4-3-ViewRootImpl的意义\"><a href=\"#4-3-ViewRootImpl的意义\" class=\"headerlink\" title=\"4.3 ViewRootImpl的意义\"></a>4.3 ViewRootImpl的意义</h3><p>通过分析 Window 的创建流程可以发现，Window 创建真正相关的其实是 WindowManagerImpl 和 ViewRootImpl，甚至可以说直接相关的只有 ViewRootImpl，因为 DecorView 也是在 ViewRootImpl 中维护的。而上文也提到 Android 中 Window 只是一种概念，Android 中的 Window 是用一组 ViewTree 表示的，因为 ViewTree 具有从上到下的层级关系，所以实际上 Window 可以与 ViewTree 的顶点一一对应，那这个顶点应该是什么呢？</p>\n<p>答案就是 ViewRootImpl，而不是 DecorView。尽管在 Activity 启动流程以及 Window 的创建流程中，DecorView 才是实际上 ViewTree 最上层的 View，而且 DecorView 本身也继承自 View，但是 View 最主要的功能还是承担 UI 上的显示，用一个 View 来承担与 Window 的交互从设计模式上是不合理的，而 ViewRootImpl 对上承担了 View 对 Window 的请求，对下承担了 Window 对 View 的事件分发，因此把 ViewRootImpl 看作 ViewTree 的顶点更合适。个人认为，这也是为什么 ViewRootImpl 会实现 ViewParent 接口的原因，这么设计使得 ViewRootImpl 也可以看成 View 的 Parent，例如每一个 View 在需要刷新 UI 的时候都会调用 <code>invalidate()</code> 和 <code>requestLayout()</code>，最终也都会向上传递到 ViewRootImpl，然后由 ViewRootImpl 统一处理渲染、VSync 信号处理等等逻辑，而 ViewTree 中实际的每个 View 只需要根据 ViewRootImpl 分发的回调处理即可。</p>\n<hr>\n<h2 id=\"5-Window加载时机\"><a href=\"#5-Window加载时机\" class=\"headerlink\" title=\"5. Window加载时机\"></a>5. Window加载时机</h2><h3 id=\"5-1-Activity的Window\"><a href=\"#5-1-Activity的Window\" class=\"headerlink\" title=\"5.1 Activity的Window\"></a>5.1 Activity的Window</h3><p>在 <a href=\"/post/android/android-activity/\" title=\"@LINK\">Activity 启动流程</a> 中对 Activity 的启动做了分析，Activity 的 Window 是在 <code>ActivityThread#handleResumeActivity(...)</code> 中调用 <code>wm.addView(decor, l);</code> 创建的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 先调用了 performResumeActivity</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                    a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 然后才创建 Window</span></span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用到 Activity 内</span></span><br><span class=\"line\">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终调用了 <code>Activity#performResume(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">performResume</span><span class=\"params\">(<span class=\"keyword\">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 这一步已经回调了 Activity 的 onResume() 生命周期</span></span><br><span class=\"line\">        mInstrumentation.callActivityOnResume(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码可以看出，Activity 在回调 <code>onResume()</code> 生命周期的时候，Window 以及 ViewRootImpl 是还没有创建的！</p>\n<h3 id=\"5-2-创建新Window\"><a href=\"#5-2-创建新Window\" class=\"headerlink\" title=\"5.2 创建新Window\"></a>5.2 创建新Window</h3><p>上文已经得出结论，Activity 在 <code>onResume()</code> 执行完返回之后，才会执行创建 Window 和 ViewRootImpl 的逻辑；</p>\n<ul>\n<li>这就带来了一个问题：在 Activity 生命周期的 <code>onResume</code> 回调中，可以创建 Window 吗？例如弹出一个 PopupWindow、或是调用 <code>getWindowManager().addView(...)</code>、或是弹出一个 Dialog？</li>\n<li>答案：<ul>\n<li>Dialog 可以。</li>\n<li>PopupWindow 默认情况下不能，需要指定某个范围内的 Type，否则抛出异常。</li>\n<li>手动调用 <code>getWindowManager().addView(...)</code> 只有在 Window 的 Type 属性在某个范围内才可以，否则抛出异常。</li>\n</ul>\n</li>\n</ul>\n<p>抛出的异常是：<code>android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?</code>，抛出的地方位于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首先把 DecorView 存为成员变量 mView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mView = view;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过 IWindowSession 实际请求 WMS 创建 Window：</span></span><br><span class=\"line\">            res = mWindowSession.addToDisplay(...);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (res) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class=\"line\">                <span class=\"keyword\">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class=\"line\">                    <span class=\"comment\">// 就是在这里抛出的异常，Token 为 null。</span></span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> WindowManager.BadTokenException(</span><br><span class=\"line\">                            <span class=\"string\">&quot;Unable to add window -- token &quot;</span> + attrs.token</span><br><span class=\"line\">                            + <span class=\"string\">&quot; is not valid; is your activity running?&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上文分析可知，创建一个 Window 的过程为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">WindowManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(<span class=\"meta\">@NonNull</span> View view, <span class=\"meta\">@NonNull</span> ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class=\"line\">        applyDefaultToken(params);</span><br><span class=\"line\">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际创建 Window</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class=\"line\">        <span class=\"comment\">// 如果 parentWindow 不为空，说明当前已经存在一个 Window 了，</span></span><br><span class=\"line\">        <span class=\"comment\">// 就需要用 parentWindow 的属性对新 Window 的 LayoutParams 做预处理。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将 DecorView 传入 ViewRootImpl。</span></span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法的意义就在于，如果新的窗口是一个 SubWindow，则它需要继承一些父 Window 的属性，</span></span><br><span class=\"line\">    <span class=\"comment\">// 例如 Token，SubWindow 会使用父 Window 的 Token 作为创建自己的授权。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">adjustLayoutParamsForSubWindow</span><span class=\"params\">(WindowManager.LayoutParams wp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意这里最外层的三个条件，对 Window 的 Type 做了判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class=\"line\">                wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当 (1000 &lt;= Type &lt;= 1999) 时，也就是 SubWindow，则 Token 是通过 DecorView 获取的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wp.token == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                View decor = peekDecorView();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (decor != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    wp.token = decor.getWindowToken();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ......</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp;</span><br><span class=\"line\">                wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当 (2000 &lt;= Type &lt;= 2999) 时，此时新 Window 是一个系统 Window，</span></span><br><span class=\"line\">            <span class=\"comment\">// 因此不需要继承什么属性，生命周期也应该独立，源码注释也有说明。</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则此时新 Window 的 Type 范围就是：(1 &lt;= Type &lt;= 99)，属于 Application 类型，</span></span><br><span class=\"line\">            <span class=\"comment\">// 则 Token 直接复用当前 Window 的 Token。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wp.token == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                wp.token = mContainer == <span class=\"keyword\">null</span> ? mAppToken : mContainer.mAppToken;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在 <code>Window#adjustLayoutParamsForSubWindow(LayoutParams)</code> 中对新 Window 的判断有三个大分支，按优先级顺序：</p>\n<ul>\n<li><code>1000 &lt;= Type &lt;= 1999</code></li>\n<li><code>2000 &lt;= Type &lt;= 2999</code></li>\n<li><code>1 &lt;= Type &lt;= 99</code></li>\n</ul>\n<h4 id=\"5-2-1-作为SubWindow时\"><a href=\"#5-2-1-作为SubWindow时\" class=\"headerlink\" title=\"5.2.1 作为SubWindow时\"></a>5.2.1 作为SubWindow时</h4><p>当新 Window <code>1000 &lt;= Type &lt;= 1999</code> 时，说明新 Window 是一个 SubWindow，SubWindow 的前提就是已经存在父 Window，因此 Token 就从父 Window 的 DecorView 里面获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// getWindowToken() 其实是 View 的方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">View</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// dispatchAttachedToWindow 存入 AttachInfo，</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dispatchAttachedToWindow</span><span class=\"params\">(AttachInfo info, <span class=\"keyword\">int</span> visibility)</span> </span>&#123;</span><br><span class=\"line\">        mAttachInfo = info;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// getWindowToken 就从存入的 AttachInfo 里面取出 Token</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IBinder <span class=\"title\">getWindowToken</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以看到返回的是 mAttachInfo.mWindowToken</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mAttachInfo != <span class=\"keyword\">null</span> ? mAttachInfo.mWindowToken : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>DecorView#getWindowToken()</code> 获取的实际上是从 View 成员变量 <code>mAttachInfo</code> 获取的，因此就需要找到这个 <code>mAttachInfo</code> 是什么时候被存入 DecorView 的，也就是 <code>dispatchAttachedToWindow(...)</code> 是什么时候调用的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClientTransactionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建 Window 时传入的就是 DecorView</span></span><br><span class=\"line\">        wm.addView(decor, l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowManagerGlobal</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入参的 View 就是 DecorView</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addView</span><span class=\"params\">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentWindow != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ViewRootImpl root;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">            root = <span class=\"keyword\">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class=\"line\">            view.setLayoutParams(wparams);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将 DecorView 传入 ViewRootImpl。</span></span><br><span class=\"line\">                root.setView(view, wparams, panelParentView);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewRootImpl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setView</span><span class=\"params\">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首先把 DecorView 存为成员变量 mView</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mView == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mView = view;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里 mView 就是 DecorView，用局部变量 host 持有：</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View host = mView;</span><br><span class=\"line\">        ......</span><br><span class=\"line\">        <span class=\"comment\">// 就是在这里把 AttachInfo 存入了 DecorView 中。</span></span><br><span class=\"line\">        host.dispatchAttachedToWindow(mAttachInfo, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从源码中可以分析得出：</p>\n<ul>\n<li>WindowManagerGlobal 创建 ViewRootImpl 之后调用 <code>ViewRootImpl#setView(...)</code> 将 DecorView 存入 ViewRootImpl；</li>\n<li>ViewRootImpl 在实际开始渲染第一帧的时候才将 AttachInfo 存入 DecorView；</li>\n<li>这之后 <code>DecorView#getWindowToken()</code> 才不为空。</li>\n<li>因此当新建的 Window <code>1000 &lt;= Type &lt;= 1999</code> 时，只有在 DecorView 第一帧渲染之后才能获取到 Token。</li>\n</ul>\n<h4 id=\"5-2-2-作为SystemWindow时\"><a href=\"#5-2-2-作为SystemWindow时\" class=\"headerlink\" title=\"5.2.2 作为SystemWindow时\"></a>5.2.2 作为SystemWindow时</h4><p>当 <code>2000 &lt;= Type &lt;= 2999</code> 时，说明新 Window 是一个 SystemWindow，则不需要从其他 Window 继承任何属性，也不需要复用其他 Window 的 Token，Android 将以独立生命周期处理这个 Window，在源码中也没有做什么处理，这种情况下是不会抛出异常的。</p>\n<h4 id=\"5-2-3-作为ApplicationWindow时\"><a href=\"#5-2-3-作为ApplicationWindow时\" class=\"headerlink\" title=\"5.2.3 作为ApplicationWindow时\"></a>5.2.3 作为ApplicationWindow时</h4><p>当上述两个条件均不满足时，说明 <code>1 &lt;= Type &lt;= 99</code>，也即新 Window 是一个 ApplicationWindow，则新 Window 就直接复用当前 Window 的 Token，又因为 WindowManagerGlobal 中调用的是 <code>parentWindow.adjustLayoutParamsForSubWindow(LayoutParams)</code>，所以新 Window 就是复用的 <code>parentWindow</code> 的 Token，对应在 Activity 中就是 Activity 的 Window 的 Token，再进一步也就是 <code>Activity#attach(...)</code> 阶段从 AMS 传进来的 Token，因此新 Window 在这个阶段（只是预处理 LayoutParams 的阶段，还没有创建 ViewRootImpl）就已经具有了 Token，因此在后续创建 ViewRootImpl 并调用 <code>ViewRootImpl#setView(...)</code> 时也就不会抛出异常。</p>\n<h4 id=\"5-2-4-问题分析\"><a href=\"#5-2-4-问题分析\" class=\"headerlink\" title=\"5.2.4 问题分析\"></a>5.2.4 问题分析</h4><p>上文 3 个小节已经对新 Window 的 Type 取不同值时，对应 Token 的获取时机做了分析，因此对于 <code>Activity#onCreate()</code> 时是否能创建新 Window，就能通过新 Window 的 Type 取值做判断了：</p>\n<p>（1）PopupWindow：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PopupWindow</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际取值：1000，属于 SubWindow 的范围</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWindowLayoutType = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWindowLayoutType</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutType)</span> </span>&#123;</span><br><span class=\"line\">        mWindowLayoutType = layoutType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getWindowLayoutType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mWindowLayoutType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showAtLocation</span><span class=\"params\">(IBinder token, <span class=\"keyword\">int</span> gravity, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams p = createPopupLayoutParams(token);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showAsDropDown</span><span class=\"params\">(View anchor, <span class=\"keyword\">int</span> xoff, <span class=\"keyword\">int</span> yoff, <span class=\"keyword\">int</span> gravity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams p =</span><br><span class=\"line\">                createPopupLayoutParams(anchor.getApplicationWindowToken());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> WindowManager.<span class=\"function\">LayoutParams <span class=\"title\">createPopupLayoutParams</span><span class=\"params\">(IBinder token)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> WindowManager.LayoutParams p = <span class=\"keyword\">new</span> WindowManager.LayoutParams();</span><br><span class=\"line\">        p.type = mWindowLayoutType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，PopupWindow 在成员变量中已经指定了默认的 <code>Type == 1000</code>，因此默认情况下的 PopupWindow 在 <code>Activity#onResume()</code> 阶段无法通过 DecorView 获取到 Token，会抛出异常，但可以通过手动设置 <code>popupWindow.setWindowLayoutType(1 ~ 99)</code> 直接复用 Activity 的 Window 的 Token 解决问题。</p>\n<p>（2）手动调用 <code>getWindowManager.addView(...)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">getWindowManager().addView(textView, <span class=\"keyword\">new</span> WindowManager.LayoutParams(</span><br><span class=\"line\">        <span class=\"number\">100</span>,              <span class=\"comment\">// 宽</span></span><br><span class=\"line\">        <span class=\"number\">100</span>,              <span class=\"comment\">// 高</span></span><br><span class=\"line\">        TYPE_APPLICATION, <span class=\"comment\">// Type 值，手动指定在 1 ~ 99 即可</span></span><br><span class=\"line\">        <span class=\"number\">0</span>,                <span class=\"comment\">// Flags</span></span><br><span class=\"line\">        <span class=\"number\">0</span>                 <span class=\"comment\">// Bitmap 的像素格式</span></span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>由于可以手动指定 Type 属性，因此指定在 1 ~ 99 范围内即可。</p>\n<p>（3）Dialog：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dialog</span> </span>&#123;</span><br><span class=\"line\">    Dialog(<span class=\"meta\">@NonNull</span> Context context, <span class=\"meta\">@StyleRes</span> <span class=\"keyword\">int</span> themeResId, <span class=\"keyword\">boolean</span> createContextThemeWrapper) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Window w = <span class=\"keyword\">new</span> PhoneWindow(mContext);</span><br><span class=\"line\">        mWindow = w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Window</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Window 的 LayoutParams 有默认值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WindowManager.LayoutParams mWindowAttributes =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> WindowManager.LayoutParams();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WindowManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LayoutParams</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LayoutParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class=\"line\">            <span class=\"comment\">// WindowManager.LayoutParams 的默认 Type 就是 TYPE_APPLICATION</span></span><br><span class=\"line\">            type = TYPE_APPLICATION;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，Dialog 在构造方法中创建了自己的 PhoneWindow，而 Window 默认的 LayoutParams 中 <code>Type == TYPE_APPLICATION == 2</code>，所以 Dialog 也是直接复用了当前 Window 的 Token。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/weixin_43766753/article/details/108350589\" title=\"@LINK\">Android全面解析之Window机制</a></li>\n</ul>\n","categories":["Android"],"tags":["Android","Window","PhoneWindow","WindowManager","ViewRootImpl"]},{"title":"JVM的GC策略","url":"/post/java/java-gc/","content":"<span id=\"more\"></span>\n\n<h1 id=\"JVM的GC策略\"><a href=\"#JVM的GC策略\" class=\"headerlink\" title=\"JVM的GC策略\"></a>JVM的GC策略</h1><h2 id=\"1-GC简介\"><a href=\"#1-GC简介\" class=\"headerlink\" title=\"1. GC简介\"></a>1. GC简介</h2><p>GC（Garbage Collection，垃圾回收）是 JVM 中非常必要的一个机制，之所以需要 GC，是因为程序在运行中，会产生很多 Garbage，而 JVM 的内存是有限制的，如果不及时对这些 Garbage 进行整理和清除，会使得内存占用越来越大，最后导致没有足够的内存生成新的对象。GC 中有一个很重要的前提：Stop-The-World，也即：JVM 由于要执行 GC 而停止了应用程序的执行。当 GC 发生时，除了 GC 所需的线程外，其他所有线程都处于等待状态直到 GC 任务完成。而通常做 GC 优化的目的，就是减少 GC 发生，以减少卡顿。</p>\n<p>此外，GC 运行在单独的 Daemon 线程中，当 JVM 开始 GC 时，会暂停当前进程内的所有线程，然后启动 GC 线程回收资源。</p>\n<blockquote>\n<p>每个 Java 进程都拥有独立的 JVM 实例，所以 GC 仅能触发当前进程下的资源回收。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-GC的两种核心判定原则\"><a href=\"#2-GC的两种核心判定原则\" class=\"headerlink\" title=\"2. GC的两种核心判定原则\"></a>2. GC的两种核心判定原则</h2><h3 id=\"2-1-引用计数\"><a href=\"#2-1-引用计数\" class=\"headerlink\" title=\"2.1 引用计数\"></a>2.1 引用计数</h3><p>引用计数也即：为实际内存中存储的对象所具有引用记录引用数，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 省略类 A 和 B 之间的关系</span></span><br><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">b = a;</span><br></pre></td></tr></table></figure>\n\n<p>此时，<code>new A()</code> 执行后在内存中实际存储的对象数据，就具有了 <code>a</code> 和 <code>b</code> 两个引用，则其引用计数为 2，而 <code>new B()</code> 生成的实际对象数据则引用计数为 0。</p>\n<p>引用计数法的核心思想即：一个对象，每增加一个引用，则引用计数 +1，每减少一个引用，则引用计数 -1，任何时刻，计数值为 0 的对象，就是不可再使用的（例如，<code>b = a;</code> 后，原本 <code>new</code> 出来的 <code>B</code> 对象，就无法再通过代码获取到了），即可马上将自己当做空闲空间链接到空闲链表。</p>\n<h3 id=\"2-2-引用链\"><a href=\"#2-2-引用链\" class=\"headerlink\" title=\"2.2 引用链\"></a>2.2 引用链</h3><p>提出一个初始根节点对象的概念：GC Root，当一个对象产生时，会将其建立与 GC Root 的直接或间接连接，例如一个外部类可能直接连接 GC Root，而该类的子类则先连接到该类，再连接到 GC Root。也就是说，GC Root 本身也是对象，只是这些对象，在整个程序运行期间，都有用或不会被销毁，那么与这些对象相连接的对象，则说明是有用的，则不需要被回收。而某些对象与这些 GC Roots 没有连接，则说明这些对象不是必要的，则 GC 可以回收。这些引用关系，被称为：<strong>引用链</strong>。</p>\n<p>例如：通常一个 Java 程序，都是从 <code>main</code> 方法开始执行，可以将 <code>main</code> 方法的实际内存引用作为 GC Root，如果在 <code>main</code> 方法中声明两个对象：<code>A a;</code> 和 <code>B b;</code>，则 <code>a</code> 和 <code>b</code> 都是与 <code>main</code> 相连接的平行平级的对象，这时如果执行：<code>b = a;</code>，则将内存中 <code>a</code> 的实际引用（指向内存中的实际数据）赋值给了 <code>b</code>，则原本 <code>b</code> 的引用（内存中实际的一个 <code>B</code> 的对象）被中断，此时的引用链则是：</p>\n<p><code>main</code> 连接到平行平级的 <code>a</code> 和 <code>b</code>，然后 <code>a</code> 和 <code>b</code> 同时连接到内存中 <code>A</code> 的实际对象，而内存中 <code>B</code> 的实际对象则失去任何引用。</p>\n<p>当一个对象，可以连接到 GC Root，则称之为是“可达的”，或“具有可达性”，否则为“不可达”或“不具有可达性”。</p>\n<hr>\n<h2 id=\"3-常见的GC算法\"><a href=\"#3-常见的GC算法\" class=\"headerlink\" title=\"3. 常见的GC算法\"></a>3. 常见的GC算法</h2><p>常见的 GC 算法有：引用计数法、标记清除法、复制法、标记整理法、分代收集法。</p>\n<h3 id=\"3-1-引用计数法\"><a href=\"#3-1-引用计数法\" class=\"headerlink\" title=\"3.1 引用计数法\"></a>3.1 引用计数法</h3><p>即是通过判断引用计数是否为 0 来决定是否回收，引用计数法最致命的缺点，是当发生循环引用时，无法回收无用对象。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">A a = <span class=\"keyword\">new</span> A();</span><br><span class=\"line\">B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\">a.friend = b;</span><br><span class=\"line\">b.friend = a;</span><br></pre></td></tr></table></figure>\n\n<p>则 <code>a</code> 和 <code>b</code> 二者互相引用，执行完这段代码后，其引用计数始终不为 0，则 GC 始终无法回收。</p>\n<h3 id=\"3-2-标记清除法\"><a href=\"#3-2-标记清除法\" class=\"headerlink\" title=\"3.2 标记清除法\"></a>3.2 标记清除法</h3><p>标记清除法分为“标记”和“清除”两个阶段。</p>\n<ul>\n<li>标记阶段，从 GC Root 出发，遍历所有的子节点，并将所有可达的对象进行标记。</li>\n<li>清除阶段，遍历所有的对象，将未标记的对象回收。</li>\n</ul>\n<p>标记清除法最致命的缺点是：多次 GC 会导致内存碎片化，即空闲内存在实际内存中不是连续的，导致当有大内存对象产生时，无法找到足够的连续内存而又一次触发 GC。</p>\n<h3 id=\"3-3-复制法\"><a href=\"#3-3-复制法\" class=\"headerlink\" title=\"3.3 复制法\"></a>3.3 复制法</h3><p>将内存划分为大小相等的两个区域，每次只使用其中一半，当 GC 发生时，找出其中存活的对象，按照顺序复制到另一半内存中连续的区域，然后直接把之前的一半内存清空，这样就不会出现内存碎片的情况。这种方案适用于大部分对象生命周期都比较短的情况，例如新生代中的对象，而当遇到极端情况，例如一半的内存中，在 GC 时所有的对象都存活，则直接把这一半内存全部复制到另一半，结果还是全部存活，又要复制回来···，实际上就是浪费了 50% 的空间，所以像老年代（存放经过多次 GC 后仍然存活的对象，所以这些对象被 GC 后仍然存活的几率很高）就不能用这种方案。</p>\n<h3 id=\"3-4-标记整理法\"><a href=\"#3-4-标记整理法\" class=\"headerlink\" title=\"3.4 标记整理法\"></a>3.4 标记整理法</h3><p>标记整理法和标记清除法类似，都是通过遍历标记所有可达的对象，但不是直接清理掉不可达对象，而是将所有含有标记的对象，向内存的一侧移动，用空闲指针来标记最后一个存活对象，然后清理掉空闲指针之后的内存空间，这样清理后的空闲内存则是连续的一段。</p>\n<h3 id=\"3-5-分代收集法\"><a href=\"#3-5-分代收集法\" class=\"headerlink\" title=\"3.5 分代收集法\"></a>3.5 分代收集法</h3><p>首先需要明确的是，分代收集法本质上并不是一种 GC 算法，对于一个复杂的系统，例如 JVM，只是用一种单一的 GC 算法是不足以应对所有场景的，因此需要针对多个场景制定一套算法，而分代收集法就是基于这个理念创立的。</p>\n<p>堆区本身有 3 个区域划分：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。</p>\n<p>（1）新生代：所有新生成的对象都在新生代，新生代的目标就是尽可能快速的收集生命周期短的对象。新生代又分为三个区（通常是两个 Survivor 区，但也可以增加）：Eden 区，Survivor 1 区，Survivor 2 区。</p>\n<ul>\n<li>Eden 区：大部分对象在 Eden 区生成，当 Eden 区满了 GC 后存活下来的对象将随机复制到其中一个 Survivor 区。</li>\n<li>Survivor区：当一个 Survivor 区满了 GC 后存活下来的对象，如果是来自 Eden 区，则复制到另一个 Survivor 区，如果是来自另一个 Survivor 区，则复制到老年代。</li>\n</ul>\n<p>通俗地说，如果一个对象首先在 Eden 区中被创建，Eden 经过 GC 后存活，则被复制到其中一个 Survivor 区，如果这个 Survivor 经过 GC 后还存活，则被复制到另一个 Survivor 区，如果另一个 Survivor 区经过 GC 后仍然存活，则复制到老年代。需要注意的是：两个 Survivor 区是平等的，没有优先级高低、顺序前后之分，都有可能接收来自 Eden 或另一个 Survivor 区传来的对象。Survivor 区可以手动配置为多于 2 个，即可增加对象在新生代中的时间，减小被复制到老年代的可能性。</p>\n<p>（2）老年代：在新生代中经过 N 次（N 即为新生代中区的数量）GC 后仍然存活的对象将进入老年代，通常都是生命周期比较长的对象。</p>\n<p>（3）永久代：一般用来存放类的信息（包括类名、类方法、字段信息等）、静态变量、常量池等不会改变的数据，但在 JDK 1.8 开始就使用元数据区取代了了永久代。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/abc512427549/article/details/80654131\" title=\"@LINK\">Android ART 垃圾回收机制</a></li>\n</ul>\n","categories":["Java"],"tags":["Java","GC","垃圾回收"]},{"title":"Java类加载机制","url":"/post/java/java-class/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java类加载机制\"><a href=\"#Java类加载机制\" class=\"headerlink\" title=\"Java类加载机制\"></a>Java类加载机制</h1><h2 id=\"1-对象加载流程\"><a href=\"#1-对象加载流程\" class=\"headerlink\" title=\"1. 对象加载流程\"></a>1. 对象加载流程</h2><p>当 JVM 收到一条创建对象的指令时，需要经过以下过程：</p>\n<ul>\n<li>JVM 对类采用懒加载的方式，避免启动时大量占用 CPU 和内存，因此创建对象前，需要先检查常量池中是否存在目标类的符号引用；<ul>\n<li>如果存在，说明类已被加载，JVM 将在堆区为新生对象分配一块内存，分配方式有「指针碰撞」和「空闲列表」两种，分配过程通过 CAS 保证原子性。<ul>\n<li>指针碰撞：如果Java堆是绝对规整的，所有用过的内存都放在一边，所有没用过的内存存放在另一边，中间存放一个指针作为分界点指示器。分配内存时，将指针从用过的内存区域向空闲内存区域移动等距离区域。</li>\n<li>空闲列表：如果Java不是规整的，这时，虚拟机就必须维护一张列表，列表上记录了可用的内存块，在分配内存时，从列表上找到一个足够大的连续内存块分配给对象，并更新列表上的记录。</li>\n</ul>\n</li>\n<li>如果不存在，说明类信息仍未被加载，需要先加载目标类，然后再继续完成新生对象的加载。</li>\n</ul>\n</li>\n<li>初始化内存空间内的信息：新生对象在堆区分配内存后，将内存空间中的非静态成员变量都用默认值初始化（静态变量在类的加载流程中就已经初始化），因此成员变量在声明时可以不必显式初始化。</li>\n<li>初始化内存空间的基本信息：计算哈希值、记录所属类的信息等。</li>\n<li>继续执行代码指定的初始化，例如构造方法、代码块等。<ul>\n<li>按照顺序也可以看出，非静态成员变量的初始化发生在构造方法调用之前，非静态成员变量的初始化在效果上等同于一个非静态的代码块。</li>\n</ul>\n</li>\n<li>将堆区的对象内存链接到栈区的引用。</li>\n</ul>\n<p>至此对象已经创建完毕。但 Java 中栈区的引用和堆区的对象只是一种链接方式，引用如何通过访问指向的对象内存完成方法调用、数据读写，则是由虚拟机实现的。主要的实现方式有两种：</p>\n<ul>\n<li>句柄访问：JVM 在堆区独立划分一块句柄池，每当一个对象在堆区创建后，JVM 都将对象在堆区的实际地址存入句柄池作为一条句柄，然后将栈中的引用链接到该句柄，因此引用实际指向的是一条句柄，再由该句柄指向堆中的对象内存。<ul>\n<li>优势：由于引用指向的是句柄，因此当堆中的内存发生改变时（例如被 GC），不需要改变引用的指向，只需要改变句柄指向的内存，这种情况下引用的指针是稳定的。</li>\n<li>劣势：更多的引用意味着访问实际内存时会带来额外性能开销。</li>\n</ul>\n</li>\n<li>直接指针：JVM 直接将栈区的引用指向堆区的对象内存，引用可以直接操作内存指针访问，因此相比句柄访问减少了一个指针。<ul>\n<li>优势：由于指针更少，因此从引用访问实际内存时，性能开销更小。</li>\n<li>劣势：当堆区内存经常改变时，引用的指针也需要经常改变，指针的指向是不稳定的。</li>\n<li>HotSpot 虚拟机采用的是直接指针。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>对于句柄访问，从应用层来看比较难理解其引用指针稳定带来的好处，但从 JVM 实现上来看，JVM 的开发人员可以不用关注堆区的对象是否改变，以及改变后对栈区引用的重定向等问题，因此这个优劣势更多是面向 JVM 层而不是应用层的。</p>\n</blockquote>\n<hr>\n<h2 id=\"2-Java类生命周期\"><a href=\"#2-Java类生命周期\" class=\"headerlink\" title=\"2. Java类生命周期\"></a>2. Java类生命周期</h2><p>通过上文可知，JVM 在创建对象时，如果目标类还未加载就需要先加载类。对于一个运行中的 JVM，其读取的类是已经编译成二进制字节流的 class 文件，class 文件中包含了对这个类信息的描述，因此类的加载流程，本质上就是 JVM 读取并校验 class 文件中的数据；然后将这些数据转换、解析、以及初始化；最终成为可以被 JVM 直接读取的内存。从一个类被 JVM 加载进内存到被 JVM 卸载清理的流程如下：</p>\n<p><img data-src=\"./class_lifecycle.svg\" alt=\"JVM 中类的生命周期\" title=\"@ASSET\"></p>\n<h3 id=\"2-1-类的加载\"><a href=\"#2-1-类的加载\" class=\"headerlink\" title=\"2.1 类的加载\"></a>2.1 类的加载</h3><ul>\n<li>加载：主要是读取 class 文件；<ul>\n<li>通过类的全限定名获取对应 class 文件的二进制字节流。</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li>\n</ul>\n</li>\n<li>验证：为了确保 class 文件中的数据符合 JVM 要求，不会危害 JVM 的稳定性；<ul>\n<li>文件格式验证：验证字节流是否符合 class 文件格式的规范，并且能被当前版本的虚拟机处理，通过该阶段后，字节流会进入内存的方法区中进行储存。</li>\n<li>元数据验证：对字节码描述的信息进行语言分析，对类的元数据信息进行语义校验，确保其描述的信息符合 Java 语言规范要求。</li>\n<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段对类的方法进行校验分析，保证类的方法在运行时不会做出危害虚拟机安全的事件。</li>\n<li>符号引用验证：对类自身以外的信息（常量池中各种符号引用）的信息进行校检，确保后续解析阶段能正常执行。</li>\n</ul>\n</li>\n<li>准备：为类的静态变量赋默认值；<ul>\n<li>静态成员变量根据变量类型被赋值为 0, false, 或 null。</li>\n<li>静态常量 <code>static final</code> 不会被赋默认值，在编译时会为静态常量标记 <code>ConstantValue</code> 属性，如果没有则会编译错误。在准备阶段 JVM 会用标记的 <code>ConstantValue</code> 为静态常量赋值。</li>\n</ul>\n</li>\n<li>解析：主要是针对（1）类或接口、（2）字段、（3）类方法、（4）接口方法、（5）方法类型、（6）方法句柄、（7）调用限定符，将常量池中的这 7 种符号引用替换为直接引用。可以理解为，JVM 在加载阶段使用一些符号来描述类的这些信息，但还没有创建实际的内存，然后在解析阶段再实际加载进内存中，并转换为直接引用；<ul>\n<li>符号引用：用一组符号来描述所引用的目标，符号可以是任何字面量，只要使用时无歧义定位到目标即可。符号引用与虚拟机的内存布局无关，引用的目标并不一定已经加载到内存中。符号引用的字面量形式明确地定义在 JVM 规范的 Class 文件格式中，因此各种虚拟机实现的内存布局可以不相同，但是他们能接受的符号引用必须都是一致的。</li>\n<li>直接引用：直接引用是可以直接定位到目标的指针、相对偏移量或是一个能间接定位目标的句柄。直接引用是与虚拟机的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li>\n</ul>\n</li>\n<li>初始化：按照代码执行的初始化，直到该阶段，JVM 才会真正开始执行构造器的初始化，例如成员变量的赋值、代码块、构造方法等；<ul>\n<li>尽管静态成员变量在准备阶段就已经被 JVM 赋了默认值，但直到初始化阶段才会读取代码中的显式赋值。</li>\n<li>静态代码块也在初始化阶段才会执行。</li>\n<li>静态构造块（静态成员变量和静态代码块）的执行顺序取决于 JVM 的读取顺序（通常也就是代码编写顺序）决定。</li>\n<li>非静态构造块（非静态成员变量和非静态代码块）的执行顺序也取决于 JVM 的读取顺序（通常也就是代码编写顺序）决定，如果一个非静态成员变量在声明后没有立即显式初始化，则也会被赋默认值。</li>\n<li>在静态成员变量初始化完毕和静态代码块执行完毕、非静态成员变量初始化完毕和非静态代码块执行完毕之后，才会调用构造方法。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-类加载器\"><a href=\"#2-2-类加载器\" class=\"headerlink\" title=\"2.2 类加载器\"></a>2.2 类加载器</h3><p>JVM 默认提供了 3 种类加载器，如有必要也允许添加自定义的类加载器：</p>\n<ul>\n<li>Bootstrap ClassLoader: 负责加载 <code>lib/</code> 目录下的类，以及 <code>-Xbootclasspath</code> 参数所指定的路径中的类。通常这些类都是 JVM 运行必须且核心的类。</li>\n<li>Application ClassLoader: 负责加载 <code>classPath</code> 所指定的用户目录下的类，如果应用程序没有自定义类加载器，则通常使用该加载器作为应用程序中默认的类加载器。<blockquote>\n<p>Application ClassLoader 也叫 System ClassLoader。</p>\n</blockquote>\n</li>\n<li>Extension ClassLoader: 负责加载 <code>lib/ext</code> 目录下的类，以及被 <code>java.ext.dirs</code> 环境变量指定的目录下的类，Android 虚拟机去掉了这个类加载器。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassLodaer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ClassLoader parent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">ClassLoader</span><span class=\"params\">(ClassLoader parent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(checkCreateClassLoader(), parent);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">ClassLoader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当使用无参构造方法时，传入的 parent 是 SystemClassLodaer，其实也就是 ApplicationClassLoader</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ClassLoader</span><span class=\"params\">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ClassLoader <span class=\"title\">getParent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 只有 Bootstrap ClassLoader 返回 null</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JVM 启动时就会运行 BootStrap ClassLoader，用于加载 Java 核心 API，以及另外两个 ClassLoader：Extension ClassLoader、Application ClassLoade。每一个 ClassLoader 都继承自 ClassLoader 抽象类，如果 <code>getParent() == null</code> 则认为该 ClassLoader 就是 BootStrap ClassLoader。</p>\n<p>ClassLoader 在加载 Class 文件时采用双亲委托模式，所有的 ClassLoader 在收到一个加载类的请求时，都会先委托它的 ParentClassLodaer 加载，并逐层向上传递直到 BootstrapClassLoader。当 ParentClassLodaer 无法加载时会返回，再由当前 ClassLoader 尝试加载，并逐层向下返回。因此，加载过程可以看成 <strong>自底向上检查</strong> 以及 <strong>自顶向下加载</strong>。这种设计有 3 个优点：</p>\n<ul>\n<li>使用双亲委派模型来组织类加载器之间的关系，Java 类随着其加载器一起具备了一种带有优先级的层次关系。</li>\n<li>避免类的重复加载，当父类加载器已经加载过了某个类时，子类收到加载请求后，向上传递给父类时即可判断该类已被加载。</li>\n<li>避免核心类（如 Object, System 等）被篡改，JVM 在启动时，BootstrapClassLoader 会加载核心类，如果用户尝试加载一个篡改过的类，由于双亲委托制，一定会向上传递到 BootstrapClassLoader，因此就能判断类已加载，即可跳过非法类的加载。</li>\n</ul>\n<h3 id=\"2-3-类资源的初始化\"><a href=\"#2-3-类资源的初始化\" class=\"headerlink\" title=\"2.3 类资源的初始化\"></a>2.3 类资源的初始化</h3><p>根据上文，类中的静态资源在准备阶段就已经被赋默认值，但所有变量的显式赋值都发生在初始化阶段，静态变量和静态代码块等效、非静态变量和非静态代码块等效、等效的资源按照 JVM 执行顺序初始化；按照该规范即可分析所有资源初始化情况。</p>\n<p>（1）静态变量显式赋值在静态代码块之前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Demo() &#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类准备阶段，为静态变量赋默认值 <code>int a = 0</code></li>\n<li>类初始化阶段<ul>\n<li>执行静态构造块<ul>\n<li>先执行显式赋值 <code>a = 5</code></li>\n<li>再向下执行静态代码块 <code>a = 10</code></li>\n</ul>\n</li>\n<li>执行构造方法<ul>\n<li>最终获取到 <code>a == 10</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（2）非静态变量显示赋值在非静态代码块之前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Demo() &#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类初始化阶段<ul>\n<li>执行构造块：<ul>\n<li>先执行显示赋值，<code>a = 5</code></li>\n<li>再向下执行非静态代码块 <code>a = 10</code></li>\n</ul>\n</li>\n<li>执行构造方法<ul>\n<li>最终获取到 <code>a == 10</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（3）变量显式赋值在代码块之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 静态代码块 + 静态成员变量赋值</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    Demo() &#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 非静态代码块 + 非静态成员变量赋值</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    Demo() &#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照一般理解，非静态的成员变量是在类初始化阶段执行到的时候才会定义，那如果在声明之前的非静态代码块引用，应该会报错 <code>Illegal forward reference</code> 才对，但实际上编译是通过的，最终构造方法里都是 <code>a == 5</code>。难道是对于变量赋值也采用了懒加载，执行到代码块中的 <code>a</code> 时，先执行了 <code>a</code> 的定义吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否静态是一样的，以静态为例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = a;  <span class=\"comment\">// 编译错误，Illegal forward reference</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    Demo() &#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而，在代码块中只要引用 <code>a</code> 就会编译出错。实际上，<strong>等效代码中变量的声明总是应该在被引用之前，唯独「除非该变量位于赋值语句的左值」这种情况例外</strong>，其中 <strong>等效</strong> 指的是「静态代码块与静态成员变量」、「非静态代码块与非静态成员变量」这种关系，等效关系的代码的执行顺序取决于 JVM 读取顺序。如果是非等效关系的代码，则还与 JVM 加载的时机有关。例如上述例子，如果改成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是否静态是一样的，以静态为例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = a;  <span class=\"comment\">// 通过，运行通过</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    Demo() &#123;</span><br><span class=\"line\">        System.out.println(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于静态成员变量在类的准备阶段就已经定义且赋默认值，并且在初始化阶段，静态的构造块又先于非静态构造块执行，所以不论编码顺序如何，最终执行到非静态代码块时，<code>a</code> 已经完全初始化了。</p>\n<hr>\n<h2 id=\"3-热修复（热更新）原理\"><a href=\"#3-热修复（热更新）原理\" class=\"headerlink\" title=\"3. 热修复（热更新）原理\"></a>3. 热修复（热更新）原理</h2><h3 id=\"3-1-代码替换\"><a href=\"#3-1-代码替换\" class=\"headerlink\" title=\"3.1 代码替换\"></a>3.1 代码替换</h3><p>两个方案：Native替换和Dex插桩。</p>\n<p>（1）Native替换</p>\n<p>例如阿里的AndFix，是先在Native层找到需要修复的方法的结构体，然后改变其NativeFunc字段值，这个值是用来指定JVM执行方法时在Native层对应的指针位置，也即：Native层在执行代码的时候，不同的方法存在内存中由Native层的指针指向不同的地址里，修改了某个方法后，将新的方法的NativeFunc字段指定为旧方法的，使得Native指针指向的方法所在的内存为新方法所在的内存，来达到替换的效果。</p>\n<p>优点是不需要重启就能生效，是基于方法级别的修复。<br>缺点是不能新增变量和类、方法等，因为如果新增了方法或类，就会导致编译后的Dex中方法数发生变化，则 <code>dexElements[]</code> 中方法的索引就会变化，原来的索引对应的方法就可能发生错乱。</p>\n<p>（2）Dex插桩</p>\n<p>在编译 Android 代码时，会把代码编译成 dex 字节码，Android 在运行一个 App 时，会通过 ClassLoader 来加载 dex 文件，加载时，越靠前的Dex优先被使用，因此可以通过把热更新后的类或方法编译成的 patch.dex 文件插入到 <code>dexElements[]</code> 数组的头部使得虚拟机只加载修复后的类。</p>\n<p>优点是可以做较大的改动，稳定性高，不会侵入进程（因为需要重启才生效）。<br>缺点是影响性能，安装APK时，如果某个Dex中的类，在static方法、private方法、构造方法、override方法中引用的对象，也在同一个Dex文件内，则虚拟机会给该Class打上CLASS_ISPREVERIFIED已验证标签，运行时对应的对象就直接在当前Dex中找，否则没有打上标签的类，在运行时，就需要遍历所有的Dex查找，会影响性能。但热修复时，打出来的patch.dex，只包含了修复的class，所以绝大部分情况下，是不能打CLASS_ISPREVERIFIED标志的，否则在运行时，在patch.dex中找不到引用的对象，会抛出IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation错误。所以需要强制不打标志，不打标志就会导致在加载的时候要遍历所有的Dex，因此影响性能。</p>\n<h3 id=\"3-2-资源替换\"><a href=\"#3-2-资源替换\" class=\"headerlink\" title=\"3.2 资源替换\"></a>3.2 资源替换</h3><p>（1）资源的加载是通过 AssetManager 实现的，通过反射调用addAssetPath，将完整的新资源包加入到AssetManager中来替换掉整个AssetManager中持有的资源。然后查找所有引用了旧AssetManager的地方，通过反射替换为新的AssetManager的引用。</p>\n<p>（2）SO库的修复本质上就是对Native方法的修复和替换，把新SO库的路径插入到<code>NativeLibraryDirectories[]</code> 数组的最前面，就能使得Native层加载SO时加载的是新的SO库。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/a745233700/article/details/90232862\" title=\"@LINK\">Java虚拟机：对象创建过程与类加载机制、双亲委派模型</a></li>\n<li><a href=\"https://blog.csdn.net/csdn_life18/article/details/107302315\" title=\"@LINK\">java对象的访问方式句柄和直接指针介绍</a></li>\n<li><a href=\"https://www.jianshu.com/p/9d358d652fd6\" title=\"@LINK\">JVM 虚拟机与对象创建过程</a></li>\n<li><a href=\"https://blog.csdn.net/king_kgh/article/details/78291783\" title=\"@LINK\">Java虚拟机类加载(解析阶段)</a></li>\n<li><a href=\"https://blog.csdn.net/wang_k516/article/details/90753472\" title=\"@LINK\">JVM、Dalvik和ART</a></li>\n</ul>\n","categories":["Java"],"tags":["热更新","Java","ClassLoader","类加载机制","双亲委托","热修复"]},{"title":"Java泛型","url":"/post/java/java-generic_type/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java泛型\"><a href=\"#Java泛型\" class=\"headerlink\" title=\"Java泛型\"></a>Java泛型</h1><h2 id=\"1-泛型的基本定义\"><a href=\"#1-泛型的基本定义\" class=\"headerlink\" title=\"1. 泛型的基本定义\"></a>1. 泛型的基本定义</h2><p>Java 中的泛型是 <strong>伪泛型</strong>，这是因为 Java 中的泛型会在编译期被擦除、在编译后通过强转实现类型的约束，换言之一个类不论具有多少种泛型变体，其编译后的类型都指向同一个原始类的字节码，好处是避免编译产物膨胀。而相比之下 C++ 的泛型（实际上是基于模板）在编译时会将每个模板都展开编译成不同的数据结构。</p>\n<p>泛型的基本语法主要有以下几种：</p>\n<ul>\n<li>上界约束：<code>Data&lt;? extends SuperType&gt;</code></li>\n<li>下届约束：<code>Data&lt;? super BaseType&gt;</code></li>\n<li>并列约束：<code>Data&lt;? extends BaseType &amp; ITypeA &amp; ITypeB&gt;</code></li>\n</ul>\n<h3 id=\"1-1-上界约束和下届约束\"><a href=\"#1-1-上界约束和下届约束\" class=\"headerlink\" title=\"1.1 上界约束和下届约束\"></a>1.1 上界约束和下届约束</h3><p>在日常编码中绝大多数场景下都是用上界约束 <code>extends</code> 而极少见到 <code>super</code>，网上对于这两个约束的区别通常解释为：</p>\n<blockquote>\n<ul>\n<li><code>extends</code>：用于限定泛型类型的上界，表示类型参数必须是指定的类或其子类</li>\n<li><code>super</code>：用于限定泛型类型的下界，表示类型参数必须是指定的类或其父类</li>\n</ul>\n</blockquote>\n<p>约等于废话。要理解它们的适用场景可以参考以下例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设有一个工厂负责生产多种手机，设计如下手机数据结构：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasePhone</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">extends</span> <span class=\"title\">IBasePhone</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addFaceId</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Samsung</span> <span class=\"keyword\">extends</span> <span class=\"title\">BasePhone</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addBoomb</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设有一个工厂 PhoneFactory，它可以：</span></span><br><span class=\"line\"><span class=\"comment\">//   - 接受一系列手机信息用于生产；</span></span><br><span class=\"line\"><span class=\"comment\">//   - 给出一系列已经生产好的手机给用户使用；</span></span><br><span class=\"line\"><span class=\"comment\">// 设计如下工厂数据结构：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createPhones</span><span class=\"params\">(List&lt;? extends BasePhone&gt; phones)</span> </span>&#123; ... &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;? <span class=\"keyword\">super</span> BasePhone&gt; getAllPhones() &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（1）对于 <code>createPhones</code> 方法，<code>PhoneFactory</code> 接收到的集合中的对象必须满足 <code>T extends BasePhone</code>，也就是说 <code>PhoneFactory</code> 在访问其中元素时已知每一个元素都可能会包含除了 <code>BasePhone</code> 以外的信息，就像 <code>Apple</code> 和 <code>Samsung</code> 一样每个手机都要添加不同的零部件。此时 <code>PhoneFactory</code> 只能读取其中的元素而无法添加任何元素，因为：</p>\n<ul>\n<li>编译器无法推断存入的元素到底是 <code>BasePhone</code> 的哪一个子类；</li>\n<li>编译器可以将所有取出的元素赋值为基类 <code>BasePhone</code>，等同于「将子类对象赋值给基类引用」；</li>\n</ul>\n<p>这也明确了 <code>PhoneFactory</code> 作为消费者（消费 <code>phones</code> 列表）的职责。</p>\n<p>（2）对于 <code>getAllPhones</code> 方法，<code>PhoneFactory</code> 返回的集合中的对象必须满足 <code>T super BasePhone</code>，也就是说用户访问到的元素（手机）最多只能包含 <code>BasePhone</code> 所含有的信息（即手机的最基本功能）。此时 <code>PhoneFactory</code> 只能向列表中添加元素而无法读取任何元素，因为：</p>\n<ul>\n<li>编译器可以将每个元素都视为基类后存入集合中；</li>\n<li>编译器无法推断取出来的元素到底应该赋值为哪个类型，等同于「无法将基类对象赋值给子类引用」，除非使用 <code>Object</code> 类型引用；</li>\n</ul>\n<p>这也明确了 <code>PhoneFactory</code> 作为生产者（生产 <code>allPhones</code> 列表）的职责。</p>\n<p>当然在本例中，两个方法都可以直接使用 <code>List&lt;BasePhone&gt;</code> 代替，但这只是一种普遍存在的偷懒做法，如果有更好的规范来约束数据结构、增强代码可读性，为什么不呢？</p>\n<h3 id=\"1-2-并列约束\"><a href=\"#1-2-并列约束\" class=\"headerlink\" title=\"1.2 并列约束\"></a>1.2 并列约束</h3><p>可能很多人此刻才知道原来泛型还能并列声明，并列泛型可以同时对类型增加多个类或接口的约束，但是当存在多个并列约束时，仅有第一个声明可以是 <code>class</code> 类型，此时其他的生命都必须为 <code>interface</code> 类型；或是全部都为 <code>interface</code> 类型。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// T 的实际类型必须同时满足以下条件：是 BaseType 或子类、并且实现了 ITypeA 和 ITypeB 接口。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Data&lt;T extends BaseType &amp; ITypeA &amp; ITypeB&gt; data_1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// K 的实际类型必须同时满足以下条件：实现了 ITypeA, ITypeB, ITypeC 接口。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Data&lt;K extends ITypeA &amp; ITypeB &amp; ITypeC&gt; data_2;</span><br></pre></td></tr></table></figure>\n\n<p>但是要注意：当存在并列约束时，编译后的约束类型仅会保留第一个泛型声明，其他类型均是通过强转实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doBaseType</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITypeA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTypeA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITypeB</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTypeB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends BaseType &amp; ITypeA &amp; ITypeB&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWithType</span><span class=\"params\">(T type)</span> </span>&#123;</span><br><span class=\"line\">    type.doBaseType(); <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\">    type.doTypeA(); <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\">    type.doTypeB(); <span class=\"comment\">// 编译通过</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译以上代码之后的字节码为（省略部分）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">public &lt;T extends com.example.BaseType &amp; com.example.ITestA &amp; com.example.ITestB&gt; void doWithType(T);</span><br><span class=\"line\">    descriptor: (Lcom/example/BaseType;)V</span><br><span class=\"line\">    flags: (0x0001) ACC_PUBLIC</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">        stack=1, locals=2, args_size=2</span><br><span class=\"line\">             0: aload_1</span><br><span class=\"line\">             1: invokevirtual #16             // Method com/example/BaseType.doBaseType:()V</span><br><span class=\"line\">             4: aload_1</span><br><span class=\"line\">             5: checkcast     #17             // class com/example/ITypeA</span><br><span class=\"line\">             8: invokeinterface #18,  1       // InterfaceMethod com/example/ITypeA.doTypeA:()V</span><br><span class=\"line\">            13: aload_1</span><br><span class=\"line\">            14: checkcast     #19             // class com/example/ITestB</span><br><span class=\"line\">            17: invokeinterface #20,  1       // InterfaceMethod com/example/ITestB.doTypeB:()V</span><br><span class=\"line\">            22: return</span><br></pre></td></tr></table></figure>\n\n<p>注意 <code>descriptor</code> 中只包含了 <code>BaseType</code> 类型，而方法实现中的 <code>checkcast</code> 就是强制类型转换，反编译成代码如下（省略部分）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends BaseTest &amp; ITestA &amp; ITestB&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTest</span><span class=\"params\">(T testObj)</span> </span>&#123;</span><br><span class=\"line\">    testObj.baseTest();</span><br><span class=\"line\">    ((ITestA)testObj).testA();</span><br><span class=\"line\">    ((ITestB)testObj).testB();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-上界和下届嵌套约束\"><a href=\"#1-3-上界和下届嵌套约束\" class=\"headerlink\" title=\"1.3 上界和下届嵌套约束\"></a>1.3 上界和下届嵌套约束</h3><p>此外，上界约束和下届约束是可以同时存在的，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends Comparable&lt;? <span class=\"keyword\">super</span> T&gt;&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWithType</span><span class=\"params\">(T type)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对上例中的泛型 <code>T</code> 拆解：</p>\n<p>（1）首先 <code>T</code> 需要满足：实现了 <code>Comparable&lt;? super T&gt;</code> 接口，注意 <code>super</code> 约束意味着实现的接口不能使用子类，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 符合泛型约束 Comparable&lt;? super T&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseType</span> <span class=\"title\">implementation</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">BaseType</span>&gt; </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不符合泛型约束 Comparable&lt;? super T&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseType</span> <span class=\"title\">implementation</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">SubType</span>&gt; </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubType</span> <span class=\"title\">extands</span> <span class=\"title\">BaseType</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）其次 <code>T</code> 需要满足：作为实现了 <code>Comparable&lt;? super T&gt;</code> 的类型本身或其子类，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BaseType 和 SubType 均符合 T 的定义：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseType</span> <span class=\"title\">implementation</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">BaseType</span>&gt; </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubType</span> <span class=\"title\">extands</span> <span class=\"title\">BaseType</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然上下界约束嵌套的情况比较少见，了解其解析规则即可。</p>\n<hr>\n<h2 id=\"2-运行时泛型\"><a href=\"#2-运行时泛型\" class=\"headerlink\" title=\"2. 运行时泛型\"></a>2. 运行时泛型</h2><p>泛型信息存储在类信息中，但类信息有两种载体：</p>\n<ul>\n<li>静态类信息：<code>Object.class</code></li>\n<li>对象类信息：<code>(new Object()).getClass()</code></li>\n</ul>\n<p>而泛型实际上保存在 <strong>对象类信息</strong> 中，而所有类型都可以分成两种：</p>\n<ul>\n<li>Parameterized Type（参数化类型）：表示含有泛型信息的类型</li>\n<li>Raw Type（原始类型）：表示不包含泛型的原始类型</li>\n</ul>\n<p>编译后泛型会被擦除成 Raw Type，但 <strong>满足一定条件</strong> 的泛型会以 Parameterized Type 的形式保存在对象类信息中，这于泛型的擦除机制有关。</p>\n<h3 id=\"2-1-泛型擦除的规则\"><a href=\"#2-1-泛型擦除的规则\" class=\"headerlink\" title=\"2.1 泛型擦除的规则\"></a>2.1 泛型擦除的规则</h3><p>泛型擦除遵循以下规则：</p>\n<p>（1）无约束泛型被擦除为 <code>Object</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译前：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译后：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）约束泛型被擦除为约束类型本身：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译前：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends BaseData&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(T data)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T <span class=\"keyword\">super</span> BaseData&gt; getData() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译后：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(BaseData data)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> BaseData <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>（3）多约束泛型被擦除为第一个约束类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译前：</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends BaseType &amp; IType&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doWithType</span><span class=\"params\">(T type)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译后：</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：反编译工具在反编译时仍然会将入参 type 自动转换为 T 类型，</span></span><br><span class=\"line\"><span class=\"comment\">//      但实际上在字节码中，方法参数定义（descriptor）的类型只有 BaseType，详见前文。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doWithType</span><span class=\"params\">(BaseType type)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>（4）泛型容器类被擦除为原始类型（Raw Type）容器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译前：</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;KeyType, ValueType&gt; map;</span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;List&lt;DataType&gt;&gt; nestedList;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Set&lt;DataType&gt;[] setArray;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译后：</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map map; <span class=\"comment\">// 等同于 Map&lt;Object, Object&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List nestedList; <span class=\"comment\">// 等同于 List&lt;Object&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Set[] setArray; <span class=\"comment\">// 等同于 Set&lt;Object&gt;[]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此外，如果通过反编译去分析泛型类的字节码，会发现实际上字节码记录了泛型的详细上下文，但是这并不意味着都可以在运行时可以被 JVM 读取和使用。</p>\n<p><a href=\"https://stackoverflow.com/a/29375667\">Java Generics Type Erasure byte code</a></p>\n</blockquote>\n<h3 id=\"2-2-泛型保留的条件\"><a href=\"#2-2-泛型保留的条件\" class=\"headerlink\" title=\"2.2 泛型保留的条件\"></a>2.2 泛型保留的条件</h3><p>泛型类在编译后其泛型信息会被擦除为 Object，泛型会被转移到实际使用了泛型的变量或方法中（如果没有则彻底丢失存根），所以编译后的类已经丢失了自己声明的泛型信息，但可通过 <code>Class#getGenericSuperClass()</code> 获取父类（包括匿名类，本质上也是一种父类）携带的泛型信息。接口可以理解为一种特殊的父类，可通过<code>Class#getGenericInterfaces()</code> 获取接口上的泛型信息。</p>\n<ul>\n<li>符号泛型（泛型仅以符号形式存在，没有被具体类型显式定义）在编译时被擦除；</li>\n<li>参数泛型（泛型被具体类型显式定义和替换）将被保留至实例化对象的类信息中；</li>\n</ul>\n<p>假设定义以下类关系：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">IBase</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bypass</span>&lt;<span class=\"title\">K</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Base</span>&lt;<span class=\"title\">K</span>&gt; </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Base</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>（1）符号泛型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Bypass&lt;Short&gt; bypass_a = <span class=\"keyword\">new</span> Bypass&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p><code>Bypass</code> 上的泛型 <code>Short</code> 本身并没有「显式」地被传递至父类 <code>Base</code>，传递的仅是泛型符号 <code>K</code>，因此 <code>bypass_a</code> 被擦除自身泛型后将丢失 <code>K</code> 对应的实际类型。</p>\n<p>（2）参数泛型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Child&lt;Integer&gt; child = <span class=\"keyword\">new</span> Child();</span><br></pre></td></tr></table></figure>\n\n<p><code>Child</code> 在继承 <code>Base</code> 时「显式」地为 <code>Base</code> 的泛型 <code>T</code> 指定了 <code>String</code> 类型，因此实例对象 <code>child</code> 将丢失 <code>Child</code> 自身声明的泛型 <code>Integer</code>，但会保留父类 <code>Base</code> 的泛型 <code>String。</code></p>\n<p>（3）匿名内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Bypass&lt;Float&gt; bypass_b;</span><br><span class=\"line\">bypass_b = <span class=\"keyword\">new</span> Bypass() &#123; ... &#125;;        <span class=\"comment\">// ❌ 编译报错</span></span><br><span class=\"line\">bypass_b = <span class=\"keyword\">new</span> Bypass&lt;Float&gt;() &#123; ... &#125;; <span class=\"comment\">// ✅ 编译通过</span></span><br></pre></td></tr></table></figure>\n\n<p>匿名内部类也是一种特殊的子类实现，因此等同于为泛型指定了实际类型。创建匿名内部类时，编译器会要求「显式」声明泛型信息（即等号右侧的泛型类型不能省略），此时的 <code>bypass_b</code> 是 <code>Bypass</code> 的匿名子类对象，因此此处的 <code>Bypass</code> 实际上是父类，并且编译器强制要求将泛型 <code>Float</code> 传递给 <code>Bypass</code>，因此 <code>bypass_b</code> 保留了父类 <code>Bypass</code> 上的泛型信息。</p>\n<p>（4）泛型嵌套：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Base&lt;Double&gt;&gt; list_a = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">List&lt;Base&lt;Double&gt;&gt; list_b = <span class=\"keyword\">new</span> List&lt;Base&lt;Double&gt;&gt;() &#123;...&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>嵌套泛型可以逐级拆解，每一级均同样遵循以上规则：</p>\n<ul>\n<li><code>list_a</code> 没有「显式」地将泛型传递至 <code>ArrayList</code>，因此 <code>list_a</code> 丢失了泛型信息；</li>\n<li><code>list_b</code> 是匿名内部类的实例对象，因此保留了所有泛型信息，包括 <code>Base</code> 和其嵌套的 <code>Double</code>。需要注意：<ul>\n<li><code>list_b.getClass()</code> 才是真正包含了所有泛型信息的类对象；</li>\n<li>如果通过 <code>list_b</code> 获取到实际的泛型类型 <code>Base</code>，然后再直接对 <code>Base</code> 获取泛型，则无法获取到嵌套的泛型 <code>Double</code>，因为此时获取到的 <code>Base</code> 类不遵循「参数泛型」的规则。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-解析泛型\"><a href=\"#3-解析泛型\" class=\"headerlink\" title=\"3. 解析泛型\"></a>3. 解析泛型</h2><p>将泛型解析为实际类型是一个很常见的需求，例如事件监听：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends BaseEvent&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addListener</span><span class=\"params\">(Class&lt;T&gt; clz, IListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends BaseEvent&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeListener</span><span class=\"params\">(Class&lt;T&gt; clz, IListener&lt;T&gt; listener)</span> </span>&#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>IListener&lt;T&gt;</code> 需要和泛型 <code>T</code> 的事件绑定注册，但由于 <code>T</code> 不是真实的类型，因此无法使用 <code>T.class</code> 或 <code>obj instanceof T</code> 之类的方法，导致必须另外传一个 <code>Class&lt;T&gt;</code> 用于标定 <code>T</code> 的实际类型，这个写法很不优雅。</p>\n<h3 id=\"3-1-解析单个泛型\"><a href=\"#3-1-解析单个泛型\" class=\"headerlink\" title=\"3.1 解析单个泛型\"></a>3.1 解析单个泛型</h3><p>从对象中解析出泛型的实际类型，已经有通用的方案：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; getGenericClass(Object obj) &#123;</span><br><span class=\"line\">    Type superClassType = obj.getClass().getGenericSuperclass();</span><br><span class=\"line\"></span><br><span class=\"line\">    Type genericType = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (superClassType <span class=\"keyword\">instanceof</span> ParameterizedType) &#123;</span><br><span class=\"line\">        genericType = ((ParameterizedType) superClassType).getActualTypeArguments()[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (genericType != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Class&lt;?&gt;) genericType;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是该方案只能解析类似于 <code>IListener&lt;TheEvent&gt;</code> 这种最基础的泛型形式。</p>\n<h3 id=\"3-2-解析嵌套泛型\"><a href=\"#3-2-解析嵌套泛型\" class=\"headerlink\" title=\"3.2 解析嵌套泛型\"></a>3.2 解析嵌套泛型</h3><p>假设此时有以下两个 Listener 类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">IListener&lt;Content&lt;Integer&gt;&gt; listener_a;</span><br><span class=\"line\">IListener&lt;Content&lt;String&gt;&gt; listener_b;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然实际业务中这不是主流使用场景，或者也可以通过 Wrapper 来规避，但本文重在探讨如何解析。</p>\n</blockquote>\n<p>使用上文的解析方式只能解析出外层泛型类型 <code>Content</code></p>\n<h3 id=\"3-3-解析匿名类泛型\"><a href=\"#3-3-解析匿名类泛型\" class=\"headerlink\" title=\"3.3 解析匿名类泛型\"></a>3.3 解析匿名类泛型</h3><hr>\n<h2 id=\"4-通用泛型解析工具\"><a href=\"#4-通用泛型解析工具\" class=\"headerlink\" title=\"4. 通用泛型解析工具\"></a>4. 通用泛型解析工具</h2><hr>\n","categories":["Java"],"tags":["Java","泛型","Generic"]},{"title":"Java-HashCode","url":"/post/java/java-hashcode/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-HashCode\"><a href=\"#Java-HashCode\" class=\"headerlink\" title=\"Java-HashCode\"></a>Java-HashCode</h1><h2 id=\"1-Equals和-的区别\"><a href=\"#1-Equals和-的区别\" class=\"headerlink\" title=\"1. Equals和==的区别\"></a>1. Equals和==的区别</h2><p><code>==</code> 仅在相比较的对象就是自己本身时，才返回 <code>true</code>。而 <code>equals</code> 是 Object 类中的方法，其返回值可以根据需求定义，默认情况下，<code>equals</code> 返回的也是 <code>==</code> 的值，但在像 HashMap、Array 中等则会返回 key 或 value 是否相等。</p>\n<p>由于 String 和常数是存放在常量池，因此直接比较 String 的值时，相同的字符串两个都会返回 <code>true</code>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String sa = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">String sb = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">String sc = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">String sd = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sa == sb <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">sa.equals(sb) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">sc == sd <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">sc.equals(sd) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">42</span> == <span class=\"number\">42.00</span> <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-为什么要同时重写equals-和hashcode\"><a href=\"#2-为什么要同时重写equals-和hashcode\" class=\"headerlink\" title=\"2. 为什么要同时重写equals()和hashcode()\"></a>2. 为什么要同时重写equals()和hashcode()</h2><p>默认情况下，equals比较的是两个对象的内存地址是否相等，重写equals 方法通常是转换成比较值是否相等，如果重写了equals方法而不重写hashcode方法，默认情况下hashcode是根据对象的内存地址计算的，则可能出现equals为true而hashcode不相等的情况，这和hashcode的本意是不符的。HashCode不相等的两个对象一定不相等，相等的两个对象HashCode一定向等。</p>\n<p>（1）为什么要有HashCode方法？</p>\n<p>可以根据HashCode来判断两个对象是否相等，而不需要依次比较equals。switch判断String时，判断的是hashCode。</p>\n<p>（2）hash算法的原理是什么？</p>\n<p>（3）在Java中哪些地方用到了HashCode？</p>\n","categories":["Java"],"tags":["Java","Equals"]},{"title":"Java-HashMap","url":"/post/java/java-hashmap/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-HashMap\"><a href=\"#Java-HashMap\" class=\"headerlink\" title=\"Java-HashMap\"></a>Java-HashMap</h1><h2 id=\"1-哈希散列表\"><a href=\"#1-哈希散列表\" class=\"headerlink\" title=\"1. 哈希散列表\"></a>1. 哈希散列表</h2><p>HashMap的最基本原理就是哈希表，哈希表也就是，把一组不相干的数据，通过哈希函数计算后，映射到一个数组中，这样通过数组下标就能直接确认原来数据的存储位置。但哈希映射有可能会导致哈希碰撞，解决方案有：开放定址法、再散列函数法、链地址法，而HashMap采用的是链地址法。</p>\n<h3 id=\"1-1-开放定址法\"><a href=\"#1-1-开放定址法\" class=\"headerlink\" title=\"1.1 开放定址法\"></a>1.1 开放定址法</h3><p>开放定址法的核心思想就是增加偏移量，其中增加偏移量的方法有多种：线性探测、平方探测等，但整体思路是类似的。当插入一个新的数据时，发现经过哈希计算后，原Key的目标插入节点已经被占用了，发生碰撞，则向后偏移一位，再次检测，如果仍旧发生碰撞则继续偏移，直到到达数组尾端，根据不同的策略，可以绕回到数组头（负偏移）或扩大散列表。</p>\n<p>线性探测会导致元素聚集，这和哈希散列表的初衷不符。</p>\n<p>平方探测则是用：1, -1, 4, -4 ... 这样的方式进行左右跳跃性查找。</p>\n<p>伪随机探测，即一开始就定义一个伪随机数列，每次发生冲突即从伪随机数列中取出下一个伪随机数作为偏移量。</p>\n<h3 id=\"1-2-再散列函数法\"><a href=\"#1-2-再散列函数法\" class=\"headerlink\" title=\"1.2 再散列函数法\"></a>1.2 再散列函数法</h3><p>也即每次发生冲突时，就再用哈希函数散列一次。缺点是增大计算量。</p>\n<h3 id=\"1-3-链地址法\"><a href=\"#1-3-链地址法\" class=\"headerlink\" title=\"1.3 链地址法\"></a>1.3 链地址法</h3><p>也即，哈希表的主体是一个数组，数组的每一个结点，都是一个链表，当发生哈希碰撞时，后插入的Key则插入到对应结点的链表的末端。</p>\n<p>如果不存在哈希冲突，也即 HashMap 数组中不包含链表，则每次添加、查找都是单次寻址，时间复杂度为 O(1)。如果目标节点存在哈希冲突，则添加、查找都需要遍历整个链表，时间复杂度为 O(n)，其中：查找时，通过 key 对象的 equals 方法逐一比较，相同则返回；新增时，遍历链表，若存在相同 key，则覆盖，否则新增至链表末端。</p>\n<p>hashMap 与 hashTable 其中不同的一点是 HashMap 允许 key 为 null，把 key 为 null 的对象存在数组首位（<code>table[0]</code>）。</p>\n<hr>\n<h2 id=\"2-HashMap源码分析\"><a href=\"#2-HashMap源码分析\" class=\"headerlink\" title=\"2. HashMap源码分析\"></a>2. HashMap源码分析</h2><h3 id=\"2-1-静态内部类Entry\"><a href=\"#2-1-静态内部类Entry\" class=\"headerlink\" title=\"2.1 静态内部类Entry\"></a>2.1 静态内部类Entry</h3><p>HashMap 有一个静态内部类 Entry，其源码清晰描述了 HashMap 数组 + 链表 的数据结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 存储指向下一个Entry的引用，单链表结构</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Creates new entry.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">        next = n;</span><br><span class=\"line\">        key = k;</span><br><span class=\"line\">        hash = h;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">          V oldValue = value;</span><br><span class=\"line\">          value = newValue;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-HashMap的重要成员变量\"><a href=\"#2-2-HashMap的重要成员变量\" class=\"headerlink\" title=\"2.2 HashMap的重要成员变量\"></a>2.2 HashMap的重要成员变量</h3><ul>\n<li><code>transient Entry[] table;</code>：实际存储键值对的表。<br><code>transient</code> 关键字仅可修饰成员变量，表示“禁止序列化该数据”，其意义是：HashMap 本身的数组，通常会有很多空闲的节点，对空闲的节点空间序列化没有意义，所以其手动实现了 <code>writeObject()</code> 方法进行实际的序列化。<code>table</code>、<code>size</code>、<code>modCount</code> 都被 <code>transient</code> 关键字修饰，是因为每次 HashMap 执行 put 或 remove 操作后，三者都会发生变化，由于三者状态常变，所以没有必要在默认序列化类对象时将其指代入。</li>\n<li><code>static final int DEFAULT_INITIAL_CAPACITY = 16;</code>：默认初始容量为 16，必须为 2 的幂。</li>\n<li><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>：最大容量，必须为 2 的幂且要小于 2 的 30 次方，传入大于该值的参数将被该值替换。</li>\n<li><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>：默认加载因子。</li>\n<li><code>final float loadFactor;</code>：实际加载因子。</li>\n</ul>\n<p>为了降低哈希冲突的概率，默认当 HashMap 中的键值对达到数组大小的 75% 时，会触发扩容操作。因此如果预估容量是 100，即需要设定 100 / 0.75 ＝ 134 的数组大小。</p>\n<ul>\n<li><code>transient int size</code>：Map 中实际存储的键值对个数。</li>\n<li><code>threshold</code>：阈值。</li>\n<li><code>transient volatile int modCount;</code>：HashMao 被改变的次数，用于快速失败。</li>\n</ul>\n<blockquote>\n<p><code>volatile</code> 关键字修饰的成员变量，可以阻禁止代码重排序，保证所有的写操作都在读操作之前，使得变量在内存中的变化可以被多线程所知。由于 HashMap 线程不安全，<code>modCount</code> 用于快速失败机制，所以写线程执行时带来的变化需要及时被读线程所知。</p>\n<p>put 操作时，若 key 已存在替换 value 时，<code>modCount</code> 不会增加，不存在新增时才会增加。也即，只有 HashMap 中元素的数量增多或减少时，才认为 HashMap 的结构发生了变化。</p>\n</blockquote>\n<h3 id=\"2-3-HashMap长度必须为2的幂\"><a href=\"#2-3-HashMap长度必须为2的幂\" class=\"headerlink\" title=\"2.3 HashMap长度必须为2的幂\"></a>2.3 HashMap长度必须为2的幂</h3><p>HashMap 在将一个 key 经过 hash 后映射进数组节点中时，经过了如下运算：</p>\n<ol>\n<li>计算 key 的 二次 hash；</li>\n<li>将 hash 值的二进制与 HashMap 的 (length - 1) 的二进制进行 &amp; 与运算；</li>\n<li>得出的结果即为需要存进的数组节点下标。</li>\n</ol>\n<p>（1）如果数组长度为 2 的幂，则 (length - 1) 的二进制一定是各个位都是 1，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>^<span class=\"number\">4</span> - <span class=\"number\">1</span> = <span class=\"number\">15</span>(d) = <span class=\"number\">1111</span>(b)</span><br><span class=\"line\"><span class=\"number\">2</span>^<span class=\"number\">5</span> - <span class=\"number\">1</span> = <span class=\"number\">31</span>(d) = <span class=\"number\">11111</span>(b)</span><br></pre></td></tr></table></figure>\n\n<p>由于与运算是“两位为 1 才为 1”，因此用 hash 的二进制和 (length - 1) 的二进制做与运算，其结果就完全取决于 hash 的二进制数。例如：</p>\n<ul>\n<li>若 hash = 1011011，(length - 1) = 1111，则 hash &amp; (length - 1) = 1011。</li>\n<li>若 hash = 1101100010，(length - 1) = 11111，则 hash &amp; (length - 1) = 10。</li>\n</ul>\n<p>这样可以使得键值对尽可能均匀的分布在 HashMap 数组的各个节点。并且在扩容时，由于二进制的每一位只有可能是 1 或者 0，且扩容后的 (length - 1) 依然是各个位全为 1 的二进制数，也即经过与运算后，有一半几率该点依然位于原来的数组节点（而在链表中的位置则不确定），另一半的几率会被重新分配到其他的数组节点，从而可以保障扩容后键值对存储位置的均衡性。</p>\n<p>（2）假如 HashMap 的长度不是 2 的幂，也即 (length - 1) 的二进制中可能存在 0，例如：</p>\n<ul>\n<li>若 hash = 1011011，(length - 1) = 1001，则 hash &amp; (length - 1) = 1001。</li>\n<li>若 hash = 1101101111，(length - 1) = 1001，则 hash &amp; (length - 1) = 1001。</li>\n</ul>\n<p>不仅会导致哈希碰撞的概率增大，并且在上例中，由于 (length - 1) = 1001，则注定任何一个 hash 与之做与运算，其第 2、3 位都一定是 0，也即有些 HashMap 的数组节点则一定不会被用到。比如上例中当数组长度为 10 时，(length - 1) = 1001，则下标为：<code>0111(b) = 7(d)</code>、<code>0101(b) = 5(d)</code>、<code>0011(b) = 3(d)</code>、<code>0010(b) = 2(d)</code> 的数组节点一定不会被用于存储，这是显然不符合 Hash 散列表特性的。</p>\n<hr>\n<h2 id=\"3-HashMap流程\"><a href=\"#3-HashMap流程\" class=\"headerlink\" title=\"3. HashMap流程\"></a>3. HashMap流程</h2><p>在向 HashMap 存储数据时，会首先判断 key 是否为 null，如果为 null，则直接存入 <code>table[0]</code> 中，每次存储都会直接覆盖。若 key 不为 null，则会对 key 进行重哈希，也即哈希两次：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> hash = hash(key.hashCode());</span><br></pre></td></tr></table></figure>\n\n<p>通过计算出来的 hash 值，判断该键值对的目标数组节点下标：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>\n\n<p>然后遍历该节点中的链表，依次与之比较 hash 值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">    Object k;</span><br><span class=\"line\">    <span class=\"comment\">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">        V oldValue = e.value;</span><br><span class=\"line\">        e.value = value;</span><br><span class=\"line\">        e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若遍历链表中已存储的键值对对象 e 时发现已存在，即：<code>e.hash == hash</code>，则直接用新的 <code>value</code> 取代旧的并退出，否则也即遍历 <code>e = e.next</code> 直到 <code>e == null</code>，则调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">addEntry(hash, key, value, i);</span><br></pre></td></tr></table></figure>\n\n<p>将当前键值对存储到链表末端，并使前一个 <code>e.next</code> 指向该新键值对。</p>\n<hr>\n<h2 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h2><p><code>HashMap</code>、<code>HasTable</code>、<code>ConcurrentHashMap</code> 的关联与区别：</p>\n<ul>\n<li>HashTable 的 Key 和 Value 都不能为 Null，线程安全，在修改数据时给 <code>put()</code> 加锁锁住整个 HashTable。</li>\n<li>HashMap 的 Key 和 Value 都可以是 Null，线程不安全。<ul>\n<li>所以当 <code>HashMap.get(key)</code> 方法返回 <code>null</code> 时，可能是 key 对应的 value 为 <code>null</code>，也可能是没有找到对应的 key，因此判断 HashMap 中是否含有某个 key 时，应调用 <code>containsKey()</code> 方法。</li>\n<li>HashMap 是线程不安全的，其迭代器是 Fail-Fast（快速失败）的，也即：当有其他线程改变了 HashMap 的结构（增加或移除了元素），则有可能抛出 <code>ConcurrentModificationException</code> 异常，但迭代器本身的 <code>remove()</code> 则不会引起该异常。</li>\n</ul>\n</li>\n<li>ConcurrentHashMap 将整个 Map 分段为 N 个 Segment，每个 Segment 独立加锁，对于需要跨段的操作（如 <code>size()</code> 和 <code>containsValue()</code>）则按顺序锁住所有段，操作完毕后再按顺序释放所有段的锁。且 <code>Entry#value</code> 添加了 <code>volatile</code> 关键字，确保读操作获取到的是最新的数据，因此是线程安全的。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_40118851/article/details/82804510\" title=\"@LINK\">HashMap底层实现原理</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247503378&idx=1&sn=2b26e61ae4dee9d9e3570fbdbbcec80c\" title=\"@LINK\">ConcurrentHashMap中有十个提升性能的细节，你都知道吗？</a></li>\n</ul>\n","categories":["Java"],"tags":["Java","HashMap","集合框架"]},{"title":"JVM内存模型和内存分区","url":"/post/java/java-jvm_memory/","content":"<span id=\"more\"></span>\n\n<h1 id=\"JVM内存模型和内存分区\"><a href=\"#JVM内存模型和内存分区\" class=\"headerlink\" title=\"JVM内存模型和内存分区\"></a>JVM内存模型和内存分区</h1><p>前言：Java 和 Android 面试中，堆、栈、JVM 内存模型等几乎是必问题，但其实平时口头上，对堆、栈、堆栈、堆区、栈区、内存模型等等的概念是混淆的，因此专门用一篇文章来记录总结。</p>\n<hr>\n<h2 id=\"1-堆、栈和队列\"><a href=\"#1-堆、栈和队列\" class=\"headerlink\" title=\"1. 堆、栈和队列\"></a>1. 堆、栈和队列</h2><p>首先需要明确的是，堆、栈、队列是数据结构，堆是一种优先队列，可以采用二叉树实现；栈是一种线性表，其特点是：后进先出（Last In First Out，LIFO）；队列也是一种线性表，其特点是：先进先出（First In First Out，FIFO）。</p>\n<h3 id=\"1-1-堆（Heap）\"><a href=\"#1-1-堆（Heap）\" class=\"headerlink\" title=\"1.1 堆（Heap）\"></a>1.1 堆（Heap）</h3><p>堆（Heap）总是一颗完全二叉树，且某个节点的值总是不大于或不小于父节点的值。若某节点总是不大于父节点的值（即父节点大于等于子节点），称为最大堆或大根堆（Max Heap）；反之称为最小堆或小根堆（Min Heap）。常见的堆有：二叉堆、斐波那契堆等。</p>\n<blockquote>\n<p>完全二叉树可以这么理解：如果有一棵二叉树，只有最末端的节点可以有 0、1、2 个子节点，倒数第二层的节点要么没有子节点，要么必须有 2 个子节点，并且末端的节点都集中在左侧若干位置上，则该树称为完全二叉树。完全二叉树如下图所示：</p>\n</blockquote>\n<p><img data-src=\"./complete_binary_tree.jpg\" alt=\"完全二叉树图示\" title=\"@ASSET\"></p>\n<p>完全二叉树的详细解释可参考：<a href=\"https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin\" title=\"@LINK\">《百度百科——完全二叉树》</a> 或 <a href=\"https://blog.csdn.net/qq_22642239/article/details/80774013\" title=\"@LINK\">《完美二叉树, 完全二叉树和完满二叉树》</a>。</p>\n<h3 id=\"1-2-栈（Stack）\"><a href=\"#1-2-栈（Stack）\" class=\"headerlink\" title=\"1.2 栈（Stack）\"></a>1.2 栈（Stack）</h3><p>栈（Stack）是一种运算受限的线性表，其限制在于：仅允许从表的一端进行插入和删除操作。插入到栈中（入栈）的操作叫压栈（Push），从栈中删除（出栈）的操作叫弹出（Pop）。后入栈的数据先出栈（LIFO），类似于枪械弹匣，最后一颗压进弹匣的子弹在最上面，是第一发被打出去的。</p>\n<h3 id=\"1-3-队列（Queue）\"><a href=\"#1-3-队列（Queue）\" class=\"headerlink\" title=\"1.3 队列（Queue）\"></a>1.3 队列（Queue）</h3><p>队列（Queue）和栈类似，都是线性表，不同的是数据存取的顺序。队列中插入数据和取出数据分别在表的两端，且先插入的数据最先被取出。</p>\n<hr>\n<h2 id=\"2-JVM内存模型\"><a href=\"#2-JVM内存模型\" class=\"headerlink\" title=\"2. JVM内存模型\"></a>2. JVM内存模型</h2><p>首先需要强调一点：<strong>JVM 的内存模型和 JVM 的内存分区（内存结构）不是一回事</strong>！</p>\n<p>JVM 内存模型描述了 Java 程序各类型变量的访问规则，以及在 JVM 中将变量从内存中存储或读取的底层标准。</p>\n<p>JVM 内存模型有两个重要准则：</p>\n<ul>\n<li>所有的变量都存储在主内存中。</li>\n<li>每个线程都有自己的工作内存，里面保存了该线程使用到的变量在主内存中的一个副本。</li>\n</ul>\n<p>并且 JVM 的内存模型还规定：</p>\n<ul>\n<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li>\n<li>不同线程之间无法访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>\n</ul>\n<p>为了在多个线程访问同一个共享变量时，能保证共享变量具有实时性，JVM 内存模型还遵循：缓存一致性协议。该协议规定，如果一个线程将共享变量回写进主内存，该动作会导致其他线程中的该共享变量的 Cache 失效，但线程在修改完一个共享变量时，并不一定会马上将其回写进主内存，而 <code>volatile</code> 修饰符即是用来声明，一个变量在被修改（写入）后，立即回写进主内存，并更新到其他线程中。</p>\n<p>可参考：<a href=\"https://www.jianshu.com/p/bf158fbb2432\" title=\"TOLINSK\">什么是Java内存模型</a></p>\n<hr>\n<h2 id=\"3-JVM中的5个区\"><a href=\"#3-JVM中的5个区\" class=\"headerlink\" title=\"3. JVM中的5个区\"></a>3. JVM中的5个区</h2><p>在 JDK 1.8（不含）之前，JVM 的内存分为 5 个区：堆区、栈区、方法区、本地方法区、程序计数器。</p>\n<p>堆区（Heap）和栈区（Stack）是内存模型，虽然英文一样，而且也常常被简称为堆和栈，但实际上他们和数据结构中的堆、栈是完全不一样的概念，底层也并不是直接使用数据结构中的堆和栈的存储方式来实现，只是比较类似。</p>\n<p>堆区是存储的单位，而栈区是运行时的单位。通俗地说：堆区解决程序数据存储的问题，负责管理数据怎么放、放在哪；而栈区解决程序运行的问题，负责管理程序怎么运行、怎么处理堆中的数据。</p>\n<h3 id=\"3-1-栈区（Stack-Area）\"><a href=\"#3-1-栈区（Stack-Area）\" class=\"headerlink\" title=\"3.1 栈区（Stack Area）\"></a>3.1 栈区（Stack Area）</h3><p>栈区和线程相关，每个线程有自己独立的栈区且不共享，因此栈区是线程安全的。OS 在切换线程时会自动切换栈区（即切换 SS / ESP 寄存器）。栈区内存不需要手动分配和释放。</p>\n<p>在 Android 中，栈是 Dalvik 的内存指令区，用于存储：基本数据类型、方法内部的简单类型变量、对象地址。</p>\n<ul>\n<li>局部变量中的基本数据类型：byte，short，int，long，float，double，char，boolean。需要注意的是，成员变量中的基本数据类型存放在堆区。</li>\n<li>对象引用：通常大多数对象都会存在堆区中，而把对象的引用（即对应在堆中的地址）存在栈区，当调用一个对象时，就可以快速地从栈区找到该对象的引用，并通过引用找到堆区中的实例。</li>\n</ul>\n<p>栈区存放的是多个栈帧，每个栈帧对应了可以被线程调用的一个方法，栈帧中包括：局部变量表（Local Variables）、操作数栈（Operand Stack）、指向当前方法所属类的运行时常量池的引用（Reference to Runtime Constant Pool，当方法内有 String 类型变量时，用于查询常量池中是否已经存在常量）、方法返回地址（Return Address）、以及一些额外的附加信息。当线程执行一个方法时，就会创建对应的栈帧，并将其压栈。方法执行完毕后即弹出。因此，线程当前执行的方法一定在栈区的顶部，而递归方法时，也相对更容易出现栈区内存溢出的情况。</p>\n<p>由于栈区中存储的都是内存占用较小，且固定长度的变量，例如基本数据类型、对象的引用（仅仅只是一个地址，通常为 4 位，指向堆区或常量池中实际存放的对象），因此栈区的内存是连续、且在创建栈帧时就提前分配好的，所以栈区的内存不需要也无法手动管理，当调用所需变量时，仅需将指针按预定义的长度移动即可，因此分配和释放内存的效率都比堆区快得多。</p>\n<blockquote>\n<p>Java 中，对于 byte、short、char 这些基本数据类型，本来比 int 占用的内存更少，对一些标志位、临时变量等，使用这些代替 int 似乎应该效率更高，实际上 JVM 中，在处理这些数据的加法操作时，会先隐式转换成 int 类型再操作。例如以下代码会编译报错：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">byte</span> c = a + b;  <span class=\"comment\">// 编译报错：Type mismatch: cannot convert from int to byte</span></span><br></pre></td></tr></table></figure>\n\n<p>这么做的意义其实是在于，Java 中 int 和 float 是 4 字节 32 位，long 和 double 是 8 字节 64 位，这些类型都能以 4 字节为单位，位移 1 倍或 2 倍得到，而 byte、short、char 分别只有 1、2、2 字节，如果先统一转为 4 字节 int 类型，寻址的时候就能极大提高效率。当然选择 int 作为标准的原因主要也是因为 int 的长度在中间，如果选择 8 字节的 long 或 double，则会大量浪费内存空间，选择 2 字节的 char 或 short，则很多变量都需要不止一个内存块来存储，降低效率。</p>\n<h3 id=\"3-2-堆区（Heap-Area）\"><a href=\"#3-2-堆区（Heap-Area）\" class=\"headerlink\" title=\"3.2 堆区（Heap Area）\"></a>3.2 堆区（Heap Area）</h3><p>堆区通常和进程相关，进程建立初始化时会分配默认堆区，运行过程中也可以申请额外的堆区空间，但在需要手动释放，否则会导致内存泄漏，未释放的内存在进程结束时由 OS 回收。堆区分为全局堆和局部堆，全局堆就是所有未分配的堆区空间，局部堆则是用户分配的堆区空间。多个线程可以访问同一个堆区，当然也可以申请额外的堆区空间。</p>\n<p>在 Android 中，堆是 Dalvik 的内存数据区，用于存储：对象实例数据、方法内部的复杂类型变量、动态属性。</p>\n<ul>\n<li>对象实例数据：包括对象实例的属性、属性类型、对象本身的类型标记等，但是并不会保存对象实例的方法（类方法），实例方法属于数据指令，保存在方法区中。</li>\n<li>方法内部的复杂类型变量：例如方法内使用了自定义类的实例对象等。</li>\n<li>非静态成员变量：所有没有使用 <code>static</code> 修饰的成员变量，包括基本数据类型。</li>\n</ul>\n<p>堆区的内存是不连续且无序的，分配和释放内存的成本都比较高。例如在分配堆内存时，可能需要在堆区搜索多个空间，如果内存碎片（多次分配和释放后，会造成占用内存和可用内存互相掺杂）太多，则会消耗较长时间来搜索可用内存区，甚至需要向 OS 申请分配新的堆区空间，因此堆区的效率较低，但是内存分配更加自由，内存的分配和释放可以手动控制。</p>\n<blockquote>\n<p>实际上，如果 JVM 开启了 <strong>逃逸分析（Escape Analysis）</strong>，会在满足一定条件时，将本应存在堆区中的变量存在栈区，便于内存的释放。例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DemoClass demoClass = <span class=\"keyword\">new</span> DemoClass();</span><br><span class=\"line\">    demoClass.demoData = <span class=\"number\">5</span>;  <span class=\"comment\">// int 型</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoClass.demoData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>本来，<code>demoClass.demoData</code> 虽然是基本数据类型 int，但由于它是一个类成员动态属性，因此随所属对象 <code>demoClass</code> 被分配在堆区。如果 JVM 开启了逃逸分析，则优化后会将该段代码转换为如下的形式运行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> demoData = <span class=\"number\">5</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就将 <code>demoData</code> 存在了栈区，提高了内存分配和回收的效率。但是逃逸分析优化有一定的前提：原本存在堆区的对象，仅在方法体内部有效。如果该对象与方法体外部有交互（即逃逸），则不会优化。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">demoFun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DemoClass demoClass = <span class=\"keyword\">new</span> DemoClass();</span><br><span class=\"line\">    demoClass.demoData = <span class=\"number\">5</span>;  <span class=\"comment\">// int 型</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;Demo data is : &quot;</span> + demoClass.demoData);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> demoClass.demoData;  <span class=\"comment\">// 逃逸到外部</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，堆区本身又有 3 个区域划分：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。</p>\n<p>（1）新生代：所有新生成的对象都在新生代，新生代的目标就是尽可能快速的收集生命周期短的对象。新生代又分为三个区（通常是两个 Survivor 区，但也可以增加）：Eden 区，Survivor 1 区，Survivor 2 区。</p>\n<ul>\n<li>Eden 区：大部分对象在 Eden 区生成，当 Eden 区满了 GC 后存活下来的对象将随机复制到其中一个 Survivor 区。</li>\n<li>Survivor区：当一个 Survivor 区满了 GC 后存活下来的对象，如果是来自 Eden 区，则复制到另一个 Survivor 区，如果是来自另一个 Survivor 区，则复制到老年代。</li>\n</ul>\n<p>通俗地说，如果一个对象首先在 Eden 区中被创建，Eden 经过 GC 后存活，则被复制到其中一个 Survivor 区，如果这个 Survivor 经过 GC 后还存活，则被复制到另一个 Survivor 区，如果另一个 Survivor 区经过 GC 后仍然存活，则复制到老年代。需要注意的是：两个 Survivor 区是平等的，没有优先级高低、顺序前后之分，都有可能接收来自 Eden 或另一个 Survivor 区传来的对象。Survivor 区可以手动配置为多于 2 个，即可增加对象在新生代中的时间，减小被复制到老年代的可能性。</p>\n<p>（2）老年代：在新生代中经过 N 次（N 即为新生代中区的数量）GC 后仍然存活的对象将进入老年代，通常都是生命周期比较长的对象。</p>\n<p>（3）永久代：一般用来存放类的信息（包括类名、类方法、字段信息等）、静态变量、常量池等不会改变的数据，但在 JDK 1.8 开始就使用元数据区取代了了永久代。</p>\n<h3 id=\"3-3-方法区（Method-Area）\"><a href=\"#3-3-方法区（Method-Area）\" class=\"headerlink\" title=\"3.3 方法区（Method Area）\"></a>3.3 方法区（Method Area）</h3><p>方法区和堆一样，是线程间共享的。方法区用于存放：类的信息、静态成员变量、运行时常量池等。</p>\n<ul>\n<li>类的信息：包括类名、方法信息、字段信息等，调用 <code>Class.getName()</code> 和 <code>Class.isInterface</code> 等方法时返回的数据都是来自方法区。</li>\n<li>静态成员变量：Java 局部变量没有静态的概念，只有成员变量、成员方法可以设置为静态。</li>\n<li>运行时常量池：类和接口被记载到 JVM 时，就会创建对应的运行时常量池。</li>\n</ul>\n<p>不论是否静态，方法都存放在方法区，非静态的方法，Dalvik 会将其对象实例在 Stack 中的引用地址（指向了 Heap 中存储的实例），作为隐含的参数传入，这样在非静态方法在需要调用其实例对象的其他数据时，可以确保总能找到在 Heap 中存放的实例数据。因此，调用一个非静态方法，必须首先 new 一个实例对象，也即创建一个实例对象在 Stack 中的引用地址，然后再调用。而静态方法不需要传入隐含参数，因为方法区是线程间公开共享的，而且存放的都是相对唯一、不变的数据，因此静态方法可以直接通过 <code>Class.method()</code> 的形式调用。当然，由于没有传入隐含的 Stack 引用地址，也就无法找到 Heap 中存放的实例数据，静态方法内部是无法获取到实例对象的其他非静态数据的，这也是为什么静态方法中不能调用非静态方法、非静态成员变量，而非静态方法可以直接调用静态方法、静态成员变量的原因。</p>\n<p>静态成员变量只在 JVM 第一次载入类时加载，也因此内存中只会保留一份数据，因此也是存放在方法区中的，这也是为什么作用域比较小、使用频率比较低的一些标志位等等不建议设置成 <code>public static</code> 的形式，因为这会导致很多临时才使用的变量被加载进了方法区而不释放（JDK 1.7 之后在满足一定条件下，方法区也会 GC，但是相比栈区和堆区，方法区 GC 的频率很低，因此仍然不建议大量使用静态成员变量）。</p>\n<p>运行时常量池并不一定质保函 Class 文件常量池中的内容，也即并非只有代码中显示定义了 <code>final</code> 的成员变量才会进入常量池。例如 <code>String.intern()</code> 方法，其作用就是：如果一个字符串存在常量池中，则直接返回常量池中的引用，否则将该字符串存入常量池，再返回其引用。</p>\n<p>常量池的意义非常重要，之所以 String 内部都要做成常量，主要是因为字符串的重复率特别高，因此如果字符串不可变，常量池才便于管理。而且由于 String 的不可变性，HashMap、HashTable 等使用 String 作为 Key 时，JVM 可以在缓存 String 对象时缓存其 HashCode，极大提高执行效率。</p>\n<p>在 JDK 1.8 以前，HotSpot 虚拟机的方法区是用永久代实现的，<strong>但方法区同样有可能发生 OOM！</strong> 因为方法区的内存是固定，因此如果频繁调用 <code>String.intern()</code> 方法，或者一次性加载太多类，仍然会导致OOM。JDK 1.8 之后，虽然用元数据取代了方法区，直接使用本地内存，支持扩容，也取消了永久代，但并不是无限扩容的，所以仍然有可能，只是几率会小一些。</p>\n<h3 id=\"3-4-本地方法栈（Native-Method-Stack）\"><a href=\"#3-4-本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"3.4 本地方法栈（Native Method Stack）\"></a>3.4 本地方法栈（Native Method Stack）</h3><p>本地方法区和方法栈（也即栈区）比较类似，区别在于栈区是针对普通方法的，而本地方法栈是针对 Native 方法的。JVM 规范中没有强行规定本地方法栈的实现方式和数据结构，虚拟机可以自由实现，HotSpot 虚拟机就直接把栈区和本地方法栈合二为一。</p>\n<h3 id=\"3-5-程序计数器（Program-Counter-Register）\"><a href=\"#3-5-程序计数器（Program-Counter-Register）\" class=\"headerlink\" title=\"3.5 程序计数器（Program Counter Register）\"></a>3.5 程序计数器（Program Counter Register）</h3><p>JVM 中的程序计数器和汇编中的程序计数器（CPU 中的寄存器）概念类似，都是用于指示下一条需要执行的指令，只不过 JVM 中的程序计数器并不是指向物理意义上的真实 CPU 内存地址。JVM 中的程序计数器是线程独有的，指向的是当前线程正在执行的字节码代码的行号，如果当前线程执行的是 Native 方法，则值为 <code>null</code>。</p>\n<h3 id=\"3-6-JDK8内存分区的变化\"><a href=\"#3-6-JDK8内存分区的变化\" class=\"headerlink\" title=\"3.6 JDK8内存分区的变化\"></a>3.6 JDK8内存分区的变化</h3><p>在 JDK 1.8 中，对之前 5 个内存区的划分做了一些改变。</p>\n<ul>\n<li>首先是使用 <strong>元数据区</strong> 取代了方法区，但实际上元数据区的作用和原来方法区的作用是几乎一样的，只不过不再是永久代（针对 HotSpot 虚拟机，其他虚拟机例如 Oracle 的 JRockit 和 IDM 的 J9 本来就没有永久代）。</li>\n<li>其次，元数据区不再存放在虚拟机内存中了，而是直接使用本地内存（由 OS 管理的内存）。</li>\n<li>另外，原来的字符串常量池存放在方法区中，新版 JDK 放到了堆区。</li>\n</ul>\n<hr>\n<h2 id=\"4-JVM中的4个Segment\"><a href=\"#4-JVM中的4个Segment\" class=\"headerlink\" title=\"4. JVM中的4个Segment\"></a>4. JVM中的4个Segment</h2><p>如果在网上查阅 JVM 分区的内容，会出现两种回答：</p>\n<ol>\n<li>JVM 内存模型分为 4 个区：Heap、Stack、Data Segment、Code Segment</li>\n<li>JVM 内存模型分为 5 个区：Heap、Stack、Method、Native Method、Program Counter Register</li>\n</ol>\n<p>其实这两种分法都对，只不过是针对不同的场景分的，个人认为分为 5 个区的更加全面一些。两种分类中，Heap 和 Stack 都是一一对应的，关键是其他部分，方法区是一个特例。在 HotSpot 虚拟机中，由于早期（JDK 1.8（不含）之前）是直接将方法区设置为永久代（Permanent Generation），也即方法区内的所有数据都不会被 GC，因此方法区也被习惯称为永久代。而方法区同时对应了 Data Segment 和 Code Segment，方法区中存储字节码的位置称为 代码段（Code Segment），存储静态常量和字符串常量的位置称为数据段（Data Segment）。</p>\n<hr>\n<h2 id=\"5-Java内部类\"><a href=\"#5-Java内部类\" class=\"headerlink\" title=\"5. Java内部类\"></a>5. Java内部类</h2><h3 id=\"5-1-静态内部类\"><a href=\"#5-1-静态内部类\" class=\"headerlink\" title=\"5.1 静态内部类\"></a>5.1 静态内部类</h3><p>静态内部类不会持有外部对象：</p>\n<ul>\n<li>非静态的内部类，在编译时，实际上会把外部类对象通过构造方法传递给内部类，这样内部类可以通过外部对象的引用调用外部类的属性。static字段使得该内部类可以直接通过类名调用，是线程共享的方法，因此不会传递外部对象的引用，也因此静态内部类无法调用外部类的非静态成员变量和非静态方法。</li>\n<li>使用内部类需要注意：内部类可以访问外部类的数据，而且具有较好的封装性，而且多个内部类分别继承不同的父类，再由外部类调用，可以间接实现多继承的效果，某些情况下可以简化代码逻辑，但内部类有可能会因为执行耗时操作使得外部类无法回收导致内存溢出，这时可以考虑改用静态内部类实现。</li>\n</ul>\n<h3 id=\"5-2-匿名内部类\"><a href=\"#5-2-匿名内部类\" class=\"headerlink\" title=\"5.2 匿名内部类\"></a>5.2 匿名内部类</h3><p>局部变量（如方法参数）必须声明 <code>final</code> 才能被匿名内部类（如子线程）使用：</p>\n<ul>\n<li>方法参数是局部变量，将局部变量传递给内部类实际上是编译时将局部变量传递给了内部类的构造方法，因此 <strong>内部类持有的是局部变量的引用的拷贝</strong> 。</li>\n<li>如果不加 <code>final</code>，内部类可能改变该变量的引用，但实际上改变的是构造方法中拷贝的引用，就会导致内部类持有的引用和局部变量的引用不一致，则程序的执行结果不可预期的。</li>\n<li>而成员变量则不需要加 <code>final</code> 也能在内部类使用，是因为匿名内部类是非静态内部类，而非静态内部类会持有外部类的引用，因此内部类是通过所持有的外部类来调用的外部类成员变量，并没有创建引用的拷贝，所以和外部类成员变量的引用是一致的。</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/bf158fbb2432\" title=\"@LINK\">什么是Java内存模型</a></li>\n</ul>\n","categories":["Java"],"tags":["Java","数据结构","内存模型","JVM内存区"]},{"title":"Java同步锁","url":"/post/java/java-lock/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java同步锁\"><a href=\"#Java同步锁\" class=\"headerlink\" title=\"Java同步锁\"></a>Java同步锁</h1><h2 id=\"1-Java锁的基本概念\"><a href=\"#1-Java锁的基本概念\" class=\"headerlink\" title=\"1. Java锁的基本概念\"></a>1. Java锁的基本概念</h2><h3 id=\"1-1-锁的种类\"><a href=\"#1-1-锁的种类\" class=\"headerlink\" title=\"1.1 锁的种类\"></a>1.1 锁的种类</h3><p><a href=\"https://blog.csdn.net/qq_41931837/article/details/82314478\">https://blog.csdn.net/qq_41931837/article/details/82314478</a></p>\n<h4 id=\"1-1-1-乐观锁和悲观锁\"><a href=\"#1-1-1-乐观锁和悲观锁\" class=\"headerlink\" title=\"1.1.1 乐观锁和悲观锁\"></a>1.1.1 乐观锁和悲观锁</h4><p>悲观锁认为一定会有别的线程抢占数据，因此操作数据前都要先获取数据的锁，<code>synchronized</code> 和 <code>lock</code> 都是悲观锁，适用于写操作较多的场景。</p>\n<p>乐观锁认为不会有别的线程抢占数据，因此只在写操作前判断是否有其他线程更新了数据，CAS（Compare And Swap）就是乐观锁的一种实现方式，适用于读操作较多的场景。</p>\n<h4 id=\"1-1-2-公平锁和非公平锁\"><a href=\"#1-1-2-公平锁和非公平锁\" class=\"headerlink\" title=\"1.1.2 公平锁和非公平锁\"></a>1.1.2 公平锁和非公平锁</h4><p>公平锁是多个线程按照申请锁的顺序来获取锁，非公平锁则不规定线程顺序。synchronized是非公平锁，ReentrantLock可以通过指定构造方法的参数来创建公平或非公平锁。</p>\n<h4 id=\"1-1-3-独享锁和共享锁\"><a href=\"#1-1-3-独享锁和共享锁\" class=\"headerlink\" title=\"1.1.3 独享锁和共享锁\"></a>1.1.3 独享锁和共享锁</h4><p>独享锁即一次只能被一个线程持有，共享锁一次可以被多个线程池有，synchronized和ReentrantLock都是独享锁，ReentrantReadWriteLock的读锁是共享锁，写锁是独享锁。</p>\n<h4 id=\"1-1-4-互斥锁和读写锁\"><a href=\"#1-1-4-互斥锁和读写锁\" class=\"headerlink\" title=\"1.1.4 互斥锁和读写锁\"></a>1.1.4 互斥锁和读写锁</h4><p>和独享、共享是一个意思。</p>\n<h4 id=\"1-1-5-可重入锁和不可重入锁\"><a href=\"#1-1-5-可重入锁和不可重入锁\" class=\"headerlink\" title=\"1.1.5 可重入锁和不可重入锁\"></a>1.1.5 可重入锁和不可重入锁</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> sychrnozied <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    xxxxxx;</span><br><span class=\"line\">    test2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    yyyyy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Reentrant</code> 就是可重入的意思，所以 <code>Reentrant</code> 和 <code>synchronized</code> 都是可重入锁，也即上面的代码可以顺利执行，<code>test()</code> 获取了对象锁后，再调用 <code>test2()</code> 时，可以直接用已持有的对象锁直接进入 <code>test2()</code>，如果是不可重入锁则会发生死锁。</p>\n<h4 id=\"1-1-6-自旋锁\"><a href=\"#1-1-6-自旋锁\" class=\"headerlink\" title=\"1.1.6 自旋锁\"></a>1.1.6 自旋锁</h4><p>自旋锁就是使用循环尝试获取来替代线程阻塞等待，好处是减少线程切换的消耗，但会增加CPU资源消耗。</p>\n<h4 id=\"1-1-7-偏向锁、轻量级锁、重量级锁\"><a href=\"#1-1-7-偏向锁、轻量级锁、重量级锁\" class=\"headerlink\" title=\"1.1.7 偏向锁、轻量级锁、重量级锁\"></a>1.1.7 偏向锁、轻量级锁、重量级锁</h4><p>这是三种锁的状态，是针对 synchronized 字段优化的，通过对象监视器在内存中的头部字段来标明。</p>\n<ul>\n<li>偏向锁是指，如果一段同步代码一直被一个线程访问，则该线程会自动获取锁而不需要申请，以降低获取锁的资源消耗。</li>\n<li>轻量锁是指如果锁是偏向锁时，有另一个线程访问了同步代码块，则将偏向锁改为轻量锁。此时另外的线程不会阻塞等待，而是通过自旋来尝试获取锁。</li>\n<li>重量级锁则是，如果锁是轻量锁，另一个线程虽然是自旋，但不会一直持续下去，当自旋超过一定次数还没有获取到锁，就会进入阻塞状态，该锁膨胀为重量级锁。</li>\n</ul>\n<h4 id=\"1-1-8-分段锁\"><a href=\"#1-1-8-分段锁\" class=\"headerlink\" title=\"1.1.8 分段锁\"></a>1.1.8 分段锁</h4><p>分段锁不是一种具体的锁，也不是锁的形式，只是一种设计方案，在ConcurrentHashMap内部使用，通过将数据分段并分别加锁，来提升并发情况下的写入性能。</p>\n<h4 id=\"1-1-9-同步锁\"><a href=\"#1-1-9-同步锁\" class=\"headerlink\" title=\"1.1.9 同步锁\"></a>1.1.9 同步锁</h4><p>（1）对象锁（方法锁）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(Object object) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>当多个线程使用同一个对象锁则可以达到同步的效果，否则无效。</p>\n<p>当 <code>synchronized</code> 修饰方法时，实际上等同于获取该方法所在的外部类对象的对象锁。</p>\n<p>（2）类锁（静态锁）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(DemoClass.class) &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>同一个类只有一个类锁，但每个类的实例对象都有自己的对象锁，因此当使用类锁时，所有该类的实例对象拿到的都是同一把锁，而使用对象锁时，不同实例对象之间是无关的。</p>\n<p><code>synchronized</code> 修饰静态方法时，即为静态锁。由于非静态方法会自动持有其所在外部类对象的引用，因此非静态方法加锁等同于其所在外部类实例对象的对象锁，而静态方法不会持有其外部类对象的引用，因此是使用其外部类的字节码对象作为锁。</p>\n<h3 id=\"1-2-锁粗化和锁消除\"><a href=\"#1-2-锁粗化和锁消除\" class=\"headerlink\" title=\"1.2 锁粗化和锁消除\"></a>1.2 锁粗化和锁消除</h3><p>锁粗化和锁消除的本意都是尽量减少锁的获取和释放，节约资源。</p>\n<p>锁消除是虚拟机在编译阶段做逃逸分析时，判断到某段代码，虽然加了锁，但不可能会被其他线程访问到，因此加锁是没必要的，则在编译阶段就去除加锁部分。</p>\n<p>锁粗化可以理解为扩展锁的域，例如在一个循环内部对一个操作加锁，由于重复获取和释放锁会带来很大的开销，因此虚拟机在编译阶段，将锁粗化，加载循环体外部。</p>\n<hr>\n<h2 id=\"2-Synchronized关键字\"><a href=\"#2-Synchronized关键字\" class=\"headerlink\" title=\"2. Synchronized关键字\"></a>2. Synchronized关键字</h2><p><code>synchronized</code> 只会同步尝试获取同一个 <code>monitor</code> 对象的线程，如果一个线程已经持有该 <code>monitor</code>，则后续所有尝试持有该 <code>monitor</code> 的线程都需要依次等待前面的线程释放 <code>monitor</code> 才能继续执行。</p>\n<ul>\n<li>对非静态方法加 <code>synchronized</code> 相当于对象锁。</li>\n<li>对静态方法加 <code>synchronized</code> 相等于类锁。</li>\n<li>用常量池和自动装箱的基本变量作为监视器，一旦改变了值就相当于改变了监视器。</li>\n</ul>\n<h3 id=\"2-1-Synchronized如何保证原子性\"><a href=\"#2-1-Synchronized如何保证原子性\" class=\"headerlink\" title=\"2.1 Synchronized如何保证原子性\"></a>2.1 Synchronized如何保证原子性</h3><p>所谓原子性指的是不会被线程调度机制打断的操作。java中对基本数据类型的读和写是原子性操作，但自增自减不是。例如 <code>i++</code> 在 JVM 中实际上是三步：</p>\n<ul>\n<li>取出 <code>i</code> 的值</li>\n<li>对值做 <code>+1</code> 操作</li>\n<li>重新赋值给 <code>i</code></li>\n</ul>\n<p>虽然其中的每一步都是原子性操作，但这个过程并不是原子性的。所以如果需要保证原子性，可以通过 <code>synchronized</code> 关键字实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;i++;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者使用原子类 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code> 等，其中 <code>AtomicInteger#getAndIncrement()</code> 效果相当于 <code>i++</code>，<code>AtomicInteger#getAndDecrement()</code> 效果相当于 <code>i--</code>，<code>AtomicInteger#incrementAndGet()</code> 效果相当于 <code>++i</code>，其内部原理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndIncrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> current = get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> next = current + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSet(current, next))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-Lock\"><a href=\"#3-Lock\" class=\"headerlink\" title=\"3. Lock\"></a>3. Lock</h2><h3 id=\"3-1-Lock的基本用法\"><a href=\"#3-1-Lock的基本用法\" class=\"headerlink\" title=\"3.1 Lock的基本用法\"></a>3.1 Lock的基本用法</h3><p><code>Lock</code> 的基本用法为：<code>Lock lock = new ReentrantLock();</code>，可以通过 <code>lock.lock()</code> 手动加锁，通过 <code>lock.unlock()</code> 手动释放锁。但 <code>Lock</code> 的性能很差，需要注意在 <code>finally</code> 中释放锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"><span class=\"keyword\">int</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\">lock.lock();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    value++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-Lock的实现原理\"><a href=\"#3-2-Lock的实现原理\" class=\"headerlink\" title=\"3.2 Lock的实现原理\"></a>3.2 Lock的实现原理</h3><p><a href=\"https://yq.aliyun.com/articles/640868\">https://yq.aliyun.com/articles/640868</a></p>\n<p><code>Lock</code> 本质还是通过 <strong>CAS 乐观锁</strong> 实现的。一个线程尝试去获取锁，如果获取到，则更新一个 <code>state</code> 字段，表示当前是正在等待锁还是持有锁还是释放锁的状态，然后去执行操作。否则如果没获取到，则将该线程放到记录等待线程的双向链表中，然后线程做自旋，直到获取到锁。<code>Lock</code> 建议在低锁冲突的情况下用，否则非必要（例如需要公平锁）的情况下，还是使用 <code>synchronized</code> 更好。</p>\n<hr>\n<h2 id=\"4-基于原生方法手动实现公平锁\"><a href=\"#4-基于原生方法手动实现公平锁\" class=\"headerlink\" title=\"4. 基于原生方法手动实现公平锁\"></a>4. 基于原生方法手动实现公平锁</h2><p><a href=\"https://blog.csdn.net/sddh1988/article/details/68068971\">https://blog.csdn.net/sddh1988/article/details/68068971</a></p>\n<p>使用队列，在 <code>lock()</code> 内按顺序添加等待的线程名 <code>currentThread()#getName()</code>，然后 <code>peek</code> 出最前的线程名，自旋对比当前线程是否是 <code>peek</code> 出来的线程，如果不是则一直循环。</p>\n<hr>\n<h2 id=\"5-死锁\"><a href=\"#5-死锁\" class=\"headerlink\" title=\"5. 死锁\"></a>5. 死锁</h2><p>死锁产生有四个必要条件：</p>\n<ul>\n<li>互斥（线程要求的资源仅能被一个线程所独占）</li>\n<li>保持（线程因请求被其他线程独占的资源而阻塞时，保持已获得的资源不释放）</li>\n<li>不剥夺（线程独占的资源未使用完之前，不可剥夺该线程对资源的独占）</li>\n<li>环路等待（发生死锁时，必然存在线程-资源的环形请求链）。</li>\n</ul>\n<p>预防死锁的方式有：</p>\n<ul>\n<li>避免运行中请求资源，线程所需的资源一次性分配</li>\n<li>一个线程如果请求独占某个资源失败，则其他的资源也拒绝被该线程独占</li>\n<li>如果一个线程请求独占某个资源失败，则释放该线程原有的独占资源</li>\n<li>给资源进行编号，线程按顺序请求资源，逆序释放资源</li>\n<li>超时放弃，尝试获取锁一段时间不成功，则放弃自身独占的资源（如 <code>Lock#tryLock(long time, TimeUnit unit)</code>）</li>\n</ul>\n<hr>\n<h2 id=\"6-wait和sleep\"><a href=\"#6-wait和sleep\" class=\"headerlink\" title=\"6. wait和sleep\"></a>6. wait和sleep</h2><p><a href=\"https://www.cnblogs.com/loren-Yang/p/7538482.html\">https://www.cnblogs.com/loren-Yang/p/7538482.html</a></p>\n<ul>\n<li><code>sleep()</code> 是 <code>Thread</code> 类中的方法，<code>wait()</code> 是 <code>Object</code> 类中的方法，因此所有的对象都能调用 <code>wait()</code>。</li>\n<li><code>wait()</code> 会释放该对象持有的锁资源，所以一旦一个对象调用了 <code>wait()</code>，其他线程可以通过 <code>notify()</code> 或 <code>notyfyAll()</code> 来唤醒，而 <code>sleep()</code> 不释放锁资源，因此其他线程无法使用同步控制块。</li>\n</ul>\n<h2 id=\"7-Volatile关键字\"><a href=\"#7-Volatile关键字\" class=\"headerlink\" title=\"7. Volatile关键字\"></a>7. Volatile关键字</h2><p><code>volatile</code> 一般用在多个线程访问同一个变量时，对该变量进行唯一性约束，<code>volatile</code> 保证了变量的可见性，但不能保证原子性。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread write = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        i = <span class=\"number\">2</span>;</span><br><span class=\"line\">        flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Thread read = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">write.start();</span><br><span class=\"line\">read.start();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，在某些极端情况下，可能会输出 1，也就是：</p>\n<ul>\n<li>write 线程先执行了 <code>flag = true</code></li>\n<li>然后 read 线程执行了 <code>if</code> 判断并通过，输出 1</li>\n<li>然后 write 线程才执行 <code>i = 2</code></li>\n</ul>\n<p>为了避免这个情况，可以如下改写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Thread write = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        i = <span class=\"number\">2</span>;</span><br><span class=\"line\">        flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Thread read = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">write.start();</span><br><span class=\"line\">read.start();</span><br></pre></td></tr></table></figure>\n\n<p><code>volatile</code> 用于告诉 JVM 变量不允许线程缓存以及代码重排序，会使得其所在域的写操作一定发生在读操作之前，且每次有写操作后，都将所在域中的写入值同步到主内存中，从而避免其他线程从缓存中拿到旧数据。</p>\n","categories":["Java"],"tags":["Java","同步锁"]},{"title":"LRU算法及其优化","url":"/post/java/java-lru/","content":"<span id=\"more\"></span>\n\n<h1 id=\"LRU算法及其优化\"><a href=\"#LRU算法及其优化\" class=\"headerlink\" title=\"LRU算法及其优化\"></a>LRU算法及其优化</h1><p>LRU（Least Recently Used，最近最少使用）的本质是一个链表，新数据插入到链表头部，每当缓存命中，则将数据移到链表头部，当链表满了或者需要清理内存时，将链表尾部的数据丢弃。</p>\n<p>特点：当存在热点数据时，LRU 的效率很高，但偶发性的、周期性的批量操作会导致 LRU 命中率急剧下降，产生缓存污染的（将不常用的数据也存入缓存，降低了缓存效率）问题，且每次缓存命中时，都需要遍历链表，找到命中的数据块索引并移到头部。</p>\n<h2 id=\"1-LRU-K\"><a href=\"#1-LRU-K\" class=\"headerlink\" title=\"1. LRU-K\"></a>1. LRU-K</h2><p>为了改善 LRU 算法的缓存污染问题，额外维护一个队列用于记录所有缓存数据被访问的历史，只有当数据的访问次数打到 K 次，才存入缓存中。当数据被访问次数不到 K 次时，按照一定规则（FIFO、LRU 等）淘汰，当历史队列中的数据访问达到 K 次后，将其从队列中删除转移到缓存中，并按照时间顺序重新排列缓存数据，且缓存中的数据每次被访问后重新排序。当需要清理缓存时，淘汰缓存中排在末尾的数据，也即淘汰距离上次访问最久的数据。</p>\n<p>特点：LRU-K 降低了缓存污染带来的代价，命中率比 LRU 高，但由于其历史队列和缓存中的数据都具有优先级（可以即时排序也可以在需要淘汰数据时才排序），因此其算法复杂度和性能代价较高。尤其当有大量存入历史队列却还未存入缓存中的数据时，内存消耗较大。</p>\n<p>通常，LRU-2 是综合因素下的最优选择，LRU-3 或更高 K 值会提高命中率，但适应性较差，需要大量的数据访问才能冲洗历史队列表。</p>\n<h2 id=\"2-LRU-Two-Queues\"><a href=\"#2-LRU-Two-Queues\" class=\"headerlink\" title=\"2. LRU-Two Queues\"></a>2. LRU-Two Queues</h2><p>LRU-2Q 祛除了历史队列，而是直接使用两个缓存队列进行管理，其中一个缓存队列采用 FIFO 淘汰规则，另一个缓存队列采用 LRU 淘汰规则。一个新的数据首次被访问时，假如 FIFO 队列，当该数据再次被访问时，则转移到 LRU 队列中，LRU 队列中的数据再次被访问时，则移至 LRU 队列的头部，两个队列分别根据对应的淘汰规则按需淘汰数据。</p>\n<p>L特点：RU-2Q 的命中率高于 LRU，尽管需要两个队列，但两个队列的维护算法都比较简单。LRU-2Q 和 LRU-2 命中率、内存消耗都比较接近，不同处在于，LRU-2 中，数据首次被访问加入历史队列后，需要被访问 2 次才转移至缓存中，而 LRU-2Q 在数据首次被访问加入 FIFO 队列后，仅需再被访问 1 次即转移到缓存中。</p>\n<h2 id=\"3-LRU-Multi-Queues\"><a href=\"#3-LRU-Multi-Queues\" class=\"headerlink\" title=\"3. LRU-Multi Queues\"></a>3. LRU-Multi Queues</h2><p>LRU-MQ 拥有一个 LRU 历史队列 和 K 个 LRU 缓存队列，均采用 LRU 淘汰规则。当一个数据首次被访问时，加入到最低优先级的 LRU 缓存队列中，队列中的数据每次被访问则重新计算优先级并排序，当低优先级的队列中，当某个数据优先级达到下一级 LRU 缓存队列时，将其从当前 LRU 缓存队列转移到更高级的 LRU 缓存队列的头部。为避免高优先级的数据永不淘汰，当高优先级的 LRU 缓存队列中某个数据在指定时间内未被访问时，降低其优先级并转移到低优先级的 LRU 缓存队列的头部。所有 K 个 LRU 缓存队列中被淘汰的数据，均转移到 LRU 历史队列的头部，若 LRU 历史队列中的数据重新被访问，则重新计算优先级，并根据优先级转移到目标 LRU 缓存队列的头部，否则根据 LRU 算法直到被完全淘汰，</p>\n<p>LRU-MQ 进一步降低了缓存污染的问题，着重突出了“优先缓存访问次数多的数据”的思想，但由于具有多个队列，且每个队列都需要维护每个数据的访问时间，当 LRU-MQ 中队列数和数据量过多时，具有较高的复杂度。不过，尽管 LRU-MQ 的队列数量较多，但由于内存是有限的，因此所有的队列所占内存之和仍是受限的，因此多个短队列的长度之和与单个长队列的长度相差不大，其队列扫描性能仍然比较接近。</p>\n<h2 id=\"4-LRUCache\"><a href=\"#4-LRUCache\" class=\"headerlink\" title=\"4. LRUCache\"></a>4. LRUCache</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> LruCache&lt;String, Bitmap&gt; mLruCache = <span class=\"keyword\">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">sizeOf</span><span class=\"params\">(String key, Bitmap value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//计算一个元素的缓存大小</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.getByteCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">addBitmap(String key, Bitmap bitmap) &#123;&#125;</span><br><span class=\"line\">getBitmap(String key) &#123;&#125;</span><br><span class=\"line\">removeBitmapFromMemory(String key) &#123;&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Java"],"tags":["LRU"]},{"title":"Java-思想规范","url":"/post/java/java-standard/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-思想规范\"><a href=\"#Java-思想规范\" class=\"headerlink\" title=\"Java-思想规范\"></a>Java-思想规范</h1><h2 id=\"1-面向对象六大原则\"><a href=\"#1-面向对象六大原则\" class=\"headerlink\" title=\"1. 面向对象六大原则\"></a>1. 面向对象六大原则</h2><h3 id=\"1-1-单一职责原则\"><a href=\"#1-1-单一职责原则\" class=\"headerlink\" title=\"1.1 单一职责原则\"></a>1.1 单一职责原则</h3><ul>\n<li>两个完全不一样的功能不能放在一个类中，一个类应该是一组相关性很高的函数、数据的封装。</li>\n<li>如何划分一个类的职责因人而异，但要根据个人的经验、具体的业务来定，比如图片加载和缓存应该放在不同的类中。</li>\n</ul>\n<h3 id=\"1-2-开放关闭原则\"><a href=\"#1-2-开放关闭原则\" class=\"headerlink\" title=\"1.2 开放关闭原则\"></a>1.2 开放关闭原则</h3><ul>\n<li>软件中的函数、对象，应该对于扩展是开放的，对于修改是封闭的。</li>\n<li>当软件需要变化时，应该尽量通过扩展的方式，而不是修改已有的代码。</li>\n</ul>\n<h3 id=\"1-3-里氏替换原则\"><a href=\"#1-3-里氏替换原则\" class=\"headerlink\" title=\"1.3 里氏替换原则\"></a>1.3 里氏替换原则</h3><ul>\n<li>所有引用基类的地方，必须能透明地使用其子类的对象。</li>\n<li>只要父类出现的地方，子类就可以出现，替换为子类也不影响。但是反之不行。</li>\n<li>核心是抽象，抽象又依赖于继承。建立抽象，通过抽象建立规范，具体的实现在继承时替换掉。往往和开闭原则一起，通过接口和抽象的方式。</li>\n</ul>\n<h3 id=\"1-4-依赖倒置原则\"><a href=\"#1-4-依赖倒置原则\" class=\"headerlink\" title=\"1.4 依赖倒置原则\"></a>1.4 依赖倒置原则</h3><ul>\n<li>实现类直接不直接发生依赖关系，其依赖关系通过接口或抽象类产生，即：面向接口编程。</li>\n<li>Java 中抽象指接口或抽象类不能直接被实例化；细节是实现接口或继承抽象类的实现类，可以直接被实例化。</li>\n</ul>\n<h3 id=\"1-5-接口隔离原则\"><a href=\"#1-5-接口隔离原则\" class=\"headerlink\" title=\"1.5 接口隔离原则\"></a>1.5 接口隔离原则</h3><ul>\n<li>类之间的依赖关系应该建立在最小接口上。让客户端依赖的接口尽可能小，解耦合。</li>\n</ul>\n<h3 id=\"1-6-迪米特原则\"><a href=\"#1-6-迪米特原则\" class=\"headerlink\" title=\"1.6 迪米特原则\"></a>1.6 迪米特原则</h3><ul>\n<li>最少知识原则：一个对象应该对其他对象有最少的了解。因为关系越密切，则耦合度越大。</li>\n<li>只与直接的朋友通信。</li>\n</ul>\n<hr>\n<h2 id=\"2-继承和多态\"><a href=\"#2-继承和多态\" class=\"headerlink\" title=\"2. 继承和多态\"></a>2. 继承和多态</h2><p>重写和重载？</p>\n<hr>\n<h2 id=\"3-自动装箱和自动拆箱\"><a href=\"#3-自动装箱和自动拆箱\" class=\"headerlink\" title=\"3. 自动装箱和自动拆箱\"></a>3. 自动装箱和自动拆箱</h2><ul>\n<li>自动装箱：<code>int i = 0; Integer n = i;</code> 内部调用：<code>n = Integer.valueOf(i);</code></li>\n<li>自动拆箱：<code>Integer i = 0; int n = i;</code> 内部调用：<code>n = i.intValue();</code></li>\n</ul>\n<hr>\n<h2 id=\"4-Java-泛型\"><a href=\"#4-Java-泛型\" class=\"headerlink\" title=\"4. Java 泛型\"></a>4. Java 泛型</h2><p>泛型类在编译后其泛型信息会被擦除为 Object，泛型会被转移到实际使用了泛型的变量或方法中（如果没有则彻底丢失存根），所以编译后的类已经丢失了自己的泛型信息，无法通过反射获取自己的泛型，除非其继承自某个使用了泛型的父类，则 getClass().getGenericSuperclass() 才会保存父类的泛型信息。</p>\n<p>而接口则可以理解为一种特殊的父类，因为接口无法直接实例化为一个对象，匿名构造类也是编译时通过匿名类实现该接口后返回来实现的，因此对于实现了接口的类，可以通过 getClass().getGenericInterfaces() 来获取接口信息，因为接口实际上可以看作实现类的&quot;父类&quot;，所以获取接口信息时就能获取到接口的泛型信息。</p>\n<hr>\n<h2 id=\"5-Object方法\"><a href=\"#5-Object方法\" class=\"headerlink\" title=\"5. Object方法\"></a>5. Object方法</h2><ul>\n<li><code>Object()</code>：构造方法。</li>\n<li><code>clone()</code>：用来另存一个当前存在的对象。</li>\n<li><code>equals(Object)</code>：用于确认两个对象是否相同。</li>\n<li><code>finalize()</code>：这个函数在进行垃圾回收的时候会用到，匿名对象回收之前会调用到。</li>\n<li><code>getClass()</code>：返回一个当前类的 Class 全名。</li>\n<li><code>hashCode()</code>：用于获取对象的哈希值，这个值的作用是检索。</li>\n<li><code>notify()</code>：用于随机通知一个持有对象的锁的线程获取操作权限。</li>\n<li><code>notifyAll()</code>：用于通知所有持有对象的锁的线程获取操作权限。</li>\n<li><code>toString()</code>：返回一个String对象，用来标识自己。</li>\n<li><code>wait()</code>：用于让当前线程失去操作权限，当前线程进入等待序列。</li>\n<li><code>wait(long)</code>：用于设定下一次获取锁的距离当前释放锁的时间间隔。</li>\n<li><code>wait(long,int)</code>：用于设定下一次获取锁的距离当前释放锁的时间间隔。</li>\n</ul>\n<hr>\n<h2 id=\"6-抽象类和接口的区别\"><a href=\"#6-抽象类和接口的区别\" class=\"headerlink\" title=\"6. 抽象类和接口的区别\"></a>6. 抽象类和接口的区别</h2><h3 id=\"6-1-使用上的区别\"><a href=\"#6-1-使用上的区别\" class=\"headerlink\" title=\"6.1 使用上的区别\"></a>6.1 使用上的区别</h3><ul>\n<li>抽象类使用abstract修饰；</li>\n<li>抽象类不能实例化，即不能使用new关键字来实例化对象；</li>\n<li>含有抽象方法（使用abstract关键字修饰的方法）的类是抽象类，必须使用abstract关键字修饰；</li>\n<li>抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；</li>\n<li>如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类</li>\n</ul>\n<h3 id=\"6-2-逻辑上的区别\"><a href=\"#6-2-逻辑上的区别\" class=\"headerlink\" title=\"6.2 逻辑上的区别\"></a>6.2 逻辑上的区别</h3><p>抽象类的本质还是一个类，可以为子类定义所需的逻辑，本质上是对子类的抽象，也能通过实际实现方法，直接统一子类的行为，而接口更像是预先安排一些功能，而对于实现了这个接口的类的外部而言，其他类并不需要关心这个类具体的功能或实现，只需要根据其实现的接口就能调用相关的功能。</p>\n<h3 id=\"6-3-优缺点比较\"><a href=\"#6-3-优缺点比较\" class=\"headerlink\" title=\"6.3 优缺点比较\"></a>6.3 优缺点比较</h3><ul>\n<li>抽象类可以定义方法的默认实现，也即可以预定义其子类的主体功能。但一个类只能继承自一个父类，所以抽象类需要高度抽象才具有价值，但高度抽象又会降低对子类主体功能的控制性。</li>\n<li>一个类可以实现多个接口，接口可以定义一个类的行为。但实现一个接口时，就必须实现该接口内的所有方法。</li>\n</ul>\n","categories":["Java"],"tags":["Java"]},{"title":"Java中的引用","url":"/post/java/java-reference/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java中的引用\"><a href=\"#Java中的引用\" class=\"headerlink\" title=\"Java中的引用\"></a>Java中的引用</h1><p>Java 中的引用，是指除了基本数据类型以外的所有类型，这些类型在内存中，会在堆区存储实际的数据，在栈区存储一个别名（Alias），应用通过栈区的别名指向堆区的实际存储空间，来操作实际的数据，详细参考：<a href=\"/post/java/java-jvm/\" title=\"@LINK\">JVM内存模型</a>。</p>\n<h2 id=\"1-四种引用关系\"><a href=\"#1-四种引用关系\" class=\"headerlink\" title=\"1. 四种引用关系\"></a>1. 四种引用关系</h2><h3 id=\"1-1-强引用\"><a href=\"#1-1-强引用\" class=\"headerlink\" title=\"1.1 强引用\"></a>1.1 强引用</h3><p>直接 new 出来的对象就是强引用。只要强引用还存在，则不会被 GC，若内存不足，则 JVM 会直接抛出 OOM，可通过置为 null 来尝试回收。</p>\n<h3 id=\"1-2-软引用SoftReference\"><a href=\"#1-2-软引用SoftReference\" class=\"headerlink\" title=\"1.2 软引用SoftReference\"></a>1.2 软引用SoftReference</h3><p>若内存足够，发生 GC 时不会被回收，若内存不足，发生 GC 时会被回收。若回收软引用对象后仍然内存不足，则抛出 OOM。使用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SoftReference&lt;Type T&gt; sr = <span class=\"keyword\">new</span> SoftReference&lt;&gt;(Object obj);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-弱引用WeakReference\"><a href=\"#1-3-弱引用WeakReference\" class=\"headerlink\" title=\"1.3 弱引用WeakReference\"></a>1.3 弱引用WeakReference</h3><p>不论内存是否足够，只要 GC，都会回收。</p>\n<h3 id=\"1-4-虚引用PhantomReference\"><a href=\"#1-4-虚引用PhantomReference\" class=\"headerlink\" title=\"1.4 虚引用PhantomReference\"></a>1.4 虚引用PhantomReference</h3><p>一个对象持有虚引用几乎相当于未持有任何引用，随时都可能会被回收。虚引用必须配合引用队列一起使用。</p>\n<hr>\n<h2 id=\"2-引用队列ReferenceQueue\"><a href=\"#2-引用队列ReferenceQueue\" class=\"headerlink\" title=\"2. 引用队列ReferenceQueue\"></a>2. 引用队列ReferenceQueue</h2><p>可配合软引用、弱引用、虚引用使用。当 GC 准备回收一个对象时，若发现该对象存在引用，则会先将其加入到与之关联的引用队列中，可以通过判断引用队列中是否存在引用来判断被引用的对象是否将要被回收。</p>\n","categories":["Java"],"tags":["Java","引用","强引用","软引用","弱引用","虚引用"]},{"title":"Java-String","url":"/post/java/java-string/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-String\"><a href=\"#Java-String\" class=\"headerlink\" title=\"Java-String\"></a>Java-String</h1><h2 id=\"1-StringBuilder和StringBuffer的区别\"><a href=\"#1-StringBuilder和StringBuffer的区别\" class=\"headerlink\" title=\"1. StringBuilder和StringBuffer的区别\"></a>1. StringBuilder和StringBuffer的区别</h2><p>StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是 StringBuffer 中的方法大都采用了 <code>synchronized</code> 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p>\n<p>在单线程程序下，StringBuilder 效率更快，因为它不需要加锁、不具备多线程安全；而 StringBuffer 则每次都需要判断锁，效率相对更低。</p>\n<hr>\n<h2 id=\"2-扩容策略\"><a href=\"#2-扩容策略\" class=\"headerlink\" title=\"2. 扩容策略\"></a>2. 扩容策略</h2><p>StringBuilder 的初始容量可以容纳 <code>16</code> 个字符，当该对象的实体存放的字符的长度大于 <code>16</code> 时，实体容量就自动增加。StringBuilder 对象可以通过 <code>length()</code> 方法获取实体中存放的字符序列长度，通过 <code>capacity()</code> 方法来获取当前实体的实际容量。</p>\n<p><code>StringBuilder(int size)</code> 可以指定分配给该对象的实体的初始容量参数为 <code>size</code>。当该对象的实体存放的字符序列的长度大于 <code>size</code> 个字符时，实体的容量就自动的增加。以便存放所增加的字符。</p>\n<p><code>StringBuilder(String s)</code> 可以指定给对象的实体的初始容量 <code>size</code> 为 <code>s</code> 的长度 <strong>额外再加 <code>16</code> 个字符</strong>。当该对象的实体存放的字符序列长度大于 <code>size</code> 个字符时，实体的容量自动的增加，以便存放所增加的字符。</p>\n<h3 id=\"2-1-扩容算法\"><a href=\"#2-1-扩容算法\" class=\"headerlink\" title=\"2.1 扩容算法\"></a>2.1 扩容算法</h3><p>使用 <code>append()</code> 方法在字符串后面追加东西的时候，如果长度超过了该字符串存储空间大小了就需要进行扩容：构建新的存储空间更大的字符串，将旧的复制过去；</p>\n<ul>\n<li>在进行字符串 <code>append()</code> 的时候，会先计算追加后字符串大小；</li>\n<li>将追加后的字符串大小传入 <code>ensureCapacityInternal()</code>，由这个方法进行是否扩容的判断；<ul>\n<li>如果需要扩容就调用 <code>expandCapacity()</code> 进行扩容，尝试将新容量扩为大小变成 <code>当前容量 * 2 + 2</code>；</li>\n<li><code>if</code> 判断一下，如果容量还是不够，直接扩充到需要的容量大小。</li>\n</ul>\n</li>\n</ul>\n","categories":["Java"],"tags":["Java","String"]},{"title":"Java-Thread","url":"/post/java/java-thread/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-Thread\"><a href=\"#Java-Thread\" class=\"headerlink\" title=\"Java-Thread\"></a>Java-Thread</h1><h2 id=\"1-Thread简介\"><a href=\"#1-Thread简介\" class=\"headerlink\" title=\"1. Thread简介\"></a>1. Thread简介</h2><h2 id=\"1-1-Java中的线程\"><a href=\"#1-1-Java中的线程\" class=\"headerlink\" title=\"1.1 Java中的线程\"></a>1.1 Java中的线程</h2><h2 id=\"1-2-Java守护线程\"><a href=\"#1-2-Java守护线程\" class=\"headerlink\" title=\"1.2 Java守护线程\"></a>1.2 Java守护线程</h2><p>Java 中的线程有两类：User Thread 和 Daemon Thread，引用 Oracle 对 Thread 的介绍：</p>\n<blockquote>\n<p>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:</p>\n<ul>\n<li>The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.</li>\n<li>All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method.</li>\n</ul>\n</blockquote>\n<p>实际上，Linux 本身只有「守护进程」而并没有「守护线程」的概念，Java 借鉴了 Unix 的思想设计了 Thread。但不论是守护线程还是守护进程，其守护的都并不是其他线程 / 进程，而是 <strong>创建者</strong> 的「生命周期」：</p>\n<blockquote>\n<p>守护进程可参考：<a href=\"/post/linux/linux-process\" title=\"@LINK\">Linux-Process</a>。</p>\n</blockquote>\n<ul>\n<li>Linux 中守护进程的意义是可以在操作系统的后台长期存活而不受到控制终端的影响，直至与操作系统一起结束。</li>\n<li>Java 中守护线程的意义是可以在 JVM 运行时的后台长期存活，直至与 JVM 一起结束。</li>\n</ul>\n<p>一个 Java 应用启动后，默认具有一个主线程（User Thread）和一个 GC 线程（Daemon Thread），当 JVM 中所有 User Thread 都结束后，JVM 就会结束守护线程并退出。除此之外 User Thread 和 Daemon Thread 在其他方面并没有区别。</p>\n<p>Java 中可以通过 <code>Thread#setDaemon(boolean)</code> 将一个线程设置为守护线程，有几点注意事项：</p>\n<ul>\n<li>设置守护线程必须在线程 Start 前，否则会抛出 <code>IllegalThreadStateException</code> 异常。</li>\n<li>守护线程创建的线程将默认也是守护线程。</li>\n<li>守护线程的意义并不是常驻后台，因为当所有 User Thread 均退出后，JVM 就会结束守护线程并退出，因此不能在守护线程中执行重要操作。</li>\n</ul>\n<hr>\n<h2 id=\"2-线程池\"><a href=\"#2-线程池\" class=\"headerlink\" title=\"2. 线程池\"></a>2. 线程池</h2><p>线程池底层是通过 HashSet 维护的，可以确保不会出现一个线程的多个实例，并且集合无序，可以保持高效率。多余的任务用一个阻塞队列来管理，阻塞队列满了才会激活非核心线程。</p>\n<h3 id=\"2-1-线程池关键参数\"><a href=\"#2-1-线程池关键参数\" class=\"headerlink\" title=\"2.1 线程池关键参数\"></a>2.1 线程池关键参数</h3><ul>\n<li><p><code>corePoolSize</code> 核心线程数：线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了 <code>allowCoreThreadTimeOut</code>。这里的最小线程数量即是 <code>corePoolSize</code>。</p>\n</li>\n<li><p><code>maximumPoolSize</code> 最大线程数：一个任务被提交到线程池后，首先会缓存到工作队列中，如果工作队列满了则会创建一个新线程，然后从工作队列中的取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由 <code>maximunPoolSize</code> 来指定。</p>\n</li>\n<li><p><code>keepAliveTime</code> 空闲线程存活时间：一个线程如果处于空闲状态，并且当前的线程数量大于 <code>corePoolSize</code> ，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由 <code>keepAliveTime</code> 来设定。</p>\n</li>\n<li><p><code>unit</code> 空闲线程存活时间的单位：<code>keepAliveTime</code> 的计量单位。</p>\n</li>\n<li><p><code>workQueue</code> 线程管理队列：新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。JDK 中提供了四种工作队列：</p>\n<ul>\n<li><p><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列；按 FIFO 排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到 <code>corePoolSize</code> 后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到 <code>maxPoolSize</code>，则会执行拒绝策略。</p>\n</li>\n<li><p><code>LinkedBlockingQuene</code>：基于链表的无界阻塞队列（其实最大容量为 <code>Interger.MAX</code>）；按照 FIFO 排序。由于该队列的近似无界性，当线程池中线程数量达到 <code>corePoolSize</code> 后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到 <code>maxPoolSize</code> ，因此使用该工作队列时，参数 <code>maxPoolSize</code> 其实是不起作用的。</p>\n</li>\n<li><p><code>SynchronousQuene</code>：一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到 <code>maxPoolSize</code>，则执行拒绝策略。</p>\n</li>\n<li><p><code>PriorityBlockingQueue</code>：具有优先级的无界阻塞队列，优先级通过参数Comparator实现。</p>\n</li>\n</ul>\n</li>\n<li><p><code>threadFactory</code> 线程工厂：创建一个新线程时使用的工厂，可以用来设定线程名、是否为 <code>Daemon 线程</code> 等等</p>\n</li>\n<li><p><code>handler</code> 拒绝策略：当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，JDK 中提供了 4 种拒绝策略：</p>\n<ul>\n<li><p><code>CallerRunsPolicy</code>：该策略下，在调用者线程中直接执行被拒绝任务的 <code>run()</code> 方法，除非线程池已经 Shutdown，则直接抛弃任务。</p>\n</li>\n<li><p><code>AbortPolicy</code>：该策略下，直接丢弃任务，并抛出 <code>RejectedExecutionException</code> 异常。</p>\n</li>\n<li><p><code>DiscardPolicy</code>：该策略下，直接丢弃任务，什么都不做。</p>\n</li>\n<li><p><code>DiscardOldestPolicy</code>：该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2-线程池参数设置\"><a href=\"#2-2-线程池参数设置\" class=\"headerlink\" title=\"2.2 线程池参数设置\"></a>2.2 线程池参数设置</h3><ul>\n<li><p>CPU 密集型任务：由于每个线程执行期间都大概率会占用完整的 CPU 时间片，因此通常可以设置为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// processorNum 是指 CPU 的逻辑核心数而非物理核心数。</span></span><br><span class=\"line\">ThreadPoolExecutor threadPool = <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">    processorNum,                         <span class=\"comment\">// corePoolSize，需要根据具体情况调整，例如预留 1 ~ 2 个核心给主业务。</span></span><br><span class=\"line\">    corePoolSize + <span class=\"number\">1</span>,                     <span class=\"comment\">// maximumPoolSize，CPU 密集型通常用 N + 1</span></span><br><span class=\"line\">    <span class=\"number\">10</span>,                                   <span class=\"comment\">// keepAliveTime</span></span><br><span class=\"line\">    TimeUnit.MILLISECONDS,                <span class=\"comment\">// timeUnit</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class=\"number\">32</span>), <span class=\"comment\">// workQueue，CPU 密集型使用有界队列，防止资源耗尽</span></span><br><span class=\"line\">    Executors.defaultThreadFactory(),     <span class=\"comment\">// threadFactory</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> ThreadPoolExecutor.AbortPolicy()  <span class=\"comment\">// rejectPolicy，CPU 密集型需要防止资源抢占</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>IO 密集型任务：由于每个线程执行期间大概率只会占用很少的 CPU 时间片，因此通常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// processorNum 是指 CPU 的逻辑核心数而非物理核心数。</span></span><br><span class=\"line\">ThreadPoolExecutor threadPool = <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">    Math.min(<span class=\"number\">16</span>, (<span class=\"number\">2</span> * processorNum)),            <span class=\"comment\">// corePoolSize，IO 密集型可适当增大，16 为经验值</span></span><br><span class=\"line\">    <span class=\"number\">2</span> * corePoolSize + <span class=\"number\">1</span>,                        <span class=\"comment\">// maximumPoolSize，IO 密集型可适当增大</span></span><br><span class=\"line\">    <span class=\"number\">10</span>,                                          <span class=\"comment\">// keepAliveTime</span></span><br><span class=\"line\">    TimeUnit.MILLISECONDS,                       <span class=\"comment\">// timeUnit</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> PriorityBlockingQueue&lt;Runnable&gt;(<span class=\"number\">32</span>),     <span class=\"comment\">// workQueue，IO 密集型可使用无界队列增加吞吐量</span></span><br><span class=\"line\">    Executors.defaultThreadFactory(),            <span class=\"comment\">// threadFactory</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> ThreadPoolExecutor.DiscardOldestPolicy() <span class=\"comment\">// rejectPolicy，IO 密集型通常以最后发生为准</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Thread.html\" title=\"@LINK\">Oracle-Thread</a><br><a href=\"https://stackoverflow.com/questions/65102625/daemon-and-non-daemon-threads-in-java\" title=\"@LINK\">Daemon And Non-Daemon Threads In Java</a></p>\n","categories":["Java"],"tags":["Java"]},{"title":"Java-ThreadLocal","url":"/post/java/java-threadlocal/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Java-ThreadLocal\"><a href=\"#Java-ThreadLocal\" class=\"headerlink\" title=\"Java-ThreadLocal\"></a>Java-ThreadLocal</h1><h2 id=\"1-认识ThreadLocal\"><a href=\"#1-认识ThreadLocal\" class=\"headerlink\" title=\"1. 认识ThreadLocal\"></a>1. 认识ThreadLocal</h2><p>ThreadLocal 是 Java 中一种很重要的机制 / 数据处理方式，尤其在并发中，数据是否共有、唯一，会直接影响项目的运行逻辑。一般情况下，防止并发冲突或数据不安全的做法是给对象、方法加同步锁 <code>synchronized</code>。但同步锁并不是万能的，例如同步锁会降低批量处理的效率，或者当业务需要保证数据的隔离性，使用同步锁则需要在方法内频繁销毁、重建对象，如果数据使用独立的处理模块，还会破坏模块化，提高耦合。为此，JDK 1.2 增加了一个工具类：即 <strong><code>ThreadLocal</code></strong>。</p>\n<hr>\n<h2 id=\"2-不使用ThreadLocal的问题\"><a href=\"#2-不使用ThreadLocal的问题\" class=\"headerlink\" title=\"2. 不使用ThreadLocal的问题\"></a>2. 不使用ThreadLocal的问题</h2><p>为了更好地理解 ThreadLocal 的设计理念，首先考虑以下两个更普遍一些的场景：</p>\n<ol>\n<li>一个客户端，需要并发地和服务器交互，并且每个连接都需要持久化（需要保存 Cookie）。</li>\n<li>一个客户端，需要并发地存取数据库，并且每个连接都可能会提交超过一个操作。</li>\n</ol>\n<p>（1）如果按最简单的方式来做，每个线程都维护一套自己的网络请求框架，确实不会导致什么异常，但是第一：实际项目中不可能采用这个方案，第二：这么做简直就是“高耦合低内聚”的代表，第三：重新参考以上两条。项目中，绝大部分情况下，一个连接会话会在一个独立的线程内执行，这个线程需要维护一个仅对自己可见的 Cookie，不仅对其他会话不可见，同时也要确保只能获取到自己的 Cookie。</p>\n<p>（2）同样，每个线程都独立维护一套数据库会话管理是不现实的，通常会封装到一个工具类中，从工具类中获取、开启、关闭会话以及提交事务等。假如有一个业务：当修改用户信息时，把这个操作记录保存下来。假如每一次的操作都从连接池获取 Connection，就有可能一个操作执行了另一个可能因为某些原因没有执行，所以一般通过以下方式来获取管理 Connection：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略一些成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connection connection;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取连接实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class.forName(driver);</span><br><span class=\"line\">            connnection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connnection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                connnection.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后用 Transaction 统一提交事务。到目前为止，如果是单线程做这个操作，那是没问题的，但是如果出现并发的情况呢？如果并发很低并且操作轻量，给这个业务方法上同步锁，也是没有问题的，但是如果并发稍微高一些，就不可能放个同步锁了，这时如果还使用这个方案，很有可能会出现 <code>No operations allowed after connection closed</code> 错误，这是因为连接是共享的，如果后启动的线程 2 先执行完并且关闭了连接，先启动的线程 1 再执行相关操作时连接已经被关闭了。</p>\n<hr>\n<h2 id=\"3-ThreadLocal如何解决问题\"><a href=\"#3-ThreadLocal如何解决问题\" class=\"headerlink\" title=\"3. ThreadLocal如何解决问题\"></a>3. ThreadLocal如何解决问题</h2><p>ThreadLocal 为每个线程分配了一个独立的资源副本，并在内部通过一个 Table 表来维护每个线程和其拥有的独立资源副本的映射关系，所有的线程共享这个 Table。简单点说，ThreadLocal 中通过 <code>set()</code> 方法存入对象，通过 <code>get()</code> 方法取出对象，且线程存入的对象只有该线程自己可以获取到，，每个线程也只能获取到自己之前存入的对象，如果没有存入则调用 <code>get()</code> 返回的是 <code>null</code>。</p>\n<p>因此针对以上两个场景，用 ThreadLocal 就可以很好地解决痛点。</p>\n<p>（1）首先是会话连接的持久化，每个线程在建立连接后，调用 <code>set()</code>将自己的 Cookie 存入，并在需要的时候调用 <code>get()</code> 获取即可，对于每个会话线程，<code>get()</code> 到的都只是自己的 Cookie。</p>\n<p>（2）第二个数据库连接管理，也可以把共用的 Connection 放进 ThreadLocal 中管理，改成如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DBUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 省略一些成员变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Connection&gt; localConnection = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取连接实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connnection = localConnection.get();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(connection == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Class.forName(driver);</span><br><span class=\"line\">                connnection = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            localConnection.set(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connnection;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">closeConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Connection connnection = localConnection.get();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (connnection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                connnection.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            localConnection.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个新线程调用 <code>DBUtil.getConnection()</code> 时，会先判断当前线程是否已经存入了一个连接，如果已经存入则直接获取并返回，否则创建一个新的连接，关闭连接时同理。这样，线程之间的连接都是自己的独立对象，不会互相影响。</p>\n<hr>\n<h2 id=\"4-ThreadLocal和同步锁的比较\"><a href=\"#4-ThreadLocal和同步锁的比较\" class=\"headerlink\" title=\"4. ThreadLocal和同步锁的比较\"></a>4. ThreadLocal和同步锁的比较</h2><p>当然，ThreadLocal 并不是万能的，相比较同步锁方式，由于每个线程都拥有自己的资源副本，因此消耗的内存也更多，需要根据具体的业务确定方案。详细分析将在之后重新整理一份独立文章。</p>\n<hr>\n<h2 id=\"5-ThreadLocal源码分析\"><a href=\"#5-ThreadLocal源码分析\" class=\"headerlink\" title=\"5. ThreadLocal源码分析\"></a>5. ThreadLocal源码分析</h2><p>暂未完成</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247504024&idx=1&sn=2415122cb8139549d8d56c737963f5cc\" title=\"@LINk\">细数ThreadLocal三大坑，内存泄露仅是小儿科</a></li>\n</ul>\n","categories":["Java"],"tags":["源码","Java","ThreadLocal"]},{"title":"Linux-IO阻塞模型","url":"/post/linux/linux-io_block/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Linux-IO阻塞模型\"><a href=\"#Linux-IO阻塞模型\" class=\"headerlink\" title=\"Linux-IO阻塞模型\"></a>Linux-IO阻塞模型</h1><p>通常，对于进程间的通信有两对常见的概念：同步和异步、阻塞和非阻塞，但实际上对于通信过程中的发送进程和接收进程而言，这两对概念是同义词，只有站在一个完整的进程间通信流程的角度，才会具有不同性质。</p>\n<h2 id=\"1-同步异步及阻塞非阻塞\"><a href=\"#1-同步异步及阻塞非阻塞\" class=\"headerlink\" title=\"1. 同步异步及阻塞非阻塞\"></a>1. 同步异步及阻塞非阻塞</h2><p>从《操作系统概念》中节选出有关进程通信的部分：</p>\n<blockquote>\n<p>3.4.2.2 Synchronization</p>\n<p>Communication between processes takes place through calls to send() and receive() primitives. There are different design options for implementing each primitive. Message passing may be either <strong>blocking</strong> or <strong>nonblocking</strong> -- also known as <strong>synchronous</strong> and <strong>asynchronous</strong>. (Throughout this text, you will encounter the concepts of synchronous and asynchronous behavior in relation to various operating-system algorithms.)</p>\n<ul>\n<li>Blocking send. The sending process is blocked until the message is received by the receiving process or by the mailbox.</li>\n<li>Nonblocking send. The sending process sends the message and resumes operation.</li>\n<li>Blocking receive. The receiver blocks until a message is available.</li>\n<li>Nonblocking receive. The receiver retrieves either a valid message or a null.</li>\n</ul>\n<p>Different combinations of send() and receive() are possible. When both send() and receive() are blocking, we have a rendezvous between the sender and the receiver. The solution to the producer-consumer problem becomes trivial when we use blocking send() and receive() statements. The producer merely invokes the blocking send() call and waits until the message is delivered to either the receiver or the mailbox. Likewise, when the consumer invokes receive(), it blocks until a message is available. This is illustrated in Figures 3.15 and 3.16.</p>\n</blockquote>\n<p>大致含义为：</p>\n<p>进程间通信通过 <code>send()</code> 发送和 <code>receive()</code> 接收两种操作完成，这两种操作可能存在多种实现方案。消息在进程间传递时有可能是 <strong>阻塞</strong> 或 <strong>非阻塞</strong> 的，也被称为 <strong>同步</strong> 和 <strong>异步</strong>。</p>\n<ul>\n<li>Blocking Send 阻塞发送：发送方发送消息后将一直阻塞，直到接收方收到消息。</li>\n<li>Nonblocking Send 非阻塞发送：发送方将消息发出后就处理其他任务，不论消息是否被接收方收到。</li>\n<li>Blocking Receive 阻塞接收：接收方调用 <code>receive()</code> 后将一直阻塞，直到收到一条可用消息。</li>\n<li>Nonblocking Receive 非阻塞接收：接收方调用 <code>receive()</code> 后将立即获得一条可用消息，或是一个空值，而不会阻塞。</li>\n</ul>\n<p>因此进程间通信时，站在进程的角度是对「发送方 / 接收方」与「阻塞 / 非阻塞」的自由组合，而「阻塞 / 非阻塞」与「同步 / 异步」是同义词。</p>\n<hr>\n<h2 id=\"2-进程切换\"><a href=\"#2-进程切换\" class=\"headerlink\" title=\"2. 进程切换\"></a>2. 进程切换</h2><p>当 Linux 从一个进程切换到另一个进程时通常包含一下几个步骤：</p>\n<ul>\n<li>对于运行中的进程，<strong>中断（Interrupt）</strong> 或 <strong>系统调用（System Call）</strong> 都可以将 CPU 的控制转移到内核。<ul>\n<li>中断（Interrupt）：CPU 有一个中断信号位，CPU 在每个时钟周期的末尾都会检测中断信号位是否有中断信号到达，如果有则会根据中断的优先级决定是否要暂停当前执行的指令，转而去执行处理中断的指令。</li>\n<li>时钟中断（Clock Interrupt）：一个硬件时钟每隔一段时间就会向 CPU 发送一个中断信号，CPU 在响应这个中断时就会去执行操作系统内核的指令，继而将 CPU 的控制转移给了内核，由内核决定下一个要被执行的指令。</li>\n<li>系统调用（System Call）：操作系统提供给应用程序的接口。用户态通过 System Call 来完成那些需要内核才能执行的操作，例如硬盘、网络接口设备的 IO 等。</li>\n</ul>\n</li>\n<li>内核会将原进程在 CPU 中的上下文（程序计数器、寄存器等）信息保存在分配给该进程的内存区域 PCB 中。</li>\n<li>内核从另一个进程的 PCB 中取出其上下文信息，将 CPU 的控制转移给新进程，开始执行新进程的指令。</li>\n</ul>\n<p>当 CPU 在进程间切换时，由于需要在用户态和内核态之间切换，并且需要对进程的 PCB 做读写，所以会带来一定的开销，对于运行着 Unix 系统的现代 PC 而言，进程切换通常至少需要花费 300 us。</p>\n<p>因此，当进程间需要通信时，CPU 需要一定的时间做数据的 IO 和进程切换，并且由于进程间内存默认不可共享，所以往往还伴随着数据的拷贝，这就导致发送进程和接收进程在这段等待时间内可以有不同的策略，也即是否阻塞。</p>\n<hr>\n<h2 id=\"3-进程间通信的模型\"><a href=\"#3-进程间通信的模型\" class=\"headerlink\" title=\"3. 进程间通信的模型\"></a>3. 进程间通信的模型</h2><p>在实际的进程间通信案例中，阻塞通信会使得进程的执行是顺序的，开发人员可以预知进程的执行情况。而非阻塞通信则可以提高 CPU 的利用率，换言之也就是提高性能。但在实际的进程间通信过程中，通常会考虑一个完整的进程间通信流程，此时「阻塞 / 非阻塞」更多是指通信过程中数据的流动，才会与「同步 / 异步」搭配定义。</p>\n<p>但是需要明确，「同步」一定意味着「阻塞」，反之「阻塞」也一定意味着「同步」，「异步」一定意味着「非阻塞」，但「非阻塞」不一定「异步」，根据进程的执行策略而有所区别。</p>\n<h3 id=\"3-1-同步阻塞BIO\"><a href=\"#3-1-同步阻塞BIO\" class=\"headerlink\" title=\"3.1 同步阻塞BIO\"></a>3.1 同步阻塞BIO</h3><p>发送进程 A 向接收进程 B 发送消息，随后 A 挂起，等待内核将消息发送给 B，处理完后内核重新唤醒 A，A 再将返回的数据从内核拷贝到进程内。</p>\n<ul>\n<li>A 在发送数据后挂起等待 B 接收数据，这个过程是阻塞的。</li>\n<li>B 成功接收数据后，A 继续挂起等待 B 处理数据完成，这个过程也是阻塞的。</li>\n<li>B 处理完成返回数据后，内核唤醒 A，A 仍然需要等待从内核将数据拷贝回用户进程，这个过程也是阻塞的。</li>\n</ul>\n<p>由于整个过程中，A 都处于阻塞状态，直到被唤醒后执行吓一条指令，所以从整个通信过程来看也是同步的。</p>\n<h3 id=\"3-2-同步非阻塞NIO\"><a href=\"#3-2-同步非阻塞NIO\" class=\"headerlink\" title=\"3.2 同步非阻塞NIO\"></a>3.2 同步非阻塞NIO</h3><p>发送进程 A 向接收进程 B 发送消息，随后 A 立即执行其他指令，但每个一段时间就会主动发起请求，查询 B 是否成功接收数据，以及是否处理完毕返回数据，如果有返回数据，则继续执行原来的指令，并将数据从内核拷贝到进程内。</p>\n<ul>\n<li>A 发送数据后立即执行其他指令，不论 B 是否成功接收数据，这个过程是非阻塞的。</li>\n<li>A 周期性请求内核，查询 B 是否成功接收数据，以及是否在执行完毕后返回了数据，这个过程是非阻塞的。</li>\n<li>B 成功接收数据后，将状态同步给内核。B 处理完成返回后，将数据拷贝到内核空间，A 查询到后，再将返回的数据从内核拷贝到 A 进程中，这个过程是阻塞的。</li>\n</ul>\n<p>由于 B 返回数据后，A 需要从内核拷贝数据，这个过程仍然是阻塞的，所以从整个通信过程来看仍然是同步的。</p>\n<h3 id=\"3-3-同步信号驱动\"><a href=\"#3-3-同步信号驱动\" class=\"headerlink\" title=\"3.3 同步信号驱动\"></a>3.3 同步信号驱动</h3><p>发送进程 A 向接收进程 B 发送消息，随后 A 立即执行其他指令，直到 B 处理完毕并返回数据后，由内核通知进程 A，然后 A 再从内核将数据拷贝到进程内。</p>\n<ul>\n<li>A 发送数据后立即执行其他指令，不论 B 是否成功接收，这个过程是非阻塞的。</li>\n<li>B 处理完并返回数据后，内核通知 A，这个过程是非阻塞的。</li>\n<li>A 从内核中拷贝数据到进程内，这个过程是阻塞的。</li>\n</ul>\n<p>虽然信号驱动模型不再需要 A 频繁主动查询 B 的数据返回状态，但由于最终仍然需要将数据从内核拷贝到 A 进程，这个过程依然是阻塞的，所以从整个通信过程来看仍然是同步的。</p>\n<h3 id=\"3-4-同步IO多路复用\"><a href=\"#3-4-同步IO多路复用\" class=\"headerlink\" title=\"3.4 同步IO多路复用\"></a>3.4 同步IO多路复用</h3><p>多个发送进程向同一个管道注册，由管道完成和内核的交互。当一个进程通过 <code>select</code> 函数从管道获取数据时，如果所有被监听的 IO 的数据都没有准备好，则调用 <code>select</code> 的当前进程会进入阻塞状态，直到「任意一个」被监听的 IO 数据已准备好并返回，然后通知对应的监听进程，监听进程再从内核中将数据拷贝到进程内。</p>\n<p>由于 IO 多路复用在调用 <code>select</code> 时会进入阻塞状态，并且监听进程在收到数据已准备好的通知后，仍需从内核拷贝数据到进程内，因此从整个通信过程来看仍然是同步的。</p>\n<h3 id=\"3-5-异步非阻塞AIO\"><a href=\"#3-5-异步非阻塞AIO\" class=\"headerlink\" title=\"3.5 异步非阻塞AIO\"></a>3.5 异步非阻塞AIO</h3><p>进程 A 发起一个 <code>aio_read</code> 指令，将自己的「描述符」、「缓冲区指针」、「缓冲区大小」、「回调函数 / 回调信号」信息发送给内核，内核 <code>aio_read</code> 指令会立即返回，进程 A 即可执行其他指令。当 A 指令所需的数据准备好后，再由内核负责把数据拷贝到 A 的用户内存，然后再通过回调信号或基于线程的回调的方式，通知进程 A，此时 A 已经可以直接操作所需数据而不需要拷贝，是真正的异步 IO。</p>\n<hr>\n<h2 id=\"4-Java中的IO\"><a href=\"#4-Java中的IO\" class=\"headerlink\" title=\"4. Java中的IO\"></a>4. Java中的IO</h2><h3 id=\"4-1-BIO\"><a href=\"#4-1-BIO\" class=\"headerlink\" title=\"4.1 BIO\"></a>4.1 BIO</h3><p>BIO 面向「流」<code>Stream</code>，<code>Stream</code> 只能单项传输，Java 中对应的就是输入流 <code>InputStream</code> 和输出流 <code>OutputStream</code>。最普通的 Socket 和 ServerSocket 就基于 BIO，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketBIO</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动 Server</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    startService();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 启动 Client</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    startClient();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 绑定 8888 端口，最大同时连接数为 5，超出的请求会被拒绝。</span></span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接受一个连接，accept 是阻塞的</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> (Socket client = serverSocket.accept()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从客户端读取数据</span></span><br><span class=\"line\">                BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readLength = bufferedReader.read();</span><br><span class=\"line\">                bufferedReader.close();</span><br><span class=\"line\">                <span class=\"comment\">// 向客户端发送数据</span></span><br><span class=\"line\">                BufferedWriter bufferedWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">                bufferedWriter.write(<span class=\"string\">&quot;Output Content&quot;</span>);</span><br><span class=\"line\">                bufferedWriter.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 连接本地 8888 端口。</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> (Socket client = <span class=\"keyword\">new</span> Socket(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从服务端读取数据</span></span><br><span class=\"line\">                BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(client.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">int</span> readLength = bufferedReader.read();</span><br><span class=\"line\">                bufferedReader.close();</span><br><span class=\"line\">                <span class=\"comment\">// 向服务端写入数据</span></span><br><span class=\"line\">                BufferedWriter bufferedWriter = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(client.getOutputStream()));</span><br><span class=\"line\">                bufferedWriter.write(<span class=\"string\">&quot;Output Content&quot;</span>);</span><br><span class=\"line\">                bufferedWriter.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然上例中 Socket 和 ServerSocket 都用了 <code>BufferedWriter</code> 和 <code>BufferedReader</code>，但 Socket 本身提供的是输入流和输出流 <code>client#getXXXStream</code>，只是业务上再封装了一层 Buffer，所以 BIO 本质上是「流式传输」。</p>\n<h3 id=\"4-2-NIO\"><a href=\"#4-2-NIO\" class=\"headerlink\" title=\"4.2 NIO\"></a>4.2 NIO</h3><p>NIO 面向「通道」<code>Channel</code>，<code>Channel</code> 支持双向传输，Java 中常见的 Channel 有：</p>\n<ul>\n<li><code>FileChannel</code></li>\n<li><code>DatagramChannel</code></li>\n<li><code>SocketChannel</code></li>\n<li><code>ServerSocketChannel</code></li>\n</ul>\n<p><code>Channel</code> 只是一种双向通信模型，因此通常搭配 <code>Buffer</code> 一起使用，由 <code>Buffer</code> 充当实际数据的载体，Java 中常见的 Buffer 有：</p>\n<ul>\n<li><code>ByteBuffer</code></li>\n<li><code>CharBuffer</code></li>\n<li><code>ShortBuffer</code></li>\n<li><code>IntBuffer</code></li>\n<li><code>FloatBuffer</code></li>\n<li><code>LongBuffer</code></li>\n<li><code>DoubleBuffer</code></li>\n</ul>\n<p>SocketChannel 和 ServerSocketChannel 就基于 NIO：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketNIO</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开启 Server</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                startService();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 开启 Client</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            startClient();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startService</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开启通道</span></span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定本地 8888 端口，最大同时连接数 5，超出后连接将被拒绝。</span></span><br><span class=\"line\">        serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">8888</span>), <span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置 accept 时为非阻塞</span></span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 接受一个客户端连接</span></span><br><span class=\"line\">            SocketChannel clientChannel = serverSocketChannel.accept();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (clientChannel == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 由于 serverSocketChannel.configureBlocking(false) 使得 accept 变为非阻塞，</span></span><br><span class=\"line\">                <span class=\"comment\">// 因此需要对 accept 返回的 SocketChannel 判空，为空说明没有客户端连接，可以执行其他指令。</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 用 ByteBuffer 缓冲读取字节数据，缓冲区大小设置为 48 字节，</span></span><br><span class=\"line\">            <span class=\"comment\">// Buffer 默认的起始指针 start 和当前指针 current 指向 0 下标，终止指针 limit 指向末位，</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示接下来的操作从 start 开始，当 current 指向 limit 时说明 Buffer 存满了。</span></span><br><span class=\"line\">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 从通道中读取字节数据并写入缓冲区，此时对 Buffer 的操作是「写入」，</span></span><br><span class=\"line\">            <span class=\"comment\">// 每次都向 Buffer 的 current 指向的位写入一个字节，并把 current 指向下一位。</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> readLength = clientChannel.read(byteBuffer);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (readLength &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果原本 Buffer 用于「写入」，则需要「读取」之前需要先将 Buffer 翻转，</span></span><br><span class=\"line\">                <span class=\"comment\">// 使得新 start 指向原 current，新 limit 指向原 start，</span></span><br><span class=\"line\">                <span class=\"comment\">// 表示接下来的操作从 Buffer 原先的 current 位置开始反向进行。</span></span><br><span class=\"line\">                byteBuffer.flip();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;Read: &quot;</span> + byteBuffer.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 重置 Buffer 的 start 和 current 到 0 下标，limit 到末位，</span></span><br><span class=\"line\">                <span class=\"comment\">// 相当于标记这个 Buffer 又可以从头重新操作。</span></span><br><span class=\"line\">                byteBuffer.clear();</span><br><span class=\"line\">                <span class=\"comment\">// 继续从通道中读取数据，直到通道中没有数据为止。</span></span><br><span class=\"line\">                readLength = clientChannel.read(byteBuffer);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 开启通道</span></span><br><span class=\"line\">        SocketChannel clientChannel = SocketChannel.open();</span><br><span class=\"line\">        <span class=\"comment\">// 连接到本地 8888 端口。</span></span><br><span class=\"line\">        clientChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 设置缓冲区大小 48 字节。</span></span><br><span class=\"line\">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">48</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 向 Buffer 写入数据</span></span><br><span class=\"line\">        byteBuffer.put(<span class=\"string\">&quot;Output Content&quot;</span>.getBytes());</span><br><span class=\"line\">        <span class=\"comment\">// 为了读取 Buffer 中的数据并通过 Socket 发送，需要先翻转 Buffer</span></span><br><span class=\"line\">        byteBuffer.flip();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">            clientChannel.write(byteBuffer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        clientChannel.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/19732473/answer/241673170\" title=\"@LINK\">IO 概念区分</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/zMGt19ae0UP7NhNhBX7QUw\" title=\"@LINK\">漫话：如何给女朋友解释什么是Linux的五种IO模型？</a></li>\n<li><a href=\"https://blog.csdn.net/m0_38109046/article/details/89449305\" title=\"@LINK\">ava面试常考的 BIO，NIO，AIO 总结</a></li>\n<li><a href=\"https://blog.csdn.net/oMaoYanEr/article/details/79976359\" title=\"@LINK\">Java NIO总结（一）：Channel、Buffer、Selector</a></li>\n<li><a href=\"https://blog.csdn.net/u013096088/article/details/78638245\" title=\"@LINK\">Java NIO学习笔记二（Buffer的flip()方法详解）</a></li>\n<li><a href=\"https://blog.csdn.net/he_jiawang/article/details/84792619\" title=\"@LINK\">Java——SocketChannel</a></li>\n</ul>\n","categories":["Linux"],"tags":["Linux","IO","同步","异步","阻塞","非阻塞"]},{"title":"Linux-Process","url":"/post/linux/linux-process/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Linux-IO阻塞模型\"><a href=\"#Linux-IO阻塞模型\" class=\"headerlink\" title=\"Linux-IO阻塞模型\"></a>Linux-IO阻塞模型</h1><h2 id=\"1-Linux中的进程\"><a href=\"#1-Linux中的进程\" class=\"headerlink\" title=\"1. Linux中的进程\"></a>1. Linux中的进程</h2><hr>\n<h2 id=\"2-DaemonProcess\"><a href=\"#2-DaemonProcess\" class=\"headerlink\" title=\"2. DaemonProcess\"></a>2. DaemonProcess</h2><p>在 Linux 中，依赖终端启动的进程将会绑定终端的生命周期，随着终端的结束而结束；而某些进程需要长期在后台存活、周期性处理任务，就需要将其设置为 <strong>守护进程</strong>。守护进程脱离控制终端运行，且不会在任何终端上显示其任何信息。</p>\n<blockquote>\n<p>每一个可交互的界面都被称为「终端」，通过终端启动的进程，都将随着终端进程的结束而结束。</p>\n</blockquote>\n<p>创建守护进程时，可以从任意父进程 fork 出一个子进程然后结束其父进程，则子进程将脱离父进程的生命周期成为 <strong>孤儿进程（Orphan Process）</strong>，操作系统会将孤儿进程视为 init 进程的子进程，由于 init 进程与整个操作系统的生命周期绑定，因此守护进程即可绑定 init 进程的生命周期，直至操作系统结束时才结束。</p>\n<blockquote>\n<p>因此创建一个守护进程实际上有以下几种方式：</p>\n<ul>\n<li>直接从 init 进程 fork；</li>\n<li>从另一个守护进程 fork；</li>\n<li>从任意父进程 fork，然后结束该父进程；</li>\n</ul>\n<p>守护进程「守护」的并不是其他进程，而是其创建者（实际上也就是操作系统）；并且「守护」表示的只不过是与目标共存亡，并没有「保护」的含义。</p>\n</blockquote>\n<p>此外，<strong>init 进程也可以「视为」一个守护进程</strong>，因为其生命周期一定与操作系统绑定，区别在于一个守护进程可以被主动结束或重启，但 Kill init 将会结束整个操作系统。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://stackoverflow.com/questions/36546414/why-the-parent-should-die-in-the-process-of-creating-a-daemon\" title=\"@LINK\">Why the parent should die, in the process of creating a Daemon</a></li>\n<li><a href=\"https://www.zhihu.com/question/38609004/answer/529315259\" title=\"@LINK\">什么是守护进程？</a></li>\n</ul>\n","categories":["Linux"],"tags":["Linux","Process","Daemon","进程","守护"]},{"title":"ML入门-机器学习简介","url":"/post/machinelearning/ml-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-机器学习简介\"><a href=\"#ML入门-机器学习简介\" class=\"headerlink\" title=\"ML入门-机器学习简介\"></a>ML入门-机器学习简介</h1><h2 id=\"1-什么是机器学习\"><a href=\"#1-什么是机器学习\" class=\"headerlink\" title=\"1. 什么是机器学习\"></a>1. 什么是机器学习</h2><p>机器学习是人工智能的一个分支，主要关于构造和研究可以从数据中学习的系统。</p>\n<p>这也说明，机器学习的本质是通过数据实现的，更进一步讲，是从大量无法手动推算出规律、分布、结构的数据中，利用 CPU 强大的计算能力、通过迭代等科学的计算方法来自动计算出某种类型数据的共性，并使用这些共性为新来的数据假设、模拟出其可能的结果。</p>\n<p>机器学习的数据通常包括训练数据和校验数据，其中：</p>\n<ul>\n<li>训练数据用于建立机器学习模型，通常包括：① 输入（特征 <strong>X</strong>）和 ② 输出（标签 y）。<br>注意：此处黑体 <strong>X</strong> 表示矩阵，且有一些模型可以没有输出 y。</li>\n<li>校验数据用于在模型初步建立完毕后检验模型的效果，常常从训练数据中分割一部分作为校验数据，与训练数据具有相同的分布和格式。</li>\n</ul>\n<hr>\n<h2 id=\"2-机器学习的学习类型\"><a href=\"#2-机器学习的学习类型\" class=\"headerlink\" title=\"2. 机器学习的学习类型\"></a>2. 机器学习的学习类型</h2><ol>\n<li>监督学习[Supervised Learning]：从带标签的数据中学习。例：房价预测、邮件识别等。</li>\n<li>非监督学习[Unsupervised Learning]：从无标签的数据中学习蕴含的结构。例：文档聚类等。</li>\n<li>强化学习[Reinforcement Learning]：通过曾经执行的动作及带来的奖惩进行学习，强化学习的标签 y 具有延迟性。例：AI 下棋等，当前棋子带来的影响需要经过一段时间才会表现出来。</li>\n</ol>\n<h3 id=\"2-1-监督学习\"><a href=\"#2-1-监督学习\" class=\"headerlink\" title=\"2.1 监督学习\"></a>2.1 监督学习</h3><p>（1）两种任务类型：</p>\n<ol>\n<li>回归任务（Regression）：输出 $y\\in R$ 为连续值。</li>\n<li>分类任务（Classification）：输出 y 为离散值。</li>\n</ol>\n<p>（2）学习目的：学习到一个 <strong>X</strong> 到 y 的映射 f，从而对新输入的 <strong>X</strong> 预测其输出</p>\n<blockquote>\n<p>$\\hat{y}=f(\\textbf{X})$。</p>\n</blockquote>\n<p>（3）监督学习的训练数据包含标签 y，即标签在训练数据中是可见变量。</p>\n<p>（4）数据样式：</p>\n<blockquote>\n<p>$D=\\{\\textbf{X}_i, y_i\\}_{i=1}^N$</p>\n</blockquote>\n<p>其中 D 为数据集，$X_i$ 与 $y_i$ 为第 i 个样本的输入与输出，N 为样本总数。</p>\n<p>（5）Scikit-Learn 中监督学习的大致流程：</p>\n<ol>\n<li>estimator.fit(X_train, y_train)</li>\n<li>estimator.predict(X_test)</li>\n<li>estimator.score(X_test, y_test)</li>\n</ol>\n<h3 id=\"2-2-非监督学习\"><a href=\"#2-2-非监督学习\" class=\"headerlink\" title=\"2.2 非监督学习\"></a>2.2 非监督学习</h3><p>（1）两种任务类型：</p>\n<blockquote>\n<ol>\n<li>聚类（Clustering）</li>\n<li>降维（Dimension Reduction）</li>\n</ol>\n</blockquote>\n<p>（2）学习目的：发现数据中的“有意义的模式”，亦称为“知识发现”。</p>\n<p>（3）非监督学习的训练数据不包含标签 y，即标签在训练数据中为隐含变量。</p>\n<p>（4）数据样式：</p>\n<blockquote>\n<p>$D=\\{\\textbf{X}_i\\}_{i=1}^N$</p>\n</blockquote>\n<p>（5）Scikit-Learn 中非监督学习的大致流程：</p>\n<ol>\n<li><code>transformer.fit(X_train)</code></li>\n<li><code>X_train_trans = transformer.transform(X_train)</code></li>\n<li><code>X_test_trans = transformer.transform(X_test)</code></li>\n</ol>\n<h3 id=\"2-3-增强学习\"><a href=\"#2-3-增强学习\" class=\"headerlink\" title=\"2.3 增强学习\"></a>2.3 增强学习</h3><p>（1）学习目的：从行为的反馈（奖励或惩罚）中学习，以找到一条回报值最大的路径。</p>\n<p>（2）步骤：设计一个回报函数[Reward Function]，若 Learning Agent 在执行一个动作后获得了较好的结果，则给予一些奖励（例如：回报函数为正），否则给予一些惩罚（例如：回报函数为负），驱使 Learning Agent 寻找出一条最终获得回报总和最高的学习路径。</p>\n<hr>\n<h2 id=\"3-机器学习开发环境\"><a href=\"#3-机器学习开发环境\" class=\"headerlink\" title=\"3. 机器学习开发环境\"></a>3. 机器学习开发环境</h2><p>机器学习开发通常分为两部份：本地开发及验证、真实训练；在探索和调参阶段通常都使用 Python 开发，而在大量数据的真实训练中，则可能使用 Python 或是 C/C++ 完成，并且个人设备已经很难完成对应工作了，因此开发环境的重点在于「本地开发」。为了开发环境的稳定性及更方便地获取依赖包，通常会使用 PyCharm / pyenv / Anaconda 等工具。</p>\n<h3 id=\"3-1-安装Anaconda\"><a href=\"#3-1-安装Anaconda\" class=\"headerlink\" title=\"3.1 安装Anaconda\"></a>3.1 安装Anaconda</h3><p>（1）下载及安装 Anaconda</p>\n<p>进入 <a href=\"https://repo.continuum.io/archive/index.html\" title=\"@LINK\">Anaconda 安装包归档</a>，找到目标版本，以 Linux 下 64 位集成 Python3 环境的最新版本为例，其安装包名称为：<code>Anaconda3-2019.03-Linux-x86_64.sh</code>，在 SSH 终端中输入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 下载安装包（默认在用户目录下，通过切换当前目录更改下载路径）：</span></span><br><span class=\"line\">wget https://repo.continuum.io/archive/Anaconda3-2019.03-Linux-x86_64.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 安装 Anaconda（默认在用户目录内，通过切换当前目录更改下载路径）：</span></span><br><span class=\"line\">bash Anaconda3-5.0.1-Linux-x86_64.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 配置环境变量：</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> .bashrc</span><br></pre></td></tr></table></figure>\n\n<p>在终端内输入 <code>conda --version</code>，正确显示 Anaconda 版本信息则表示安装成功。某些情况下可能需要手动配置环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 对所有用户生效则编辑：/etc/profile</span></span><br><span class=\"line\"><span class=\"comment\"># 对当前用户生效则编辑 ~/.bash_profile</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加环境变量，保存退出后 source 一下，或是重启终端：</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> ANACONDA_HOME=/home/root/anaconda3/bin <span class=\"comment\"># 如果以 root 用户安装，使用此环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> ANACONDA_HOME=~/anaconda3/bin <span class=\"comment\"># 如果以当前用户安装，使用此环境变量（其他用户同理）</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$&#123;PATH&#125;</span>:<span class=\"variable\">$&#123;ANACONDA_HOME&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）修改 Anaconda 默认配置</p>\n<p>Anaconda 默认存在一个名为 <code>base</code> 的虚拟环境，且每次启动 Terminal 时会自动激活 <code>base</code> 环境，可以通过 Shell 配置修改：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改 Shell 配置（以 ZSH 为例，其他同理）：</span></span><br><span class=\"line\">vim ~/.zshrc</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果希望默认不激活 Anaconda，则添加一行命令，启动时取消激活：</span></span><br><span class=\"line\">conda deactivate</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果希望自动激活，但命令行的标题不显示 base 环境名，可还原 Shell 默认标题（也可以自定义）：</span></span><br><span class=\"line\">PS1=&quot;%n@%m %1~ %# &quot; # ZSH 默认命令行标题</span><br><span class=\"line\">PS1=&quot;\\h:\\W \\u\\$ &quot; # Bash 默认命令行标题</span><br></pre></td></tr></table></figure>\n\n<p>（3）新建 Anaconda 虚拟环境</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 首先激活 base 环境：</span></span><br><span class=\"line\">conda activate base</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 然后创建一个名为 demo 的虚拟环境，Python 版本为 3.7.x 最新版：</span></span><br><span class=\"line\">conda create --name demo python=3.7</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 激活和退出虚拟环境：</span></span><br><span class=\"line\">conda activate demo</span><br><span class=\"line\">conda deactivate</span><br></pre></td></tr></table></figure>\n\n<p>（3）管理 pip 依赖包</p>\n<ul>\n<li><p>查看当前已安装的 pip 依赖：<code>pip list</code>；</p>\n</li>\n<li><p>添加 <code>-i</code> 参数使得本次 pip 命令走镜像地址：<code>pip install -i [mirrors_host] [package_name]</code>；</p>\n<ul>\n<li>清华镜像：<code>https://pypi.tuna.tsinghua.edu.cn/simple</code></li>\n<li>阿里云镜像：<code>http://mirrors.aliyun.com/pypi/simple/</code></li>\n<li>中国科技大学镜像：<code>https://pypi.mirrors.ustc.edu.cn/simple/</code></li>\n<li>华中理工大学镜像：<code>http://pypi.hustunique.com/</code></li>\n<li>山东理工大学镜像：<code>http://pypi.sdutlinux.org/</code></li>\n<li>豆瓣镜像：<code>http://pypi.douban.com/simple/</code></li>\n</ul>\n</li>\n<li><p>修改 pip 配置文件使得全局 pip 命令均走镜像地址：</p>\n<ul>\n<li>Mac / Linux 系统修改：<code>~/.pip/pip.conf</code>；</li>\n<li>Windows 系统修改或创建：<code>C:\\Users\\XXX\\pip\\pip.ini</code></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">[global] </span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple </span><br><span class=\"line\">[install] </span><br><span class=\"line\">trusted-host=mirrors.aliyun.com </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>常用的依赖包：</p>\n<ul>\n<li>scikit-learn (Including scikit-learn, numpy, scipy, joblib)</li>\n<li>pandas</li>\n<li>numpy</li>\n<li>nose</li>\n<li>jupyter</li>\n<li>Pillow</li>\n<li>psutil</li>\n<li>pygame</li>\n<li>seaborn</li>\n<li>matplotlib</li>\n<li>caregory_encoders</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-彻底卸载Anaconda\"><a href=\"#3-2-彻底卸载Anaconda\" class=\"headerlink\" title=\"3.2 彻底卸载Anaconda\"></a>3.2 彻底卸载Anaconda</h3><p>（1）准备工作</p>\n<ul>\n<li>确认 conda 环境变量可用；</li>\n<li>退出 conda 环境；</li>\n<li>关闭 conda 相关功能；</li>\n</ul>\n<p>（2）安装 Anaconda 命令行卸载工具</p>\n<p>执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda install anaconda-clean</span><br></pre></td></tr></table></figure>\n\n<p>（3）使用卸载工具卸载</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先激活默认环境</span></span><br><span class=\"line\">conda activate</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 执行卸载</span></span><br><span class=\"line\">anaconda-clean</span><br></pre></td></tr></table></figure>\n\n<p>卸载过程会提示是否删除对应模块，彻底卸载则全部选 <code>y</code> 即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Delete .anaconda? (y/n): y</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 会自动生成一个备份，具体路径以实际为准</span></span><br><span class=\"line\">Backup directory: /Users/xxx/.anaconda_backup/xxx</span><br><span class=\"line\">Delete .conda? (y/n): y</span><br><span class=\"line\">Delete .condarc? (y/n): y</span><br><span class=\"line\">Delete .ipython? (y/n): y</span><br><span class=\"line\">Delete .jupyter? (y/n): y</span><br><span class=\"line\">Delete .matplotlib? (y/n): y</span><br></pre></td></tr></table></figure>\n\n<p>（4）删除残留文件</p>\n<ul>\n<li>删除卸载工具生成的备份文件：<code>rm -rf /Users/xxx/.anaconda_backup/xxx</code></li>\n<li>删除安装路径下的文件：<code>sudo rm -rf /Applications/anaconda3</code></li>\n<li>删除环境变量中与 Anaconda 有关的部份；</li>\n<li>删除可能存在的隐藏文件：<code>rm -rf ~/.condarc ~/.conda ~/.continuum</code></li>\n</ul>\n<h3 id=\"3-3-配置Jupyter-Notebook\"><a href=\"#3-3-配置Jupyter-Notebook\" class=\"headerlink\" title=\"3.3 配置Jupyter Notebook\"></a>3.3 配置Jupyter Notebook</h3><p>使用命令 <code>pip install jupyter</code> 安装 Jupyter 到当前环境中，如果需要切换环境，可以先在 Anaconda 中新建环境并切换至新环境后执行命令；安装后可输入 <code>jupyter notebook</code> 启动，验证环境配置。</p>\n<p>默认情况下，Jupyter Notebook 运行时的工作目录为当前用户根目录，每次运行都要手动切换到开发目录，可通过 Jupyter 配置文件来修改：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先备份原始配置文件（如果有的话），以防万一：</span></span><br><span class=\"line\">mv ~/.jupyter/jupyter_notebook_config.py ~/.jupyter/jupyter_notebook_config.py.BAK</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 生成新的配置文件：</span></span><br><span class=\"line\">jupyter notebook --generate config</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改配置文件：</span></span><br><span class=\"line\">vim ~/.jupyter/jupyter_notebook_config.py</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改以下行为自定工作目录：</span></span><br><span class=\"line\">c.NotebookApp.notebook_dir = &#x27;XXX&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-在云服务器中运行Jupyter\"><a href=\"#3-4-在云服务器中运行Jupyter\" class=\"headerlink\" title=\"3.4 在云服务器中运行Jupyter\"></a>3.4 在云服务器中运行Jupyter</h3><p>如果是在云服务器中配置 Jupyter，安装后通过远程连接启动 <code>jupyter notebook</code> 发现连不上 Jupyter 服务，这是因为服务器上的 Jupyter 还没有配置外网访问。配置方式如下：</p>\n<p>（1）生成 Jupyter 配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">jupyter notebook --generate-config</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\">jupyter notebook --generate-config --allow-root</span><br></pre></td></tr></table></figure>\n\n<p>（2）打开 ipython，创建一个登录 jupyter 的密码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 进入 ipython 环境</span></span><br><span class=\"line\">ipython</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入 password 模块</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> notebook.auth <span class=\"keyword\">import</span> passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改密码</span></span><br><span class=\"line\">passwd()</span><br></pre></td></tr></table></figure>\n\n<p>然后会要求输入一次密码和一次确认密码，输入过程屏幕上不会有任何显示。正确输入密码后，会输出一个哈希值（省略后半部分），请复制或记录这个值：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&#x27;sha1:5311cd8b9da9:70dd3321..............&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）修改 Jupyter 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">vi ~/.jupyter/jupyter_notebook_config.py</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># vi /root/.jupyter/jupyter_notebook_config.py</span></span><br></pre></td></tr></table></figure>\n\n<p>在打开的配置中添加以下参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.NotebookApp.ip=<span class=\"string\">&#x27;*&#x27;</span></span><br><span class=\"line\">c.NotebookApp.password = u<span class=\"string\">&#x27;sha1:5311cd8b9da9:70dd3321..............&#x27;</span></span><br><span class=\"line\">c.NotebookApp.open_browser = False</span><br><span class=\"line\">c.NotebookApp.port = 8888</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>password</code> 项输入上一步复制的哈希值，<code>port</code> 项推荐使用默认的 8888 端口，也可以自己定义。</p>\n<p>（4）检查远程服务器配置：</p>\n<p>云服务器上配置好 Jupyter 后可通过以下方式远程访问：</p>\n<ul>\n<li>在已登录的 SSH 远程连接中执行：<code>jupyter notebook</code>（root 用户需要附加 <code>--allow-root</code> 参数）；</li>\n<li>本地浏览器访问：<code>http://云服务器公网ip:端口</code>（例如 <code>http://127.0.0.1:8888</code>）；</li>\n</ul>\n<p>如果仍无法通过远程访问，则可能是因为云服务器的安全组还没有配置，8888 端口（或自己设置的端口号）还没有开放给公网。设置安全组的过程如下：</p>\n<ol>\n<li>进入云服务器控制台</li>\n<li>进入安全组设置</li>\n<li>添加安全组规则</li>\n<li>选择协议类型为 <strong>自定义 TCP</strong>，输入端口号为 8888（或自定义端口号），授权 IP 设置为 0.0.0.0（即不限访问 IP，不论哪里的网络都可以连接访问云服务器的 Jupyter）</li>\n</ol>\n<p>配置完成后，即可通过 SSH 终端或浏览器输入地址的方式进入服务器的 Jupyter Notebook 了！如果仍旧提示无法访问，且云服务器所选的 Linux 系统为 Ubuntu（其他系统没试过），或许是因为防火墙的缘故，通过以下方式关闭：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ufw <span class=\"built_in\">disable</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-服务器后台运行Jupyter\"><a href=\"#3-5-服务器后台运行Jupyter\" class=\"headerlink\" title=\"3.5 服务器后台运行Jupyter\"></a>3.5 服务器后台运行Jupyter</h3><p>在选择云服务器训练数据时，除了考虑到算力的问题，当然也有持续运行的问题。尽管通过设置 SSH 的会花时间已经可以使得服务器的 Jupyter 一直在激活状态，但如果是自己的工作电脑，甚至办公本，平时还有大量的工作需要使用电脑，，一直在本地挂着一个 SSH 会话不能关机不能断开，总还是不妥，更何况如果遇到突然断网、突然死机等问题时，会话一关就中断运行，想想就让人抓狂。为此，给服务器的当前任务配置一个后台运行就显得尤为必要了。</p>\n<p>通常，在 Linux 中，可以用 <code>nohup [command]</code> 来保持一项任务不被挂起，使用 <code>nohup [command] &amp;</code> 来将任务转至后台并保持不被挂起。指令执行后，Linux 会立即将任务转至后台运行，且返回输出一个进程号：PID，当我们需要手动停止该进程时，可以通过 <code>kill -TRM [PID]</code> 来终止该进程。同时，该进程的所有输出均会默认存储至当前目录下的 <code>nohup.out</code> 文件中，使用命令 <code>tail -f nohup.out</code> 来实时查看动态输出，或者也可以使用：<code>nohup [command] &gt; out.log &amp;</code> 命令将输出重定向至自定义的文件（本例为out.log）并查看。</p>\n<p>这对于 Jupyter 任务来说也是一样的，我们可以通过将 Jupyter 任务转至后台持续运行来释放本地电脑的工作压力：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 非 root 用户：</span></span><br><span class=\"line\">nohup jupyter notebook &amp;</span><br><span class=\"line\"><span class=\"comment\"># root 用户：</span></span><br><span class=\"line\"><span class=\"comment\"># nohup jupyter notebook --allow-root &amp;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，当我们在 Jupyter 开始一项耗时任务后，即可直接断开 SSH 会话。<strong>注意：在本地需要离线时，不能终止 Jupyter 的进程，而应该直接断开 SSH 连接。</strong></p>\n<p>另外还有一点，由于 Jupyter 本身的局限性，当一个正在运行任务的 Jupyter 页面被关闭（而没有关闭服务）后，再次打开，只能保留前一次的结果，而不能恢复任务运行过程，因此，使用 nohup 命令转至后台的 Jupyter 任务应当是具有完整结果的，而不能再带有需要交互的部分，例如：</p>\n<ol>\n<li>将某个数据集预先确定好的特征进行哈希编码，并将编码完的数据重新输出存储。</li>\n<li>将某个数据集预先确定好的特征进行哈希编码，并询问我是否存储，根据选择完成相应任务。</li>\n</ol>\n<p>假设在任务开始后，本地立即断开 SSH 连接，并等待任务完成后再重新连接。那么：<br>任务 1 是合理的，因为任务过程不需要交互，重新连接后，可以在服务器的本地找到输出的已完成哈希编码的数据集。<br>任务 2 是不合理的，因为任务执行完编码后，不能完成交互因此任务将直接运行结束，重新连接后相当于白费力气。</p>\n<p>另外，除了基本的后台防挂起 nohup 外，还有一些工具也可以用来保持任务现场并恢复，例如：screen 和 tmux，可参考附录【7】、【8】，但终究因为 Jupyter 本身的原因，还是不太适合这种长时间可恢复的后台运行模式，我的建议是通过 Python 脚本进行长时间的后台操作，并尽量减少交互部分，及时将后续可能要用的数据保存成文件，而在 Jupyter 上仅作为一些可视化或测试、调整等的工具使用。</p>\n<h3 id=\"3-6-服务器SSH会话保活\"><a href=\"#3-6-服务器SSH会话保活\" class=\"headerlink\" title=\"3.6 服务器SSH会话保活\"></a>3.6 服务器SSH会话保活</h3><p>在使用云服务器的过程中，有时去做别的事了过了一段时间后再看 SSH 终端，发现先是没反应、无法输入，再过一会儿就提示连接已断开，这是因为默认情况下 SSH 会话有一个连接时间，一段时间后就会断开会话。可以通过以下方式修改时间，以达到 SSH 会话保活的目的：</p>\n<p>（1）在远程服务器执行：<code>TMOUT=0</code>，该方式方便、快捷，但缺点是仅对本次登陆有效，退出 SSH 后重新登录则需要再次设置。</p>\n<p>（2）修改ssh配置文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打开配置文件</span></span><br><span class=\"line\">vi /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 ClientAliveInterval，该参数指定了服务器端向客户端请求消息的时间间隔。默认是0，不发送</span></span><br><span class=\"line\"><span class=\"comment\"># 修改 ClientAliveInterval 的值，单位为秒。如设置 600，即每 10 分钟发送一次请求保持会话。</span></span><br><span class=\"line\">ClientAliveInterval = 600</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 找到 ClientAliveCountMax，该参数表示允许超时的次数。</span></span><br><span class=\"line\"><span class=\"comment\"># 如果发现客户端没有响应，则判断一次超时，请根据实际需要进行设置。比如设置为10，表示允许超时6000 秒 = 100 分钟。</span></span><br><span class=\"line\">ClientAliveCountMax = 10</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-7-服务器虚拟内存\"><a href=\"#3-7-服务器虚拟内存\" class=\"headerlink\" title=\"3.7 服务器虚拟内存\"></a>3.7 服务器虚拟内存</h3><p>在运行大量数据集的时候，很有可能报这个错：<code>Memory Error</code>，这个错在 Python 里面也不算罕见了，一般表示瞬间内存占用超过了可用内存，可通过 <code>free -m</code> 命令查看内存信息，如果云服务器选择了纯净的 Linux，很可能默认配置没有交换内存，好在现在的 ECS 大多都使用了固态硬盘，即便默认非固态硬盘的，升级成本也比较低，因此可以拿出一部分硬盘作为交换内存使用。</p>\n<p>（1）创建swap文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 /usr 目录下创建交换内存文件</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /usr</span><br><span class=\"line\">mkdir swap</span><br><span class=\"line\"><span class=\"built_in\">cd</span> swap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看目前总用量</span></span><br><span class=\"line\">ll</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个循环，每次复制 1024 字节，共复制 1024000 次（10G）并输出为 swapfile1 文件。</span></span><br><span class=\"line\"><span class=\"comment\"># if 表示 infile，of 表示 outfile，bs=1024 表示写入的每个块的大小为 1024B，即 1KB。</span></span><br><span class=\"line\">dd <span class=\"keyword\">if</span>=/dev/zero of=/usr/swap/swapfile1 bs=1024 count=1024000</span><br></pre></td></tr></table></figure>\n\n<p>（2）查看刚才创建的 swap 文件大小与路径：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">du -sh /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n\n<p>（3）将目标文件设置为 swap 分区文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkswap /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n\n<p>（4）激活 swap，立即启用交换分区文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">swapon /usr/swap/swapfile1</span><br></pre></td></tr></table></figure>\n\n<p>至此交换内存已经设置好了，并已激活可用，但仅限本次开机可用，想要每次开机都自动加载这个交换内存，则需要修改 <code>/etc/fstab</code> 文件</p>\n<p>（5）编辑文件 <code>/etc/fstab</code> 中的 <code>swap</code> 行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/fstab</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>/etc/fstab</code> 编辑状态下（UUID 省略后半部分），添加下面这段的最后一行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/dev/mapper/vg_localhost-lv_root   /         ext4    defaults        1 1</span><br><span class=\"line\">UUID=cef520a0-df77-4........       /boot     ext4    defaults        1 2</span><br><span class=\"line\"><span class=\"comment\"># /dev/mapper/vg_localhost-lv_swap   swap      swap    defaults        0 0</span></span><br><span class=\"line\"><span class=\"comment\"># 下面这行是关键：</span></span><br><span class=\"line\">/usr/swap/swapfile1                swap      swap    defaults        0 0</span><br></pre></td></tr></table></figure>\n\n<p>保存并重启系统后，再次输入 <code>free -m</code> 命令，即可看到多了一个 <code>swap</code> 内存，大小为 10G。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.cnblogs.com/mypath/articles/7877493.html\" title=\"@LINK\">linux下安装Anaconda</a></li>\n<li><a href=\"https://blog.csdn.net/m0_37748303/article/details/78764625\" title=\"@LINK\">阿里云连接jupyter notebook的步骤</a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/25475.html?spm=a2c4e.11153940.blogcont98527.62.4d126b80ucvIpF#h2-url-6\" title=\"@LINK\">安全组应用案例六：允许公网远程连接实例</a></li>\n<li><a href=\"https://support.huaweicloud.com/trouble-ecs/zh-cn_topic_0138293301.html\" title=\"@LINK\">怎样长时间保持SSH会话连接不断开？</a></li>\n<li><a href=\"https://blog.csdn.net/ludongdong/article/details/78524653\" title=\"@LINK\">mac 本地文件与服务器Linux文件之间的相互传输</a></li>\n<li><a href=\"https://www.jianshu.com/p/6d1a48cc6ce2\" title=\"@LINK\">如何不挂起后台，继续运行jupyter</a></li>\n<li><a href=\"https://help.aliyun.com/knowledge_detail/42523.html\" title=\"@LINK\">云服务器 ECS Linux SSH 客户端断开后保持进程继续运行配置方法</a></li>\n<li><a href=\"https://www.jianshu.com/p/300333a3f2ba\" title=\"@LINK\">使用tmux保持远程ssh连接</a></li>\n<li><a href=\"https://www.cnblogs.com/llkmst/p/4684097.html\" title=\"@LINK\">Linux 修改swap虚拟内存大小</a></li>\n</ul>\n","categories":["MachineLearning"],"tags":["AI","MachineLearning","人工智能","机器学习"]},{"title":"HTTP和HTTPS","url":"/post/network/network-http_https/","content":"<span id=\"more\"></span>\n\n<h1 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h1><h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><h3 id=\"HTTP报文格式\"><a href=\"#HTTP报文格式\" class=\"headerlink\" title=\"HTTP报文格式\"></a>HTTP报文格式</h3><p>（1）HTTP 请求报文</p>\n<p>HTTP 请求报文包括：请求行（Request Line）、请求头（Request Header）、请求数据（Request Data）、空行四个部分。</p>\n<p><a href=\"https://blog.csdn.net/zx_emily/article/details/83024065\">https://blog.csdn.net/zx_emily/article/details/83024065</a></p>\n<h3 id=\"Http缓存\"><a href=\"#Http缓存\" class=\"headerlink\" title=\"Http缓存\"></a>Http缓存</h3><ul>\n<li>常见端口号（80、443、23等）对应的含义</li>\n</ul>\n<p>23：远程登录 Telnet 服务。</p>\n<p>80：HTTP服务的端口号</p>\n<p>443：HTTPS服务的端口号</p>\n<h2 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h2><h3 id=\"SSL\"><a href=\"#SSL\" class=\"headerlink\" title=\"SSL\"></a>SSL</h3><p><a href=\"https://www.cnblogs.com/jesse131/p/9080925.html\">https://www.cnblogs.com/jesse131/p/9080925.html</a></p>\n<p>对称加密：发送和接收用同一个秘钥加解密。<br>非对称加密：发送方用公钥加密，接收方用私钥解密。</p>\n<p>发送方发送一个协议版本号和一个随机数，以及客户端支持的加密算法。<br>接收方选择一个公钥，并给出数字证书以及一个新的随机数。<br>发送方确认证书有效，使用接收到的公钥发送一个新的随机数<br>接收方用私钥解密随机数，并使用之前的三个随机数生成一个对话秘钥，用这个秘钥加密接下来的整个会话数据。</p>\n<h3 id=\"HTTPS流程\"><a href=\"#HTTPS流程\" class=\"headerlink\" title=\"HTTPS流程\"></a>HTTPS流程</h3><p>客户端访问HTTPS请求，连接到Server的443端口<br>Server回应证书和公钥<br>客户端TLS验证公钥，如果有异常则弹出警告提示<br>客户端根据证书查找本地对应的证书，如果找不到，说明证书不可信。<br>如果找到了，取出本地证书对应的公钥，对Server发来的证书的签名进行解密。<br>客户端使用hash算法计算Server传来的证书的Hash值，并和解密出来的证书中的签名作对比。<br>如果一致，说明公钥没有被替换，则可以用该公钥继续后面的加密会话了。<br>客户端用公钥加密一个随机数，发送给服务端。<br>Server使用私钥解密随机值，然后将会话数据通过该值进行对称加密。<br>客户端可以同样用之前生成的随机值解密Server发过来的数据。<br>整个过程，即使被第三方监听，也无法改变。</p>\n","categories":["Network"],"tags":["Network","HTTP","SSL","HTTPS"]},{"title":"Network-RTMP","url":"/post/network/network-rtmp/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Network-RTMP\"><a href=\"#Network-RTMP\" class=\"headerlink\" title=\"Network-RTMP\"></a>Network-RTMP</h1><hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/191542130\" title=\"@LINK\">流媒体：RTMP 协议完全解析</a></li>\n<li><a href=\"https://blog.csdn.net/z920954494/article/details/52108608\" title=\"@LINK\">RTMP详解</a></li>\n</ul>\n","categories":["Network"],"tags":["RTMP"]},{"title":"Network-Socket","url":"/post/network/network-socket/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Network-Socket\"><a href=\"#Network-Socket\" class=\"headerlink\" title=\"Network-Socket\"></a>Network-Socket</h1><h2 id=\"基于TCP的Socket\"><a href=\"#基于TCP的Socket\" class=\"headerlink\" title=\"基于TCP的Socket\"></a>基于TCP的Socket</h2><p>Socket socket = new Socket(String ip, int port); // 本地进程间通信使用 &quot;localhost&quot;<br>boolean isConnected = socket.isConnected();<br>BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));<br>writer.write(byte[] data);<br>writer.flush();<br>writer.close();</p>\n<p>DataInputStream input = new DataInputStream(new BufferedInputStream(socked.getInputStream));<br>byte[] bytes = new byte[MAX_LENGTH_EACH_TIME];<br>while(input.read(bytes) != -1) {</p>\n<p>}<br>服务端：<br>ServerSocket serverSocket = new ServerSocket(int port);<br>Socket socket = ServerSocket.accept();<br>InputStream ......</p>\n<ul>\n<li>socket.accept()函数对应着TCP三次握手中哪一次握手，哪个函数代表连接建立完毕，四次挥手的过程？</li>\n</ul>\n<p>没有对应关系。accept()发生在三次握手之后。服务器监听请求连接，成功三次握手的连接会被存放到连接队列中，accept()方法只是从服务器的连接队列中取出了具体的一个连接实例。</p>\n<h2 id=\"基于UDP的Socket\"><a href=\"#基于UDP的Socket\" class=\"headerlink\" title=\"基于UDP的Socket\"></a>基于UDP的Socket</h2><p>// 发送<br>DatagramSocket socket = new DatagramSocket();<br>socket.connect(String ip, int port);<br>DatagramPacket  sendPacket = new DatagramPacket(byte[] data, int data.length, String ip, int port);<br>socket.send(sendPacket);<br>// 接收<br>while(socket.isConnect()) {<br>    byte[] data = new byte[MAX_LENGTH_EACH_TIME];<br>    DatagramPacket rcvPacket = new DatagramPacket(data, data.length);<br>    socket.receive(rcvPacket);<br>    rcvPacket.getData().length // 等效于 data.length，等于 MAX_LENGTH_EACH_TIME<br>    rcvPacket.getLength() // 实际接收的数据长度，最大 64k<br>    ......<br>}</p>\n<h2 id=\"Socket长连接\"><a href=\"#Socket长连接\" class=\"headerlink\" title=\"Socket长连接\"></a>Socket长连接</h2><p>isClosed()、isConnected()、isInputStreamShutdown()、isOutputStreamShutdown()都是本地判断，只是本地操作connect()或close()方法后保存的状态，无法判断服务端是否主动断开，OutputStream.write()在服务端关闭时也能照常发送不会报错。</p>\n<p>采用服务端心跳回复的机制，客户端发送心跳后，服务端需要回复心跳，并设置中断超时，超过几次心跳后仍然没有回复则主动断开连接。</p>\n","categories":["Network"],"tags":["Network","Socket"]},{"title":"TCP和UDP","url":"/post/network/network-tcp_udp/","content":"<span id=\"more\"></span>\n\n<h1 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h1><h2 id=\"1-TCP\"><a href=\"#1-TCP\" class=\"headerlink\" title=\"1. TCP\"></a>1. TCP</h2><p>TCP 是可靠传输，使用流量控制和拥塞控制，仅支持一对一，首部最小 20 字节最大 60 字节。</p>\n<h3 id=\"1-1-连接的建立与断开\"><a href=\"#1-1-连接的建立与断开\" class=\"headerlink\" title=\"1.1 连接的建立与断开\"></a>1.1 连接的建立与断开</h3><h4 id=\"1-1-1-三次握手建立连接\"><a href=\"#1-1-1-三次握手建立连接\" class=\"headerlink\" title=\"1.1.1 三次握手建立连接\"></a>1.1.1 三次握手建立连接</h4><ul>\n<li>第一次握手：C 向 S 发送一个连接请求，包括一个 <code>SYN = 1, seq = 随机数 i</code>，C 进入 <code>SYN_SENT</code> 状态。</li>\n<li>第二次握手：S 收到请求后，回应一个：<code>SYN = 1, ACK = 1, ack = i + 1, seq = 随机数 j</code>，S 进入 <code>SYN_RCVD</code> 状态。</li>\n<li>第三次握手：C 收到回应后，发送一个 <code>ACK = 1, ack = j + 1</code>，S 接收并确认后，双方建立连接，进入 <code>ESTABLISHED</code> 状态。</li>\n</ul>\n<h4 id=\"1-1-2-四次挥手断开连接\"><a href=\"#1-1-2-四次挥手断开连接\" class=\"headerlink\" title=\"1.1.2 四次挥手断开连接\"></a>1.1.2 四次挥手断开连接</h4><ul>\n<li>第一次挥手：C 发送一个 <code>FIN = 随机数 k</code>，C 进入 <code>FIN_WAIT_1</code> 状态，此时 C 已停止发送数据，但 S 还在监听，还能发送数据。</li>\n<li>第二次挥手：S 回应一个 <code>ack = k + 1</code>，S 进入 <code>CLOSE_WAIT</code> 状态，C 确认后进入 <code>FIN_WAIT_2</code> 状态，此时服务器已经获取到 C 即将断开的信号，但 S 仍在活跃状态。</li>\n<li>第三次挥手：S 发送一个 <code>FIN = 随机数 l</code>，S 进入 <code>LAST_ACK</code> 状态，S 停止监听，进入等待断开状态，此时 C 和 S 均已停止数据交互。</li>\n<li>第四次挥手：C 确认了 S 的 <code>FIN</code> 后，C 进入 <code>TIME_WAIT</code> 状态，再发送一个 <code>ACK = 1, ack = l + 1</code>，S 进入 <code>CLOSED</code> 状态，挥手完成，连接断开。</li>\n</ul>\n<h3 id=\"1-2-连接的控制\"><a href=\"#1-2-连接的控制\" class=\"headerlink\" title=\"1.2 连接的控制\"></a>1.2 连接的控制</h3><h4 id=\"1-2-1-流量控制\"><a href=\"#1-2-1-流量控制\" class=\"headerlink\" title=\"1.2.1 流量控制\"></a>1.2.1 流量控制</h4><p>接收端通知发送端自己可接受的数据大小，叫窗口大小，TCP 首部有个 16 位的窗口大小字段，16 位最大表示 65535，但在 TCP 的 40 字节首部选项中还有个窗口扩大因子 <code>M</code>，实际的窗口大小等于窗口大小左移 <code>M</code> 位。</p>\n<p>接收端通过窗口大小告知发送端可发送的数据大小，通常可将缓冲区的大小设置为窗口大小，当缓冲区快满了，接收端就逐渐减小窗口大小，直到为 0，则发送端不再发送数据，但会定期发送一个窗口探测数据段，以保持获取接收端的窗口大小。如果接收端回复探测数据段的数据帧丢失，就会导致连接中断，所以发送端如果超时未接收到回复，就会重新发送探测数据段。</p>\n<h4 id=\"1-2-2-拥塞控制\"><a href=\"#1-2-2-拥塞控制\" class=\"headerlink\" title=\"1.2.2 拥塞控制\"></a>1.2.2 拥塞控制</h4><p>除了考虑到流量控制的情况，还需要考虑到：接收方的窗口大小是在 <code>ACK</code> 的时候才回传的，可以理解为，发送方总是慢半拍才知道接收方的窗口大小，因此不能每次都贸然发送最大的数据后再获取窗口大小来调整。为此 TCP 引入慢启动机制，核心思想就是先从少量数据开始发送，如果网络通畅则逐步增大，否则就逐步减少。</p>\n<p>发送方维护一个拥塞窗口 <code>cwnd</code>，<code>cwnd</code> 初始为较小的一个数，通常为最大分段大小（Maximum segment size，MSS）的两倍，也即“慢启动”，但如果收到了 <code>ACK</code>，则 <code>cwnd</code> 增大一倍（指数增长），因此慢启动只是启动初值低，而增长速度很快。如果 <code>cwnd</code> 增大到了慢启动阈值（Slow Start Threshold，SSThresh），则再次收到 <code>ACK</code> 时不再以指数增长，而是以 <code>cwnd = cwnd + (1 / cwnd)</code>，每次增长自身的倒数，且每经过一次数据包往返时间（Round Trip Time，RTT），就自增 1：<code>cwnd = cwnd++</code>，变成线性增长，以避免出现拥塞。</p>\n<p>如果发生超时重传（Retransmission TimeOut，RTO），则认为出现了拥塞，则将ssthresh设置为当前cwnd的一半：ssthresh = cwnd / 2，并重置cwnd变回初始值。</p>\n<p>因此，当 <code>cwnd &lt; ssthresh</code> 时，可以认为需要慢启动，进入快速增长，当 <code>cwnd &gt; ssthresh</code> 时，可以认为需要避免拥塞，进入线性增长，当 <code>cwnd ＝ ssthresh</code> 时，可以使用慢启动算法，也可以使用拥塞算法。</p>\n<p>接收方在接收数据后，会回复一个确认帧，确认帧包括了期待下一次接收的数据的序列号，发送方在接收到该确认帧后，会将下一个数据帧的序列号设置为接收方期待的序列号。而如果接收方接收到的数据中的序列号，不是自己所期待的，说明自己所期待的数据发生了丢失导致未能接收到，则需要根据所设置的重复阈值 N（例如3），连续 N 次向发送方发送 <code>ACK</code>，且 <code>ACK</code> 中包含了已丢失的那份自己所期待的数据的序列号，发送方在连续 N 次接收到了这样的 <code>ACK</code> 后，则认为发生了数据丢失，而不是拥塞，则进入快速重传阶段，立即发送中间缺失的数据（也即发送方没有收到对应 <code>ACK</code> 导致 <code>RTT</code> 的数据），同时执行快速恢复算法，将 <code>ssthresh</code> 调整为当前 <code>cwnd</code> 的一半，由于调整后 <code>cwnd &gt; ssthresh</code>，因此执行拥塞避免算法。</p>\n<h3 id=\"1-3-TCP-IP四层模型\"><a href=\"#1-3-TCP-IP四层模型\" class=\"headerlink\" title=\"1.3 TCP/IP四层模型\"></a>1.3 TCP/IP四层模型</h3><p>OSI 模型对应 TCP/IP 四层模型（从上到下）：</p>\n<ul>\n<li>应用层、表示层、会话层 - 应用层</li>\n<li>传输层 - 传输层</li>\n<li>网络层 - 网络互联层</li>\n<li>数据链路层、物理层 - 主机到网络层</li>\n</ul>\n<h4 id=\"1-3-1-网络层和传输层的区别\"><a href=\"#1-3-1-网络层和传输层的区别\" class=\"headerlink\" title=\"1.3.1 网络层和传输层的区别\"></a>1.3.1 网络层和传输层的区别</h4><p>网络层面向的是设备与设备之间的通信，而传输层面向的是设备与设备上运行的进程之间的通信。例如，IP 属于网络（互联）层，它负责定位一个网络中的各个设备，设备和设备之间的数据交互不一定使用 TCP 或 UDP，但需要知道 IP 地址。而 TCP、UDP 属于传输层，负责将数据从某个端口（也可以映射成一个进程）到另一端口（另一个进程），以区分不同的进程，实现不同的应用服务之间的数据传输服务。</p>\n<hr>\n<h2 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h2><p>UDP 是不可靠传输，没有流量控制和拥塞控制，UDP 支持单播（一对一）、多播（一对多和多对一）、广播（多对多），首部开销小（8 字节），适用于实时应用（IP 电话、视频会议、直播等）。</p>\n<p>远程视频流传输，可以分别利用 UDP 的可靠传输和不可靠传输。</p>\n<p>视频中的帧有关键帧和普通帧，关键帧是可以直接解码出帧图像的帧，它包含了一个帧所有的信息，而普通帧，是根据其依附的关键帧，只记录了与之相差的部分，不能直接解码出帧图像，这样做的好处，是大大缩小了视频的体积，因为每个关键帧之间的普通帧，只需要记录自己和所依附的关键帧之间的差别，然后在播放的时候只需要改变显示有差别的地方即可。因此，远程视频传输，可以在传输关键帧的时候，使用可靠传输，确保关键帧传输到位，而普通帧使用不可靠传输，这样即使普通帧丢包，也不会影响整体显示效果。</p>\n<p>UDP 如果想要实现可靠传输，可以在数据段手动添加 <code>ACK</code> 和 <code>SEQ</code> 机制，自行判断 <code>ACK</code> 和 <code>SEQ</code> 是否符合，并配合发送和接收缓冲区以及维护一个超时重传表来实现。</p>\n<p>已有的可靠 UDP 有：RUDP（实现了 TCP 中的流量控制）、RTP（）等。</p>\n","categories":["Network"],"tags":["Network","TCP","UDP"]},{"title":"Development","url":"/post/others/others-development/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Wrong password!\" data-whm=\"Error content caused by wrong password!\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"941cad99140b3617198b2911ef31b5d14361c443335c0a1f827c5b29c14631ce\">102adc1b71919baace65490f901705cde73439c07b3b46deb1e5c72bb3ea6681479fa8a28abe11089384ad17b395e01552ccb33cd47c76edc57d28fd1654c8a0194ee154fd3c06218f822ec200111b5897bb6f68d1cc964aee5e8ddeb107eb005a642f41717e820a133da3327554c210112bbbbe4f89c1e833cec5c4d357666e6f2af35938d5b1748ff053c44a5d2684e79c18e9c1a688827812054d66b4d6a366abb362c966715cadb6d20c6210e88c6fb36ceae49eabb2cbaa580e2261f271cd87b100a83c0b5a3c19a5a09f82147c0f6de94b11913dae86e24c8ef71b13a45a29ca6450b1015a882b1bf5ad0ffe457d86a507669cb98a758feb14c3ee4fb77c1ca2decdd5731ec5cbc7b98ab1afba0e11e618be87bc269e214f01640242121f21f1d980cc9b0f60145ba97963337877fa4dca685807465ff654423652864daa647cfc8e09831e5b96f6aefc6b23da3acbf880f6610e6d2c65517f811cc5a33314064317abe89bbf8c69a05aa0a47adcf2d83fc0cb6ca57d71fb9e2ae7e6719d0114a3291969a8f0dfd5d9ccd2efcbf2ce1c9015096735de0cb67487bb93e44c3de6a1d7e9338ed478c5d5c98207d84c5f96f3b703f04893d720a887e630ebae469c42a0482a5783b2f770360a11059f8d6a5c0f2b7fb85b566890b24178142bea9ad2e68c9f6c306358567dc96344abdc4f21cd88a9df4963f081aa2973b931580c9e27c22c33621e4ad35bf53fc95a2f515391f373fd6220e37c35dc0476a05054f4acf63675cb20eaa21596786daad93fa615dab921a5876d00854857952e695a41d2afca2e92b2b8dd23bcebc6bf297edf923ccec2489a7edb1d9b03a4bcf5e3a2f819f2e441859a204d7f60515607c4eedc1a84f1d52bb6ae6075f9159fa3d31aa50091b692e941988f1043bd9d0e58a4598c1bf73808d9e341e5d0cf1b3649f876f966aecd203d33a2e1bfe0bbb954d56e7bb05fece5bb2a0d44e5ac080f3b5e0cb3666be24e6a87e054c89ec234376bc9e02d44b606f1040a62126feb6a754a052e734e85cb940419912c552b37a4addef8679bab1139b020df56f101a1a36d4129dfc908d749359ff8ce4c219bb1003ae2837c144e5ef82ab6349d0414b3655eccf1b25ab30aea0fc18d07f10aa0d6fb05f4696032d73a91fe05cbdcb1cc5cf1035928fe7e5a75cdb1141a6e98b54a29b3d17126cd6b8530886bff039ba39c2814b240a9c6796e7db257667952d43a80dff94954a6d5c436ccd95ffa6089c5762daeb5e2e3f8d10914094da6400856ea3c59ea4e0a8c8610751752d50e662cad02984e88c015f351bf630b7df5398331ab99015b43f89ec75ebec0bbd2f6918a479193d28a6b1271ac8a0defa653a140ab43ead3ad5b5f76388392a0250b045fe77c95f45e62cdd154b96965edd7752918ffb34aa41dc1355571b4f2f3228e80ab163d5365a040f62ac062bbdacbe70ac058ac898d15cd57e9e9e0f1937896e4b615a3501654ce848b65e39eee93888328ace0a9b3782fdea9ed648b5efcdf6dd744ab981bd63bb95c71983c8027e20dffa3e21c207fd15288d4b32f2d6d9c18b85d1544690bfd85496ec1c8d33230666c211308303ba464562b77d3d648b951dad84a130c89892fe9cfabb2c07a27f0f9ea96d7a8dfb6a0097c794ec1287849b64a9f28fc4f757ea7750aab5d305b870f48bed9a9a84b5ba5ed081099295cda0aa8f98d9cf83179ba1b0805e96c5b463dc99763eca095697e3ec40d2451ddbb03803ab12d9ff1856492ba63c5ceb3949f0649952097a0286d025d20830af0cc5ef0fb1fe78d3b9ce905e6aa619516bb59fca58bfb8fda4021b39114188c8471e0978d88e7bb267c1784de43fd701648cdd8bcde9d9ab978a1ca931b854eef1f3eac1ee31dbd60a4975f1e2db4e3fdc4e0603f1a32d854cd0f4b639f0da47db3f2c1b5ab40c06456e7b248e83566a76d71a9b05ec016781c3c1385c574d550bd86a9673defc4d24bc25d461b62a0d23d9bb248c6cb5677d5071ef4b311e3c1427c2fe1ad9bfcc5cbcecdc98409f163c8464ed9f52b2a6702928f5bdd3ae0183fbe476d437be1157bc329fb4f46f92455c8e5f1e3b66aede16f3e91165a4d2a7e7f3f2e9842048e4e74884029a2b3a368b370a37de23745c90a5a56ac7eceddf237ff811ba5252e0b817d862d285d4e972e2ce09557f395ddc40b194a15815d2356749250ee7c5fe0cd1f935b8cbc1621e5641e1f92d6e18e4962912559a3517d1483be4aace69830f3c56ef6bde6d58dfa7156247b2665b3cce679088eff0c13f1184c9d9eeccc857d031cf96d5ffdc3c9b0f533055d8b5a221090fec7e1566b41377b74ffab4b92be85555b7d9e79e53c84da505e90328c760b18153dd345fac10a32d6324390fe273a5cbcbbe5d1e84f65524a9f5afde3787b53f909b938c7eb4a5a7dcd4eb92f0fbe4b6ad2872c60a3f34b27c51d65bf99108d2f6b5103c51c0680debb04783127775175308ed8e53992cc57f130d0430d2053fd9dde77e908c469d90eb3e4dc80174d8f9a60d5630918e3e747240dad96275f46141812170c931066e0d221e26d81e0d832bf23ec315060a5a3e6fe10f8247d0b1260e38aef62ded29c9d1726cb708517ba587f549ba661396efd2be9864f02642aeb7e812547cb35e3720b3c097b870ff82bf417cdfead13c51691cb70365f18ab83100832ba1a49f7d7adbb6f49972890a1c77286eb141a38075da93b69768c611ee5084096fa8a6ffce4b4122eb92184d55b74e2080c02e0b457900fac2d39f56477f428d9c3a4db7442f7f273fd4e041334c4521bf7aa1a0062eeb2e7fe90d45407f76e92f37879cef9b73f13d7fed8625befa4a260b449e17c4b36326ebb8732e0640c8eeb89d13753b9ce3a9ca2d273123958adeb98b2ddb6048fb373647aa6c95d94dcfebec68b929debf849c82518c78360108be92a96ade8788988f5ef7d2f1a04276e303751b5b21261b1f110acbeb6cae98e0db899a99c1a1f805d4d49c7e4d92ea10b599f690642a783595a2a4c7408828cde387f99ceace82cfec572c05f5d7c5a950f74c5a8d1e70a0660b64d042c99c3142249206721d1779ee1079c6a08a05f5b66a699805b3f97236fb3fba14ff0c3df4933681bd2670f40cdcea9474edb5208e1dca6e946616b49617178526ba6c99868d82ae8eb879fb5ec7512834b332384dd9e9c7a09ad28040660cdde79ee1276337323b76bccb01580b561ce7b1ee6dcbc06b95fe6ba6286238e2bca33bf10987554a52195fac1034a769c39a314b3770c30b24241be10d4c29242958e3f69e7fe8a717d25869197899111fe894922a0a332c68dd148aaff31817471ac6275ef356a4408c7191aad1ce5ed2c3fd036e7c92c8e02fd91b7f3f916cfc6a01e192816a7de0e44e5a542156f74e4ea57b3ea31221eac3cbfb90ef27de805e6edc98b3b4a89f513bbc41ae09291a527c5f5aa680881feb0ac0935566b3291e625ce9b041a0814e18fb55711e16a0c59b4d3ff9736933dd5b6f3b0fb7d65760e31370aa3dfc435611d7c56a096ef9542c17da9c2e78b42f131386f7e11ffcb4fd59779b88076d488e22052ce858ddc119d7b1016a307b3e7c46597c1475b805f362cbf80676b87977a0c7dbe26d45dec1a0f830c1005f80a3c00e6956b583e4db4b3672fa7ac7c56fc2aaa0c1df0bf8319132b6e7bb7b00ca9485062d6c7f44dfbe61975b33ff6b7313b98f25c7f6c0c0f7b283763ed560438916b07c53ebd7707053d7089fff93be0acd8f8850e1546a09123d2e3b3d8544e84df012331989a0c6b4ee1de16bbada667ebb613225af9c93a756e1879c813591887968ee1bc58e17d01ad9ae00a1664551c57d449f01bd0027305d9a85e99a828a1ff889c982e729f7e9909494d4a20aa8725e302bb6a4df6ddd9d6f40a67e5e2548acee0df8c79540d06da7482529f1f2b19cce032c94f471525caac1113955a70ee789421dc8982ba847cd18fb2c02bbfb33cc51bc401763607b15cb8a004c151d2c3ee3002c6c0df949dade077715b00566d78cd8d6d89e8fd3b6d0270f343a3d592b946901b5b7c761ca59eb55ab649cc675f198314b3bdae15a46f23200f74aa6b5d615597ce1eed1cc418a577ff2070b8488c28497258129a46ce778ec60b7f1c1a0bc7601361cc1915abfab103ca8ccae5e1503bb25434f164c8bf29a1ef98613daafdb62a21f109a8c37113e95d9f5f6e6366b9f1b9b630cd700d9b18f86d42fcc56754b63b3c505d97f4414b8843edf017160f7fc69c686a1e49a91051ed825af73abb47d0de0813534685b8944ad48097ada09e8fa585a8ff745f82435b3f7696323c1344eb2b19096b2bbb3b2f458b58ce6b80c2a57a00f9636878ed74013327291be7180420d2bc9c8d931e239a723a4c4d9ddf674cd4c6558344143a8592dbba8d76809348b0bc3a7e4404d3ec2651f42660e154bbfd6f6c09fa5ec903458a805a82d1d32249e9feb6d79ddddc4682091a177fc336b2b9ca8e26c2c670a81389110476f37344a9a75fb38f02dd77b940065541083f8a7695ff3f41590b4e9437d387b2254af59a3b7e051fa3ec7b2b9ef3366611ea9e0c3c8a5c09fefb4f1610984efd55fe9588e00336f035c7ca15111c535a37696b2d78e75f2a9abf6212ee1a77fd0c72d30ff11fe59786b88dde69c96f8f299a9860c455a7bd326fd25370c90e3ffdb31001d9d024bc52e14acd0fe515b0d7ed52344e01c4229cedeccb16775fd20c352dda514312abb329769bbb2cb4fed2a67a75f3f51fa5b6a699eeae892fc3bf60d23b384899fc46e919a856282f8611cf09e959d5cf3632c30d3ddd66750e0feaa7021c881d678a5cb5defa5a33fc54cac8b0c83761b0cf04b66a86462d6567aea5987689926131f2ac8d264a160828806c141eaa4568af4413cfc63ff08d887d251d6af4578774e17c7b0607992e83b1e663040d470393d50c5180ea25f681c78537e3154545e67e8f2efc34805fd6e47c1d1cc8d6ad9ca9d3ea8ed5c1ea4bb2f35ce47a51c7036ab0d1fe75ffacbc0d47709037813651a228c6f344c7ec752fb3596a91e34258f99188bf7e0e0a93059c330a36730d1e35aeaa7e9b860460c7fee5122129ce3cb71b94cafb9c899526c3d2f0353ccf7fa54f6228c9c1962b61b2bb69079e309d300fd9402d099c68f6cdbf426d168cb9eca55744280818a925febfeafa46401afd8c4ab7ca15b92ec7da3afe1cbd04d7a6768990c8681fa3158c45b771219c3ba8c6e5728377a2b078327a0e45c426532426b6f6ce90e487e2f9530c10316879d7019af3510fb72324319b1bec0be86cffa014cc6424b907b72528178bfaf227e241751da06a670b5f23cf60bdaa9157a0efaa28b0de40ae096a9c8c195678f7fd4eec1239ab95cd0b2ebb57fee90c9939c83d74df64aa76da39bbf4bea4cc785ab243ba1b61ab89d340d31c308a8d99c4f0a0ba908e7a874270d6226f9b0bd28afe11dc4cbb2ab37dd712cfff097b5c92d1c42bc42295c369f9a1f9d9161ed4fb4d335a9ebc7baa435731d12930e3096be481f3f5e1b0b703f2f057e7da957f97451608a4a043df0fc1e538ece458e9b4dca7c5ba6470a4729c658291707103b46b3a66c45abda16c3d7002d1d5e387b71912ea92fd0c028f69f61cab5cfa804c2ddf17be145e1f20f0a4ea112e854ebbb392b715211c0185154518363ecb223fc6e1b6131619009094b071c5331affe12513af5ca2fbe071f3c84262a5585c557f8cb702ff11c0f471c5ccd111960f64bc17bb65d2bb5fa988509b750c647a97fb578acc263655990262ee1ef7ff0e9f217d154a7f0080e318f2ece7abb7f99535fb9f859a3e4c23a0158ce92747da591823b50643d975e44a4d73fba2e48c63532dca1b3a3d08de03a4e967955975d12039533110b78cf38afcd082dc9eedb1f45d0a1fe8b9b2cbe3b29a0e3a22f933387d0fde5691bbb52be5c3473fc0886542bf9f5afd5c343b3d25e0dff8091b62b3172f5ece61449692c5731d1ef059c2f2639ce738667046493b2413d27746bd2c6ad81f27658e9388840a01b5c4f17886198bb82b156be50106a9d560bbc25230305620928ac072197454f908806801f3ad3cd4aeb568bc7bd1c0010f24a00833a636508724c4fbd7f0076910178efdbbfd906450c2e975e55dccdc020b1d9ad3450fff3a8520ca7dc88caf979006b87d6d1acc832f8a62602555a20d8264edd1099f364f074c9cfa232e0fa37503787a64a927cbfdb0e40a8914cca4d428262b4bf592d3b5e96a1af1b763799ddd5b5281644e940ad5dc3d659ac9a28a5dce795a1b34a49798464379161a4f1d7255bb1c3e6e1b7974d54ea43f3dc4cb7f6f89c1e5a5935a5ae6f4ecd4a813147fea09de5298c9fd4271d9faf55a2639e5640b64aafe3c88795d3390ddf332f0a6c0fed48c24f129675737d37d0c33691f23d3231fb55131a73797fea35e37a6af821faccfc31ba40d4be3555faa8a75281a677ffb752eadce32b4a193cf22dac0f3bb46b061c85a1d550727cb2b1a1139f93d5ac5e7d62e4a9dd150e85e30913614a690eee64897a341cfcd9d571d4b29030d882fadba2d662c7f4fe79ea6f777f5107a3f438b0876419ea3f60c5f77567e8609c380c2262fd207b424cef264134d97c9c1d844a267177922bcf7c320beb53ea42c5e1383c8811074a71d8cda62ce4261179c928a25b77bffd01f6c33a43c91ca8ab22bcc9d69d3821affcd11d664a9d4f2731b3e2eaa5a119e727a07281958447861822d13fe317e1f051726331a265829b68c3acfbf41cb36723fea65858d1494c9bac3e6ae759440913659203841491ae6a5466b705d7446ee1d56bc5359dcada52321792ec8d80f811b96d492759f53fb6f1bb791fd381d70477e1d4e643be1cf9cd6ad7a02f201f2aceebabe97752e911b4c82b9121ba72f00ee988214e332cfc10084e48672252264069d414acde3532ea5868e3af7bf97758601b1166edb36cc3c241cb1cfb37f2df86b4f3f40ccc2cf3e9eab301edd76424fb831d11cf221ffec494547f6041eeab8942b6ba1849bb48b19af066c526de5e429849dd19f6d8772b4a4ca69aed4c1f0131894d67432cf43af5e7dc9599ccbd634099275d7e14efa62219b08fee97b1617bd82174c3f87a73e2d67135010b6283882931af96bf7803de73231c40bae57e93866f1183fbc71a2560d6c6483058bb8e534c34d9a8a81e7ebf7b0fc21668bd696cb64a11cdf1b4debff4d8bb411cf5cae891dcf4e4e0372d1d8ad6efdc566f5b0dae2422f095bb3945ad8ef76136d46916d90e49140a5625a0367e0cb214e627fc78aa673986009ca60997bd51e003ddbd8fc819f6740b5a8f0ad1359eef560abedbff22ee091d415c703ff2c1a1ff88cb74e9911efa6d655cbc5d437391e10a1b270c8fca4e386ee96041d83f9a288f17f90278f90fde5b13ba2194f571bd095156c167cb73952cc2e213ff9580ca8869e295fe4fdaf0a1eccca5f6e03e3d0bb2d18af73951fc6e32648dda794acc800ee9dadbe4be170e91daefe09ca23994e73321c50a55301fa6f45b18c78abe2e543b2ba9d80fd43f729b1953cba72acf448739da3f51867c8a88da47113b8277dad3885c6c2ab0bbca4d90ea90f5cfaa967f2fe31d81d5844821ee79613d541702166dfdbecc1ee96774e5a8f7e8239d140607c3b1dbfc469dc38574288dcadb83b50f9be3ea9a9706edc8105e41cf1e1d136d7057a3dd0c38f4b445675cd4ffb7de372f2c40ea5a8bca85f73f3e9e52196e83f426cf99e3fe1774a6d1aaa65bcfc5c13166afe88f5b5b33d108e908264f549e8755a590072e1973147787ae6c748e2e0b8c014342d9f1d114f6d8c38224d22389918cf57a5dcb8682368944ac09cd84295769c78561c487d7bbc1336b4e76bb2461ac117269c52e7b443b23c4c510eaa724b193a6a8458bd32f0b6cb5d16561feabea65d34610c900021fd4449c7f5c2bb62804aefef89a6768b3de7ac319194cf0f52da8a71f9ea6fb2cdbfd120778f32680f6926447c7aeeea3daed51a0b7a7ee3f0affd7942507d307f8fcd8a91dd4498a1024863dcf7a829feb886001ca3f2289e5dc47285d9334365ba18817fe1a4260eaec02ffd39d719c8ca31dd22ed98e706c117cb669036c9ba2002074023bb567ba3b76907ed4b5645b113ff20107570ef5081eda1569856dfcd3414771646c2ab3e2f73bc0b628f2a94fdcef9f5100219e8b68479c723b7c6d1a7c54b1e1bf6260ce743382780eab75d474128616df681b5363636559a03e055ff49012a2264bc1111be44120bf3d1c368169844c5e726fde7f0a8d32fbc132d922906c61c401c154e670b117435037e81078924ece90f39bf560cbe2f6b6043691e4317ffe466f09d020b2984d84ada978656c40c348e65bc2eba086b1cd35a9f3c73bd66faf010952a01e0fdf556adb47a147d287ff256d390b525263edde75f8c30d612d23fb62b0de5f973797b69d8f9f7019e716ec1365b460b22fa353df147d3b0d78dce7ef4fe78f140caf72e0cdf9ecead1e4a007ab9718130e8ed44ad00437e8bbc613a6c703c6db8c8dd9c3a6bb47579a757a36ce0ac07cb3e5a53ddb233e1d288ced742a5c468cf6c392b0fe8cf5f45864d3b3e13cfe26b19b3fd4234851e0ff60a1a7c8a44cbc411e6b4b6fd28dd1fb9d8886360e5fd035ff7d3fefd9819af8b6da35c02f7e9a1b70ce1414dbc8b8a1cdb0ae4545aef0761c3752ae2f6b5179d3bf0c9897af702bd2b85756601306ed3121e4a39450525297f21fe6cd58d5d32548604788991c3a9de3755c71804d0778cedd4963a02e2c716ae38f11a9b3dc8b950ed4a1b5e292753ae9623afc2dba90cba4d8a214ccb4d33658e3e538ee53961f4721772d4c80361016d5d5cd6330ef015ec22b2d73f75c586f78bb6d3b8f5d7dad79f3aa7d70cc988d4ed241b83fe00a6d54af31f200d3e02b32e53be126111c9c4d8c130149d84b0e3d9721236da8e0a35cda10943f9f018777381c32d8896f40a1f5cdda34d3eed7b063d9b9ef4ddac820ef46d37891bb7fdd4051e7ef12ffab0a60cf900cf372e6a4091f90a61ef57c7e612e816adfabe110cdac5635a2e252c1400afa3223ff1bd333b520734eb326c050f670e508d35e7af0ffcd74b2640d63b480f49614ad14ea05e236f6f54817d9c272a5e99096410450f1c44a83bb4624c765dd5b30df77eb68b5258a370d654ac0afcecb4faa500aa91e00d97bab8ea4d8b4e884288c58c270bba7c7e528a719b60fd17c56a31159ffd345b6abf62d149daa593abe33ab58d24233b1b7e514f73da34c56b23a049a49a8afbadb5a437113fdfa858e49aaf154820306e6b7f1b9aa652b8d000f2f5204be12f5cec4eba25b3d7a96f5831fb41a92fc1669a543bfe1c903a744b9ddacc8e8734c71fac1cc83eece87770a9e5c265d6e6b570df9cfc49036151e23c1f253bacd975da2c37dc8a7d6b868a8a5bfb694bd0ad40b8f62cfc48cd2aaa74ad6660b4673470e841614971c1877fbee612d63e4972e11dcc46d007470d7adb3e6f2ff912816407cceefe24a8cb765105a02d59872a308e6a88e268fe61c53d9ece263c7c684d4c4747292422b0f6d6b15b25980044d454a762112c86110008296c32ab704e2189161e2bf70fe02f417946461988a849b56dede25eb92f14c5f0393128e19f388c093bc1ae1f481184dfbf85f66c7a1affd962bd5c684dab849354d20bd13069a2faccc1aed34fbba33bdd19ea367d4ed18d7386231359168840963e998c1bcfee704a92372e01f892c8c4b3e633dea6f7eb5d5e8183a979a43143d60561a95c5a95fd574bc2981e912d80509d83959a96cd772b5a987d9df6c1276b3efcb7283359d7105cbb63691093a45e9b2c68777bcb3f0359e98f73247096a83d858f4be8181354fe9c5ff47feb7f70870841124327e2251bb6e6345df92844647bcb57b9fd2979d9e6e37be5a5bee0b7812e0f33bab58cc393f676752e876f9422f5214a814400fc6df76123d1ba42919a6c4072743f0c7ed1c8791c6f68034c1beeb668db9d4b0008fcf1a01e44beb1e909dc58e4f5eb317e4bd7bf24a0aa7c65db68b34fb15054222f36fecffc1d2e670f30f1e5c67510a0853b3841f20b0c8266617057afdb270a8e420f5f055dd65e066981e5d53d05b6870e1805bda24ad4ce239c9184c3425cc1ec2ebbd7b16181889937ccfa50bf6008cc8ece2d40f155d32662b6d32baabe49d20699859aae04128febc2361cddabd8ba816d5ef911c5aa743ff9d7f4b1e749174c34eda2faa42e3dce4f73c0cb6179c5b7e36ea2bf7cf37adab56ad17992f110fefc926af2393f538feb5b466119cda0723818ce0102ffa826c88eb4d193c0eb136a95636024016bf135e64372f510cd14a51a20da249960dc5c4aac749d3d8a895ac09cb55b65e6a330d3e7a874dff9e2927d5346cf32387d938d10157104173367d6eba873332419666d237608a933d7722bc75ea04cfa87cffa1d4f20b05bda88a6142238274b74e2ac121616653e57d2f60e55ec0a156c56f8db02354cc5f26343480754b140e0b448c1f948ccc9efc3ca6ae0c14e1a7999369fc2dd74f460947dc2a4bb44fba387178ad28ca3b075370999e963d3247ca7919c92f52397db3035e96066f6337d702baaaa9436ba466604452df9dcd72e2c67e97451694c488a1354808cf0fe0b2536df5deabadb5e42e6b15fd907fcbc0a131a0546de7e601ceff992c83bdf24b877e95b90cb72df2ad2c6ae7ddebdf82440e0ce029c43413a2f9af13050eb4dd9ff076dc625b1d296d86a4c14fa375ea9c78699b8a8dba0064aa4d2f13ddc8a8789058f22c31ed96b1bd37a3715cacb75dcac44a60654163055b2779139f2f6c31d6cb23ef20f6dff00a452cb9ff56f6a0f02b0796deeaa2596aee1c9ae923146ce6d092dbbf77003bf2efa86d8700f03f94965ff60ff7732aca34245362069e30340260692563a8333826af06e1ce048f9146f3d5c8ebc290b5ec5aa7de9c1ee8621cf550fcf612a453c8ee4d684c01deb861105650fb84c6643927be5a0baf912eb31b106321f0ef9c7192fe87856f65f9eba7145a0f9f16c45bd9e1672e01b1d5ee55ec833261b96148dde8873cbac34b6b6f383fd6ae044f9fda6e08ff3da83fbf4e282461ddbd839c0d41af2a23e01f1dc1ecee30c55d73d966a79d36bd1031e80b5dc012d136a847e3d0ef3fd17944f946f502034da072898b12b33d90c55a77a9b413a5027158902611c90e09f90bc7f44ad317b8fa3c24ab7892a73efaa1b9c3892cd021d789deb4ae0f23be7992e7fd424b180026fbfd122eb0bf913760edb89aac7983af7e50435d1014615d6a0b7f3ee6c3fcaa1dd7c239bd7905aa3c39157334b9112f6403f6cb2540f35daea306bc64df7c3442fc330c1f9b341f4ca85c5ad14b53bbcb4756cddc98f249c77b8d041642b8e3bf422e719111090c7b74ff85fdf91dfe243cf8e6fcacd9612593feede4ca2ea260f8af1787d6f199e868de2a567cb6869cb242f69be14dcb7d43f74e24024b53912830f9cc20fd4b32f2a1efbb10f2e8dec38b4ed579730750dcf6157488398e96a4c88ad0b3e947d72a1c30ab1c17fc193f521b6c239fbca1c8bee0ec09d6c879c8352f7722b79dfd31477e1c78744154c3987775d738827aab6460eeccdb9ac6feab80b18ec4bdc0f98fdef33f99b208f9fa276b8f15e6828544f4b2423530bf4ed238d6fd5378e709679b6021ae40f1a64c1e7faf1a2619540b4c02b296039ca667be76bb3f23170aa15362a4555591cb983e3dce0b4f2bd43aa534eae9e7a6d96f7c71c1e0b3bfd7cb37af16293e62b2f30d8426014649814697a57073a63b5da6588556d799333ce7a8387c9dfbe9d12516ccb8ff8aac8b0e940ba2d1eb57ed8181cf5fe4f564b6b41d1e5f6480b2f7d47033e6fe41190751c256695caec5e6b31c61613eaacf619f2522d5f1dc4d9f831210838562ecf7692625d78e6395b8895ddedd65388ad29a96ef7e54c611afd73e493264e3cfcb4dbd6c44ef826c80607b831ccdcba61c050217083b8581e7c9d60d3115072fce1502cfd6e313bc1bc30b8c21875e5baa599b968cdace31c05bf1fcfe31c07662b42ee5607f0ed6e71a32e04c79534ac84ff55a857ba31d6f1ead29515092d16908a49e45de423136944ae04b4bde51e1b319e2667f3ed3978ed7bbaef9fe4d50159ad78655c5f0d5321ea924dcefda872a28d086fa63dcc3dd219875cf2805d8d0a0ea1e553619df7ec83ef26f7695be517afca87efa6f584fc7c5c47927ddd16a271ad3e38381e670fcd2c45781f7bca9932a5da75208a21e7dd493b224eba0d4452247b51722e7c9bdff13e1283e8df13a2d26a5666255c416b6c4e33dcc8982b31069ff1c19bc8ecedfc47125256ec11d70f149fd1f8c74e922c17c1b7282d9c00768246635c2c39311f0257d0fbba7ca2eeae6bf4bc2d1bb26564f7e5d53aab6f23ab7e14be38bf1944b96d860faa6319ee7ba6093b2e215fb2f67fe9b3453a076fed804263b9ab5f6fbaf44e17e3d86aa3a2c418a5eb5d24671759c3542b020032bca0511ff1bd662ca7cd104935eeed1766a7e50ce62c06b4b08e6c4a8c1785f791e5e07271f936a1fdfa41f9c78bf41d997cd8bdc02e5c56fb56cb1e8f7fadc96fd9c9312dd9c0ad85b5cb795bc0153d1e1d0e01090675cd2676038ffcaf5337a5f52f845cef35213a1e87cd0b2e450f3d2e258a79eb63be88bdc35e990d5c3fd27a6e73321e5401c35d2142b168682e9b83d1871f894a639be187b647c207f434c6aa4182f7f9a8db4c6041798806fa91450d959751f111da7546edfcf0b21197503bb63f26bac18619d6d0397e6200c2ee41c39a768bd72a6f138fe5639eb1fabf7fb35814862ee96b392e7eb89dfd22048dc24d197765109216dc738bebacfae75ac74342639d2dd35380d03175628f60c8cac5e32229bf757090f21941832b44ec83a3703082b19831e14f96ffccf6485c9aa86c096073d64f0233f89c3b91e9f0281874ffd5ee987d70244b05b6b5f7bc44e5b0a5d3f229abb76180d28db6c649ef69f1705571e824a7b4f4ffa30f21813e593e8320e2e2e6152b66cfbd3b2d26cb76fc400ad082722de284b8be784ea61fab2d58ec6f6e6e0ce7c62239f92f8d28f20f1b996dab2d489dfb2fdb345ecc484cb7a38642c1145671ded66ae8c5b57cf4e85e8a99653877c66de9bf21046d3aa7fe8d45955b4a4dff39bd6a154d99e0cac10e0293664894f7dc210b17ef46f084abf1c3721027a4298a6f9daad7033a7c3d67a05f2f0dc3ceb28cfb6416263c7a51414c13f90695e5ead74b1091eed7f75ea43b8d76a18dbb1012a5a925330066845207e2382fe6b8aaae1ba42eca849b5876544eb677260d3be24f7c52847912832131481924945c3ef84e7df6c7aabfc1ea2805bf2a87b207d4e1f1d36e6e6cc3899558cc9cf0dcd8c04c5e07921b10c6d28cc922a5da48fac8e5b12c4736e0cb7857fc198ca66788aad3cb69f8eadc64868602ba337af526afa5c0ef287a6356f44721102d30e6aae4048b9d0ec46b0d187d4428cf8c1956e431d6b0d3f3863c19496537d62f14d6b8b3d3aeaca53d627c46e828954e8623703df6c19ef4645f170a0fa66cca83852c4ce0fba05a48a0354d07efe7bd836e15b41ef156ddc7eea97c42ab2d937649c62bf8d4de50122cac1696ab6225e5c11c1f654b794525155ba2bcf67b7c76b409e66a2dd011b2cfc1deb8ddc66ab717a15003657796f0d1d363b7b0b72f2d1c0e6d45ebaa22db749e91db3206047268c28350b3956430cbd4bc7dccab1a653766f225d2ca3158f718bac8f54d0772249887063d58416e86eed489e131b7ec0a2541ac9b94aa591e5a0d8f62b42571ed45d933f6957230242588c3b1f3e70d2814f019f4bd56c757636cdeca5ad8788a9c2b8df433714644311e83b87cf6423a14bff03d4f9f1139e1bb4a71e2edb337cb7172cbcc3987c672a0109d4fb8c2d6bd319ac2a164b4ec1bf8b0ec271b6f1d093be1104821ea240e1ef9f88744dfaab2a1384cd98a1d0d1906bad4922c82f4505e0686d8d0bf785ff7e28532ae5e563e200060ca62dbd702e1a7665d732c6d1f3e85fe302d57a50e8f215947d8ca47b817da2295a2a3eed9e06c390c6d7a240ebba1d048af1163f9a25a69cd81c3091cea605187bb82f4f238dceae6247c4cc3a66ca4c217a41a231ad62c26d1c8c154617201a98d3cf78fc6c0539f04252d956a7609ae98b916887505cac69bff77f90ec00b350df93da3a4cadbe21fc493aaaad6a44166d5722750571e90001f639c70f9aec35d5f314e45d5b6520f65dd7b3cfb7ae801663e6885994e5dbba4475ee4507580bda11f46e6753b9f10ef6ca2fbad52f33d5f0db4efb73690c9612a14de52c582cb0c61598632a069ea513a688799754fce244eb8f5fb9138717685b516f5cc85cbf3a2f2b22488b77d821f8e4271728d5fabc9dbe562ea2fd53da94cca3cc83dbba529625ee9d2929ba0f1c2342819f5a0e938921f0880436d721ac38cc730c48dd372862b923fd491da7694c83b76911e3492d6e0c93d9b68655ea38564e801865e93de9494e053934e576005c5ab5090f7e07835adb2a93a82ceded220dadec79dc51db5e8a1af99fe649a6fc8572c6a1c57cf5183494fe969ab17d72ea57ea0046019096309623a72b6f76b726c65134ba13fd0d63deb880b9939677619d706127fbe222e9a97a8eb7245fca19f3e244f60c0f07c3381fa4ebf8a5a8e3a5b135c2d49240d0989085498dd3756578902dba91aa1c92eb8101175389ffc71a5f54ec0e62f747a2a8d8c6a311fc21044718f79d7ff850663d35d49ae325c1058195a3d9fdf72aa5ab6fae2d807ff5ca1fa261428dcee7c45cd92ade4084ad40b76320ba4526c3099091d0c5314370f81e6b27bfc86699ca2b06c8c7ab8964532d8d25f49619103d2f0c90121e8b9e82ef52c624fba5ef9b80729257d016533182172c66bc4a130fa3d0cd42bf63c4ee962346d4264f2f6cc35de5a50ee1ad4bcf42f8d1bce0913ea38072c36b6ba5ff8e0f45beab83c4a497fc2e84f1359eb4be428b9d672b178aeb9616fe419b22196f5f8b0ffe3d4f0bbf53b9f65962ee704ea264f15e1b9af0660b556b5e6309c3712e247d533700a2e8a7a88dae0a532a17503c0e4ab327b39df69631cd85a102bec9928cf558cbdbb88e7960803ecd2c28c9d788579816b82e2894e35d332ba54a8968a77d677a6b4b531ced128f3f8c582c9ada6b6a0f2ba17a200d97e6b7f0a90e82b618fa5fa676d3d1cf6e03cfabeca34bcab487940cdddc5ba74c3bb0c9edaf8a3bb34c771a7ba41cdeb55dc347595e4a1acd4d23c35f1c87763610b2d8906bc5db7b79110dee76bfb316278c3c7942cf752cb4dcf8601f4fc99e0bb2b4e631cc9c004d6d17c016741cbfdf75d1664afd9ac4abf3679bd339dd3f47d69e8067d797d3c21be18060be910e3b318defc27b9c4eefb209aed667de1a78c5c7d3a5a3e08e295d7ea636acefb29c321ce369fff49da8a3d45e5315f5b7af608e5f966f0de128369f40f54998b8df4ef761748fcfc19c82e80b447cc3954eb221cf064dfceaab4d4540697c008f1c06c949bd7fcff9de3859a5e0712a0e5e37bb6aefbf64ab0335113c4f9f5d0b6c82e0a62079e1f2ae9df6740b7e2bfb8e2d356afe199d651134e855de60be3923e90432b82c783a20bcd97c7e939082849d3ee8ec18cd4d40ff23954e3ae56ef0a1a36dfa03375134031ccc7acae3c08bd71746d319abb2b7c777bfe73cdf0f48e55bee82d3bdb621fbc40f91f585f5f964ae0c00ad7ec3efb11c60bd1ea00a7162086c3d89c49fb6f85581e933c78a082eca2069b99c2bd1ebbe60dc89ecc9a04bf452628fb144f2ffb8aa60ce76c49863fa3b97df8afa24e9ca8137cbc2b709e6c370c0cf3b2b00e3b2b38e2a39ada4921b7f955a59b961ce15b23107a0f40cd8fb3c0f6061b46cfe1c91914689a5042bba48eab10bbe01f63b1c3a7173565679949d943775f79fa12e42c004be3864b7529b86c5c716eb48e9e38995c4d82924b1bcf207d5a898c406a25135eeb0bc2b27ccaf6df7971356658e2fb1656625dfa513bf6a33abde68821b4779ae608761c052c923ebd5ab716a39206b22f28948ba6a680f44d87ba38c4aaecfae2652bd02d9d6ddba836f421fcdaf8071aa24d074861bed685944e07cd5af35adc0fe2a9050a510d400d507974ad9b100caa0fc485305d36b06410e43a96ec985ccf79ea4749f72054bb786410dd0d4965cf4976a364e7c1fda6b3ba1f1e14d1bfdefc5a59cc04e844f6372ef42c5689e9ed7c5e4cef260ca5e3549459c2cc6a8fd57602e3821a7b80e0dbf49ab08bb93b81d6ffbbff318a168df1635f4697056dcf379005928e37db5c67bca8583b1fefa6ab60b500ad3afec4ba0b3e5cce473fd5dfcd9560888093ad5a7abe6705f290d7d9e5ed21176eb57a1c41cc5c910ba99579bca860c0561985a6d54af8cc38fc7f83123f596afce36bbede7daa8f6cdcbebe0791d4715faea88f1074465633be707ee4b40aecb98317b562b397221edb3c8f7c0c2c5b07cae8531152d50a2229eda27464588fc0de3bb06d6d6f04b8f14109cc3222a41546df7437719de0bc41461ff38b3725fe843fd16d31e1ce4ce93c4c6b1904b74fc3d6be1f0d3ee1d56e48c2c173feee9e26712022be9942571e59bdc3037129793cc92322b23d75006dafab58d97e3254690dc9b207edfcc0177ec9f1e99922777f18bdb364d3b085afaad11f14ef32ba82d6b21c831e11a1eb9cb30f2f6cdd079eeca84ad6374aa1734f205b2f197746640d7ba6cb54429a6ff96e2b4ab4445c19b5178137c0eb7401e78babb66e89506305dc975ea9005d48e0a1ccb77be6b40376d40e83ec3ad2d4d72544f017e45ccd6dd629ef32cc00c3055b576aae08e109ee32fdc0cfe79f50f9d4ac9f8189c4dff657db155dfc63203b1c91cfe5e31f8dbef372dfd51580dc079e779048006fc5aeeb32eb0d03adc957fec2a69733465b10ddcf37c5abe6db130e0b63304849dfbce1c789828602f15f62f909e16eee246a5d131dcf02833912dbce7ab9d78585634ecde9b6fb78602a675733da2bd80ef7bbcbc2cc842febe60d04afd06b3980deec9d0e35f4f0bc97898372d825a0b7117a62dc622b5d9e8021873af4cd45c07691a6419fdb64d42a8620fbac2b694be45103366022d2488cc5c315c8692b92146767a817dbee218050f5517789acf899e20f78c1ef2af656c7b9d1ebb4c03646453a2ab8659e694337246c30458bf91b97c5aa9e3f1b4df25ad3edaa7c5977e94ebcb78e5698c537087420088582c0e85bd9db4c5ba842bd04baa96228a941e58c679b57f58ba9601be86464efd127391eb39480dd2310f56d26cc0a33231d619017a931175545edcb5b76457da81c1c48dfde04a5af21532d07f2783ccb347768eeb63e6132067fc30094dd1e43ded2b9573f263bc54d6d7cb639a86247ba5b57bb9748b1cbfdaefb8b6b19695474a6e5492038af3328e6310ba533afd279b6e3db17a01fb778d655a63f7db84e96fd4306681035a1bfca96828566523bffbcd7c8d309e33bdaeb5d7d8e9790e7a7614fd5367cda113572a5e4da1b9caca58e526c2f6e4444bfc3cb3e427fba3e6fc1f80414624c8dea0890d35b9c38d6051c7fc889abc7a3b53dc194fd1155cdc20592088fe2dffe5ae26bb974795383a778b9ea8e37dde4a88661d0da1695b2c4300e86c15f83cf7e062cdebaf4c314bd4f6aabcc6422e1964c087decb430c586149e034d68eae14ed794af8d2f7c22d08708568b26ad3f3b39de26b5a461a8eae638ba8d9823e816db0e9a0a86d756a20ddd3be901ce7fe86edef8abfe7df0a1d25b9cb9a8aa3c5aa197d466fde70d4fe29aabd82020c6000b4aed20a9d7bbc854d42093225c25ac2767a3bb7a05555cb732c99b1025003d9de2d4076f77958b34cdbcb9cd431606531c39ebed02b5e3e04ec89836ba70e00f4ab9acac0cf784e1a8ed0af3df4c994a3085ba342cf9907aa57971dd3a5fdef9f4bcb890f6438ba333211b1785a94138b8400fb09c21d946153b2502e86a08abc2525e2b247aa091fdef02b9d040ef0a9097e127d67e9f08c0f73246f51c94293157f599c730ff10e06542ed5ca377a124fb824566df3cf8eac95f5737d1b184337bb86b2c3714da6229e8459c4983c9dd38843caef7762850fc1e05b6a1f7737de1c79b2d1027875108010023d0e91fc11d20c076c5d1641cc8aa2628b6dad72db5843f790dd538fcc978b4a7b3d4fde70c31a66a1ba573aa63d77fc4e566a2e251e77a0def91ac30e98bbd6309c4619d05917624fde6dd8f610f5673cb1725aa274cebea9cfa360e23f68b242ecedf69e641977eddac329275121887a3bf7a860c4d4e495316d523625dd8408015711351c355db0ccf3f05936aff5b9955f62fd3d1112d50d5e2741b532a0f6f3c2caa377d3a8f9dae9482f527dbc7773ac1368dda678eac904a872493f839d8e98c0a967574325e7bf3c45716526c62024b396feaf337e5c3f2a91b5be9c8480934e01e3e92b0fe64d65c72270a23e31a8644bf52bb83c6c9964166bdf57e6f809f302a3a8003f76d4da152dff107f39d98d38635d3d1ced9b42c54e69e9272286b29a8f2675cbde7c443f6e20cbf484a0e4efe1e6c75c82eb760cfb75a1ff78fd0899c4a9dc2dbc9018de8645b11088e9cfad8696c4dad9987d9eeecc3bf9fa310bed500031982672c5fcf16a6dd607a04dfd5ce3ed7bb78775890582012d9400b85b0bdc574cb74fbff98d0fad19dd970cc7969847a1774c84c23fcc9d5a9ae2efbd2c14d0f3ffdd9632bd43ed1a9ec16b032dbafb64c4bda3c729253baa7bb843b00c101d123b3508485909ca2828c8acf309c844ef4993268a9ad3a5f3ac242f3c414df00c3c5c0179ddca50d9da6ff546719ff1332fa4e6f0ae8b344f34f327d3347c56d85d9a4697cb5140f4c2c5163dcf3da92496ed3faaa9a5af28a72ea324e5df033f59e20a2bf0bfdf2f5192f8d0c51739d4098153521ece122533594e7804b78717aefc962095a71dbfcba4ca9d2f0358047a24fa22a35de6cd8763cfa9456c070ab1bd5419a0be3f79a8a45d9de8f5835645123a83a12c930c948890a68ff1d7428696ea22964eed6bb431089cb25be89cbb364c8121b9d78fa0bae18f5ad3958cbbf6b845900e99a69ade0afd7ecde5d2c256e388db55c67ab8c7dfc83ecd2f2abd1a7104f9d7b8b2501d44b43b259bbf148a08b8a7b9fa97a05ea66141edd0b3b619185871902adeaeb5dc36e330b743d94ebec03ccb0888096b33130d80e2c405b25c068e63c72fc258255a7223d20faf1f0bfd6177e539ae7023c76bbb6641a29a8f92529bd54dbc0579f2ac29f099aaeea7194914520562a2ffe4efd5603294eb18d7775087d3f98f575db5dd41191cb1f3c5272901978cbe9d85dceeb655f6dbe5d87621ac8e3d67a46ca8def7d0ca389f61c3a5d417bb635db4f485f64eb768bd510a555381586227b92a3b9c9d5fa181b2cad982d4cc2294d5caaf309540e2e5916f600f4b4621936b7b92fd1fece3b9f3587cf134d083ff522ca2bd02d5bc1601b7146eb158c1880d837ff025a244234c16d0d8c6f842be84f21ee9c56601c06f1a3e607241cdfbb1ff8cd83a4f52471385fce4041a822702498e4cecefffb7b88e5adbc1fc3ac4760a991975cb901b06f8fc10dec9a1bbf69f476491b6140a99e514da1276966ba1e1e67d409c41fa3924a1249d870cd994df5e9af1ca210e34a6f2b950ce67a0772bd33549b979793b230dbacdd7be860ad6f57b3da40b0808ec1ea56f97d5b1ff46017afe4d4db5150c41348ae11511cdf0101523d2650b71b8676840a0309412ac9509bba650e3c32cf5f52090d895a6da8142675beaaf95515fff978ee120b60f2bc835838b2e0fa7b3402d47c8ce0ba1e9a03199710e109275a8f3f1222e8624aea5bc4d2d311e78726b1a6f83295e217475d2dbc23964e369e5e58df3e1e49bdf5d2de02c5368c30adec3fa0b6d0a6eb65f3dcd07da523eab3aebfb52cdd1a36c809c214ee1dc853e102d85940c495b90fcf207a73eb5b374bd53235c87589b30097fa6591549e729060dfb1e9e89ad8cb49ed05ee5a8388cefe3d9dbc06104b7a125142343b57e4ed918d93b84ace354e84051da4ffb5f8620cae928462a9497656e7ab476223e4086fa5d42d733e80a07db056cea421719de909625f5b0b76a881623317009efb5b5b05162f0d259b1f9e867ec3309e543b690139648c663509d8aab1f665099c451851fa069d3f0a3d8e45c923bee7078adb4d672e5dd1a68750e560902712d544a695f78fe3d8893867387110a79bfefe3752c8f5a93aaecb08018bb314c7c4c87451e2f3b2b458ce21b854845def095094631b0d521fb11e9ff08304df4087f714ac60005c87afef635ece001cabe4eefb32ebbca55c2c46e831829cf3ec82a51a1bc0b3947308bf2544631d242a0d48ba75e23bffa976d90b775910648dcc32ca34434d496cc60c6e2cb5f75852b0f37066876a6273af48f675c8c3e1dbf7dd914161932e7c1ee7a81906f957f5e7df94901f28d306dcbeff3999271609b928592e66cbdeae05d675c7caeab095c9be3d2993e6eb48da03afdc6596cb2a0e5df3fc6ae9b9ef9b7bac598221b6f8625347035c4c1c3d533b65d8e32d9dcacd08199558c8c19e47d578269986d941fa9a462d6eaa4018a2191549bb96c0d864cad093567084abae181ae5cba3dbf7f79dbc321476b890fd0ef45dae49f66e11478f7bce896e934687621080dd21795561676696124c5f134309cdaefb6715506cd1d389192380e8b3481d2b1d5592b3ebd6d224242f51effc4c1f11cfc6c07e9831da4b999bb8d2aa7f774bf023d400f1c636c291b04420e1de24d7dc369ea0bb48d172357eab65a1548035dbb3a8e7783a10e4dc613416fca2ce3d9e37567d4a890424138c053d72c64d9973afae3c5a564376458da8842a10618c06507679fc8611dd943ef69c4754f371c25031a9e3d6ce1a911d7c2262a1adf8ef943c3978b86be29dd4704d1a853f76d2879871533bfc10594ea91a2c9b99d6dd8a0a8d8ff824b934b6874f5bbeb929ee144736f814ead81677f1d6018243b9c3a404279fe022d932a5fe9a14e7f6cb1074016067639f982804ea0d6376b6d0a4b9679db7927972244ac6e315fd92a8c9e65f71f13f5b9c0dfa9396b0eec0fc8f8c22543d8e01065281bacc38cf32a776bf306df67be68941c71eb12100d7bac31c75cce2d11b4de391f33244efe08fb8fe32f29094391140c394550e4f156002db42575ee64a91e733c8156010c66bef35ede4ac61a5eb6d9f4e8aeafe8d832896543141206b74050ac403cd9a3dc089c46666ded6fefdd4a9c8554e55c2329085588655cd87ed02ae5f03b73e90838235cc9e230737a130eb8a05ba54c52e1f5df374bef8b6517de5e94a91297300bc6bcdebb1ab5088c82ab9a63de795c3b95ea6415a435ddefc9dae97fe9d3636465ccfe89a3964c57912b4bda7546bb89770dc6b53bf7da66efcad1587d6a00b86cd4c1672f30cd7c34ccd25bc42b76695c7d726f39f2f0346b3360f66fa66d2d0b046f1f04fae2dec9fb80ca89402421d82b990f3a87d695f00652e64ce7230c1de409ce1528013a69d8e2138fac28f94d442419a1ec317d358c4815e975578b22027223dc3024674326269bfb0485ad45b22473778c4b0fbf42447fb2c3bc3895ee40fc1214cad69c7c27cf7fa0cd0c2d8f8d0cf96fc91b6b4c5443510d5bb1345b0d757b26a1e29c0e7040edad168dc5d83f1eef680263a21d3ff465f41f3b1c2f7e7498f327e53a78c4b132b3a1f053a902d719d38afd6fc6fc09d727ec0e9ac9fb5cb2dcc54961dca65265b428a594082947e87c037413e7cd507f926954697c223d2d35e70d8c0b51495a61bcc9d660ee90184b29a1eee15405beb21d750dafd2c4aaf0249236afbbe6eb06280f16f10c4750f1ccc01bf441c35a242ec0c2526fb81088827e3a73b661b3fb6d4d1a68ea01cd9b43feca6bd65dd4612ffc74faa5acb3de11feaa4437b28852e50add03e5b1a43470ba95f26c298892af548e57a70078a7e547d52a80cf1b1156a5646396ea2dda7f74b669249364737d2e313cf16316f1e5d7dfc6f4ca733c92a59b180699f07dcf877409fd2325501b8d59ff21744314324ef9ebe819b199cbed212ea3a1a3b9fb0ab8da95b332ee31bda77d51790c2784bf58e69cffc20b3a9506a4ab559e8c1aaa1669505ce6a0c933b7ae9fc75935d7f9d15f7b8ad9b490b43068731279333140954c395c61f02900ec48fd51ecc80cd1bdb7665546bb76a9dafea4e7a4e61e42709b20f57a29b8e3c81afcc0b0b60f25dd840b342dd9b872b5da81a0a1645ddd2779696f565411b8bea3fb5751628eb021375a52864277eaf8186ba02e9471443b11df6ddb41ba31b12beded2375385438edd6b5f0b812a30a71bf8450d4aa956a01f992feffdc22204f6dc8b6640b8211c750da6cb033b77e5377f381d904c9775b92acfdfe19881f357060cc40095502cf6bc33706a29660ce84aaec81b1aac3c39688608f2f8e6b37d54de43fb2e9c7485a64eee9704d096404d648dfa2cb3e8f2597fc361541229d142b55989ddb42bc86285902a6f0bd031d1413e9b726c9b6a4c7e410f69fe433dea8ed90be140b6afb13b236bc4a9c862cfee1975af8ef395799b3ea84655dc8c79cc243f86b0759c70a60b6974788d7ca43c68fb85a1f91efdb718783ce794ed6080e53c5d812c40ed74afce40657944b3c72d03633c9133e0a8f9dd66c7c5b9686b191be8bc6de6e5e08cda498b08eba98e504cd204d0369ae9529d13ac6b9b6f95f425c87f5a9577687fae25a2a053ebb4db595477f56a9e9ebe44f1d78d5402ddb9754bc1e4acd78c7ef684fc9791a358613b55484946c650c745fcb82fe19bcd6fc9ecbe6c0862ff8ca2740b63400ec40ffe94d674d078fc6fa062f417744c4474de75907b8dc8d786a0b917e38d6d4231353b15a48e139f470b69f04366ca95ea5da33c60e4e2d3b92cd490fc11f66ead7618ec2b006528c3d705b205f7471145847b49585690120b6e0dd20c771df3b23804efa9ad10fecc09e38f81b625d063512759137327099475032188c8dfcc1a65af1f717e889fe0bb758d04f4aade068e7f8443ef1ff5a6be674d56df8f67390cce12a4a70f01fa64dc486aa39e2766c9f903f209d5efaa471342f5d94e280eced2a7bcd7dc2d5a8a2e87f8ebc7c28ec2a1d8926b4359fc31393a7c1b46adebc1db5ef2fc55291dc8f06517f3ad027254c36f2ff408c5e73e60c4acfef242313ce37616f0c0f7c88d020f04039541418aa22acb8cb0385e02ef57224e31786076710d9b7708e6c69473ecf6a0425b0253134c3fd3135c7587600feae386f5057379803b609de3cf9e637eddf84d676d42e43e29a01cb8bb9c63228a4dfa6db1c9c5a960a2a4f668395c01b22665b4304367392ff4efd6e21319ebc52ea483ed342f0414676008349a16f23b994abaabe48ac33324e319c35ab7cf39b5772e498fe87c11a2b0ddafa530ce8f45d361ba3d500c2b00099a1ab964362bc4b95aef204364161e2af99d39624216dd5031a6f742377cdf4b142799155e352090a354e4d201cec090840dd4741da3a828ddf0abb6b272af76b8858135d94ea413008f57d27343db06d1275c138ccd739277093bcfbfb9b9e3bb396763580d424a82017d499b2660afa1cbedb5cd89d8b88c771b084eae47903c313b4b007942d3f0e500270517f5f15c64537bbe5e122685a2f839ff490fe301a61623fea73bec75b69fdcb5c4b7f5879cca8020dff7587678cc3cb241ed68c982227bdc9bb20096806467344af52453ea6fea13266a826a2eb4d1badb6dc3c6652814fdaa1f0847eb18e0b4bfd610ee52e3dee6102d6c62efc4e0422995d31c8355c4ccaa363aaad9d3810cb091d1cc65bd1e59da0a8d2e816dcc16fc43db822141e48e099f97ee9a40f70dfa45d9b05b89ba5302b74511a33f4a86784b0af4500b5c104a8f9d43f3b9f7086962f9c59670164a42a1e0d1368c8f835c383f38b2123e2aec86fcbca0603d45cc76f4b5ad9b9cb7d990ba75f67938c39ee8445a5015a7bdbd4ab8da43bab7216b0f0ccdf6ca8af2496a42b497a208dde846e692e3cd91d783ea18e8a58a7db5a589b6e8d96cb0b266812d16b02d733e9c16b7ec2cf0fffc1735c5d3dc4bea365dc7436723da1f7939aae6ed4f9e7a068abaac1fcae37dd328b86dd54c755940143e229863d8b5c487433756725e93a9fcdc0d74c9b132dcd2e002159bc77bb8ae1ed4668952ace9d46a3f2b685b55dfed288c9209166791e2eb3155811250f860aa8daa2f49d1aca4bbe24a96fc45a80216a6029929d8f9e743549935c79c72deeab0d5d0e98160e36bfdcc1507f661803db0e33ad4fc713a312a9cbeab70c91f6f82f0dad44a3531763a6d760d7d11dd3a15ca1446c84e72f9df6af59c29f20795e68ca4687875a16b7ac0288723ac8781f123768cb8c74553efb85189f4e75bd83bc32e2fac9edfd779efe50c0a60771f4b923233f407d2c4a5ba20b94e85ad500ce49f738e11525a5faa6f02d23b4bf5395bdb3e9ba4c0de8795d2ae69524038c2c86e02e05720c3e3029e74a4f106bc65fba19f2fedaf3a6e676610c71868d7d9f46f961e5350cee23b9dec9917527b0485312ac7418fb6348481a925da38a796ef5b64af2af4d40e3c43d422fe9ce50b46963f9615b73e211037a584ba3695ab00bc3f5e4c5c38dda6f5dbebc020dcfa61d6cd1a739404ee672d77247756d96bea5ab5eeba8333c144f635dfb92eceed28a347cd15946a7e02c8673fc59b5bae2d050b90beeebccd2badde8a6129869ec51041965683b9fd099f865617287d0bffe8662b16854c60d58823f812cd8a1baffc8b8d75cd21a64f18a9b4976c2d77d88953be9911357420b216854ec9c27cd8f2a9bda73e1b12b4667ed8cbaee4d2c25e03a108aa0d28214032ba3af32daab22b6bb80b4c7e5e41f0edc51262a4df32fea6eb1975af8d965ce5b14a8a3c8fc676bf3607fac95a42e9f18ec2ef0d305c9274906cdc90fcb5b6f9cbcb2643f605cbd23f1c4db6aaa0754f8c865985e961a3addc985a73e2e76f954b889aec4c1fdfe2bbcee7f40183289a7e0c97216cc04281e87a6878f9179a5d0502dcb8d001594ed91b281efa8079de3f44bc710dd0c69ce461f21890e13a1c17f8ce3116deb4f9ed09cc93ba96580fba73250d9d506fcc79777cae888cef90455c839e7106c9bbdef0149b217afb5d7aff5590a41e35784abf70030bf9efc191519174f1cb01975a3b1e21cc1cb2ea833e4549dc3a7552ab4b673e6195293381cf28bad37d4c6a81317a3fbaba25463017428978503964a2e7b1a9c817ae5f432fd5f14b676ba1629f13c84b8efa0e7e1546071e13cf8ffa5922dda0154d32859d42bb96bed72760f3b08982419ea12595d2bc3eb719d0d6c659e5699a15d68a96c8f9d8d17064da9c02a4ef65ddab0c66f523f27c5addd1d1873b5c0e0204fa404180f30ee61d19e0bc610961f6d035468dc74e4f9406b01dd08195beb55a539c7ff5a53d73bec7e8084911230a36c71fe853b381967cf572ca5b1049ad55fc6c46b5db264b2801a003762e567469c1b4feac660b410ffaa8ee438e4e3d193d2f5ef4fb2049db90422d76ef8b8bf2dd145e2cfadcf2904237f304336c68ac9e905a664bb5a006c25833b566b2c03086041e59a86667cfc1bb16e4e74f4d74bd1481249d819d3a618275c142ad9545542cdf0033874f4689d0c50b34c8cf582b00856a18c7a880260f9226c553ff500f7cfe743849dda31c6a712315a091a7785d0330fb028b6c7cfc371d7c676704fa78a935d9eda809b3b33c0b26dbbfe7a050b6b64e61c203c09433c0b4d7918f197f3df5159652092a5c1a3b69fff78052617a0b491b37d36752fbbb4f2d52b68570aa7bc694b5ebb07466f68624f83a94ea00f712ac374ecc2153582fe373a3a253e93092e74de48ce4a7c66bad53dee9ee1f78cb29057194ccd780ff2381fa580917d6d6524b2b66a3da3024353443b70b1f0ab3038a58b6e4b84a03b3f3ef52b2c622520c3137d95422085ba60b5010e93323c5dd4d5aaa51a0b67a810a94bca317d879aecdf4eac6b7880d22142b0f476904865a49e618f8227eabb640b30af96bed9b55ff72196e45bb51fc16c2e885fa2023b907951e359d2b754c548be8ee078c5307b3b9620cd0c2a8cfe4be544a3852359d67740bb79780a1c459427306f4e079fb74c23665b79ade6375781b760a93eefcd3df445ef50c466514917352e7234d2385e7daa0319c28044b1138d2aa9cb273f5617e06c829dc080a029c8ceef6846e16b161e47aee3ddd52c1f9577b16fcf576b9153a4110f8d26c4a322d77007970c537c592c67b38d9e4028d88b32c5b7a5fa0390f04c83fb00fa2217c85c11a273168fa01c500293c17cf47a4980998531767c37e44958aff1eaab33cfa89e55061e416380326f2e0440e19a5ded3067fe245445c2a02d4fd7a23c5efc173775e76644e6cd4d470dbf1d5e09f1f4a8012b14ca6a8c8a4ca3d4606c0f7108cc27aca7987b8af9327f032d3cfc6a8ad044941866b2b2f6b99283df131a470c6f0958082babd38499cef90f7edb8b45b9d624b0df2a66b73defb9c993463c79ca7a9e45e5eadcb74026b16a719fe0d11cc8a7a857e8f18b92c0a9388c4e5bb073ad665e3ef0a97c9442be50036ee9b57a912fbd96c0ec3322058f5f62c74c6a0073c4c8d75bf2e2ab4ff74e3fffc8ad81840c20f12215f0c15e01f26714fa80cc674735d1a6f57de61ef3ee38df9009128a181724024dbc5597190ea47a1d4390361c0d40002d9a28ac71fb8a1cb2ec90ce7fa7cbd76b9963e421d6312f2052be62f7d0141a2ab913a9ec64cccba5449c4a38dea521e23ee21d2d0fb5c6ecb063ab537020292fe33c3ac50abddccc151f539b15cccc539d39ff7012d8255fd65a34ae4759855d30b56c721f6381b345e9f9f855194132a82ec9349d984e088c369fbbc1a66230eaced03e69221e0499e258165d7c011912e07acdf1531497635dec94680c552b2e32b1bf21b89f7cfd8e0220660571e6602856a63f9d401d5d3a2f38f747b70ef362beb43a62a8a64c97c45c3bb569a408ef0e5d32dfe2061dcbac53f658fe659cb5c413c895c1fe9b655853b505e76d66d4a9c2cb028fa8754f7dd60cbdbc9834ce76e1696e692a7a950af1b31ed78aed5e8797da7c446b131e9a8fdb2166e75d38d5f28315d77e70bcf55d7580a6666db11a87e9cbbf844ef0a4f3cde3d324d0d64c74e76d8d15a47cd8688e3cbc789df8c535840ea5b89066902a6b35e54ffd8975f0e72ddba0f5fc37f11577008fea5592b68421b200ddde6b6f4276fe8e7d75aeeb677302b3e68bbd8146298abccb74957c43392531dde98cdc8e509e84697dba3daeed4399e1d02ae280c626c2169a79bf742ae25d1d3b352cd35ffb49d6ac0e2863730cbd73768e92392e966650b071d4ec542e17001726815cb76dfa95d010193ffb0f0a3a4d6c10cc94bc82f48eb104fc00f0f9989d543e4d48d4a1f6930851381f95e1ff2f9e73fee85d64e9d22830cc73d7241525dd13acfae5b8a2a3451b70c03129fca61c66ea6614acc507744c2b439fe53c95627072a04dc8b27ce0d36f677d814bab6052b2c2def34fd114f74a00d07a57807d4cc2c92a35adb671cdc1e65c85ea2ec5e6efb9364f294ef2a3df4e9facd7923026844fdebfee97b91b943df24998488ff25ce02a3840cd223fa40f8ad63c637b713c32d6763bb9d196fe40115effbffd33fb1ff4a99459f4ed6190c0b1ccce6c38f9147eb0d1a73eacc47f9342417f297ada07d0a0a164fd70398ff44d281b0d603a56b3551b5613b4c8c98dd645ded4fa5da2a74312bf437fff47c77591bdb34c49f7fc9e99fb62c34f70b588d4a11317bec3c15927bc0c10445284558f5b2501fad388ba52103ac17ebfa98cacf93cec7769d5858c9a68b608734f4d0eb312d0548b38a4b8eac67797b9524fff932d09409ad7aad1e8184d8ec12827af2c0a9f40c8d0f569c6f7b93f407feee746e61db104f51aed4f7b90c47b9a068fe8a674617ff85c70ea174ef5fce4977631a81099dbf9ba55679241dc941f10c1c9cc94aea983b2c1f8f24a8cfa82aa6405a019d810d654d2ec9f50aaa3d64cf635a428322cb4e5e5029de075017cc6aac57a04936d6ce19d187583b19a1f6cf0a89416b7024ea7f412eebfddd80d605a713857dfaa36e4b9c675baa194aefd40407f866455d430a42228ef60d5c08de90183d040376abb49016769b7ffa416c12143a75d6574837a3a9103889b9628c72103290354a7e810901112270c7def43717b0abfc95d38a874068ab74d99ec4d7f5cde44df418404d43dd4b0c586178c74b616b5783bb3a16c2ed0116fa97e2f6a7e4eb16dac20212813f80906b5c63de58cdee5e5bbeff7f94291eb93196e06d3394f2fda9685a4f623d7e6123507a1af44b6b60bac6be5751e3e7dd2ffbef0ac94fb3f6759dd24eb180da6f09546566946942b34d4e150d3431d68dc08195ce0610673bb4c18e6ace80f3bf2d34971a6e359c900f3e8479e944b7ce9584684fa7eaae702c497df40b07114f279c334587247f22173e3d4bf577a496d758f71f0d7710ae1dd6a187031cac869e8f69f3a46162722fd863a2df9db57d2e9f502b647704aa68893e728f1cacf2f86f4dbcc24b8dc3ead1b4b87c63775c64c9e8cd6ec85921fe2aad3ce0e56d721f8ddd151b5b5b4581a15c0110156232e1983434c66174aebe5b9b0b40ba8d994eccaafc3d270136745c1609daecf0cad3df2e3efcc32b4078938662d0aaa4ce3cd2f2894bf4071a62770113b61f2bfc01a2261160de011e1428bbe896ef36321e76bcf704411258c44c3e959bd3522a93b6810a38ba19bde5f7af68f0150af3437bfd350f3f021d45fa33a30744203139a62f21f26180e50bbf0168894d58d912261635fd68678c3bf699fef5dec4bb0ac88e24e9f43ea868a60bf714a86cadfa1f2132c478ec30a8605d1e485a6e3867c13f1d588b2f7d2014f1f1a1d7943bd81955e51e418d3d1c1358033cc808f6b2a4b68c31416513e22a873e66733a79dfd3ce7328e92fa6133e19255c3446c80580a32c79dffd001341dabbaac6c9e9229aa216c532ea928b22a3e9e8398b4bb8881efb28ab9b67d0ffcdb349257641f6a9397fc3509fbf63d35b2976054da8fc8026931ef1a1688bfdc6233acdbd3baef4978f6552968343205bfe9aa4b44434b28a274d12c6f0d63ca087a6adbdfecca4e92bc0de21312555c6b7cdbbec950f8da39875759c4dd4bbd2f9da3aea4185bdc165d26457ab382d10b1bb30f1fa7025986becbe0d0e4d93190dbc41b1ec598ed4a26598e77edc0a26f85758f36b5e25028ba130b6b031fb1dfaab3d8ddee69b1a86df7d99d347d48efbe10f466f8d47d7239503d70c574355ef3e054e47ffd818e923c3169b205abbd40c27b02e03e67caf194336f7af7ad3e1abd20d1a75479a29e836fd83f88e05195fb4eb7dd81e473f08d9f81404db086c22c113a96ca4f6f9c04709411d9b9acd6dc114b7b47acb3808b06463f53559d6593851024f8fb8aa6dc13077465e9068bdc023b5e6436bb12c0495cb9ff1881a7fab4ee72efb146580dd22525370a848dba1eabe8f12f2a432f49564a40aa1b5ea58ebdc4474987d9727d3d21dfc5f388f3ecd6428b3d980039c3c3043f68f401ec4d39558275c34f9193abc35253215ec870e15b3e84cca219abbf7d9e1a270eac868b3fa6617878e803f2bf1583758c7743df799df2e4e33ff0d8a7d9bb558e0ec3c7658f1499e42fa28806f818d1c558b05fb3b31053f87850ff07060bd62cd350e2a6557a0b012d26e46e9c44578437ca8285b5a2dbe208c5a8f48585a7869bcb418745f184dd68f677266517a6ab7dc8cdef662f2e3a7ebf66967cb93ffd1605f1163fde45a85332edd374c05e30b1e3386f28965df24e95232e0ab18c7a9930e406549d06a796a36ec4543bea84358eec39d80be33cb9cad87665b9a7ab9f06f825b5ac9e97a476890851105836bfccced60f963d14c69816919cd150d5ca7cd14dff765d17e819fb71b8c53e65cce70d6c64eb41e94311179aa9a62c2adfaf37b25005868e125dce2a57c8f3fe271cd3212554bc74d37a9c115b04218984ee0aef4868a9a9524186bd6a07caf4892d30a393e53b648b1898dd3f6ec6c78c1ef7a6d143b5e7a07c0832cd0e27b459b8a4260702b195e6384283fad0c01ae72ff3df0bd760e8242a6434e425819db77f686da5a1ed993d0d3f613658770bc665530af54e6bd5b8b29f2545a00f12a406c7fc233ae9a09b438b18b6d75ae4ed45e3558616d14344947d00b2e2f2d3061c86096428723b9ab00a6df7bf5b08cf75b7b00b4b6b09b69a7e481521c31c829a715714b032beb05851bbfdb0a097d71def975960649ba2fa79508d9afa15da3c9b985e82e5b8944804a686e1284fa831ba35bcf47f12f2df3f844ee0f37bbe2efb655f604e6a120fe98167c26f064a24e5fd28e49f2b08411aded492383e2c08de270e4dc204f3da2c29400b12da22b925abc8dbae488f3f3a0bc41d9d2f69772de8c0425786008357810182ad6a9cd7b9bd1ae1a6c975dbad152f6aa1464168b59ae0f0f1cda9e4de1f6cb3c4717b27a7fb60ad64ace4ad99dc82a271ac82f9476c286b7c778d71e275afc5f5a904e2bdf8e995f6650d239d2eaa9baf83e6af36133296c5099fd6be7e7ef21cda3545988254f4bf5d897424afb856dbeddf27b092be647553b287f80740108c43ece260ca1a3dc54ed674658d3f01b1ae646514e4ce07480af73b3d450410e3c03a6a67d0d7e87a02a6f5adffd41b6b736ec1004ace029d3e4c4dbbb3bf59a7c24d10b7485a2c498ecf99f2c9eb472ebe05884a26c95e2d11f573d00012467419f3f624bf6cf405bdc9f577314b546f9bd6086d347e00cf2e8abc9cf5ce69f24113d1f64e0b5690706f76f06c9b0f385a3c9b7e918ab77d6d25136a5d1a15347361fd8d8ae2423fa70ef71468b1bcd15c1fcd8e00d89fc15a4e6c5736a25c4babbf8281a5ec0f0be30f37e74f8577a86a93a482054c9765e10f6d3a5663ecacd41ef3e3287a873a9c3a81d9aabe8cb1af499d6450493713421b1941870d11f7c027b58e7da7d9e963d4d5f8ad5211d888da0967f28b52c1e5da0c4aaa1c27998b8cd77feb42991183c15f0a5fddfc92c0777a30ef16a6b5d02e7b29d532010d78c782c0a5b3a597eafe244032872e8bbb6ae24f566cad5c0429a8f2d8a05752818eef46abc62ced090d110eb7ded0160fb679ad85f0bbd0ea62fb9d996ae1f6486d7777a4a39f820e12391b7f6a9db8f2a8209558beb0baef7f0d85d3bb2594bfbd1198b998a6e0a37a19fe24d12edd61ed3484d7814ddf6e61653e4cade665aeef5ec73f24cf4b149f7dd7fe7c057baf9b713269009fe5c54c4c7cf0d46c10f5f7918cb6906526008b568839ce7dcf40cf62f4916415e0899483a8ec43f89b7f06bf77c9bd6ea0bf820d1f8d62de2179cdc044179528ce66c8dd188f5e2975353b10294bb6ebc63a08ac3a794a0ffc1e205d116b5376df07915d62411edf8f5106825d07195686f591f17a88a3e86cbd948fa5a0d971c18b6520ad33dfce61fa36fe158730ee7f659a1bab5dfd93031378dde37fe5e7436250f053a7a63bc0479003de3576d512c940e5da6f9d8f284f57d233f2848bcf9ae949ec9f22447a6eb83de1ab375a1fdb0b752a334244180ab440068fb31d93714fbf97f181091fd5cfc275be83ed96bfb7fb7cb1ab69604341322d46db179dd304586ac83389990f74a69b22a15b0dbe27a22d3f1b88e006c5b5efc528aa808f8ca0569a141ea5c9da4d0cb7072f16f7626454fb1cd61468d5cad99dfdd51291b87f8af346414a26d2a799dfddfdba777d52cad6aa6d01ae396e8090e792b9106b17dc9ecd45101fe2fd220ff30ed3b5715b23467ad26f36dfe3ec1068437e4d5e9ee6b8471552c5c080e416f55b728928dedc924a446ba0a85f6c06d8f0842edddf8b6d5fd442c173f91d9dc4b82d081523c196392e5a9cce9167d2e6fa746ae0d633a969a99cb94037c77cd9ba5b793579ba60e224a7f2e2150420b03da03fc74dbaf56c4e14d7a5bbe1a189a03a0715447fabb59db940adce0b3d471a3236940abb06aa428001215783c46456bd2b403e0ec25449d48de16d3439390ba4a2ad9672e4a853408c52d00bdbd0ea19b7aa828ba54bb4331469d256980e92e05d9ec32f19f5b00e9ffe4f8b98ca4eaefb383a5bea04ddd597acc5ecbf8d9f52102bbaeba052e115251746e81b51b7d446f22f0cc0b1a33c757045e7d006abd2ec7582f5a43230e27d0e74c1fed251692d8bdb09288c419ea42011b72f40a09da8f30bb1baf2b2231b571c27189691907e3be7ac770b75c5789b15f2f9d5aa5387486df41949ff7ccfc0e00e61cf5fd46cf50e54c1f046ef843d103e84c8614152af2fb8c210436119a5aaea00ded0d8ae53f47020b02d50903576eb5e0cb50b6080f251c38f3bdfb7b209cdbf791a604da738da6d04c3d1ab468ab1d94f9e0a6df740854f08af5b2ab511d788d0df33b0dbc90e282e9b13a3677e34d02f91c2d8ee0b9f74f0c83098a8f62006839c5f89dbb8d6055d86cbde5a58a9ac1bf477c9ea96d4d1a658b571fb9f51e5b1aa85e053dbb154f815945a2b387da466facbc3ec7df33ea02bd21b569b879566f808b73e2ab88522f98510588de0bad73a06a17e28264b2f1fd60c82508e1f25a68fa3129e5b6a07ff52c6b4d69b7535e9ad052a18d70211d72e743dfacbd42a52eb63d36d8e6c00c492eacc3cd1dd964a69bb56f9e4b662715b7f47903ce98d76c95de251355e5e80a8675b2f67f57c7ea3cd6c06754035d13bfaeef7fba2f45af4f0ff02ed44fd07d622e17f855b907c53bdf25e33ee1432dbb0a122224b21d69dfb95348cea9c2e96ac440493a42049d8f8977798df1c828f89d722c70cbc1be5862a0ebe77e6444013c4ac03d4419e003808101f19626e452d95fccdc1d6035bfdc0ad672991be306c2c3aa89d83b66e8457eecebb5af05e2694d148861557fe0d346b6a56f43b4ac3b879899a06db06390bc5c7a376866f3e1cd86f24e37e55f14fb68d7886b7a8f18178a31d386780d9c24b7bd5e3c6fa3d53b6ab8909cb8024f6d7cc3b1075a7f5106600d085bf0f28a3300f92d51f8c6f443e3e8548ba2d5dc5b05ce45db9534a0f3b2f3ac423ee7f11eca858c416dae1ae3fa661610d34110e7a73e4382ac3dc5d736dfa24803438d17d7779f0e0804afe7bb1ba7204c2e75270a5e84d94c86dca94e7f44ab70ccb2ebb91fae6023fe3be0e741f3c8680090f742e8130f81f926fce3d52de2b8f054d1bc56bb94c788cff46373dda42b76504708d9fe5e13328739134f2d4a2bf107dd6e8599b410b049baed54b1f7f668ec5c5d909fbbe40260fa55d28bf5ee137bae301ff9c117397daff77d8d4a0324418bc7d996a9767c96d209400121475507e436d73e20df0ce82b863387ee3f891f464f5ea02607d94b4efc42d18bb6d33b24619b7abe8692deb69c32f0a3658c806aa6c53edebf10061aa932660a20ffb6cbb8ff71f35756ed55757321c02bc00a1a98df7e484ebbb000ed399f64c0e88cc0fa364eda4db122ff4b8325049a1a3e92ab14c91891a7283f1b605bcfede348997693753a6cb5824223fc36f2b1191330eba1ce55dce0ff95d951906aef461a4f46f81adbb8bdb2415a31da57754acfeea621f938ea437db52b676ab63a1955f48677f6019196e6624897a721f293191f7a9efd55fc6e9e8082de85124f70b4fc1fe3c5597c4a78c6df02f5183e8379f87e9f0168cb4ee8da911ed4f266df2b4fb9fbf98e060aa9a8e3f736843c97b00c334bb4418d47f71126689b1a67a561720ce9ecb570272e7a490a9c6dd580d2dc22266689f4581881cd32c9535cd3b6f5fb919775d4a2fbc0d4ef52a32f4f6df1fac43677f19ac7fb6e48de96efe038d2950f1800a84ca35f30596d50d7ec70f22420ea4ba9fa5207f542c13e644c8dc04b33dc0d2a245d9f5d7129e7e7e7ee8641293a635fccec8fd1e430410684b00ffe0ae16b34ef1eb8d2b6161907ecd198309712277e1c49c3c69f7fde1ef7d38a19c8fa2a2f782fe3d27c01033f3a22e33816d223df2c9df50af7549f46303382981ffed2d11d890282e5f5020f9bad7eef7c38d2e2ea825c61f38dddb16abbaa0617043be616afea2310c8550603a9fbc28e90e40a24fdd8fd7a23a040eb13798da9f3a4e2c78dc9f181e6bb86af316b1aee7b0bbb5d6efdd1743dc5e50f2503b6bbe0c73d85d70fa040d609a1875fef9e3cc0ec9c50add4fbb85891364528827a4de22031743d08d8fbfc0c75f6d182639f1f42c0272ac94002f889292123e96993add83a4aa5624bbc10d20b161ecdbc2c0d1bfc82c709f98827102f4775db7f5e8be8e0ad307520b1ddd751145dd4c23e23815a4c31b3ab3c5549aca284bb95a0ca6747214a7bd166f97b450017d0e38d469244c9ec4d2f0e7da5ea3234163c7871025ae839a807dda74050088aad568b58509a18e652e2f1e0ae94a7ec63c34e3f217be17240673b1b7b886b8173d5ca5294672b73d6a7b2a54f75645ea48b93f087871f6e3ec6790ee04c4c9a910b686b4e852fdd6af929466d5dec23e8c60c1db63e4158a7d5bf2fffc9ae1471aa6ffe1b74f45815acfaec5468ff9cd72a4f07b2140122e09e9d32cf78b034bea12a304fb40f774efaa64fb2c2515b1d8ac931b37bbdcb89ab6902142e0bf2ba6356edb1ac071170702342e645abcce4917f30434179c42cdb189a9a5670f1cd9836c1da56b58fd6cba432ab1b1917d96452b9046640c2eae4532df3caa92c95da5753067b5327a0254ed2ba6dcd1422e4dfd902cef4c96bb31ddabf1bdacb51443ba4c1f03f3bc03065f70e2b4b3b366fd235447fc4208fb705a1d7e821099d1bc7ff295c41d571cf29733be1f6184716acd23cbb85ca084732a3dd8ea1267b24f3a83d237984c66286a11b0f7d08336c0b184725bca2607df4e9f21c98b48d4ced015cc9b4db3965ea745739e561d8f006c452acce1cca0f627355fb9256419599f6bea8bd1070435b643939464357ac47611a5cf5e3336fe906dbda5231882056f6b5a80321773f36ca82c8c394b1a234de7e1b9aa896fcb3b9b21567625bc8cbeca4126e6254f18461c318cc1e013e74d0fd0e2a773a5c222dee424109dee8e2139ba171d523acba6ff165a4b9f9aa02b4bbc150addf7063d74e2da491c21ea7496d52d2d8f54720087a7765200a839a43adb8c52b71db55d7886640fd0af841d8ac538ff78bb6123e17b8a011d94f7e48ea57c5b121ef308ac704727393c1bb0c680914470f6b01b60206ceeb3bf637e375d39fc4d12652bb556eb7cd3144861641ab941f8d50aacc9521fdb0a870fda509548fbdd1895de8b7e79715f56325856d1eecc30ea8552714df38643b8cd6ced5d85bbbafb625cae3053ea5503337956cd698659eb8ace407b51d1043b221421fa1f298978f9303aca459a8af61b16a3f339062e5d986b3539db2f62298c1acaa07a1036bd4a45a6ae1d92977f890a8432f8668f5f7ac53bfb7d451656e6458aa2f74b3cc713a9844bba16b029c571fbf68c62b1e631b71132200cc36b08238bbdf029d56b987ed51d9e6ba211a7980a4956d932ae6cdf05fcebb33eb1810351133a109916e2e53e33277d61346465e06af6f2ebf9b6e2808051ba116c82d641b3fc96f4adc5f6a747a40e3038b46ec47976dc5612f7d2dd95b5aeb0b1729d0e5b0f0846762332d70110f2d13390d34f052c5990e602bdb884bd88de7606f16004841fe9175a5da69b1b74f6836fd3f47beb6921cbc774fc59bce201da532ba21ef6e07236cfd58e02abd76cbf723ca91fbfe1406b5153fc353b99cc79ba200a6d503a01b2eed28fcbe4f21012bfea8273c32e53c2087fab93333440efbe3eb75537e80205ef5cf844eea2e7aa7fdeca8616d5d0a2599b8b12072008a85796766747e5fddeec911bbc6ebac0b6fa9f94eecdbf32d51f3c0263ed35ea1f7dfc2caa6189ab7d274b57fa781522762f66097ea5500f16f759e5d151bfd7a2f8f8ab02bfdea54f474dd28edde15b3de448dc5b601153eb90e21d2e772ed1193ab5927da6c47853d08a12285b9bc7a68e1736713d7952fc7efd1315ef291ee6b68859293182918e3b96c2b2ac3f49b6aa18459d654414316d1a8ae1ce7272b1486ba26eee5b616e08beff3edf3629b781fa0c53c7eea742f0a1b811baf49ceb999ef76c1adebc520de47ff3eae0522cfe2dc2b1c0e64c1f1d96dfdef217b4f3c1d33ec2029ee107ca25c08b4633cfa0aff01f0245f2fbc95be121827c1c40694a8611e4e61af17a13505e1b7e9a4d5043b81898f7a2ccf9619f9573fc5ec45a07ddcef20a0870281aba603f10ff9338fe5c1526a1ae2e2fe94f44637e5b50ad6ede5210454f2e8987b4b158d0ce350e362cd052fc0b871eb3cb6ca939c42ced7c1416b51b2c195087b20c2bee433862668c28f0fa6009e736d24ac10ec327420fb11e0b374b9867ee9d35fe7596e6dba0d89eae8318b54fe2a3b4dd1ef3a10766c50f3b104d163dd5086e13294a0f0722689c0c8c480e03dc5031e903afa5efcba980b88e89ffbd883d60a9b8baa88351aaf76dac905223514e1c7e43dcc0650ae73c64b20efa7c048f2e6665adced7e3e4a4284babc009bf91374fdaaf1a4124ee74d2d968b953bd3051a479005e623a1d2f485a4c5fc265f3654e661e2790a1247c2a21c0cd62675fd17feca9db07cf67a34242d5e5df8fe578c9a7cbfccecc905f1d70db901064705ef3acddb99e6a0ff58b84f904cac1ea6db8faaad410e5009fba0805650cdfc3f99c8aa4e431599aef25ef8d3d61e8ed4aba794b36b52918f0499ef1355297fa01a78385b9a8b8668b94359e621404080df4dfd7b3a6085ce4c0eaf8d5d68ebd9ccbf92015ecbbd4cd00cc7d3170f8379a12822a885caf7c19dd030c7d6a35f2bc92b317423b157e4be23727bb23c5c25a149c9aff5c2dd6fd02bd90f6ce26f3deae7e1f29de1d6550d22da33c6e6a5fdfe73f3063f4474de854f4d24faf3c767f26d48d45b11be0dc13802275a2b0b0c5f4bc81da4ae037585d58a944648cb15d66917ba48f26e31f63a9d4fca4296000f6d1c90b6f061c65dba9abd3f85b237a73cdf5af71ea1b985d1ea902839cc06151fee77840569342fd8cc88ff1368a62ff048993d62a7e0be034a2ac69533986f19f959bd7333a8b733c52ab528e9a6fb58bab8660e24ec3d6cc26a2ebdd1293583230ae4c93d4cb539946e022ef1fe2db13e0d5433c024ac2544575e45d569e427f338cf9c1284adc00870b6c1bc7e8784d89f8349132508337a1ff55230a471cfc91433bf2b3ee8bbc7cb18a6a6a86d2cf40977f8b7623d553d9d9192c93eefd60ac98e161d3f499ca658b05c3f27707e13f7a40dcf8953979284a289f8a42c1d19bac882f514212ba811e7bc743ee20300eaba32292acadcb3ceb3ef600cef2ab2ed84d86a885dc1e5c1e731746ba854c659dd7ffd242c7b036fbf4258e71241012a54ed411f2e0aef6c21e2f975a85cf9ef59240dcad9a13deaf673dd22be6a4f7381b1d0e4eee38662e248ae65287e6222dcb881861ee7d423daf0f907616ccd29722be7562642c42e2834708b53c10c780962b7453dfa1d4eb13b4203eb22d9238a95823e30a5269676f950838c492180a79cd7679a3e1cac7c6f3706f405a7898a906caf999fc19f5fc4a58a04c86b9b40e342cf31ebae3b4ddb1fe64ef8e0067a1fa5e17a77e8cb07d2bac151f45fceaee36e7bfe71c0a5cef2318411f06b8fe5789f101bfd699e29951f82024884860deaeb52cc1491b7740d931de4a086a2635130e26380fbd7b1a39c155bc25f22aeb4d786f224d02073645ba7916982ad61d218e397cb1efdb4ca211770269c6574ac9db84b90d324b15611125028f7a6612ede1f0e7a033d495355253dc61b9b7d196a8bc86831fac9be818c1f67b54dd11c33c1aca67b0d45cd5a7d2e3c247f01a75c18366569088284d1b6266d6584487511a54205ec49d1fb31f87c7d27396cc20a011789c06db12134c5eee8c4e5be8109ab7c5366a43e19012eecb4ef01d03cce35cead6884e3d1020d99cd4080c5d4de424901ccd5ac3b7bbf00c8e254e0dd00a88a311add48d94e7b9c58e4d6be5ca7dfce0948cb6533c9ee0f31508dc4c1f87543fe9046e2d274a32a28a5373a5d73f97a7670cd5818d91a163a0de27a332483665caa4033d30d553a79167c4ed6ba08749b906bece95a9c31aa040ba6c78baa575d9238b12d199da2b9a1d2cee17f90979e0b8c3db20c84fdc0fdfec1406206d11fbee2b95db013b83b3b4f3bacbc35dd5235faf75550fb3040b847240478596db9ace9c9a0ffdfa6898e057eaa1699d652eb15431e9848923d6b8bb1982faecd1e32aa0a83216fb7fed09a3904283b8ba34f311068b43d0f4f395681f13bfaeff999144d6549560503d0f6328d156fac36b2476dfc11251505287c6dda346aa82db62c83d92dd9b969856afe0e3d45532d872128c4c9fd1913fd8d908e2db39190fb2126c92f292f07fa170d0bdc0fc363eb98488e510f0897a24adf36bb08836f9fbeaca783f7d33b4e9b0e62ec11738a72f7ab7bb640f894f56b339689b1260319b1f186c5fdc3549c4d084d462301cb0e2cc289648e083dbbf9400974c0c346c3f9bb9215ec756e008310fd753e4dbdab3e880eeb9c3466e8801ac687b483310d4802cd93aed9678320998580d16c5e885c1c960a5e742d575578fbb2e2d2b3b15284370e6a08eab6c8cef855d56ebd18228a28d218922af68691c4bae991e107e597cdfdc632d21be941eb3acc72563766bf69736e669014a96439503e0ba70ac2c02c8e7f9049c16def85d402deefd04fceba8956927afaefb7b1dd7477597de919a083d0b79a3b139227cd188b897b53107ad01c0bdb0fd8be85c797988474884e925aeecc3f91b3c52384ed37df8fac3c49584e52c477d4835305b603002cf73663504ec305e72cb6d093eee59d78d1d6e4685cd6e630dd9a228c23a3e08bf4127dd2e4652e2da19a7d94e51ff3c25e5054bad1c5d4d8840e1fb0ceb39c943c48101ffa36d2e416bff312a88bebdc4862c3ca8392bd57f79c66e3b9790e062d64b7083958de51c58e0c984213fe189e5d40e27e983068b64b091edc84e902524c2454fddffc18b192ea01ef9918ce3a5b0b4714c7ba8b0adfaba3755e8f8d95f034b8072adfbb1f26dd05ed4f4948a3da2a32c4289c8be793b180f97b9cc3e03627762efc383b919736e80349770eff04923d2690eb4672a4c129f7dfec464b0579595e46c96d2fb924b349692dff05184d91317278c417b5b380ffa15abfc35cc5d9d53d6c2eb3083eb0be9250c185ca247e7c7a77bd12809f88ea2dd44cee1a284b463bf55984b65404815361c60ff9a25b1a627c6932c9f9dfafb3384ff62982fd941d4a17570f83b8cb7f9ea0b8b6c40bd4d2350a973e8233e9458e2e3e3ed9ef37ecf111086753f13207f609d1235c8a4814456131575d509239587e25300acf403dc88012018ca41555370b6c587e3bb5d84edd01e2baa75a907856e3d651c8dcace2d0625d278dd81357157258dad0d8c8de6d8d61881c2e74de07a26ceffaba769e5372fe72a9040a11999cef4c89fc5be7dc9fa30dffa744dea0f23237b4afdcf6d6d1fd3b008d69849e8c9c5619bd5b827efe243b165f98ecc47d918dc68d30482406bf5dd57266041483f3efece0bcb3ed2b483a9cba600b0616d404b3017c25b41133fe507cdcc09b7395c9ff19700aa8db5aa348ff7944a6e09471bdf7e1bbc452311a07372d0cb070088b3cb4ed8638d54e2a90519ea79f0e7f575457bbea26bc99edc0f314712e517325014a39ff5e4cd9f6715523d4b5770c07a344c0f0b5f74deb2c9a2a5eebb44b288eab777999090e1ada11b745d7b0f8d8bf6c86862046c028f3679a4d62d036be82c86a5e1eaf58ba438943c25c5a8cb3ba0c4677523fd0ebee396ee499c2f32c752a87f4036a664a3885f129a4546be3f6fb15ec82ab09b1c24506fdd390f1326176cc512637700da03bbecb81d87054122c543eb32d6c80d9c4833e9ff61855af2f776872c19f7af22448616efe831c39033172321004de60527a0d9634092cdf78c4e4da5cc33f4af952a620915b874b1a4dfad7f6e06a404223bc7b9e174ca565213ba8fe693c5887b900fbe8308eeb8714216cf55051ac4bdc3afb6162b3e28891f57e67ea8adae970d518fb0602761ca073ee1555fde0fb3eaac057fb1daa7b897416b86fa936d826faeea3c7d2cb92bceef8458ab62d0c5df2081daa6fd44d6195ca9b8339e978130646883a16457a74271c5b24c785b93c593ec63cbac802deb02d36a2ab45dc2940b2e683a91915716ea146505e644c20bd4a37fb712c5b4937d307e0bc380156bf07246b83a4418daf5557bb1044bceada6837f02de70cb7637a68ef0186197814f4d92a6255831ea5a8181ff547d86a9e9114ef7cfc6f9adf39af83423f019e8caaae58ea24e43b57d5ee0d34a0ec2b33d2406753ca069399f7f6a90f4d9017cb63055f34eff6427767afacdfa16efe4c4c40d684de7779be08231f5d2d21a70229c4363a4094c94ac0d66911f2c4ab9db050f33cf701763f69816021655325ef168b9450b7d0fbb0bda787b2bdaabd07a12c36ea5c1b02c15859f0134ec55ba70c970c83a43d6c68f7e56f0018a6d63d26e5f81bf2809a1b462fe5fb45b001b2b973c025e58233bb57a56414c9f60751b404301c43944de42da13c841a54174d48a014f82711e02cbc622cc997538c723a35351361071f9be9d95956edcd1e6e71bf0aaa90518c3a55ee76357a6bd8928dd85e5095e571d48235e2e13bf9cd6ac195ee334a9db5685cac8d8b35eac9450c2888f737cbc3cfa625ee1ecf41c67fc015cff333c6bc6ba1412bc05def8f1ead7b5f3fbecea7e6311fcc22af97da07fd8d18e920b37f17d6a09a2b865d0df08212c3a2f8d010799168783e2549fc75a788d24429ddfd93ba2282d2559588c0ea4dcf34596edff828bb9a49c54c2f2e05b98828a501247137d90af760e056459d31ac3eac3268c56240c02e0f9b5182be520fa0bf1f440016426b9e9d16538cd6669f664fd007cb731152407af03168615390435f20b5c96c68dd474eb8d6d3cce5eb54f18768b78f504d176305ee3ab2113778f24af358594c79cc78e5c70d2d723573eb5080632e37ffd87ec9cbce613d8e9d8e423ec11d7e4631979fe6e550aa9d9f97ee5f5b6084d7e1d2cb61b318532cd0a364cc61aa4398aa6267498be62ac3566afc7835e8fac0f4e435cf27e619f6a730ab7fed597c82e150b073d64a86fccd912fbb868aa50e08831a6cfb4aef7071cad0929410824a5784f2dfd794e26e46dea78ad038b68cb04761253cbebb2f2452ab935d2c02d5360f97ea2688d78d65375a78f879655960d32d518cd67d237c7d92b453f8a81b80f8d8c14eac7dd434b0821c4a2a076f10003f4e9db9867f22622b7c30afc5604a382075f82783ec2b8de6d818f64a96ca31ab75814c5e845e45785fc1b4e438b1091717d93c0f6a95a434222c6dcb2a1fb0ca8aa3490226c4706931e884df62546ca190e1c13190588b661d8e30e2b406b7bfacd41dfa0cfa8946a134b7c9fe39ad5d9773d642ca49e87d31bafe3612c8b94e9c8b9d7d3b75178d63a3d2b19078eee0f306748b72fb145d2cc903fd4943858d07fd7a82a837850f3ed0f4d586652322f01a6613efff8332b0ef8ac5973db814d3b118de1d8a8ae45990fa22bde821b2732fdca183dfda407ea93f2796017a169cd8c80625695eb1e70479acf5815084142e526be0c3bd81322ab99bb33267014400f079a2255fd424f42d2e21b64f7e1da36e6863579337a711f8fef2e6a2c404662dfa6642df933c8268b1a5b6c8e542de73117c12a4369d11aa977cadae4a1e175e93ac62d4fc74c41a7319033e389f830ae42aebd37fe669077908c3636d35e80130336aa63a3ca0e68d02ae93f6ece3fda2d1e57adc5ba5872a0e4b6f03d63de85c605b58dcf8a25bc73fc8587f3dfb0dfde37b66ebc32c7e73327ee98d814760f35b64bfc7192cfb37c5fb443235ad3eb2e3cabfbddcbbbbbccf68d4d0762e7ce5d934359274eabe957a7787455cc2003839da29ede5e666639cbb607125c712d30c6800389a1cd04e89b4035f8518c037e40d9f288a568e32a2c89818991e10c1c2060d40e2f759e03365728b489f0a60f9b1ca1217336962e7bc03b28b81767488ac09bb74328e859d5f2eeab514fabac055f738c27f4d3a4a7f8c3c0bdc051c4f56d74e243e3135ecef81dc069bf8573d7b66fe302a588af64a5d6b09c75acc0f96af59ddf64c6452261a46975330188048fac5b5d07bb802cf960f0cd65f9c71d3e7c0dc0a3b7557b13fc05adcd54f18366597db8ada593f90c32b1713feb3efeb2713b2bd13cb5754742c6346e43c4051416d0fa84b0fc21fe4a575df1296f3629664446f70f65fa20ee01fbedb07039845c0fec294583c61c014a46b69571371330cca1101764ffe26c0a795f063321007e2f2aea374eaccdac7b82a78c3f1515913c36c5820b2877ea04c8fa06c5dd687ef006f19895fb2a102408c0749ade49404a4e68f51fd53d634e1d8e9ca21fc7c9e80f3f823fbf9f435632d780e464b463fe20ffd867fdbf28d802f9d62fa9c1ccf291079e3ae540fbcee6b4ed8a7c0e7947cf2fe2874be9ad8c05be8171542f21b368b0eb5accdcd1782650c6842cd8d417757a49a6f80405c4697c98ea985f24d3b9301e1cadc532c43b2314d06e3e04d1f376f2df3f947d51999fb0400493952b02104b6ed827461ea6f854bf4f75306bc6aef7d6d60c2def28d4a81b530c124daf61c0181e85bf6c6565379e1dee88bdc073ebe124ad6d05560e467a9f4f1d6deae2bf34230c73cdcb82dcba606413f4d913a42fc8fd5f4cb6956dffb442207cb8d59f8680579fd9b99ecc7a9a2579cf3b1b8871280e400f9beefd781efb2b18f56332cee691e45a1d9806a8d0d362abc232175478f70102cabf2d83b736a3e3df9934939bbbef5becf4fcc80f69820fb48f9186eb3c05d29617333d9b7a6cd10d7e02b4bf37fb2ef4b98a53b3f1f7977ffda1d4039b6be581f9a5a3bb67f86e6c281ca7bdeecd195d5264daa12f72dbba4f193b8245b1f735180b8053216c370032632a0da7a229a81150be338c6705b1827bf02e953c88d8301d78b2f73fd417b1dfc7367f74b8849d7284c475a3ab134e452271b90d71bc7e732bfed5d9bdd93a906999eb0622ebfb85bff5f0d9882f69c2ea25b9000d575e6e39ff8932b4c205b38c920f95cd3fa1f6552dd49ac8cf7c0260fbb52ff15456a18637ec123648174edfa91b699a221dc3f25a8b61627b114e0c71b993d22f3f4335d0136ca0e301dc64681b1233645d533c49c57472880a7b145d3895852b348c155a77c5a5521f95ef1a18d75d6ac59f7b94ba0f7c5fbaaebf59f7f6f2e6ccd4255a0824970065fd68135c6286c87a25b0bc37f4edfedf81ec9a4f017344061a467201dee8ec528bbe404a9ce7cde598d8193729e53d29df2c2a8ccf9f40e84244395e6f05e3a0cc474f2741485072a3bdd8c5e2578e3d62f123430a2f8b12ffc98f36dd591f009a335d6134af163eaed00c56968771d33083a0c9f071b059acac11ab206dd70af3131391207f39af728b41712f6e197bc454608bee8fbfb7ebd42432fda590460d2511f1f9a77f3b30fa207dac8b0fba6c19cae98c70f3c0348d5eefea7bc6e8b60cea7100778182ed6315e8112c8126ffef251c51591b8ff0d7db5aa1c1305333f0aa58cc8c103987ea129827e75d184d310c15c8d68713f39b5800e1437476452bba7e455c80dfbc2f6539541efbe08bdd83b1503f88b9aa19b0d07beca9d48a5836ed4110f407e4d0fe4e0f65a9afaf69f3912a6b9d797d36ab2eb12eb72f2c3f4c3d764dd2dae56ed8fa3c3875a4d6eb11fc32fb50344d74ce4e6c2c2a646eecb7a12ad2f9d467910a7ffe5c11c7365aec2a5393fd2eda153c73a5eeeebb29149d04046ea88fe731f9758fccbdde8c00842c49cc9a1e60a09f47f6d8b057e6a23dfa3a76273a1fc08587dd610ada65163674a2bf11ab591ac7bc99c04296a583ecb32d524e06b428fb3ac5bd44a211858a3b3a3d5e00707f92c689f4e53db9d953dcc10b1bad76a9839c9c22ca4140280f0b1bf9ec492518aaa5790ab9863f67a9ff35615bd91d5381c18499f909ffa4d8c02c84399f8d1fb5bb4a7f4e1fb5ec6e1b72f6ad271a797fef76bb1d23a1d56e43e551a744c6a191327cd35f8bc3396329b3d6491e1df057873efc227bfd302e7c4c21207137f0f1b82da3e915b6b0fb28f2630943839e98781223d709d89e371eb712a692c89896f11416546629fa3344babd19b750b7c22b4bec2952cc9c2e13ab02529781fa6404b614bdee2c2e3d5a33344f20e3850d193d05302acf4260a6edbb09c87592ff0263109e620f7f950c0b3a5e34d71764c451e8c5f1d6075e1e8b168be61acaac175a0ef71359c0be16027d5ee3bdee9280adac433ce1b039f9f92d22d93ebf7f5293c00db4482c72fd4287804fb42654d328aae345dffce08142ecdacecfc76bc312ee6462594e0623872e63891c141412c41a09ff42f7d8a1c5c0e893141b6039e9c92fec07fd797a26ef961925796542880e43d396c272a54394bb01ffa3894776415befb603cbe57b407654090f66386234e2eb9b5a65d985e38c011a241c9d8af3c1e8e078d895e366d502f948f8e83caff62c70c14d7b54fc49e9b2087de3f8799ada4965de03940cd42ec5a509008c5a9bb5e9fa5db398f1c19d07d83008c003b1732d1c87f314da9990b13a9247336a61fb404289c129468df357c28663e468851227d94ad7f84e444d5d8590c08ebf10e96f5d41450a8ba10b02615afa467a69c2423da77e33e2f34b0a2551ddfb5fda5f966d2b7e9769f9ffae4c7312c0f61da95d524a2aa91b47bb4ba60aa10cc48eaa1625eacf0ec9c4ff77754c5631091ccb7e02b2bea92e0ccfa79153b12c04f324ed71d3e63fbf2cddb266a33447595029cdc44bb379d3cb4475f9a5b42a3705ecf2e6a5cc99ec551889822a7abb9524df36a34d932023a9a048af13dcf86a9c34cc609e1b24328edd5e78ad5b987192f4a987373449437c49c82a574de530e9d675dc24577695aff607f7c9f387dc5998545494eadabdb0dbd3e9f8e4315e199e0d28a883590c266e79bd29e69e3568ddb5e410c823592fd4c84f711cd3bacc1cbda8c9be25ce398ebb1b2757d6241d2807ca9370f2e056e1d0f1c1e4e7c2d71e84efea6184f08d1f5c93b6b2fd57bcb1ab07820afb5b6bba3aa1afa8fe04562d49931f25f896fe7bb0fa13ecdf1fc25a92d61bb77c1626b0da01349d31822cb0309f5d99cd7065ea2a09b3134b7d95def2a4e125366afa3d94f6a3071b2ae44b32caf2847ac9089bd7f181fae93817df1e4512edc3cedfc0bd4a48f1a79fbd667d6d964c9542f6c9206876d1e03b1156abb1b0b01afab015f42feb8912936fdf3ee83d7be2ae2ba56066a06a019af2ba8ccbd4067eb5b4c0737049bd44d4d1876d715f9e01af298ff05ae6f49a5892f1110fe31bd518d27f108169f1e6e21612a55e6d135ecd1d867b4fedca126b0a90270397b4d1601f3502ca89fe84fa94246accd132f4cff9255876cb59635df14db4973638bb95a7c55b4c7be839c273e979287a340bcfcc38c9b52cf831bfe1c598f45254db25714d2d6fa3128ddf3faf130d32e5870451a6cc6570a7c23c9d3f7ac3289b20cfcaf3b79ec15fdcf8ecd983b972c565fca4a766dbfd950ceda0e5a04260c8f433e66d7c6115b70b4a0586134917b8c5d2dc679a3fb3da6a460caa458b724dac2c5de0d4b98bb6973966fe7be9252bdc137968da79059a5cc4fc8d8545b6a96b62b74297078dabe6db5fb57c9940f8525380de874a935cc4f2ac83d061228b2c3515176053057d69db528aa4f9f1e8e81760ae6c238e811e8a4444ec00198bcc07400ac04d81dcc455a8aa7e25a51cd24d2b20a1c9edc2ce628939f8530e56a77c74baebffbf393efb785c109b0f1475f17ca94119d18ddee60048fa1be63b96c87102b934153c7e2528d5dac6812c823832ab8caa59e07552f6c2fa98c5f40bc0996b70022c5f806f840db17840e5be84285a76ba56d54c26f3f38716534f9f3747a46020ef89f2a75d3ec9a908e9f6f5939c382c73ec01d2b96efd83b285ec95d8069f4e67a4cdb004785d418458f41c9febe6385b2858f8201fe4a786cd386676ff5d9161ec01657a9668ada34d48283c442c873c3fabe5193786f34a4ce3d8928dd6a5000eaed66e606f76e7bf18439f686ee56fcc9c079e684b2814f3b91a6bc686268c436d2a43e5a701b8ba58752634517dead89f31b9e7c2fca96f99b8ceca6ca695d4032a6aa4502024e9d137214025934a563161b722d3bc4fc45f686abae2ef0f4d5937049cce73d2ba03e9f92764a95f7a2b7e34b8ece2a33b4e152afea61177430182c947b4f04004034fa8cc5718ce460b099d6d2513cff26f94b8d82452f26e2210dc59a055c1c56e5c1a43c45f88969c1519060073a0561ccee6f5019b8820f3c26850be4cf8397efee7874e06884810ef4d5a894a8abb40d8048510c1d1dee440f4eb49999592e7a7013a98531ee0c4d6c411ed9a2568660012f7e27d6f4164ce31672b3fdbcb3bb40aad5c21fa247a608f459fc5327e0f915c84b07ce53367361ab621085263d6fda08b779e08726df36f6b00868d9855179fda90af8c89dd5d2963fb072a2d8fefd2a1c76aa48ce72f65be7e0b3909ca6eb0c3806ef76f87c68a283cba69b0fa1441f4e7409d4bb16a14dd3a002bd84c5a0b7d3c6299f1c0002d47b37d23afc7dd6ceb95d6ec0abbf1b67aaedd1c1c42d60ea4129fcb2cdc3897a997e2f79896e7ea7907f1761f731e1bbeee786cc5dabad627b17b96f20dd8ca22bc1f4c9cb8166ebd8124892cf181a06912dec5bb8cf0955370ff20f89c2072e8bc76e77249dcd374ea7ee64b3d74f6913fa9bf5eb8b98a46ceee21c116845553d0f527d8d8a0198df9d168ee7183a8bce2d6974d02eea41b8c89c4b9fd92a66a0c949404a7a84e3fad600e24f4683a194a695b49ca6564d7381ca9dd58ea48f8901e2031afb79e2e5d3c90eba73d0f0c902889f523b0f7d966d5a882ac424b7eb012b3eabb035791d1e5f49364d271fd22a9ed69975d772ed7e5da9caa3b631cdac34a097940f044bf451ef39d87e284d9309ca79fde5d9adc66b7ac160a6e7b285ce861d7ec4d1ae439037edae870da03e0c2cf03b23ae7d26c41e996d1366830280bf7112fc1aaebeb39c9764b2ef63bcce24b2a7d4864afb7699e4e3284b090075efb15722846d71b23ea78a7902694e918d90fc225d62eecb4a1025051c248e1d83af5b3ec8a0193e44fc6ad0aac20ba56e8c44d7e2109a47d98e02846f1b749996891af165bd9f25b37a936c3798053f9f387f644e8397c3a3a0fba02d6acd396904fa666e57cf60d26633e6b18bcc85a1cc2b542c5d8b72f8393e84c0deb4e17c81f0d119c5869a2becdca9b2b89b7af50038cd41c254b751361c1fb0a7a43431efbf907bb8cc9e4fdfb4b43c9fe9ec9a91e4407f2a85b6f5f8c5eff8719d941102a6154a9904c55f8e456b7c747b09f508fa37dc6a0111f652a362f066bd10f4bc05b85a50bb0d86df256bc32d91ec04a82cb186a8aad7a3ecafe0e99609d4ee9ac7e1799cd1074ff36bc9d5121376cfc3f2344e9ddb0b80f29ffc9e5921e105da1de81a6e8fe2d7d5d4681e4e8b90bc4cbe6fb5d193e6f4c828167f01fecae2b14b4fe085c8294a456fa22ba4a2054634560d58b32030f61815f3575083a50b0f608bb26199f923aeeb220758d4652f218afdd821cbd7141c3107a6e1cb15787ba456d6aa5c9f65af0a6f5cffc33a9e874f75a0a80eea1ba165d747e714c46d180a82941ba386859de4e0d0494f110c1ed1ed75aee917b2fca78e4aff0cd95a21ecf5d55c971049f09b38acd9d3f3c56e1e2f1ec9ac4190d0bab244b7a61ed56a3e3c3adf59646c7f7c3bb6001a5f6bd48531439a3e370c29dcb44b797a0c5e9f823f2b918f257e6e3bd5946afc2fbbd2cdcdc25c16c855460677dbe6ecf15fd4f0f60270a4cdcf23b3a60956e34c681b5c0ff2e1aa2e4404c9755c98349865a75280ed88e68e0c3bf2206eadefa463f43018d864dd9a71ab55261a7cbc4b97e48b3e054e03d650a7474f3d082570cb38e921462b8b052a059627f03139b4fbd3e2f45d97825069779f04295141405d28a6dc5a2f60f4439d89253fb11605b24c91cf6ca60844a40b52ab1600546ce808f7f16ec92edf96818b75cdebd81cbd6bd105d7a678db22a94b23a936a38f43343d7eb7f92e7471cb85e6cfdcd9b0d286d59c3e95f3b02937b93a56b0d68da27f3ea7053c11b1e87a834c540891c03028cb7e394712b62381b520c5a3c2c4cb00aa116b80c6dc87dab74168dcaa7a11c2b9dcd301e5fcfc3f3510a85e0388339ee653540ab0992a8460f5d20affae5c46a63229b1ca335312a25d95851157c73d5544701c4f372a594a66582da61288ed6bd2822b9eb06f57622146722ce36645eef87da86369159f1e63eed4479b124df78a23abf603464b34347723daf3d9f4acf422efacc2be68c3d916cfeba850bc0290e3227d526b4bf9f807aee555bca0a1bda64fd002ed4c297500b6415dd128b2c14e322ee37d7d7d84449a5281dfcdb024601b614777880a16368f7df98f4552c80df5c532ecdb5e8cd1f3d40f1bc1c2baa17f0f35927e9910c3a889bdec389c4121d99dc4d194152d24e29d491af1cc1c234c27f08c68cd11724512298920e6d0bd515e96a7e612f4cadb377539fdfa6144fdf0e0368c7332af6b43934d128f7827d5d61029217e84e8eff32176fbec3fbb71e298a5ef5c17de73830b3b6db867142e5bbe4ab1ea7c623d4ea62a81a2425d1807144ea21bde9840abcd0c972074b95aa2c04df1a202a3e315d844251d28884b9e6271c1ceb41644ab9c17a55c5e08bf53c508a5bbe1b57942d85eba9fdcb174c8e6d8fdaf45d224334dbe3239415e825ac23ef979fcb104524de3a3f6db526b55e6262269054266f0840043cda4cd31592bf5ffa465710382a8b435d53efa5acfc3844949696f854b52b8104f491d98cb043ae15b49b5574a919972a441e956f052fa5ddc4bf1ae7642d8cf5bdb2b56702fcb43ee5866c10699389407930204a25764ebfed1fd97278bb473f813a740db5f6ca85fcff3211de11142c8ea440f0c5951a00ff7d1e96af53d800caaf5db49ab6ab177293095386d388d6696a54f25cee3d7c4a7573bafa3b749e0e39396a010e1b8a3c75010ef8c5bbe15c2ea0a52361162f568e2a0c2c7f55267ac9f74b64064d6d7aca2539208b790998a86e3d189815ab05b4377e7ad1b1944cb1a0a84521f9c05f6845a1b67d015c8d106bd90a064865c61e8e2734f617e8d2be1ceda987abc52da4d64f8bb9b88a5f5a41188277bf23594e502e89e620323bf248195c8790a43963378b7ba380a333a0165b9b74e2012b637c022cb5995a756d7cfeeb9518874e42c87aae1da7a2389a08c9958b2dd20919919fcd83ae503e7f6e960bded3f031f4c527f4dc62f25a7abdcb2026be60483d879ddb93019bc0a69f1c5befefa437ed1d2ec28f610034bdcd955fd71b2557658b9bca0315396bc49638482b3518b34567c4001dfcbbe7e9d0b01a8b98f8bfb7123b661cfce6ce066376a9e9ba0d2847d42a1f45a24c59533b5dfe984814117fba9bf397f53cb346a6c6fc60c89dd249ea473340492aa018d79b15decfcd91d3da0414f3f3fe67fcb2bf2a0d2023d159480f74322464dd405d1d4d7368803cf3f842bf55d9fa9cdb1b89fae8a718181a1eefa3d9d16cdbd8d03eac5e506a35aa425bedbd61c0104b36fbb4ae8dbf33a5187be1458ecc3b4ad25062295b9b9f7c85a2caca6238bd929b3784fcb51c52c8f4cc50436ee31ad6109490489bfe150e8b0b93d3f6accb3d22d61c7914ceb458314f92d9b55cfa27e96b520aeefdb283b405dd182b598eba28d48b7f2c20520dc2cb83e46662a382a6f9d9431d0c8e7539eaa50970bd6facc50e044fc2638059931a91d2bd50ff1dba3d38b3769f4c2a584c0d65339a30be9d16988c285e6d6fd84e0e5fc4672c021d97ceb48ec19117985ef556516dceec3d29d65c0add1bc22f10a006fa520a85fc623b1696afc30f45e757f4a6dc692513cae121d1341f759543efa904b212af31231142f7e84abae372b3436f8e33eba351ef4f8ad04dd28dbad29cfe975acf856b016fb7df66614c7f4ae24e2431daa374ea0f403bc7e9b43daeb3bac86a4c79c1f64a10bdf2b97d4df3ac963cf9283411fc27d03fd471614b4477de43284b9c8237fdc5c0030547411f44adf716698e6ea99176b76da2e06a05996a661952fc849e96c751307e272f4d9605e100234457a2f077a4f6699e6a3bf5e35f85d6ef245b675a533f47d393fd7bba352493ff16e4359cbcfd958e2c6eed0ea4dd5b2d1632f6d3e4f9c6ec275568bb042a84e8e59181cc3d4ed2088ca604ff581e320e5146d87045769c93917765cd607c4fb15d4d253f09deb1bf6269cac1ce429d750ac56866ef1feb7f1d5135599745a60c9149d4f5961b21d91c7b532cb2e58b55aaf717e690f6aed9b89450dd2e5424f8611ba97fdcfbda2c34ddfcb2b3c2b55dc74698252057f3ee59945640a3a1aa2f3db61f27e0a952bd1bc74023c396e6aaa4bbe360f4d315c5e8d7c3e082acb5f39f145324ea39e391eb22046762950b3d4b772a0118b7491fb896180a7dc477e31bc226216c8d3556e7828872721eed80ee68cbf6704130b14b834e0515f4ae9ccfe2f402060f96fc24524012bbe33b8fd8bc6f5f20f2b96b39e2f54f8043121e649ecae21186566966eccf1cbb6e5499dfcb0114ba7f54c45ad3f88049ce675daeb8e378eb84e1045fcf3cdca954d09fc58038c70afada9fd9e53471535e0695ead2fcb0ca0435562ae3bdfb4a09d09c8fbe35e0457ded87b36db7cf3932af0ad53ce11caab8b923f2b78b76eba6c2422fe682eecd8c7f61ff8ebdf67bfa38791d90f96f05e5291f25901822ddd2fab1932d053aa378c365c6d3bd06735d31bb17accc6d414826e1bed1aa9cc071d6ec499123b70786d72cd79c7eaa4049a5c0d1d748c2cd5de73fe1184cf927988d60bfbe1f033edd8ce4290c46e85e496ca435b941a555dc7b2a44474c0ab38a1cd0dfa97c22c240ac7b2c24e59a157c66b9131b92b3359172f22c4acb03a50c1e9a9a21387634ba81da2f7ef76fcd89c4180644d206a6cf41a157bad685925f476896a27f010a6438bebe86469d9e7bf6886db0e5e25450f78a9a08c72fe4da80772b3d0c4490059b48c8ad0280749d03e6ae50c45586b3d62661142e19430621da295028ed8d3761881848835897f1d9024de375d6a0285eb785e83e1039ebb48a128dd41e7427b7a50826e80ef7dfc9af8d0740487843d5edd578a239695dd06b67ef428e9e8361155fcc0340d4b380927d2bb574bc2081fe7517bcc5ca2397af4c6d6ad2f615aa87296029f98d024ec619b22539c5fb9e8cbb27d600616243a2e9eb7f4db0c5acde9ca7441576b8e86df9aa4a075b09f4170261790441076e7552b9f60c092d64251036f6c8bdb36d5f433966714d082869fbd9c32d914e3ad0c163621d5f60334f26eb941b3a2f99ed58097fd5a41004a065fd5051fcbb6833cc053a0f217153edb20605639fe5330324199f28616bf770181d0b9a44df70d651f0f0a43a6821782566aec564718d8692d893679f4f845718469b6eb9985b8f56e20b89e3676030698bb9cfd5fc2077b10d45495975bf2abc9bb3bac9a639360a1f3dc09d9aa48c396291e0def47feedc7fda1a0b1e138665acb4cce0d43448944435777ea6b10bddb324989a946792fa2130b90e14bfd6c66c4d75acf79b8a92b4bad786cde05eeda90bd5f36e910c42a0f5c29f5f771e1d0e535a4018c5826d47116c905f67394925055ea03ded3c93980b9d2ed9bd9062308fd6770c78d7112fc9262f74d8552e23792362b74ed1c20d8492e993123f04ba78f70d8a404bf300b75708754f3458fbcfff26b44fd69c3f72346616a4fc25e29a7989bb14a5ca449583243d3c3114c35172e02559698be699b1afc5c14a5d75aa97188e427be690e673d52fa9eb8d888711ce1b74421d21093870dc02a5c7e354556bea4819044e38d52badd8827af38675d7372381a3dcba8e7a7ea8bbe98a9a58744de0333d33ec8e7dc054a88e686beac4afc4a5cd6a0ed5aaf335a6607bb84e6ae229aa85ab42fac4af2d044bab4b72406b5c44d582214e86679ddc88df8d7d5de9c7544d982e30c20db4c1a92f67b4bd8b0d257eb116e3c4af82f40286f2d646cc0f9810fb336e2bdbbad10d909d0f72071e1301b67562b2cf9d4397d55a269ac389e11565d9cbacd7e93d9530298e315493cb2f80c3a4af2b1799070b3b685bea007907946475b2938d670d553bdca6c8eaecf13b09c9e87ec286de404b3b965872f973abf557c58979a55ab6e811006ee40c0faa68b783d713a832d59ece4b26cec05c9f7473b3ba27fdcf4fa55b1639e512336304888afff550ca78663e529379be0867c36cbcf5b7ae6de94ff7f3f704cedd7720608e056030f79bba613f24f0e4385d99c5e639dab9e55b3013e44acafa84be852078e12aa8a81b53341fcba6fa3a100b17025564697113abddd992020b623a6bc1525923bd3531a6f7ad573730e1d8086c475b8b59cae73a05011615077d11071fb4c18b7d2cf6041109f62664c48eb4329963ed7a1f79345bae7418095c5fa3307c29a686e1d1ccb61168c686aa5a25277493ced1217d1ccc551ff9bdd3359112a85b542606969786aea2dbf95bbc5bbb45dba127239d581d24c2ce421ca5e402fe51e2deb076e92f6d97d45eb92c9f5129f6e50b1f8cfe3a648266a7e12da6b4c408e20fc0332078bd6a0c26c250433b78a717ed73777b669e449455d60dbdf15b144af2f483c815361cb567575e19789f706cf565c96165aaa3adb77897bbae8c7594965762f271809ee949edfaf2ce4ecef8284282ac189508d55aae041466aafbacd256356352392ec08399883aad887091c334b88059a3e0ed896e4d740d41bcca773fb368a06d11a9bb3b48e5885d2b15a508f31991b64c70401d4d6fdc4162b174c7f93595eed548dc17755c93f2364625930ad7254ce3bc9fd7e2bea69cd4ab89a1af70164e0ddd3ead2bc951efbc3b694ba0c0ae9ee92174ccb09ee57249d918b9d18d0ea2c7f22a50f16d4e35178cb110b984f068f35697d16e6e488afb6e29b3aafaf79dbacbe7292388889310a7e5ba7361325d704319b86cae8068930d16c19e206533326f50b0888f0b952d632d53c3bb944349866fd992f81c9d7ae0a70a7b0c9dbe1a3d00eebfb6ada20712c7fdcfabf2c4fd68ac49a251fcabe1243a599f906f10dce02e756cdb14bdebfed0e0cdd12470807ae987dcdf8acd80fac5b50ee25777d627c4100ab16cf299ec409a74aec11df73e8130751da69127cc8c2b5a5f2ece218599c1989cbb59f5afa70f86bc1da3ab592a13476950301e8df159b21c2743fc956174a4d7436b73fd9c19087554ebfaea01f083eb15cf120510562b509518af6f56c44cc3f507808cbd3f84e2971ab510b6795ed3ceff8a8b7ffd6173e9996550038502c43486d10dd33f18818e264e3f539ce1a3be19ccbecf8ceb99278fb5f6f73bfdd4d227f10d9f7d9bc747f5fe4432ab48506e28f53707e6d1e5b11555d16a93ba8fc22e6677759722af999ee33af77b20ba6edcc305278f7e25eb46d6cefa15be15e32ba8bdb7ede9948eaf66089528e1d8ec64c9d56ce7a16bc0a64a47b3feffad731ad34e10cb9a1deefbe5340c85943c54ee7a8e5e0e1444cd83305d3ae4da2fe65f1a76d58b1231a5e2c6d63fde417864bbda1168e8d57245f0c8d866537d82326d943184474edc98b974d4c182d3f1cc0b1ad92508365d1e2046d1939b4b81a91e1806c57ecb0aef8d8e4957996c1ff2731c1c03ab89aac76b11a504511bd8fc70dfaf61b0d6e6994892960da9f21d5db7ec21664ca2062d18c29c7765cfe33a99f452a9e04fc06955e1099a71b7a150f3cc49f14f1951441ae80a5865bfdc13b3afdd34fe00d700ce4cdf9e2e9af8d766b0e86cc91dbff73eb62e4a6fe94d94cd171eb95fe0d59689ba9a3e1d7e309f85b3b55eed3e63edf9a556512e8f139b28460dd073447540ef318105abbf5fdad2f1a0a07eaa54dc89b8788ba9278e9dae4cdcc5a92a6cc12886e8a0f5f9efc197fea9629776f0b4ba346e45cd9b2a33e8680aec3f54e9dbc97ae731f2f482f615caa803842b89898f9df8884b904077582a773b677478326f6b0526f2541d3baee79de39a5a35d3e01bf866b4c8261a916ae81d37406946a43494f116bdfb8f791c5805253f9e625a5e58ace0f7ce0886a2fc0016c398a9bf21065dcc203c4a5cfebaa5ab2ce6b9fcb6a2059c6dcdf10089299722bf57fa9f155ae31d2db1a812326e81afc2e496bf140aa611df8c42365b3865b734e2fb09e929304f83049a57aea9e715b42bfada7c0a9e049de8aa01b4f4f724f657e939668c8c68b5b08249629fe16bd1a928b24878c3357c222ecdce78adf16bc392c1e57eb3a952058c038696b75f13340e56fac9ecaa135fcb10c4e08ffaea2927e5ebeb3cdd75f7ecf0aa7cc4e1e4d2e7381c727ba3d4c2fe495cb004cc20ad82ad572bb3e8b858c7c6369a9683207400f05be270047079711e2d5b96023c99fd4dec37c7aab8762c9b989a2c8aaccacb9a9f7b9e9022265c3b785458ce13abe83093f548b8fef02c8019e5ccee8d4fd2189a2c22397462a22413137a32d1baa87e05afb5a94916cb81398ad776e47bd5a8a133e973ae8b356f1687a16c450ebfb88b173b57c49591248d7cc032a4a00007047f9a375acfa527b644a5e0bdf788eef0b8ffda143e2d142f17203ba82da3714d7e779f9cb315aa9926acb750f91dd899b3784c463c9f246e77065a8c5a8ba1b011e8cc9b618714e358348a185f0140dee0e6233a0ed89a0e588270da17dbd6e1d9656e52818291cef9eeef91e0d699296e37603393c92317e490e7baa002295588d91791c2a964992863679627465a99d191f14b0e486d7b368ee0c7f469d91f88d313535645db858bca8c154b9112bf2046ab5c0987ba0b12fb5a443f7a9c69a82c003bfb3eed270702482cc2a8b38957bce5df6e52c10644333a660372fc9fa895c9c5d20541f519c1588510ebea863328ce870abaaa4634c46939c428511c2f42bba1732ba39015487c2eab856b40028f56e13718405b5a725122a68ea6fe649a8d74cb52cbee07d392d2cc68fc7b3f4f008f8461de3726a66ac8726402b7b6aaace0ce2335dbde53a48ed02f5977cdbb5d7348540f0bac5cbdced08fe759dd86ef7bece66d90ba2a8caeb30e9ce037964d1ee1d91e9744d6c6513848d8c5bd6350ffec74cec3f025c135ea443ae34074d7f89ac27daffe2a2c0f1b85c1d6a48b3292839b2ea27e8e6b7e5be9f6c8fb09005ad38ee6f77204f00695c7d2868251ffce4a67308196193d3250493663084fb28cbf90c362e66ad404654e6a6eafbeff9564d4f4400063036878d95495b964f477acec8c1fcdb20a806edfe90742cc7d45e3f1c34b2131cfb78fc105a8e9af166ae4087c34aa95b1c50b3167aedf86423abad989d761496568a431042c513ea4bc649f50127d95eff927d1a673a82636c57bc5abc054d6666315782b128551357c388bb18a415a33c994049df22c0c433153f2549bf332e3dedf33c852206dd04e9588fcc3ef62359206bb2c53ec3390f9735073c80706ad945dac85707a6fdb0d467a6e2a0a06d3fa2f23bd04bab59826135a8cb38c01d0f0e74cde4b4848cde87a5cf39f6f850974dd47baa880587b924a16741d078eb81b124532ba9b066490c043ebc8c6cc28ad3250b94f241bab635cce5b255ad00039a530db0a1a39ce9d38d1f0a63dd7cb673db02d9d70fd0a01b6db51cb6820c9193d008a90fb39b34013036e6832f505ee000a5d8f87a2b00ab05001ed45a344ff57b48708989ce76779b5d252cb31216008bde8476a6c454686639a658fb2600e24bd2db742511dd447f9e73a8d018586cf4b0c0a63342a9d91017e037bd4672a1b013086b58f3c20c1f87c3d2af7c51469dcf2a952012f6074bee7b11eb30a573f808d258f8ce5b50aa16310d09c1ff04ac7439f31e79d2e670dae4a081bfab12784d171fc47331dfc1cc18a4587e37a84d39350422823abaeac5e893f77ec67029d5fc77680db25ea74ee7e3953dff0907cf4a299c941100c509c8fdf39165bb8cf166c435e71ac47a5e36839f89119dc757937121a04b5d85e74c8d632aa8847a664c1409c952990ebbe619e2bd2eb6087e26cfc3d2d17a9a6707650a806287835207d60a0933b8d40a6a08c40d7c5f28c6353df6aeacf84ceb22106a15a33aa7ad24743a7a1491b04d3399b7eb18e563ac9d53e51cbdc213b2a3a8a6c60f3be056f0956d8fe5c4502675cccd19c77d71766d0f2bdacd865e10e344f7062f1de6f1ff7dbe5ab9840ce2166d657e2490897e5826e1b4bfe74fb5564391db4559551e27ddd0e4ec262c71075756b26f54478e7e805eb50f6e31cfb9ac58a90fc59c5a9eade91dd3c262af7a9380bdb10fda0c19f59acf61210d16564facf0e558ce9b4836ea1c4b16a5e5741b79adc8ff9b32af828e9dc112b6784e306fd5f2caf531a097b3bbd673d1f8a1adf2a1f8a7e929daa7e0eac693d84a03e455d9380073b12772993f83c91ba7875c31074c61e775a5a81e941894c5e4c8db3bc3ca1b73fbd1f3c29cb39c0c021376cad90317e117b46377afd3ef50142294d22aef82fbfcc7d324bcc078b6429018b2406b404f93743c9b92e2de80aca8d07bf333eed2e818926ff7388aec5795e9dca20ab458f528a3163a2a9aedec7ce5f5ca25b2fc6c765a9274046781e6e906f8408474389eb1efee7e904a4860bd5d01177315b9ee030045f52f2cbcfc42b5c75c6967cb92af76c1498315f60607ac6823dbc3d5ae3013c0ad37a89aaad1ee34cc6c661ce946fee79659ffb928e2ab112e795f902d7ff969b43c871174372d8e80f8bdb47b28ee737af26ea15f4ef2a95c34893de750fd1fee081a6d2645135f23009b1cb5d6200ddd06c7bbec2d4431ef0810f188c1ea5910347e254e7f9013d104c10883d9aa839512f23fff1d28f226b840d6705c9375e00de2064b05abd55a1841d97471967a68a1715d2e1fbc5271b8391271472e8cfa49e77d406b2c4e73cb38502798314871625c26dbc9d811180c40fa74999215430efda050bbd25ea34a69d490896c42cc85ee711ebe6e4e57610b838d47325bab982115142644f647badd2500a352152d207c78470a33669524fa4badc16e67b09e68bd02fe7a0b390fd72a216da45eaa7483b724043429c495cd3952050ab98badf34033672c8b443a6c2d0720acef7c55c731ce3baa43b981ac6846d2fb55ade2756e4397ecc6abd87edf6c36ca29e3ffcc384fa4e50672e036e590b2272b36935d173f7777b6606e0d51366fe8a6b1c32d716784bddd767504805d781fc0d64f390e052ba89ed10c63cba9c1a650f841599c12b41a3c14c53cb7e9601b7d5e02d3352c703962f943a15f7ffbf07afdf62906edcbba35bb4631b6fe290b92960bd69514c42775273dc546aba2b2ca91afb1c835909c81c566b31ee79c8760bd6698e6a7a213c0120a09769e76b3de75c74210d9e8badc8fb652f6e2aee78a6c48093539e043ff8b53f98c34508c67cb7f7176a3ebe4ae1f0aa471e3f46c2b2441e385e073449fcea799b1f8e4ab3ef0bfb5e2c53ec4536837fc0dc0cabf0eac90700eead31934bf67e89d380514f5290b8aed4a1eecad153930d177496e7bcd2fc69b4116829a356aa617c881dfe946cd11f3e0639ee2e39363f41ecd23348fd08288d19c7f5108c6f8f8fcd754280dcba599d3807f548efc39f4765e5d29e07589f0f3f49616e97c9a5e97feeed60ea527e0802e0f16c7f677c38dabb372d8ebe2e8c944670e30db3d7bbfbb3d4e5a6e0cf9c258458fba03f8f86bbd1bc1cadf7a55737372ed19af2e9a8b3655343cc1946fc3df7d2bd4a5b6485f37b8fab0b23ea4b537c9d0b59fdc222ad415fa3d9a140da6f1d794a900a460d64f28d1bad4e2fbc962c9d263d021c6793621334b66b94c48c4e0331e1c797c8f9cef194fadb1c9c7da9a98bdbb700a9e2a738552e52d549de1349e2242b552558145768384a73bae358f52d3940e117f020269fb7930fa2a13584140c9cadbc3c1302686c631328cf77d2b8ea3a477b25d20dd3f73b53175bfa0406fb69be01ea0ffb4829ea0a626d7133f1b0ba9ad01780f9df17882e24e1e9dcc7a9b284e248b788e966560922076719a8184d20624ace3027c666687973dc1ebe2e803001081c0c0b1fcc87251424fb663c620f6e6936d4f3854ab99bebb1c36d2eefb88403ee384a6ebac4cd43d1b01ce99a151098b8e3e120fdc3eee08e4da682d8464c6d6c0bd0157b8829c66067302cdc82376f653660fb4a0b0f4e1c672cccfb3f82800505909b6235ca4bf8a1c3cbc773cf8ad43688b14e5fd2d24828ef874782a5cda60f60fb93492fa168ddf2956119260da418f82b0574a316c226e19639b64141b79f54496ed33a3df3ee0dbe4464eb3d6c0780d429d21269b765be08ffa7f41fc212c5051289b2ea04ba59358000c5570df2f9815a88c355f0ee1b73593f904df2cc0fff9cd4903a10df916db3bf96b910b7a97b6c600b253c4ba1fe4985101c242da49aff1b6bbd55e7a742604d3d6c085ad6e43bbec4452f3067b6d0837e10eb796dd343de26bdbd74884297e152d5f0c9ad9165b130ccb4454a710bbc1aff7908fb8882b662413c9aca88f20024259ee981940dbf5dc2d037773aec4899ece809aef1cc2f2acd7746664fade34d56208b072f98eb8b8ccb47f03af1116177adb887d905da793cde864a7a0290e28958c525aa1d0b1436a562e89f3165eb1ef54a8192f928a2d5841fa858554b5de69b1f09ea42605ae88e515a8512de75c70a61a8a9549c4552cbf282e159aedbaf0b5f3085e35fbead17715528baedae5ebefc73719cba602144ede1e07d8fe46f7003464273a5dd07fc7453aa51fa2e7d61ca81be0b417de7b5e7d3d2e4019352e87ad4a47da843ed5f50c58e4ccdfefb1970607a24c87ddbaf3c5a8e6e76c250eacbb5a35878fdbca07dfda60cb36039fe995234d8315c44faba89d271e984799b5e7c5881b27918249f5af7476a846135799871ac7135945062d533384c1f2534d584e8c664a9d1ffe56436d74a64d1a3b8f31f86cf0febb6f3f66930b4fce972946c748fb0a6da0e338a5aa1cf68ed7df91f1b64d84e9e5ffaf4c32fc3e5433146197ef63a28da1cc1869c72919542dfebcc0de5e988e5c98eb5af6ff8baf8bb3a445cb0da2a0adbe48f094b51f6167269d42abf31de58307e43d182f5bd02e1e6c892126717847305c33ef018859f80bd03d1c4011a6501e4af6259eb13f1b0bc2447677915d9d57bf7acf301902e8df32093fe21a1cb2af436d198412e9ba9badd96881af54da13d2208d217a9d16e07039da78d98fb8ae29bb0e56bc011386c277ea07a3da33070611148055069115c23d6592c1ccf23c7666fed9ceca02672da5832b8b297dd84b1148435dc24bc6e7c5bd622f917d5e77bd558dc1284807c3167fec716efe78ab9e8b712a7439376b6abccd3db2dd7e954fbd25bb947f4fa32bf9cb1092e9b0ffe912bfc9aeed2557809b603a37f6bb702b23f9c1c544517fa8440043ce5743dbf18f041150993f1a63f78c42bf2148327a4e287ed9ca722ed1c6615ba4113626e5673acb771e8319112bd21c80cd7a30d764ba4e0b48c2a3a8cb0c6bbc87785b88afcb4133724b6b3c96405995e9b6e7f37f41148ea4cd165e13d0a684bdefa0520305cfc469469429463345d51ceb568b870ba8e047c9f7d5d3b23aaee4b7080c9eccbe24f7be82f2da5a3d465deb4e7b61c6300dcb3ef3286cf9929952bf2a833bd55be88bc8c17352964687eef5fb4bca8f68eecedc0e11b0cc40f2f946f92a4b5a0a4c45eda209c7f41837d77b8bb9e703e09f0d68fed58baf7e7672d8625952977cbd01c9753bc01654b9a18f4f5654869e9d046c4d80808e6336088ae15998b9dbbe4d90104a13701d4a0bb4c5e276daef61f8f174afb1b1f254fa56692cddc92bf0e855833d09c36b6d68d319c6ec923668d1c44ba045949f80a24262fcf73408289b6911397322a73be24bd6c4217cf87405a5414a04bf08dc46babecfc2d7487e01bef6285746d2c09a0853585ece0b95017806ff80188b1ec88e579254f7826fc351e6618b0477a798650484aa32cec598511034b531beacd10a684ff99ea4717126f08fd88f26c5d7e79b6e0856286ed83d2cacc221f3a2b351872426714d9262230d0a1f92a7c82775af5c404e2d596fa5d6aff07f481ef4808928609cf21d93d0d890fb66864a8359631596ada4c534b53e13912ab0dc6471979175ca961e3a88fe5bc7144686594d67bf128f5b06ecc4479ce69a499054eb367231022d1b314bdcb65ab0db5ec3f3739f5c6d340c59022f5f5124809d4caaa78982319ccf275c01ef55425ce5bd6497b3d43e571b9ad4452ca02f75b3b35ec51467ef3fef99a5e428fe0928fca7f6b458fcc99800d2f0b6d4a42fb76ad4171eba800b8fca7259110c65d56b1ecfe9aa8e7fe4fcb3512b3fd879e5143fc5c0242f4ef447e6a5bf7f7d870b6f66b59491fea5b5f3f1a5e5f8dd48242102ab058c13462089140c3f9bd2277b7e4751893a054f4535a0a9b2fc0afb3520ec9c1a353613c523072c9ac58afddf4f8da5a941ab1b54ecb60eee6127acd1d695a193684e0f3e87fe28251697d3866a4f8eea634dbe2327ab33987a11055701a7f2c8384f86e5443c4d24f71df993c9abbaf0e88978efab4c7188b709d71c39630a16c6d8e85ecf7f02146138e9097538fd1103d97cbb03260b30f36fd6250e6e3e102eec27e6adffa0ec2d078a88949d5e74d74bb42bbc6fe7662eafe688a891383fcf14613c57ef83cbbb5c0222712cb6fa1ae89746a298828a590612cdddd2abdaa86297b6ed183e97fe8ebadc09e1e05ea3f25aaa196f025e6034b80166581b501d5469be5296a93a91f6ba2b9b956ae9e3beea38f4a553b080a7c2d51a452825b158644280978d5939f413ec7a036e02e81836f4010567d3714dd0b1c19e6a2593c1989ac365b6d7193704bb129a125a5b7c5189675ff697550464358873565935a72d4df405f51f04821f8bde8b0ca7af319231698b4a2b35cded07ffec428e636e8d1f1130ec5ab1668a676a45d6e3df28a425d484a9431c6cd4e5800f0430d017fa07db46f86c1e6dfc8163325668c2ccd7fe498d6cfa1ce825d079a2e9759c7b514ce296d1c99b5f43ce2bce1359e7b84b3ccd7f96d4b8cc77fe34e555a84b5e96ab147e24dbbe446e42e6ed0b72fc308141259ccf7b483823fa628fa4cecc91df0c076b009d60c1adba3dda3a5aa4e58ca0128438f233f84fea1c704b7df7927b69ad96698daffc3dcadab0c131f346e1ec289b0326c727849438d908a3a36dc79fa258412c693e5e826342f2e402c5853f8e5ede036428a6b0c2af1d4a5d0cfc1561237b42041c60da30541b4e8ed19ade61734fbfdeb7285fa6a4db83b8e9bba90ac8425cbdccbf75c67dacfb9baf348253418e25a581b5733490157f1735f57e7230a31d7a233ec613ac677a63f3eb83713253afe014d3202e9adc78e51fbcb2b9c1bad28c74f057d584166d60b40776117d25cf045720be5b4fbef36bef0130c133418d4fc36b3c3309e78a640d4b03c09d12f0b1ebbe9bd5d2f2476bd4b84414c8a35e1cd4e6ba2ad44ea0fb7f84305c2a5d8ffaa5a9d3407e3ff0a6af4a0f981e6290ae61b4318b12117466c06fe0c0631e88840e066d7ebdd5a8cd20870cc048905760f8ff6db62c4e71bf63c44db27f86fc1c71039e21967411b6bbcce6d6fa8c0ca0d0a8d1114b7c9282ad16d2223e46530cba8b5640e8ed6c52bfd58cc96429121f70e4e6c707369bf29f70429bac83c4f112659251fe5d1e7f633d72b251c9481849d545004b7097757dc56a5daca6e8fe2a13cb458229777644dcb2df7b339e725d772410f860a3504ab3bc2b569d03eea8fe58fae43cb83e6eb73783b63ceaaaf4c223bedcc6e04ae08e965650f4214b1e06a50a2e032ede7ca75a5bb8ba32260f1908920682c03093de13f6ec6ed38d66a1150025ec96fd32ac515b2b2e26cad26ed3bea55adb9f1fbd69d6cabcda2d312eadc8e110e87c80c1e1853162dd30d60a5237e9d915075a068e0425586ac129c82aec96954ca130e2e84d63ee7f8de2a64b9e885268a6d765d5566f04416472f50e82ec82cfc006aa52489e14b62876efea5bc927801c2efb5750363b67d730031aa4e89c0c4492a2f6f335ec0111425f9f312fe3c630d2f41cbbb327e63f1cbfad6543f61b5c890a4bd35fa50032ca42e21ccf6977798cffeec341cbc63f52cb5f8962eb63f7c89a1aed98c222c1a9736c7adab77b7fadcf90399b7dd8d83edb9212e8a2ceaf33a40dbbb49cec7ad5c7f7b790159258f94b4c863bcbbe7609458f8c649db81f859b5f55d2bebc047abd865078b69c16f6726e317ee80dcbc9f30f213f30f432ba303e8df06a92b8b7eab36295090ac37b109974995e753173fef529ef9c5dc908a36b19986fef449bb10c422112a72776660ae528259dc1d40182556899545aae1e02dd86fc7856a0ecd41864285053824033e687ea30adfcc5c28797fca693a81a20387abc77d9f6b55704942250a3dad9a9f8a637e9ae92e8d01271a4b21570032e66394e8af17290cd7ff18b4db1d643122a65ab996733af364728713d450d4628f7acb4c346429f0a7237b9001a12c216dc5b7aaaa1acbbf3447fc9efd111f98b70e8074c8ba805ff99efc1fc86c2f01f96bde102af6411a1178237f8e8bc63e4f630ef5d2ecae739fa0a214330c991bcf155ae5364015ea1e34823001b16a7d0543fccbd004bd9b0357637349d444ca7420100d6267b7d53bb647b0960a7f89f28ef20cdb56d2f1e7748d2a7c879f6ec5f8bea4754458c7369e6ab22c522154040161a4b7fca2dc3cae7d7c72fd51008278507668bf4c64925aca64143c4d75b25ae9e491e4c9a99128db152ff69915ea4212e4b8563d45fe7bacdb4c4462427fcd8a3457ffb53a43346ea8749014e6f451153d35d2f748184904dd6508d29875c35383cde691c6a035f66b6d52535ed3a153997f69dc691cf38e11a3d4758c08bd10fce9889603d2d6a46ebf0c4be08f0eae22198b00b952661e62a77ddb36eafeb699c24a253c9355957acd2a02b502b79be83aafa99731b606bed4f936fa6170a9562858ecd13482c378cffc201c1f9ddcce7c4b8dfcfb048306aee53f060eeabf8fe7a3dabc499284815599aeb19dd4808a4ead94c038e07879900b7d8dfa119266c2d1c1b42446543d6f85bfa4d68bf2f7c0ef74c0b424c0db746bfe8b8ba637a2ef2072a43c0aafca422697f4393f266b0d05bb0181c9fe20700a23d97abb011b66abd8043f97378f4fee3465a4e0e0510333b828141e0004ed4a2427b42116c8f473fa386eb735792f55710242c1ab0cfe16a38b73fdd223c04df64b74c772c436d29cffce29830a9d8ccbed158f0609a7f447a8d447c68c942c70672518676c2b3681a10cf2efd5719879c80fe8eef8edfbb6f85d9e028bce62df4244c3c12ff522089082b74eee8e415bca5a6f6f77c972492348a85d750ef2f76c755d94061849cf7028dd003a18d4da087b09182d59f943f9ac9fcd92afa96e1827e83af870b2d08036e461db597fd9b741159a8143deff5e32ced06fee09ada3239a6b3aed9763c770a0f13d2eb4e305de5fbaee2c5b51b702ed31a6a60296b7ac7ee6615416f9fcc092cc4f53907ebfa12c8e2a6c221aa79ff3f3f2e89ee48300d87a0ff80a2211e2d960f29a52a4777f231b564f2f7bd6dc430b03f3c9b9540df55dbc02bc7537c464b3a8b9552ff3ef54b151a41f8bed5b8db3290e85398ba75604a9ebf83bfe21c410582e75d4aee3ea908dff8e4fa1e2dc33054b036807536860dc792b4913205104548d526f6bebff4365f8e39b6c0d07e82e729db6d673607351b27e0f71dfa188d8950b7d3c86706b05301ede09381f3fea7d50344f0c5cb2af9e0a9520732c43f5f8460f74ff0eb3145d76cc9b867fd014bfd8d10a8d8a2a33e6a1f11614544a548cca5a43300429673bff0dd06f05eae02da22ddbc7ca6badb83a9d1ab1e326f9dc97065598949ea033b6d5f36a7da52ad0341945b9e9b52a54de0eb7d7dae1b1af843d9abdd9d85ab1e1c2f82c52b5c35842e53eaf3f42eebe00706617a093e3c210c59d5f827f4914323e277859e2638ba8e168f907375408069f409be8d40348b80afb4617778248dc4d875d1d8b65f06c6006aabbc1aca4c6c0a9cab5fea933dc64a59c5e57cc99e398e04e22a0d43dcdce519f66b283b4677c3072a583b23b30c3574232d7782707cd27ab71db2864cd688590ac9735bf32331ff7570550b99b270456e8f515fc8480374ee0915f3d8a1cd7a63577c50445a1477acb207b85ef6eef022eadf4ee820d06a2f710b8e6682b0ccf97fbf3af27399f0b98ea0902ab2c3fd7db8d9badeb377566cc6f8d5f6ce6f2348642971c809fe5f1ff8996a845b7fd4465165b40a725c737a323e43e72e94bccf62f52eefac117795a88686cf2978ea31a3040bb0981dae7b2486b91623facd29ccf3915413f88c47c7faca3d7d3cfd228fd07787e231ef64e1a911ae6e0f7860fbe96e946c14430665878f5a27eb15b9d17a203ce578a1ecbfb680001f1b87dce672cc76f90363440b08c791def337cda708720e3d14b815807d055a79e462a601ddc6fa4dd33adebe879ae8c031e289d869ff1aa75fd99a9f0aff64afc1fcc81dbf7b2ca2af6877b521174f4716bbb7940c61b92d76099b09796181163d0d62996f2308b9addab47b4b759829a0981ec647a2529b67bb4ef64ec92d751e93fb18af6cb6e0b58fd2b2c58351f12ddb709bdb47de6f7351108520cb322f1dd68a85c545a911c306bc447354b1255fa995de145de87d065997b44a8e106a721ffd23c4c6c6dce39fb2b9961323cd09aa6c42020153c4873c3b069f8d4ad60ae068342d6c672787120f03761021da3f268c6baebde329487b8afe610953473a4861aa6bbe71b6e144587f082aabd7f294b1198baaacfb6cacb8f53989afd8162c2f9a3d8a4278b07d970f7550200dc7ab82a747ff3403df1b39240d40917c467c49436886583d66b88dcd44e020ce71ac4d0a06de0f03f4a6c82db8e2ffe9361fd0c3d462aa7b1272c3dadce7bf9d0335362aa0dee87e54fb198afd1ab901babb9cf6275391ccab0268822c1adc39e40498219ab081df33b9d31600709ab2bbe017a78e16b2da08bb8e7a77cd607bd6a87b66817b1b0ebdfa64b941595d5ff660ca6b99c4fd229c74555eaf559cf33940e1240b6ea640f8280ea4816c8316adcef1b5d79be5e6ff1c47eb7994805da77c664823ea0bc5a6f1a18b4f297d932621c94f9f8785985755368221a250bf7aef7a5e9f397e174a72e61804ef98ca2349d4a8cdbc74c5fab70a253a9a90f381b5add1f9ab97155da9b1995c91e0ebe57bfd751b519eefea16169304b04ed7ea79fb6131485c2879b4fdb35f6d8f1ccde20850f1f9d39f3c293130ce5d0087c754e51530010943c0784d8dbca759fa3d9145fd7092f79b5bc772f8bfe3d83e0a8673732673c9f4d1aa07042d3021b608a1442bf8fe47472e4b156d689909dd31ab1c14930064fa40e07dc13557d38326795cd3323f795a8615969566900c9ea485df6001d4116d7cbf898a2595d445d5ce6fae6e7df0fcdfe074493cd53d98e81c2fecc70f85fdb3ef6ca6a20b45f4f2151260a8f1ebc8aa583fd8046dde38f72f6b3ad7fb0f063544314e19ba2df330e42b210da41e901cae40dba034cbb624fa4bf657f6501322adca8c09289c1f9bd46ae0813dceea670b16d5aa4d6d1143b88051d6e064c405aabf46646a2f5cd5edc7ad62110add4801b53a08feb74b91dd5483a582b4ebde18fb752a9f7cbbb5669e93d4a46c856f1ba96ab59cf3c961a990e37428276614a9bdeeae4545cf424d4c224422b8de62ea00ba53021931744a0f43b47e8ce8d8c1dca70eb756d3811aa215128329c3def7b64d7cd8d1856feb743e688bbd18bf834ea7ac993aed98950f4d46321485c0fe09a99d3d53947fac3191e575e210812c87b0e7c464d50325d31c74efbdabf4aece64aaf9240b1b08c716270941cf601330c75b0f2cf8eda09014215bcbf1d0d76ca414b17b882f332a91fca60e11ea6ffef5d2a928ccd4c62d1f13404a448f522363e28468d6fb2b3644dcc299fd1ad2549483f9728ab5d68e29c7d61b1c3a84abcd4b93de65e03876729982246aca4f777a379dbe5ccb5ca9893c4cfbf1878709442307c240976795cc5b64811f33f1deccf9d8f58ebf65668b96fe20756645ca0fd9f93c65450d77bb7ddebc179e00bb52ac122a7384e972b93c62964b464fa82a8f567f566224847090dd452a3c7fe04273cfa21e6133f21619ec2cb216d8baac30adb41a58912329e1d50a311fae0e6e8f4ac6134ef18a926381b066f18a87ee45d6c5db9db2be1025dc85a5d2ae9020c64804af802643ac1715a739ffeb71b3f6c160df2c51847fc3f4c6aca729869c0485332e8132368defa86bb907724d92a31a7151b1b00874c1419df87aac3e74cd46693cb6e27562c26d2c0698e83efba5902b179f9e3fd549df6e564683626e7def6f80e4fa5a4bc167e8cbaed848163b38bc2f4d6e0749ae83adddd3669c65183ad65397fef6f11529b440dee8e879ce117c7bcba9687816298d4c0b60580e2d0c400eb2cb2d39ec61726d3f2f8246f0dcc7615ab85d58fb9759a9c38138f80e13c5b428364b8daa134cf90629bf9826aba584d4d0691127294cda84f75c19df436ea36f6b808938f6e6df826794e8493ff89c8562b4f025a754cf3e1ef3607248f707999a19eea37bb9642de3dbbd0492772c670e6eec8c8d6011c11d3eb59d5d693e09db4e9b16d51078e6b8a3d4d5e89e636efaa295bbe5649cecaeb47e7638cf06e13aea2b08d0d6ab4c94ce7b83ab7dd72f85295978f524233abf02bd662fc593d05d8d9c743d5a65721b7a6d9d73510bb8aeed4370303c21e3f2bccff4a3cbd34802af80df0b31ac870f491d68b318988bdf2fc30afd4e4afad93ce1e633fdd859239e2bf430807910dea5a5b8833b5ed31f72fd1b72f5332771b90f46ddca021c56b70e538266892b5dcae2c49488761fea29510f516cd95da64cec0721810222368abdd349674271f37f8d3d54f4364d94a885b3b00fa0999a7008b121b9891e420cd511557608f666aa251a25b0cffdf1fd7ac8adc3db2e7d303f70815f17e9694fb59015b4c9326e30d84e04939e890921270e2bb00925ad837f54c3809a59453c99480c59d784f80ef79d5bfbe417b6f2d50f6adec2655d3abdf4f6d84afd3085c76eaf31176573d2b28a90a211bb37a0667913e35c2db370aff278a7c0cd6c978739655fa400a20d6ed8b9375e66536795d70878656ee019e21e2f63097e1f7ca5bb7ffbcc139ba5eb42e395a06d429c9535614db343eec5f0a30c28e0e52081a0aaf7fedc3ef317d82bce72194403e7310b870c889cd19fa4b4ef90708aa239dd53640ea9c2bca21debc7c68ed2e83d00008e346309604618165cfcea88eea8d7de33f98fad1905ba87892b3ff35fd7ab155daf344ff5b4e98400894308d4f10edfc6db9af6fea3ab5db024de93f072809e76ea1394e019757bb7214f515c57a9ba31d330f9a4e4db6d70c1bead729b1218daf5c3dc05e9b03dc526a7ba038be64478f29a5a95dcc3458d0ac690ec7853716454cf688d23860b65b1b0660643f555dcbd88abc7da74548f3902baf8ecb686622db8d9541c90bbce1f21dbc00cfe81b0a22792dc1af87cdc4374d9911a1f18c4e2dd3a0e102b5f448326cb732ee7e17725d148b1dbd8fc8c765d6aa4adea5d9ff7404b26e2a2d1a405c9a054ddac5750bcc8714d22194d3096b045a9528f426dd46996d3befcf60aad5eb4aff463572c84d0e307a816bb25495fbdcf3784add4facffffe43fa0c06f752966535cec855abfe776fb000a8a4267663c3cb2fdb23deec1eadb88104c33ddcc33885a7cad6bbd5c09713194996d96a4dcfbb248f65ad2df81aa1dd19523f1021f80ea66dbdd8a6b042a500ea4626dc20935df3a053b2ff41f6895ee969ea5974e8450427220fe91fdf34ef6b91d2d28542db722ec9f8bb3edb1ec48894c1015157e152bfb787e75d76500f4dd2b6307779e57a1aaf73adfc53fb0b9f526d4c6b319bd3b8edc81cb2d6053d7d313e3337cd21394d9c99c4cac5223c45c66904b68700f2fc1d5157f3428ee659b1c74ecfff3087b3c5edb29e6ef8f6f0aaeb774c16895d1bff9eb0e3cd0739cc415ce2926325283108234c2f072a4169d334c843ecc78af4c73c5278e6f3d1c0233e1cfd4749669fd6170d2f62dd9eb3823049023918ac4d3214470ae32ffb3972bba2ee479ae3924b1e062db47a77e4fc7f34d6a7a244689f269ad7941c0141a7126bc6421290f695d77675f5c915ae9cd48741126645421d75524fa2fea7f624a86efec5e86393506f0269599c64b9b874c4d86938719aebcf53c00408e529a0ce237e8563c4a17ea3cb012923c6bb5882c1f87ae48f592d1d27c93aae4d31b07fcef6a0bc895e53a4dfd52b7764f4f1ab3b04985ca28f575c37a68bab10e7941aead4dd59232dc6be49a71ca4c547fb1a15a6ddeeb8f4fcc1f36b430eb771eb35ad19c737356d18aa2308d558c541923cc5fb7a539a234aea59361b4effeb3fae2414d5f543d7be48d60393c46547b4e179c9dd7c02fd17b76215eeff919326fd00b95458de487eb0b89bf36c0dd74c018d9ab5e3e208cbcbd83c7be6f184abbfb55866dea1b57ab6dcf828007ae5c58167013849602c36a4573e494f346d606fd42d43dd7899f707ed34778e47f75bf24dfd655caaf78421d9b04a8809e38556f2f5679a284a975567842846f15e60b578ae2ab68971c335f3b336b114c9a3eafc0d129495dbb451cbdaea9ffa43e81163b0a96d6e8538f842bf46a69a2f79e2e9d2a1a3229adbad7aff402336b2da1ea93f10a55cb2ea296864830fd4275199f57ac699c0b93c8f9feb087cf7a7941d3e3f7d3f5f8858c542b8c27dc3570c5c8e4f2d32e8255668a695bedd100fff94b298bfdb8398e9d4a376499c14cc9e26cf20d9e06e9839e03fa061c5f3d989d261447a96141a931fa06a0d5b93292f3c354e121d6647262205b9f4a91df10f812dea3cd2c749723a59e8cb5e1d67065141975d7be3f3f7ede621b3d13723142494c5ff1ff8b720b5a640c60d4e2a4ed2bc8516fffb7065b91c20225a896e206326b18aa3df8e27a63454276672a200d76d2bc38e19a3e38af1866987dc1de94e50ad9e45ee4eb754bb7b7e1fc220972e6d29473a0f6a3d01f2b10bd5b4ebd836e64a948de26f2019b0bcb953893ce69537d5474b1cd68ed73ce7112f4e77eb2c5bbef90ea4bece8ec9bcffa17fd72c8b167d04ce86f893b90da3edb23ef5b717018a9d555eb9a64691f333547d34c69f77a5f4f39e9c0686a412caa97bb112fcd63cfdd96de94a7e7dbbd2b9d613cffb350c11bc5c7cf58f9ff2c7466843161ef0ab176ff26ff39efe78bbd18c550a4f9f0863cfc165c9dcc901c12bfc6539d7afc05d747789198f6fe7427736fd315eea915436a4bd6abf11dbb1eeed7559fe866a308e0d8784e2cfd5557cf572089912ff1f7aed81d9ced9c63be81c0dce1449bd3660cd57e81161a88a549a203ac11fd248645c2f580ff8482b1640a1fa01cc8d0ec8badfa3eb637ac33858c68267e5b09156a3239cf3f69d2cda59609cb212d851f51770f4ef8b2390c237d5af311b9dd48aa393d57c365078b7f6c0f599fd4ac355279e77eb9212e38942f940e7ee8b02839effe3958043bd4a50f24cb77b3b120fbe9ecebf42e7521adfbe723d510841c317ff917dbc82d79411529e2bd473a59b74ccbcb97e3effdb60dfd8d3a6cfbc290027fe43788646c0360c2f76cafcaf30c3c0ecbc6dd325bd3f312be388c6755450c88d8baf347323e50a4f119f6cd7370cc8d7506013fb97c79f998906561d7713da4d799b120cbb008febdbfb09538f7d8a4b7a9a1350740f80f9423afcadee38771d26214b5efaaa764626b0bf08378d24d5333f4c837e7ee9d7dc32a6ee2d9ba92b218ed6abebc6114f6cf22a3242ebcb525e24ed68d6e5471ac6d31e5f260358832021d395e6d23079837ba8345d4a2b96ae9b15f4fa450f1db4756ccd215be1ca283ffadf754b9a4bab7c9217212ad10055182087209cab55f2ac22ce72b915be53e8a6e0b0543e878c817281daedd36fd5b9f5f0cc1891e697d6f2bc09d2c66517b5675ce2df9e75be6ed564e01857c7979858733ee6d53f5d179d85d58dde6b887c169eb83b970db7b6301fe5f54d72851f63bc630457d2aad48cc924001fc7220cacda4f69893eb3ced53323ba81ef812587192077da6b1c8cee6626a0bbb5087fc32545aa2889a6872d84e2b45a361783a4b297ca67614189f6e3ff5a3536d62b8463479d83aa40383d69bf9aba4a4883d65839485e126f227fe2e2028630b01abc0a6ea664c30581172fbab60ab2e33729dce1ff544b627b0b2d86dd829590e153cf23526c6994a6d608e1a52ae1c9a6c5be4c6000b89238573c8322ff1667237094a5da4a64ff1b47b2c62a96cf7b0306d598847bc0e154db02394e802b89caae69d0874754d3df288638029844c939cb528c406209a2f2b1fe695e89af663cc10b45c7517554c96fea09a59ad07f8a1a2dc9d78128b7b4f3fd48b614f9aae8123955a57cd993b6299dac171392e2ba1841cad0c7ab2a476a0374ebfcf04397df0c481d9555062a96407b686dd7f4a0b6ff9c3a73f923596ba8d1ee7524b845c37b48ad87a2fcf98ad98f5d1e25d1e9fe2d53829f78b7899328426c235c3e9bae84661d30617bdcfbebd070b86c5a1b15bc71a378c3384b8e628eb358c6354b8fba443ef0aacd2f2e88fc8be062d273db00dc2bd7262415032332e0375970130a0e9e6eaaa7306dd12851b1f13688280fa6d63a663fc206ef124194512a6daf634fafb2fa4f940ddab383549b476be78db2c757e13286922c5680e62ea132b58445ccfdeeb349f7334bd95fd05c5fc7ccec463cfc032cccab65bed5c235625ee0af3fafbd0a39983c7bea3b436ad6de6478120b8eff4fa59e9d170ca5a87480ad2076d6559872432f70a75db45caba1ec4e8787db7cdf6cd6b8fd8650c4e47e62f72529f8d6b0f1c7e2e4d9d53ee07508c0bdd4327f5e9f4e0589ab4ceb60f49c5ea46421f258c1eaa2ee82d689beb9504d632e51f27a0a4f0820aeb7a171eb7ac7bc6877e8d37b5f246b9df30e5189e7ef91485fbb57e2ec51387d7aac81ce9d157e5146de72bc8aa8d2502806c1a9338c5aa9e4660da261fdce661523f26d04ca1f54226bf216b97ce582c99b8f7af4d2ca4071c0b43c72c14afcba66192e9d05b9d879bcbcc07125b4c6daf9489cdcf55cd289e8e4b3c38d18242d3722207792fd0879a94b6c1fd70716fb29c6d4d7c54a8585eb0c7ff71e600274ad939f976e9c2ea547c325e259f5a4d2f03f29a69d442561de058782170cc469f67dd644dccc41bdbe83aad1e4c2fbdb97e1df79817b67ae34a4b69a4db2eed9d96cf0329c615f315e3e7e009cec500debb98f6d5cc4ed433838a5e099b3ac2d875e6890acdda0692bff275c4a701011ef14da7956508e82d68136185df83991bc3b18a38ee920ef743e86d2c8a673b106e2396ca0f91395ad51b4ce1775ad01559f7ae32018255b108ec71c0f9f4e555704ed65cb23b0cb6a01da5b8850736b56fe0cd60d0fae918dca7b3662a18d0f7d69bb96da463a065a101a1327829f91f34236a1bfb372841723e4f0ad1aa837a7298c0ed37c578b5d203f503ab52c96928c4ad20494ffaf3e8c600482ff9c262ca8937ed231a4e2e8f28cb151072fc14d5ca3bdedaaf25cddba7497da984c342b3e78021628b6b823424f59f2b78aa7ef369596381814a07fe702065d6cbff95ea266529715c9a673d23752a2e19576505a60323b8c817fde64d7e2714734f801722b3d06b89ccbf8bdc87b3972482d470833198c454ee9a8b6765e6956c9cfba4dd26565284ccd660bccb57a6e21dcff221d42693bcc7c5194a163e0937807373f4351ed1a7d037680bb8d9b4216fb8508194c760a80712e922ff2f5d7538c15ef3dd697e69b4a67f00e794cdc5102839fe7ef6117fc87e2b65d0051398bbb8de29229793f73689a6c0cf28dd1be48d1ac19295d2af09b7130ece36796082a755afee2a961b2fd7053aa86be0be70e6fbb59b1f16d2d0e69922fefc85c607518cc725a23724bf2b37d64ffcb399a88a1653ae3d86de137f6635f3bb12ac9cac10063d150c8901f7ccb09d425f0aebf151891ace52bb27a8dd4e167c74be8010ddc7e549970d3145e21def911e37cb922e6251f283577b42f2365c60c2e2c5ccd7c284c5837c36df1b5daff66c3caaf52cc9870cdaf831f663c93dcf9ae3a2c9b680794cdd72b340a0faaae19bb664cf785cf0b153d751190744da044c54ce23541b3e64d9417e229777be51cfa2f757610520dcf98f73f3a9638dc9124a279267a7e824dcd5f6fb56f502a38eb44cd924f7309cf21731776631ffca7d58aa76f5f9c1abd7e0afbabd1d3bbd9ffc7b4d73667329854c0693b5d14fd111fe49e3a3987a8eb186a89a77b0f9c0341ff300d02e484881fe22e483b86feb7b4bc6617eee5428f7ba1c9aeefb61228e871529205a0304e5696be77ea3097ccaaced07aa4c10762828cdce31cc2f47b73c66fafefa768529f6e9aea2dd1d6ae5d8dc66583122f61f8622382c48b478f0eb42f124499e576c7566626a5525b1e560c00d1d798fb7dbc2271730701dc90669e7c14ae6537b463753df211436ca1f2be9857427ddf454b0062d2c5e2ba39425306d66aab3678e3296ebdd16849d00b596e55a25edbfe512c8cb1584b641c3e73054076555208bb2c360b45cf551b383195bfb259eb6132bff609d9d2e2a09f468bea3198d653b9e618645a519f22ea9dd1a4fbb09669a762a5597ceec9567f874a6bc8455ffa4d3491b1e0b6bfd05bf7ca48e7686ae4c1d2e6b9f0a7495e63e896966881191b76b1422c6ddb9c3b4f93e6bd3240ec653ae90ca2a36b061a58c6fa1b96d6c196bbfac421269dfe0eec6431704d60a4b4d74fc038098ba9a9855c26fe2f2d9ead3f620ab89869a32cfe59e5ae1c89a708cce3461603e54515229c3971ddf63585c869068f058d2749f130bda60c4ada5731c9633babfc7f5d193da96229a88bf187f84d2cbcdc88bb780e769bee6ab193d62743d7274bff0c41d4f8eb8357f2a6388d90fdaa682df9ee67ae0547e71f95ad2a0f2400b2d51f86b15f9cba3883cd06a6dfdb3339dd51cad3dcd195100f93d544e7ee2416838b10ee1ba37d7e773ef93e34793d3c3aa00d677020f8b08751cf5ab6171e72c4eaa702b9ca44393941de2c6c85010fd226ca8f217c067917eacc07b3e36324707a3742226de6d15302087fb5f7d0d2640f9712e4bdc0caccffd779a760edfbdf42c73812f13027d725b225a77aa6f32b2eacfe8f3998e9f05e5c3e57845abd8865baf098b5473569cefc8ec67957e19343807c5340194f12613ea54fd1ebf38b643bdae6f298e434d75a8b35858b522fed07f0779ee74a02ef64b7cc7992a161c0b01726aeff426ba5b891006231493a14110f122db2b0417db773cf8a8ae62bf03ebc7b83501b8d226ea523867e73581cd2c73c25f65bd7ae9efe002de4d232d1299db71d857bb340f0980989383865805a3b172e63b468ad93093f820433185642a56313006467283f2b31b1b7509e0a3a847caa998b6747b221a4d35adbe585d9c7b691c890af835b5c6fb4c0962de162401355a8261675f113d183788d066fbec5c3cd7c1c4f787cee689310784c56132fdb64bff3d584a7931a7b91aaec648ed35fe693f75221cdb248149bd3ab49683be3ab1886ef2bd1bd090b72c8524fb9757c63c39dd854d93ad1b048fb00d9d0a1b1f98633426d84edc70b7741fec110f265a9993ca391211d76b455db9acdf9bfb5dd5d91173f59dc573e08242dcdf7832921404800caee250ee8dc1478a31f5feff53bce27d87a26a75080cd4971004fdac1ceb9846a66def37455167877e207b99a0fa137f3f79a3c5cb23911cf5983d9ca1b466c4ff33d2d95696552f54da07ffb50cca8e29e9084173d32785f9a554b2e163faf52d25e0cce2c21b21ee5352e63899142dc23efe3fcca9061e4d4062808e7a103484bf8a0e1386015b711bd12af63a7b002d5a68627726d05c52993b4cc8487fe47ae68cab509f84c6295161fffb6bf0a2584f01cb51c9d73cbc96ac1c69f552d1eba39a5e0cf7f0dafb943a9e8b11a51793e59f6bbe6d775e560498a5f5cae37a42cb09b8cd0707bc939486641d944d440005a28c3a95a4e2d20a373d3fe2e227f69f511e78d3aa1a29dc7bff91a8b15ca9d17ee64889c248faad931405d3a1eec1470ff6b4badd4a797fae9c00ac9a63fafd25708384747f30b66fd493e135356722e0c052de00fbd170172b02daf836fb4093ff36411e1ff7a2fe3bd267f46cf6ac9a7941fa5242fff170967756a343ab2b03e79d50e3ed1ae1ddbf9c088b2899d58786ac4ba1ab8b4ab3d1b1cf576b7accab68fdba61c1b436e0c91fbf51438bc5007bded8f3995972c13edb02838869a05e5f9fe1676a065653a95afdb0fb8986fbb5359b3b91ca164fa590692548642a11cdf3b580a6221c81387175fd35980ecedce71b4c2ca242d3e17c34ef5de8a153b450d61ef8bf6812a5208b89b35c79c7ad8a4aa7558a5e9d84098759f6934b87830aca505a47e027bc383efdd563bc20a72d98fcf55d42bfb1b0aa886dd514db0cbb1b13d80578850f34c5e2336695ba3b2d3b8dbc4337afc325cd825081f46c51c96bb48519c5858ec58df8987f1c7e830b25518555c219775b4fdae8d2bbfb4f99a91e08e9c9e88d16588ff9be9f460274a58d0e174e7d742bf48687d44dbb5d8e92d053cc226582682666374abe46b699f6f2194cedf171429b1e140f4dff79473923210360767f97d8ea02442249f1eb96da3c28da252b9ff45609f8adb31c473d5f71ff1466daf54c6d454b992257d382d0f0a2a632991c7c59b910720ef88beeafde0f799168a95407194571e92143768c0c6d687a671fe3d3f42da849ee52de760b23ba2afd4542dfbe6422c43de9dc1d00ff828dda792ee62d4791c3892eb6e2acc421ebf244b2dc9239186a15f9c809ec2ff1d8809c3f9fa6b6c672ce6b397e0736c0d69f71974f66623f8528570150dea6616880aceb072897f0bbb366752186130b3397200d9a5da5c136c29402e8026d09f00b754ff80a6e3a86890c7e614de37be9a49706ef5d73f80065a81f3638aea0103dc547bbd13ab3d9dd508f711f14daac35c39b7c32d3faf7683f584e89f162efbfdd9fb344e36ee640eb6e7ec5de753753e590745235942c8894a40485b666eeae08637bfd49da1c9bfac32c606f2baf98d1b9dc62747f9618457c7038f12a8b1d88b7c433c7e288d781afe77595efadc43dcfb74b96d8289e97b486de43abe9eea3990295b68310d50a4e8ca5ad38a139ac128f680bd4b07ade0b451e26621045c43b99fd05b7af9bcfdd55579d45a87343482e64db0d7790625a7d9ce2a4dc890e600c6f1b30b44b35980972aa5956d43d2e369b6adaf2c75dc8c9df1b2c68d279437bd9ac0c8016b583b312b95da8d0f452d4874a93ba660ce90d51f5411abba7ec67c314316fc4862b731c463f76f6ade00de6c80f168c399aad35211e5d9eea49cce6d2a3c5accdb0da893ae9d2d6cb336bd7565894b83197a3eda8371cdb27534ef0f855c493e679bc0c33c46cc219384d11950522e3f07c793b2e12b34cde0c09a18b981e3cdfda73244819434356b6185e4d022cafa022dc85af92c4c04079d84d75302f39b0f1ec60a1a07bd10ef031e0a30d5f96c4a6f09e534c8e1d80bf38b4cf96a9ac347094cedc383ba4874052a9cf2e6f743037f51d91e8480ee9629027852c3b2a5f19d8f4b5aef016c384c5d2d0a033bd30ee105fe96e63ea8030bd665b7fbdfd5f412ec40c2ecd00499ae32f6b64d3af63c3e167f60cb2114fa451523eaeb201a27fde81822a782eaf69ff3f87501e44945eed9f4ed1dcd78c713a447988d66af2dbecd23e9133e2a6e75de38d247ddebfc80fb0b5f051b7292c452d6edfbe837ed779bc4cdc631d1cf66e091ba9c38b15dbe3ee23fbe11725a74b5249988ef30c7c8ecf091b75040abff26376387fe121a43e26c98e39ba68a53094a41c81fcc05610c6746f73ee90e6f63212e3a86926ff8e15b414330022092e7e7d2f80a0f801e3483169cef6886128a21f6ee64f48ad3bcef9c44fba6b247cc82dcc4c3f2d670c82e44d162504e969bc06ef09d24dc3136e83994e8833d2d394caf68fc172f390aab63f1349156bc8d002f04cba39df76472090a76f0dc56e7f74f32299c10564d50dbd7b944e0b34f8f881bcb8b61fd433d8577e6c2b6852f457cdf60c453a13269566bb4f268a9d4501315d81c445ffe9c079fef79e5ff6da0993f34404308ce7f2324985edc3a6e75ed50ff7c23ff54d40cd9eab0acedc6c30c8d76023e75671c4de327a51e3faceb57f79891cf790e4b36904efe64dc7112b15f33120b9b6f73ddee0bb7e6be5bf0a491a976fae5899d6b75e47ba6972900110f1296c57a519d0acfe7b140a01f6d4ce22b150ad39a04096a095801f009b535b93ffe08d0b10b69d862c5540f682eafc24e884b9f56ec50ba84eb63745e2f1c851a2c5b67f16eb4717ecacca8dd6fd21c3091d6d505af367e520059a181fa7fe4c1f3a4cb6774651d5bd91a175a416639eaac3b81ebe1672a5f92f6da75ee47ffebe057b1e3eda3a9efd9790e461a79f7c562475f039299271b4b7acb9f8c9797a61c36185892ba079a15d1200ce6be41b450d2eaca9eab3c2e99126320ddb4de5cba7429d2dd378ffb6dbbccb029b9a611a7d69441318a54fedac769aa8b47332c1388b37f0e796cae598a2c08d5a161cb091559976b9c47a280d8e5ea4a241ac236dddf7fd4e6961022dabed11a6e3a6d1a4eb6594968d35503692156b91175237c36f9046f930ee11395708726c8d68ca4146b014f64b879e423ba9d58d8e38ea09110703978692b95085200ee8de95cc79dff5695c2f91ff2f8f6a80ec9b088c325cf5464928d44d92b807b86e9a5f3ba675c3a94d795ec113c84064dc9824977058ae3ef0369a1618447ad1438c0a9204f4db2bfbaa4b6f14049ff0d5bbd854000a13f427712bb2d00787bcf58e13adc726b4a14e5bd030c21692ca3e5171c470d3a89f38ced869237145a2c35063cdb4d82077131b6a1f103b0b902033357db6dff8319f5bac8b6050733d52118142257f2df3cf9967d38f2c9bc8b3d528a4e1255f7b2d8425c71207b7bd8ee649193e02188072a388feee88e2cff196e1eec8319a6671226960589880349748474629c8b20eed86ef0696d05a3406736b95e21e70845bdef771415c47a678beb41dd70338f2fb12f3f6ac0f514ec8cf68cda8ebf7b1034826a45863455bf0d7822183743ffd1478ce97ab268db206dde8566201870bf1c8192c961728f1c4691cd9e3e488322bb6d06e8f7afba9a9fab7fc9c70d5a108b703be589fd8f041c33ff320d74ae034d76c6bd317f8777a9803803e2a9f2c9fb4754e9d10a80ab8f95eb1e61b63f902453d1553018baea00a933e567fb7f95136c31a2eb280fb7adcdc67fa042c27ff70d4232eeb20a3528b7f160b6a3ec32f788e4890567d0bbd57819fb71ef7578746d2a0470957f741d389bd76527c80d714d5caada7c375aaca3b69397a307c0c283503ae55463069ce9822458cdf9c72d9a4ee238c2b5126e87fcbc1f6dac1dc5c2d627a02f45fdefa8dc566aab9d92ba869f138ebd10b2f4b62f0800de386af4a904c1025b7e639835ca96a5bbef3efa1ecfb0a2d78622b3991f36a8d8adefbb01427a22e415bf3b06f5fd769992d3852dec22ce18be9a66653d6b62902ff75f29508e5612f959d18378ba93c354e35ace8019dcc2dd3f9f0e2929065056053ebac9d3ae08617d34b3b901960c60e40c637fca5764e807113deeea94bdfa88308f5b18d1155fdf6827a451e4554c3fc1795e7f9fc983402b9b04494dec2d5476defec64bff38480755aa9ea63b10abb422c213098a8ec8aea38f1149935784bc846131dac87ba3b5a2d0f3752bb4075be062e71eea1ac444629b81fbed5cc8fcbff22aa972a4a4063fb1bb120ce09a4e1a99e32839414228e740c51098183c3a0d588a69c1051fc86ba63a2d0aa8dabfe6a3fd32942619a834b47ac14f3dc0892f4b64962dd7feb064f8756f44597d051b0c9f22efb0e409840da6c798e03c218c6150eddf43f7110279bb4bbd3203db6b1529413696b026358e48b99331599fc0cf806c053e0ab4dfa43195f3cf92002e7a133e8b87dc339350d1500d829576755822c101628f32d91fccfa577f19f7a7e1018ca1912909523c35a59aa9f8400c27ba675f7c7587899b0099c4f5195db4257c56939e0a409fe6a3d7299e1ae2513e91064958025f73decd4c9ceb5b42fbaffda5648e62504c7b35aea9e05fa85883a05ddaf3960544d6c2a4aeda8699a8f19f62699d9436fa269419eada137b923bd1ffd2ff375611b034c435d2247e897ac67b8f544c87fc9ea9691ca59d1458e6138d51affaa04e74addbf824a189694971d7a776cfa27d504e4cfd4a543e1f9782b1af16f0297ddbdf92578fb8d538e7f1c3312a18589712dca652fb4c11233bff7d56470a18a3b85b2f1502c46e2d8ee61dd3696a4c966b3aaba26c0ee4ab0bb36f1252177bed4b7c9e726d288268e0813d62d842ff5abb4f2e0a87d49c8d9c95fb85df450432902c405ebe1c44590eafceeb19a82d7ac1f1a795e9a5523515bd4400db4884e80f1a2ece3e51e60a3d4589416098f1f36fc1d531dc21ff2ebe52f750062539e1aafc0a33ac1fe178982871759ac13736496fc12359ed320a7eb94b461f6dbbaff44981e4c0849bc678c9b34a5816e5f3a8701ea2158f91f7eca0d0644034ff0cdc947715a6e6348df977137d932c493af4c3266f70b270c3306fbd4cba8f6b6358535f6904c4529e129e9f428604a9679b0f4ce1cafbe08a89c48cf807c7190a2412290d2bcd21b99d58cca211a9db35d7315358e7ba63774fcea7839cc502ef4277107f4bed9dc6e7a2c03524002ea52aa1399448861c427088e9135f56adbda3875b2eb0599f8403f16b4a9c89108f5eaa0599fb21b623855d645af62a0e3d5b1be7b004766ac6c99e8d14af5b38a7d09693f303af8eba7077d75e4e2ef5cd1289756b6c7a86982325d704f05aed8332be3cfcb2f5c36ef8d6e5e6fb2c82b649389da3ee04451a8bfb832ebecb4b2a06310b6e11049256172237e207ecdf3a21e2e9f6fed1d9df165943fc08a23ebaa3f044f7ffe52d68139774919908755f343d1055b2d05f603c1de87cf3a459c66bfefb109933b5f65fc6584fbc96dd7c087026b6ecde453f3dac4e03a64b9ba644de22304b58eef79569679513ed257f51d000fbd88be75ef5a09b1d3062b3637610f154fb85993e9c84b88e590b61dab6cb372fa626de1e569a691ff59ca2acab59194a82e9a41bb3c4929134e7ece93bf09ca1a05bcddbe4830076cede82bb3fd4e705586fd72739067275fbc70f2c592f414996cb5e20053aab754a90890b9bacbb29e7f0b86866a0f076642aa3a3c600867ead79d430c6701e759f6cbe5b28f07fee0663c7b067d4531ac264d4d599529bd61a2d91a2562136c9de67cecb2a06e2f6ba5e7266b212a3665576b959b1c0575dbd7713a05d58c5c44ffe3786208445ef371fcf63ab3e6c0c319eb9c51f3ad15e6cf95152f9e927573d96b13c1b7ced6dab91df478ef8bc6591841aea4a7e4a9795d7ff0f36477848fbf1b12148470b0c6980672c474c7eef6185b00fc1144e8f9cb4294f3f2b7fc2ee9cc2fd0cb87745f4dabb5b297a0118e46dfc456d0b45226aa0bf017a37374c5de6264f964be3c83c3e31183611d17e59773cdb956297ffe3d8b745e1e67bb6eb2c132ded935c000f2b5df47bb00edb47275044d030d8596b2e919420601f0c8b1332f64d76e03a70a475816c244351d1fd9382f24090928849100920283099a2bde162ce80e502c385e801f4daf6b31e6e9c2fc8b276d547f152b89921c2cc9ebf223a42b77b47a1bba0a7d6e203c788330246c450e7f439d50c2b0a656c99e7616d52cbf73e2603c70ff1187b8a34c890a9fdd854a74dfe1ed36b1ca2a60c2a59c6c0e3abbcae1f61f8d5c6a2eed3c9d91b61c69eaf553f6a7d6bfebaf358b23a63d3e3cddf1bb6e531ef59857925b29b1edd00bd74c5934ec2997e5e59c093f7c2873b6fa34610f7cfd02f5b775dab1249d55b36f9193ad288b42f780b61c75111e3066178a46cb3f58287485424f983e0a82729cf488439abad761741ea4e9610a01b66be5d54902f553a8648a115de2c3520a23b846357ab30b1dfefb7b4c8763e0b1e03c0c7e53de5f2c92b2f50d7e13a2f92d2fcbbad407b07eba1f0d4a00f4826cdb501250ed67fcf31a01a661c3fa20edb7cc8dbaba9891cf4c22af5f321f2f91d61f129a8270dd856a6b61d2beaf55a42a82e1b788f0b97f1825ae86c5dd4c40921b7cbc2e5577acd3223320c7ab4034470ec7482189de3c67dbc6793f20d508b995f0dac50b2f36dd257a5ccc977e8aa95e58be5d5e5a83dcf91478f0bd7351c3a33e99893208ede73b485d49d8a24dc4610073adb551feffc63e3747c08a6199053221f215e71c7d5e51b51b5052c479c8c8d7f89278ba6abf0d63a670c3bb04c7c47d295fc48ddb61251b546446e69d14e5b4c6ecda43167a9ca31d607f3aba1defc067570c8d45cea4d8a01cef59c1061b96a7d51f152d824b8d4eab59ff502207445eb5832f438ae33b87d4bdea34e9b5181b0921cd5bdce3a8ede5f1edc18607d2c737ad2b6e2b475050e1a3ecaf322212578bdd56ea3d9c3251352a8a240fcadac07f1aa3b39208458bc7753ad5a510dca3e3d206598936901534b0b2cf35b825bb4ff18e0e6c2e2ee7e32da629eb91a26dca7d07c0bc8afd122cf5a80ab60a868c3717c62db9769d62b484aac38ae3e7b337475d6bdfecc04b62c194e1a52e7b1d1c1069c84acc90ef418b05cefc0983be7fa8803091237cdd93423f70f420f5315b1e6cf4d0e816ba1a79439dba0e62fd9df5b989ac8558d3f7648fa75adbf3768254ec973f5f7808b6122d542604be65a2d70f03c3edfe9cae6d8cb620874f6eea82387367fee9bbc3ed415639d7a5761aa3d10b123794cbc0024937f7e0cc8a0c317a56356a6b339c2c1cc1ac05b3a0bcb50b3dc8aa8574d79779531f774390eb14e6583d47cc97d13a58f19a1e8e0e09621aa151aa2fcfab2dea4cfd16a72b7fe5220b3200c3f7927f7d2b667bd1b2ba503fdfef332f881386e72cd155b5bcda42c6216aa0fbcaf1252f89052e8263aacec9361141138aaf6c01b296acedc439929940360d4e12790db3a882f14186cd6c73ac537d9f7d7b6783a22229c17d85f831864c1ae599e84ef46b882790f4c9504ea9748e80ab67c0a606729e20746a007165510abe7757b295c2f76c258b84596c02bbe9500418749fd71ecede000c1d5821cb9ea0c49eb8b89e89ddd1b408f770a53afc625a8f64d688a4c1b00005773df147c245c352bfe5d36c3879c1e22169a829e4635b36ee00c8b4d58622c34d37aecc8f782f490b5de80ea26f507734e015c8dacf8d5c68bad6f58ff1cd8760ecc966c44aaad410e696e2e49fe136957d5512d427c7cb9226ec5b5cdac6b92e504723873bc1db0afa96f0903955b1591ca55099cee06889f95392d29c5d4bbe301f41db0836e83e6c7cd0a843b4d2d15435a2caa923c46a773d3cce8a4f6ca382074a948de33a58345377ef8711fd7eb05c70626881639f72c4e42ddb780059bcfe273881e342b26c9ecde13c89846debecd4cdfbf4d5fd38e568277b3559c919c643f4ebe2de4aa35c9e501b1f37b35553edea8597b33f8812efe0480525547546e6c16cd94a801c71a2e5bfa856ff5383270de741101d5164aa7bdb839eb5865a276aad14a46cc460e6319b80658c3e6665cf2f03b6e321e80962396c02fd970e310a8831033ab71e71113f3d49d9c657f8af8e52603fa14cb75405631681e0e38d500cf7020068babeec2c1026b3eab7bd5bc0d407c8906279ce9951dbbd9795b24f4b5abb2c09a92c44bf4f45fe110016bceaf4bd841c31d3ab4ff93b6b9fcb78e17636018133db8d789515065fd1fe7253a9e20cd32dc228faf1aff95f654c35ae8b2d9839e63d49b78fc9626a1a333e7624d1272cc5732386b189c1d9f747517acbba61589d87283547a6075c228403bd4700956347576399b8fcbdc91541e5c205559dcac7091d890f815457cec199c848a858138ed069beba5050a4f550ef1b3279b62a6ff4d25cc632cb9037796e6ade081be251b55819147043304a0a2bceceac471d6ea2d505988e057ecfccf1409f7d596cfcbccacbde8d148cc44cb1e13ba03fd6b21fc5e63258caaac1a686d1e3f92d31da678b9abfa4771eed92371e7dbd6d7e44776466169f84a08568e5184d77aa499cc6e8e7ccd961a3c5ef241e692d86bd99a67bea901a67c281fb213ba5b9ddc6de304688ee27c0d8bf715ebe264ff41b0b0842db262e25ce1719082198928dd904804473e1fe36cfb578bef68265b2a8052378816326fc9e00e860ae07073af4cd3059593561e0b6a6d43199064b203a02a9c09419cba7d3d0e953979108bf0b36694cca1dd09a3aae6dc3664963d0614ae7f9f4babfdf48e9ed67abab3fc2ea2eabce93a671b68517f2fa5f7b98fe33b1070a1fb89164ace61cda194748ca0a548083eb6ff3302b71427cc62dfdab72bd89d42cd81b3a10691d4dd1f97fe5cfa455491ddb6348e135be1adefd4b613b0c3ea12f108c0e99cb1c141b48a0bb41f3a8f721689e87641c3c97d8ea9ecf6284c1a72f3bcc4cc23563e35e08dfcdac63a03eb4940cf6316f65b32ddaedb9cbbc8d663700a1c9bf49bca439c4803ece1d43578a1a9e69e7db7e61602ae1825edbf569106909ca22614fd1a9cb375328553d05b50686bb13ca27c41f013ea7df45d4459d2aa69302fc76ecc2d39ee1c58123b056a9e19ecb3132697f1759a57cc2f7f760ce74ca0cbb120ad7e85f220b337fccf7f571624e9e01f11ca0fb406bb1d76c89c28675175026a9773cfa051701d92d259c981126c2fe1a655883bb34f9b29ad3399a0f90cf5af0704599159122598742569779b9fb447fdb8a552321adce31f2704fba26f1494fd2eaff0fbb424d8a0dca2f73afb6bcd06119c814f316a863b1732cdd4484d1e7c379a899d5b3219f3d1a156655291797873bf023483468c336b68cbe497442db389a54c2ec84baadd7c7c26b1abb4093e85a0e9ac0e60e90cc31ba115645a616a35ee653d7be15d07f741fc7b8ae7082b4605348d845790be3e3a558542f53970155d84ad632e7ebd396d8afab4771ccc3ed7d712f79c2a3747344d7ce461918228a2f6bd3c7dc80ff7e4052f8ae9dca5553e2d756264c9105f53a7f199909e1424301946de404dc46e581c6a7e449eb8924759e494a0f98d8895b449b5fc239a6c1280040caeded0c9d47177a5134fea058393fb2ed45acf065eb2c62f3adbaf1fa4e61f624ad40412a514404d1e7c5ab203baca90107936dacd2e4b3c1bc32c69e22ad4550a043231deeddf3f1ad340f828d98e6b5528905e41398a03ebfeba80f53b8fc7fe708b5fa06eb051fc90c379e0cfbfbc1d98b992ac6b086dfd553215aa478a352baabe419d9addcf7b9cdbc363e9465356995bdd107f40dc4de31930b1358dd8fa8d4d9e64f56dee9324e11987ab9028079221e7214c8d084fd958c94fa76094c290fd7afb07e718da88f5667cb175bea16fb23a703a53e75da5147f2823d4155157ba188b5dcf413be70563347de8671b0b45743492810b59a0da88e7281b0d93e8ab846ab9d8abd53b723189c1c17a74f98e97385b1d19263da5ae54ae7a87580b3025e83866c2730901debde74e6b8a2d09594e2bc61850cb3b5d1a52e300600639f8fb7a8da2630920e1655d63838b072003baf1213e32ec6120a0c915e81dccf5dc36b8d502cf57b6826f4dbad83f5da2bf10a18aac9049cc235a2996762610a28cc585c49a9c3122750d7d89e6f5dba87106c01f1c951c720ebbc298fafdd02eec374e89bcdbf81474f7640c5b4c5e9a998dce39c5b64751745de4d042714d0e567ab13c042afed215275c059fc77358c3d39f49501f0aebb441a6767af031e11e9dca8be849e0eb0c57d099294d181bb887a41282515a4c1f462bcff2cbf249e808e91c4f590d10d5780aefbb1da9c54855fd09a06aaae5b83f02756881d73af7404d90f014c0db5bc5849916fb136c9ef0aacfa09519616782ed37bc6a2f9abaa49fc1711bbb09fcee0ba6044de2051e0700324d5d1aaecef412466a84b5f89511a1ee19a395d6fb340b5042953781704f90642976561f71554ce10a586eb91d6aa06ffda19cded7c6984d1774f4992131297c0660f6c95b116de41ad2bdc9862c3a8efcd38f68c1e3fd578e0826585472505bd1a208a728bfb9feee9ad90a3424aa91f210b66665f19c8b7965aa93f5a4e669faf87612eb39b46b76152db45dbb40c7bf0dd80cdcb19a2323d83e6c1541dfc835ec2395ed42f03591479c09283355c718d8759f5d1aedfaa98a54be2e3185500bd4fbbabb3badf1516da35c2b7340a74eb20d20bc7e18233a49dde3dec34796ee124a1a9002b3bf5607ee5d91c4db3753f2417b10753c5943eacc5e03d3df86fdd093dbc82cf0f85bb529b5ddd4a5876a2e57580d95da0ccab66f7bf8cdb24de15694811c4389fff2e542b94981b48053f1516a0a316bb02581d1c9c83d4afc53b40cbaa11f585fdf0011a02d5e35a163c508e2d4dbeeb0e634a2d9afd56f0d30d6afbf88f6e6fd7afa0e379402bf60c63750b152afcd27b5c34c39cafb9e4d7d5b45c57402880b37af326fd96158495b0c45c508599ad9681661f1f2e49b30f60ea0fe1f30072c20b912cb1c9c5633bb420e466d9e29c6bb13ab95c3c892c27d5cf3c6ba71c15ea57d15fdb2124deff1c101964643efc128d1106af63cdee9a056b9b31a2ce7d48a8d356d8f1ea4c8d012e513e6b9685156ebc886bad99b486f7bc2bd756a48b98101667975a0658be030577f5f276988312aa61083d90ce5bde1cc42603ee74b2ae5fe18ebb022cf0c120ee133e7a52c4a8f769455666adf709290cd76523827efdfc59701b78c1db7de242fd1015731cce7d3797b753292372db5e6b3d356b70607770b48ce8d3cf3998fd041303c7c472719b35da6cfada88537191416cd1984dfd173de1758d3997c6bf51c76f4f55cc98f53c8ec2f99adadfda488038a34d7073511f73e90536b4ab59d2fa6a6b6e53faf780db2420f02fe140bc6f52fffd14bf4fce7c673eb5c55dd3f2715d522226aea5906d847ef63f87613cfdc328730bd1c48b15e8425ef68bf76162ae696c408577ccd7688c0d6d95b413f1a3e94c7e57fe4d83a7d975f91e49280dc4f1704c3a02de515248f22b7e94bd0e43370403dbda96b8f800eee3f59321ecee22bf1684b9325cbaaea7ccf5bebb870bdba74bb85129c38a2f98d496ab839c989c6c7ff7da31cb530084ae6ad2d65a79daf875394854f31c35770c6e7dc994b26f3d8f7636539292bd21139a24a5af415bb4ceaf02d351a6db02358c0bb07bed189144b3db94678f2ab6d456114f292f54386f9fbb36145f2ed60cca48a4ccac2e11e6717f4bdc2976e51373e56154dfccd06fe1dcf25dc22d0126129db6c781b188f9511fc570d79633aee56b25bb281814af1f3c074e1ca969153a5e92e229c07530fcdd144512186531694e28b7022bd155bfea584c151ba91e7c860921a3ec8499d96cfe784af47987b602799bc50ef8755a254c9c4c8a38c162bb2a8ea2f653f2bfa22c19d77d9e9a479d4ce23fe4786053da0997cb5391c2459ff8662ecde0246436410ac01027097d8e9361b1bf7e32c9688a884e2882ac0862bcd8ccf6b758d4268ba21862f990c8177dd16393edee5a8a755782947c1ad1e3ebebedf17341b792b9a18f949bb4b5e24b1679a336c02df519493eb2147f55103927ade3359e6f92d4b7eb918dadadb1373e791c1f8f9e9aee47cae1d4c24bad1712d56c9b9ae543fdb9681c7e1c78bac0f90f3e71d5fc72c5cbb6e5fa401e81acbf41205c9c955f3f1ce87fd8830a2bf75bda434a09b3906aba1100287e3628aeecfd0a04f639d908221722ca015e04d64e55552538e4763bee727fe09bf4ef6ce1c730623911e472c9a0f8b9f861ba31f94bc57b400f903a2f409943a168a9175950786ec64daec39b183c8b67fcee939f9eaee83415b03157a4486eaae6d67c13ae7352764a8920618ede372aa1c997e873f4d20ead4c5bfc1926ac2afe3cf1efeeee6507b4f0ab7b5f06e0af115d761d04cbf016bfcbe5e47e68600a7c1a59d0e92da4066c03e89af7dcb035a61c1c33fc5cdbd77ff9b4d613c1677caaf5effc644d1bbc63a47a1326901a7d8e0e8212f798855b95a784fff3a9fdc93d29e90facd010e5ecc587c357691615939366c8638cfee5eb7e7da6c6b5b6dbfcc9204c74c717111150c334b05847234dc92231a10f9eef9bf3f160168d04937a3600ab50b482e38d95fabd7b1880ec91929e3b3b8d43bb76759c6968773143d4c5f1b3d142ab62db6ed89d4f844b4f580a56db5615a1d7e7adf802f722603d9c9c067faec6ed3a8b01ad552d9d926ed805eadfd79de012d77669929f0c572d25935dddbf4433222628ede80a38ac3d2efd8777111e29f32608b97bfc04fc17ae5e85fa45d1c81f2179b2036d9393e4c0a0abb493651f30e9907e20d207f0bf3832d7f406fe5e0b871b900323798ac9ff6506b0c2cd04fb39c3ca9265b12b53f201fd979aaf61859838e5423664db7204d864c617303f84a9100a1cd3bbd407da00a5369f8415c4ce3beb32d99342a6986b4bfb0839869a8c03193dbdd104ef6dd144fe944cc80323bbfed814b38516de6442a7a207b6834de545ca3e846f9398973e2bcc3624540b655ae33bb3699e2eabdbf8403f17bf5eddb1c919a73e976aa693c5b89b5371519a36a74a5eb80043615022dd3ff5b8d9fb3ec7d296b7580b8b09c9d0a2966f64f3d82bbb439389d0c660c7c5f293bd5f85f22d3ec58b52fa860d1388f928d6c206dc9e543eb4c4cd91545e0b6de9d9090964d3794e3e70a5004f433bd42a0c3ee15e53d1defebb6945573ebfefb42b86b5104d081fd17bde1ff58ff3d19e4fb0df20ac67c2922a3954f374340972b</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Enter the password to read:</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["Others"]},{"title":"Essays","url":"/post/others/others-essays/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Wrong password!\" data-whm=\"Error content caused by wrong password!\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"ce3d6b955b73960dc125a66cce4115a8c0a286dbeed5a2908241408fc067a0f3\">102adc1b71919baace65490f901705cde73439c07b3b46deb1e5c72bb3ea6681479fa8a28abe11089384ad17b395e01544ac79a500428cd255581934151bee79eaea5581c433ae2b63112093e4240d193fb7ec5f5c7645c1165dc923ac6bc29bdd78e20bef62ac0611413234791b5b3dab4ca41d2a92d396c01edeb6196e93dae873a59c2cbf92ec68cddd9a983b2a8e256b8038f3512c6af94b50ce864dd0a88821d6738a2767bb128efc8bba6994aa481dc2fb2a63d92e015602fa342503fe9d5c53833fecb5f01178b3cc0d4ddecc52897768055939cdfa5ea31e2cf66972a2ccfd2ea7f9810426fc2aeb48d6b45cb703c942692b555cd0d9a143f27684c701f5c15df0661771f1b8f4d982a2e9c24ed2ecf411a7028b1102873b1c0a433dea0ecbfe8c64bcc9eda28c08301dfdb6228c36f7dc6667ebb1b979d474e15ddea159211a79d3f779f2202a4e3922843ef86381953a6732351b544e60c67f07ce153b475aed60b86d0bfd032805b54e79c16554308440220bcf18b18918dac8f33396450ef759076594cd943c5f6a9669e5c245407a3200215bee29e67c9a9257a894d135b76c4e179be24f128121d5c44a4a2623a6db2d406152bb9823791fcf0bf365c132c7f4de205192444cc61a49f5e6c49a56cf836bce5b6bf4ab55855655407084b3d99f337243a5e41b8fc2df442b12a65e38c3de6df29e319804c696e4391196415c759bd73b3b8b0fdb29a9417bd02aba9988925d6add05ac441f306aa5de958b2729208fd2f861cd1282627155321de345425655610f88cd7d90dc930ac41c8b4a5f34b244db8dd494dd026a45a3325eab95a244f22ea9a947eaf186eb72771fcc64181e9f057cf46afde73bb46438584e2b8d5a9306e918c16c42c0a83ce20a5ccdbe0028a915331f22d73d6198ffc59179abb32602c6fee5fca03211342a5a2f0d8ea4ecfa33b540f96b8d2f0616170f103b8a1dad76786af0190d466e7a4d996473ffe5e869b51bd73177758ebaddd049237b0f1906aeeb841cd515a48d1637148c204e2e6ae37c76c91510b24607b5b8dcbe8ab2a74f992daa307d22fc28b7e01ceb811ca9e85ea629b920a99eb8c1e1fb7e0a50a41dc3befdc026f027c2da443f6ce840e96947b982cf9b7dc956f0c3db539c5cfe6fffc5c6b820f0b9585dbe535e63eed19c5d78a62fb4da9c07bbd0aa0b96e69199a217a1c835a157759a20e8308e05262468d25a8c4404091f042599e93e1c6cca2c93f140bcbcd4f9f6a0a5f673aa8fee18d5b4017bf445f5ad6b0f6bce02191e29254a04d55e2e18e769d0ad562c5d3d0862b5736a6d9a880ac008ba744891cad1c234e87ffba2c4b68391b0732f75dabaf7dea97eeb0c2efdea24de9c133d518914688850279b0e2e33457241dafa26e25b088097d50b25b4030ae802a40a69183d9c0485bec00a0f77e946ae6d955acec1809e2d6b405b21d5ec8daf12c28d6a2eda256109d4ede0ed4770f3f2e4f6cc3a3955b5ecade6547bdd0478474f888ff6479a543cce7eb2cc7148dcbd2e2adaae17920130820868869e58ad2e660d75e1b4096c01577ee48f50d21f28e87760b5d91b19a4b9bff69d1d65f802699792ac37f98e726921306f0ee818b16a8c3dce133c5f2052630a15a93565b25ef9ab08cddb6b32585fcb2d1279cdd3523fdd13f6976f6322e1cb96113d84f0a1901d5a186447c7afa46656da8a1eaba6ec1b6ce28704c8faad9d6a7f38497cad75f2f98611ce31b0e11ec9a191af3dc1e543857163264345cf08f0334c005e12b1b1cbd169e04638c78c21dcb17164261a92cb4f5b586deb949a2dffd77e87145554c0e8c7d66d6bb304185fa8e19d833cb30ba5b6d01c0dcdb872275dda36a839c14ddae5d7338edc7f1c79332851c156efdddb585174c81fc9eca596c61421e708eb80f18cf94e09d41a73b6ce783ac0d4a8b3b2f42163d5411503f6f92d1e6d21317cff75a192e00d6196ef7f216b4e1f22c38d93fc83b4c6e7f41e16db7618e17dc8ff4bb7f8d5952cc9002812650ea4557f42b8ebadd5d1c461371550f42bdbae8d58e1d04fb404c5fbe189521e834776e0317a924891856317fbf4f5bd0c9c4afd4b115d6cf191647efa203e5e8cae017e8de8cb4258fbe808f31136ac66008e33eb949c492044e45df02a30c41baf4c15f7b637af927d6b2e229c545c77c5eab1a0c11b5aedd8976000049b53f6ca45958cd77123a8caeb46ae8f23c137fbbef3b1ccb156d8dc9e0f8008e917d66407e9a221575de22083a4da666b032ba62b588f35d96f198851aec1d25f5939d2d218c63b69257334e371522a759d8a53c45e0c0c11ef8473f4b8fcd7c6e98c28771d0ea71039217f3e94d4127896581c090fe40d75bdff5e2dc3939a4acfabcfd8f84be3fbd3305b96bfe6773afe356c819c4f57c1f6b0dae7bed1ae8fbbd7ee9af90af1c973f17533094ff20a27620747da2437b2ab1dc871c0d3392c23eaf9d9bca689907b14463114b33b3af006b5772834cc405650b4e0361755baf877621ef515fc1ea246f2fbf3192e57f1d52672b6176cbbb81c635de9d0eabee499746ae83e2f3ff30482a412650d5018f6b98e92a3a66d1faf9be0de96320447a4951b391f7a1162f8c00c60a00769559e34460917d4c2af447834802c374a11b27d918725026311b705948e55a631e670a32b41b5784a826c2e93ba50c3b0a9c1b5cdfe8885cf009cd15440b86038ca460d0d200306e5db15c74d1498a68b8c10bd89e9909a3acdff5050b97287f517d61fadb0ce309e1d5f3d6d1294c956182303b3cdc4b056bd76089a2f4b6cc52081edbbb363473b8f251a02ba87d9c696a9882a1c3cd58e3d6b8111f6cdf438e0372677b13bf72759126187f24884c3b99322d037f103da7aabcbb5a745b329448e66f7e2a24056e40df3e9b85b23db41333e767ddac1151bfae3eed8ba10b2ff0976ee75e6c2754651340384cef995dad02faee2a47ec3284a288030f69950c20d3a32892709f8f010e1dac8db885886cfc40b77538584201b69362e9b02ddf02b6f9a40671203577ac29ea80b97f2e8d5df4983a3abbc3c456f2aae92cc08899e57b6c4f90bd5d72c92903ffcb9998f7300f0dc2fd5979ea41e9db7c286dce14793852b141bfd05923e700e19005e6f851e67eccac2d7698cc04ce52bf60c2b5d1ce0c147a825b73784f03d2a6a54ed51a218d8c4f36cb342c1ad6e3f4df5e5a4353052</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Enter the password to read:</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["Others"]},{"title":"Interviews","url":"/post/others/others-interviews/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Wrong password!\" data-whm=\"Error content caused by wrong password!\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"aefe8db5d20a524c036a4cd9320d6c0f71c6e7cc19aefc039a4e77fe112f2b7b\">102adc1b71919baace65490f901705cde73439c07b3b46deb1e5c72bb3ea6681479fa8a28abe11089384ad17b395e015f841bfcf476af3fb783540170d472edc1bd4b66f1a7ece2575e86fd1e319d316b6efcb89c0e6855a395fdf14ac5f63a8968ae31b81ab8da4e704bb4e4fa8218373aee63f753f98261880f20dd26ad02092558cd4d1631b7c50ad84668d99a5652c7070af15de68b334260d00861349cdf0feedf6299277fcc2db93f406ca89cd873878e6951456fdb49727ec24ac084ca9997b7ef6c3da2fe7a23d161851d41d024375deee199318d8ed7bb177d73ca3347e67c3effea27d0d4f6e328bfeb17ecb868faf71128b4a429aad8fc495f98640efe95b406731a7387de0afb215a57747d84747228e66f5a25a87979bb3deaaa53e8506b4171323621e7b38f60e9b013b09f42167a463e94af7a4ba8da344825da78ae2d8ad6b887f585ec222320f10592acee32fa24a0510d4ee77d8eb45f22a53fec8d9124a0cfaf31ea119771ab1b7fd780a166bae40b736cbad1d445230eeae3353cca1d74de3582933e7e4cbd04ae853dadf598bc0b65044aa3629e719f8d8d0cb8219b594d455c70164c9b7fe0774f265120dbc2e6d9db550fe39d01d4928f35d5a9980add08f4bd1347be4c25419d003844b4696f90b9c5722b4ab0b45cc8d791fc3db17917e05d92e52251880843efe8507a657449c6f5bc27c5cf16bef01f32cb0def60062217f9af871d57d86fd2cd8dae778e4d08d9fb69d76cecb4d1ec33cc604d3ca142060d3caf07b2935664e84fe894b17a3f8cf2baf7aad9aba14ef5090a80ca03896f58a16f7bf423b6894a380cbf18b8d60fe77457e568cd35ad84da63c0ec56e71321b32af0ddd28126660f031434188910a687a906985d4f8f4676ec228625f60d1d1be26d06ac26469fb7dbe6fe44369bca2f0934e2f061a495fe15223b4740fe5d5d1aaea79f247cba161434f6e3309658a3cb1b6a2208bd015deb6f64397e1e6d7edd02776bdfc5eeb04a4df738fd7df6b7e2129ff81807f06ecf510ab629daaad1e5627ea3edeab338c8e6c34c9ecf41cfc8adaf2aca5aecbb4a0a323d48598ddcd08d101d33c488b75da48ded87854fb5bda8d46f4db73e65074de98e0a9b2cfaa21bff282ebd1d4eff6e033efb98baa4ed6742a9e328e461b2b2801388b49c5ce1fa4140348eb8459a80698f8823e30eb2ac45c317e5785555fb75608855a3b69ff29f5609aa49c2f4f2adbe175b3bdfa8ee76605419b159bd1e5f046fcb5f522d2d942d1eee04da34b0d146dbde4f86b4ee3949f3f057a63755e4c0115f340675e8778fe021f88234cdb021a59b28e13a1e30d0be73b6ff21471bfd9fdbc4cd12237429234b0645952d0b1dfbcae21466d5f7dd4bb9260e9af5f013e82c61ea75c883ac819931c4f62f384fe716bea71d78eac034b45c10815565e7bcf8eb9fb8753de656fc1222eceb7fc33281a9982cd5d459552855e5664df6fdc5a43d37fb7070e55d793e99d50c4da9aecd3fa676ce12db75efa31c308678ccb171a1e20e7f8cb428ba2da28e4a0866288077281aa2ef69834104ac902ca1bd6650aeeb70bb66e479cd7aa8ec25c4f18b3c34274dbbd8f929b04c154ce2d6f21b26e68c588f99aa335f96a5b551e44dc668de680830880618513e5023ffcda2e582271b1fd2194743f70a04fef1b3640febeae73197a815941d607404c58ee30155f1748f51204aba08fd7f933eae0870b7f9afba5eef3c076934dfba78164e9040b18670f86c6954baa7bbf8125cc7669973ac0a5a04550ebe5f79bac721b7ec3a834127010e483c3fdaf5127af0aab7116569bed619b919a79b3e251d2fd71a1a7993f7ec457c64098078e7226d373ca2c8376b4ceaaaf0d947ee878754e6da6f9f64ef96de00a1260a4a52a5964257bb530b4dfe878eb1944446f3d88c5801cd82cfc40527ec52c93ca274069357c870c43dba0da9c2eb976d4fc1208f922e65e3cba4eeb379799f3d5653858f8002df23489d23c5d38cb6a58e79e7408445f92eaa1c230c086bbd6b3bc17ad4b5877660f6e4c07738637b2a2c014eddafb7e837d2f5894984979f3a199417f0a786e3bf5c5099262d101d973d0f534d57c1c508980ee3e9967927d9c08c37a8b0f4d04f025503caf2b3fe833dce9b1ec315d95c7c6b8d217a40348d2e2aba1cf219e43218395cd9d77f9820613fb8bbc478a0f72f902974a9935348d4522e59f3235e644aaf7cb6cde6fe2665cc4f10efd377b6758fccacf49af63f0cde1087492564e4436c2ae4048b13f0b465111ab8125f8871a0c86f44dd612de06159acebc6ec12569a162fd745150de65d76ae261e68e0d8378550633467f6e6c2025d366dcc52672e701e4a8a2c5cd251aa369c772eb9b6c2677c6fde0b9bd7acf663ac02d1003dc744e56b4e2746d42cfddeb4d2866833080f1562ea160d7c3fadb6665bc33a4dbf3b732bfcb70bf5c4eb3112c5605df622b1a29d092d707b0fac76ed65e785a7ae570039c7f3aafb0221d6df6110efde3c1c637fd9a3cbeca4c7d0d3edea1bee527c7ef868281961b9c76a08aed23ac2d7a5789bc3309d7ed30b4b74b6d722a1653486e50293d7fea9a830ab7e29b7e2b222dc9a52dc35925ed4802f3425b78a6f4a78718f01ab6cd30cdd8aa9f7ef2dd1a487a0fc110d78860ca5e9b488063fd7d69fe68052924ba659524d90bf331f832692ba6be2295924158f0716aba995378dba4c3721cee0c277bc89c13b8d7cedee8fd6fa849aab9e4035cb68454e379b4980a3972e21f99c7d77a169c9181e93501424205c2fac9588b97ea4e5911644825d327edc358ad3d455350774e7cac2b610b5291bd567285a6cc312663d01c7b427ecb3465fa0cadacf1b6bb3a4acff1da16cf6f09acbffbadb8b32fe480601b2532910ad38fef4825ba5e72d419da507fc50bda1b74329ab0fc06843f22220251e67bbbcaa41016b56b784e712d6a521361fb68c6e9c57fef6d8037a790672be5e7f2bed6de73def6136076baadcbe960726a3a1aaa50c18fbbba40a4ca87636bb96c8dbab18148a263aed168e90688fbd12d55c2c5883cd32c9a6771cd7481ca21cbd46a88f4fa5b022c89030a87e77061dd3b049f11bfbe6aed28fbbbd6660682b6b2d1162e56da40a13ffa912c82d1017013cdd879f1b26e9a4125d81f2fce58a89901be4125ad8cf382c125af12e32f41b3f477cb8a7ae9128f92212b154aa07b392048b68816695eb513f7b1dd0657732b1115aa40843539bacd6869304e138cb9294fd3ae2b0a5c01d27c2bbf1028802a8b86bf6494bc1746331e68fb522aec2a963969b51a5b82efc438a4089ab01be1c1f689794ee695eff22c8f502bef16fd4d738948a88f6a2008b55af9eedbb2ab0b0312be8635a52256a64dc54ae57636a7009dfb9a712e35c122df648c9dea0db0602cc0e96bde1543dd400e8a3286772b516a913ee79fafddeec057494f9f65cd22eb3beb103db584c6d157cc5d3ad85a8268accf232452e3e439589e361f9da1e433ad09fadd535a9a84bc8ac17c4139ba19ced2587f4cf5610310e77cc587806346e50c921fecd3d6a02930a4ec1f26438378355db0bb78e5eb2325293beee9c2ba4df0be550b172c85b1234ed2a4c3ce8a66467326f20f540dd3f77219a165cf60cdaf2db1eacf0ee31e40e3a4eeb619556e252e4fb6cc139ae4f184825ee3fc18c1bac09cc71b6b38a14effdb47d2065ab88c04b1c82f79ae4f0dbf565e9a59f96ae899c39d8cd795de22d024e58fca65406168933c3479a725baef2951ed8dc5a9d4407f8a14a4d79509adca4c37e667331023e11924b062fd99177e54a58dcd84d514009c68b5f8011595f9f278a33cae0ddb7409fa0d1b99edc932e594cb5fa6cdb9b27ae5004f8c3b18730ff8d5aec93c94fa879588b6ebe673df2b287371aaaf1256cbc81630378ac617ca2194ef2708811dc93f9090768d0fcdc90f7af615054850c05f435f2453558884074fdb1617502f7f2f030806522629a11977bfbc2605f41232bb4b8fc7b671aa075a358faadf5402ede6bc9ba7d4b1f069d7e829f806ce293584bed673b88922b44109cd716bfba54d81285ee419e10c7c6447c1344c1d6e6b3c6e5317cd6c654e508146a7cdb4829c76381580fa9ffe0866f0cf5abb75a9bd179af0705592ccde8faebbc8ec63090c63b069bc050fdeefc04272e542f07454ad4bf0fc67ed267b96ea29c25d66429e68b080c89ae2b679569d987a4f826ee817363b86a81944ad188f43ebb0366de3b929d25f544328429fc3c9742a08bbb3ccb031c8152a9896234e9fb973fb36f101bcacce82502d22cc789afb8a1348be6c5fcdca05e589946decfe42eb3c9ad44b2210ce99a85e47ccb4aad2a9154d0cf87a4be441ac144014e1d57ae60b590d3400b6e97ac7445bfcb3957d497a1aaa95470ee0b5328ec2c9975991858e5e4a3f3a794998cf68731e671b2c70d0f52fdde35a6b01df34a868c7b8b38dc03b5f28be82903475749e5e1961e034fd78406a081e6138224d4b30c918d89157eb7a743484e558a0beb02267fde11c672529fb6b1c56417924a70f002d965844bfb5f8f94cf0f1af4d36360f3b8dbc8063bf2ff22f3fa1fabbec436916f83df134484029a2e1fdd98cb33b0c5e49c6c67795b834479c751e382bb8115cc66f6f439cdffad33bedc8441b84dd55ab9392dbbbe1e89c8abb7abbb08043970055cbf1bef6998f0bcf249463673da66b9c3a7fd6b0e390625b866d12a2a0c987d00749fd94619dbd828e8b5d46bb038a9c8f43204ade5343cd1e9d7e3b0c9735496037d56ddc92450da81d1214ba969555ea5844ac88a3e617e94aecf11b290d43a9545d0cf2d125065084239bc7ff503f0cabe385a8065c825f9a4867baa6733d3792205866283579b96eaabadd9bed8dfeea73abe575241cbafc5c0194eaba2f0a46e597de3a6faa99de173e639333a9a5ee1c6cddd0adbc6939bd0d2ade04c31a6b1eee4ac3ca874e21c502c21f9046037dc0e5f5d3eb01fac6cf05c96a4bc962239b8611b505d73fedc32a7599b784884fcf88572e5b63fb01de6d454c0b044d538217eaddc5cdd4e584e260bf9f309c10a6029de3d5bcfc9a024e320050cd46d3b20319e85a29669aab786f4854b2d03ae71056d8bc4118a96fd2dc5600139325eff597e3c4a5acf2ce3c5db356deb21a747b44e98e67a090babc7a94602950f4ad73b90ec179988a772053154dba56c5459eedf61e2e1dbadc806a457f16c54b43b02cf8724fe69b1c486bc190bc5e6c363957e9f1e5c8a5e93db93cf2ad2bc4c50f912ec185d2b6a76d6e9cd0229cb2a9ea0f4aa0ffd021662f0790d022a6fb37f1fedf3b6135506aeec2246c716149abb1ff4d664164d769fe445b24c4fd24050bf4f5079ce4a8fe3c9940001a09daa618def39cc7203754241dc2215c2a82095ddb32cca0bfde61902ff4bd1e65c818238428bfe2e6f0c28e101c40fc4009e09fc1f28c5e4c388ff09deba98450b33add7f0ce9f620387dacecf22686b036899565a21bc25ba8b0993b8f77a091fc22e4ed494f6b9439a33c6738e2621e7bcde854fb690b9ac2376a85ad878200dcbf78e10871af5abe8eb995c42436e06e497792108c8c187d3c222606bf86da30207d1816050418b1fc3e9c3dfc7391a1ec71eade5b874322fa58f73c7b57b776985727ac1d94efed08afc0b74bde3184a693514ecfcf4796e1748992554f3e4754e2387b1fc17ccec394f68a6b5d1be3f0d77db749525355037d0fef0faf08f359d4ffbb2028ff044ac76bed9be495e79b27c8f0e66d683126be09a81a1d82fe32d2cec62ddfb785ea65cfe27e02b82fe54a11ea2743bbbf7d596e8cb097a6a85ddefbd7fec7919c90ee8b73418303baa3f6e66bd96e39954b66598762aa435477c84bf9d95d9c4fa985d5720f4ee612eff3fbcf44282969b7125f17193842ec49d57f2558a456528749d1f9159d9e859cddf772d471d853e2f27feb84790b72a36ce70bea123a91e7db49f6f5bf027fbaafb1ec885bbc840671f30ad23c013fcb43b6080e76c5728067737b26fb0492a3bfdbec1967b0d2e64946aed3f7f12578edc0fd6936b5bdc0dc89fdbfe4ca331b6700710d96719ad529e4ec8fd7b2d74cc3011f4c08534fc8a8dac1505559ff44eb1e08e9c63d02184dbefd58c7e79bfa137f1a373e2edf289fbe186560ac54918f5bbbe4d85bda18dfa0e19f424c12ad9641d2b015ddae6886fbb3b4c3b9ec6e0664f2c53780d528f695d7f6e3817637c4e88ad993693d793dd5a4eff246c6cfca975750ac40bc7490c90e38b65e302ee17d2fd1abf53d387c0f4aed489e8d7cd335b4f360ee5da5b7736a998b7c35f2b92fd2d85f0a9e06201fa31730b63d4d833752bcf3c74602e7ae964824333d2a0d9f486cb9df601ecff2ed6996ddc62f19f5554f4b40b6301d793df7f0e255962948f190a4abaadf43cb81d128fc8a157bd7275fa8a34c3f41bd459ae6d0f88fb9f47072a3b3438257e11c5f456f0f45643263883eb976dff49898c0908483e03e3a47ebbb7b97fd468f5662f44622c950991b754bcd28c56d34c6ab6f596d6ed0b9ab4906de99df622bf541c9687c7d20d7ebb3c64017594fc1c2e23fa190214e04d04a89e7101358aafaeea9b6da86fc0fa1e4be66ab2853580704ed9b3c322850842378fe526b52c20dc4eec8e721ce020ce18529c2f8aff598d998a3d90aa95a325d61c8a73fb3e3faeef918e2729b4f07af0bb02feb48b34aa4dc93b383548fa99e0c78cf8cd04ddee0dab3cded4e5e2517c57771a6063a35416a3988a5ccb9196eef29e3a06a93500ecccb91de9a47add328dc64be1e04062f8f98fa922bcb0a8427067be4a324ae8afd4983ebc55e42c0baabad1f8ac7efe592c596dff09aaa216209328f3c1c4ed65af60bbd98abf6450803a68bc96e0c4be312d75ab94daecac2af752e683e2417a15460cb0c8a7357ec1771cc7341be882253e118d4a31f94a5be645c98528b3e6356237cc0c49b25628299de098ec491e06026b155f18e460be0320d82e615ec0184f6fde748f9ef4b35e72ae2b7091aa290bfaa1d5c5996526db38158302deca7e92b8c87b718f9f700f9fdd7ab2b30c770e2444dce15c4fe94caf9a0dfab1e889a5a0d1957a6f704699619d86e78762019e2ec94c93762bee62bcce80739715e5f0a82417edeed76647bb6fef09fd92d398148be135f0a15c7726b4a86308c2cf49954166eddcb93508d995f26663897acc20c7d6755f520b2db2f791c6b424bd8a15789021de9148cbc8e35537abc69b64c15596c0269be4a02bbd271162ea42d051ac5db15e45ed210b5b2abac07336b113cd3a6d2ee5078c1a452606d8b8e7b366427a6761960ab2a8d490716df986d35d0b396ea420574bbe77b7f0a3841dcc128e5742de3e7ca448c9ddd9700ed2608474459e0da106c50e483b9d62887c7acef2b684cdba73b675920e2dd30b84914b9fa7100c73625b33dea9f6db063075117440cfe4324dd525fd37dbf96e4f8ce3ead46e13ce479b72c6473ef110291a00633dab7efe55492406e39359a37ae40de84c6dabd8a1daf9dc84ff3cc70d73bf1988cecb51b15f02ca4b2a129e2a4b743aeb25d663d680465783e71096756d26254dd4bfb2e8f4d3ee8a9beb0c936bf9d0aced1697539d9ec8733a92e2cb3e8f9021b23549c9d16263fe1d4785f07c8585f6fa013050e7cf29b87d711aa11f5604b3ad9107eb9f2b5ab1e0180e8f94772d2769631fd9eb6417d2fd3e4b7f7cb1775ad216ec53b5efc83d6a6457b658f42cec755905207a89e3ed0236ca6bafdb4fe078239dbcabd06a0f68a8754ba6956f4ed8abc2459a3201df33ef7615d84bb2c21be67cb06c7af7dd50ab03bfb2c304a8e1961429383bbc01bfe745690ec10296af004afd48de36ba6d8d80e932904d7e818992052036b145244b5aff154a338b866f49aeb16bbc567db10953c7e3cae71d0e676cd598878d39f78662e6be9db8988ed566e7f619f775e9399686244ad912ae7251f5004614ebb40882118f3828f3fd0d6e56393d6a5909ebed13e354f3ea0b95d9b438213ae02db29c8665bf8a589fe3c2443d82a78f8f9c7a0ad04e5773d2525fa6e4d76a1104d0736832c24bd5fe4405e2a67d329df486361832ae63853d461e6776812246487a360bc787f2ef39001e8d96b0d06c6b687be220dcd6caaee3eb168b37757f4a769591ba65973063ba3a12364325acefe6df2f726b1bb2f27f043ed0133334fce3493efa8167ebdb8f6cdb34e09b7fd7c1ea2c5b5b225762fa521a316543a7cda4a83b7e87246505b7bafb64e154a7fac09eda894da098ecdd33ec9c8bae9d7f44cda34e69d3a18d813135b9532c91a35ca53af5c982183f22f39003fe8a78768152b85b908d3f4d2ea9b3ee8720fe61384f3e6d2a519f8dac24ab5a8f7db581b81b512d70e73b77ab6d44367e35253f222cfa260227a55c60e287a0ed10d9f9f103f0ef837fb81774b17b5626ae79b3a4ec7437a38be7430eb4a21c2bd2440ac907829954c3cd6124f69f60f8fe0c62bc088f8ee7e5af60722dfa932962b187a47fe290dac9c7b7a004e4c90fa33099e5a1daa312c516330bff8f7b94fa97cb4f7211973648ce70638a3fdc3411eace8678758d7bb0d9300f229ff7dbec32ef150da625d7797bba05126036e6cd2c4179db8455fb2c3de5b8bb7355f9ee41a865d607dcf65e5b29fe96dbc3c8a0dbc839fc35f3df760d2cf9f748fb45478e627d4bdc21f9ec55276e05f8d2fda664c2803c0631f6a6e185cf2e5f7c7204cbb799d3f99f3b43a9343d15c544fd83f5ceaccf9f1b952d2456180f9ff5f0d5687d2886d7a2940c83f27141eda18551590c15547d141be700253c2eaafd7d34df4e61302f56f1274819912cb770d5d0ba98002b3832265d540b103a52788e5b32b497ca66fa1e9c587a18582f0c094c67a44c9157c04ba0a1c4a63d84b9554b7fbc54d1aaae399ad29f1fa78e2b68703e3c40c97b231a845542c790fd907c544c507be3bb8860b1c85d5d9e6d64b1534c3d1f6f118a7abf22c70f4545741b9d66393fad17fb3d231fdf821245b91d093500d5eaebcbb23a4e3f3699142e93c00e0adcb576085627c3bb1d9f471f64790627106d2043ed3ae8efbbd105a340986e0cd18c9a9b5be1062c20a08f2d7015e8b7391c56b72b0689e4998684025ff57b5d8f0407731e32b62ae0ca0e5b66bf60e3fabc0c4feb71ea852a69f29780170bdc1b266b2bc00379ed4ba69783fc012e82e6bdfaebc419c41506e87f3ff666eebbd310cd19be7ef2d39634d9142b491c6577992f616036ed4ec1a0f2e0baade9d5832b9e861d4eaf2af554581a4c27e534539086e218c6caee285aba3830831b3d6e795341261201567777c18780fd57d1e016b3ce6eb1b7452cf7cdd4295ad8abdc4d328972793eb180fa3aae342809d2834dadbdd27c57a7fdd34f6a3b402ac4b442c722d7caed05f392835b030f76c33b2658c7fe09d7f042adb1fad84db28456bc15a6528697a3b224bfc8a61199688b45e0e9c52a9088ada3c45e32515685377a74e4d46f626ec6587858d336dcb6c06c96f8d6a709719aec994b1bffb91a75f5438a1c855acf14629f32ab57637b4d3786aacfa4b2df95dd7d79e1b4ba98ba885cff88918a78463331fa1d9e3e1b847ce9ac75afc20ed1726ec4d5b214de17b5e1cc68679f28eb6f99f07646c0f72bbbeae4d1eef1efafade2d9567478e4ae23a3bbbb6f79f014efb3355f96af7eeb5a1e62a32c8966ec44512986428dbf5faf323bd1b249aa5b2bc3ad36594e63edf9098904d719d1af75fb67ed5df52124c66d94dd79839715dd50f1498da17ab71c4b12d994a80e4a52bd85c0d75138a6451ef7ba21bc083170919418c5ae8606fbbaf322b5b485ff89d516f5c471b33edd8effbb3eaf3e4795391a513cf591e3f51b239df4f35889475c85f4ab80e9132df74f67c887c9271ef67fa94bab297517c4ed4b08fd97869d06c8127f25db8b63b7ea0f7b68adc3e3217127b7058f18260b0f77aa1f2839e3473604ec773a0b9057bcd0ce3834d894157b8dac1f7e0d560b234fdc467888774eea41f5007cea94554deffbe1ebda77e3c0a91b62bcac975ccfa41cd192c8f785a6dd81e89bb75859b8f89b3160dec2b09625a4875b9317fc8d77b3863dcd06ed8ce7727fea6c19699a03a9d5686c8813c254762dfa9a7a55bf089a055d82d1c770ab0876a55cb271882ab9f05e9c913eca264c9da0435b5e7b2af050a7e44b812e96e32c4cb3974d13f334b7023bc5e94f5973ddacd8ac8952ab92472936131231add92a01e5e1883af30ee3b9fb60309884f7f431eaa45f54547eca336c5a7bc0bda8dbb5ee247db68712210d3bbba51d09e5427bbeab1e49524d15a8b9fa262dc3ca9c0738dfcce62ec7843592b5dc99b04b5cdc1d523ef8afd17f86c8b2660f367730ccb1118a62609bcddba33d555b112daa511b81a627208f5ea30cc0083649b9789e5cb2f96cfa27397ad9936b6d5a9648beddd557cc79e174caf831ca0aa8e38fe887cf1669974715e85a5be7457aca141a9a2908fc81ac320748fe227b97769714606cc13d4ebec58e82f6646deb48d783718011eb221044caa0cdd587370db3f92bed5f44ebf35fb0057d89767400001b0d12219e8ca533c35c8792cda72fd895858070d150eb0f559a9cb4dfd8d713f6cbed2b1f569a07111644b8b23e09ebf6e1525b4431dd4459c47017fa690c4b380e8321eb4d2194add434fcd72a6507883de1ca1c7d50bc1df234e18df0b1d249b68147b6a8912e047def216a9dc3b250129f5f5233b397645c56ff3304aab1344bea0dbae3720c332716920c53b8281596aef706d596115686eb0485f4634e5e094aec396360e07fc9f7fee1827e3fe0e1ac5029f19e35dca7c570c45e4def00b691b426d26d1ab64d7dd740604de9f55010e862cb56d7d822d487062450bf32be3f152bbe824231976bbe1df151764b12029a09d67cc34f57216a70b23d3ef0ccf948c90953632d053ff19e267b2b66a11a7d9990f462f892a5c6d4caee7e17c5e54e9fe5e8c43ca52fc383d2df58d81de0fb96c54a21e9f2ffc03eb679249a77c3a2a71a120f47e26937747c1c532ff7c870df718f618b74c6507f78dfa6def2f879fb4fad65f5b05dcf65132a13cf8c2d994aa80165fdf331d4b4f699dfbaf1e3d45c48ed4930773576425f562166e3f2de699d80c28e1d13ef0b05288190847157a779ae8dc475e8d396d696cd295debb9bb3efdfcb48ec350ec50249414d5e1fe3cacf0534ff4932bf2803b71990bc78e34afcd3e3fb3b616663d4dcff820a52215ac20918470f7c00d4bfe44170c5eb586e695606d3bd6ff8ecf38c1f1c141e94747642bb7c7ab1b83cd8d0ae36f5d1340b88a13db514148ec24a4c99cc416c22929acfdc54371473c9fe867118375eacb18b9c3918cfb895e6d52c67dc3ab666695beb7c59213be5988c1f2a55144020a3354f9138ce4cf7917110b2636f180b91aaf1c473b65da8dc2e5230c7886135ae80cd85a79b4bd1f30ade590a49b49cd6a70524994de8144da4078ef2e24f0570fc592ffe3fee58c89e83c261442812431d338ac9716259df6a63f3bc6878a90293065f8f5ec4b37ae76a5c73329090152e218cf739aeb611e39ce87a90fff4ba82ed0b68189db1da577c70c7495f15f48183a1080a68000657a5fab13b5327770d72eb10ad10424146e57e6ca7c73c9e46bb7a09629e5c66c66d83f4761d5fda6e969ec65e6fbb52ce8495a333a9496ecb72a8d9d031f997a60b24448d5d7c7a63fcfa409b74114c9308f19d7c495e5c2e6dbd4866dff570ffac7c07e480822cc0b202a655cde4a4ce2a671684ccbc67ada15b69f7197fd76cbc225225562b413506600523176439a435fd050db28923a0dec2fb3bb536e075cf1360debdd66099ee01a301483633bdd3aabca488261cd46a51ad9ac9262c9ac68500d47dc7381480a0d61e6ea6c44fbe76482333d93708d78143f2dcfe8045a21a59e75bc9be1a1c4d6a737b6441c863dc1c8fa41372ed6f24da96ca441c7afdb756d6de6b3b32765e0fef4c30f239667c5ea0bb70baf489338b522453f2a68d5bfe3d26f2d07223f802bdee460beb743930857792767da288f373c85acc55e13d1550cccf090647516dffec100cd11b0ae7d4089e77db2bd293d78543c5d449fc25e9fa1b6a195b702b02f673e074575014e75d2044637710af80f98688dc22ab23932e1702411397a2a469d3085fa12086978f761a276666ced9c364a079925e6090c3f72f1b612a879dfcde77c13cc0c4912af6a8558abc23cd9aa3ee0e75b5f59839003d7ba6dcfc2aeedbb0f5f16bfe84a9b96135e03677857ad6d439bbff152194c6646f6230e06f66d1431d5dfd6ec1d6dc9fb6d9c89197a3d1446b7f942516112818d8f2e5f8565604198e90e246d73360a84a2da5f243af09310e3663ad66ef5376c0cd797b503c87aa0f6aff799a86106eca23d08fb18578d99497ea987c721d4bbb8272e1e67e826fa6a60d793c12b57c5f9182d4211894ec6073fd61bbf3947ca0718e1813d21543db284a5eb1e44d058dfe02c529a963722b8dfb705bee130b5759a2dceb65c333bc9c61721cb75e2ff53b3056fea0748d269aee48cbce36a097586b81e99d1ccb336d2ba365e8dfd239b1d1b08d425569437f5a315660ee2bf6ac1a977850ce9930f90153a4f607d66cc64ff0a151be2394303dcea9fae629e474314fc75d225c546b5eda8b7fd25773ab5dddf720bef8f6de7ce9116d346f48ed353d15792a6cfe8e84869da07c8eb3cd4910051d3dc42bd102c243097ac5873500f29a6c90e39734fd72e1e4c62c19e454b90854f74aca04f8627529c708295038d5c72235fed31804c15c8cf9257e361e1e6d91f0b3a53a2e6b4381d905cf209273607d5a65cc9beeecb816a59b8ba8b45d6c38a849816eb003d1ccaf5b1e19215a64e76ae5c6c8cb9373458ea218104e02d7b173d180e648db75fb1a6fca6718bfcd271324b3ed540df00a1c5c0684c5c18154e079bb258f1bc4d6bc916e4df9d71bc77f91ea2a53c5986eae8d197e0a630066c7eabac6e35d3458c201445f26a3c3b4a6e6f59391a18cce79ccdc01f28701a27fdc112bfe8fd59607f2a5c2dcf7f86792526c56c6d04d3ef8f09640d20ea381fa507df7d616819e3a404e5ff8281ddc374c55bf7e4f7b28306909cd720faf45741de2d058e732f906a69961ec2ae8f7cb242695a0cd79f22d549cf046309b771987d0a602b406bcd81563891c2c85cf74580cb30c807c21f9f6b1a823e130d25fa0780edc36d0ba27b5d2fe47f2bbfbedc0bb53b73ae0ce3cda25595e277398c51b5298009ee4236b1afcea1555302d1626a07269eecda1fc536ae92822ac1062d5602f382dd1ca832d707b93dfc33ff46f470a841b3a5b7302700a23086dd1d2113f14a46dc19d7e7c38472597dd582f0938135a0758d6be010e659466ac32e7e42325e32d50cc8875d689ba5dc9b208857beabdc3e5ddb99b361e4886b94b741e07c5539693070adbf25104df458a0c51f8376f5d7593acf21c42f2afec5c72f4461b5fbaa1f9792ea9399fde0c582e5cae2a02fa9aa8a1c944ebbda4ac824513a34982203c264ca6fddf066a3551bb60a17185801e2336b65a2cfbc76215af1ed1304a898d36893d12bb1757f24794fc4b1080861ac70f075e84a6a86623f84d71c8d6d8f44409af787b0318677ecc23a56775d89d81c92ce1b4a92625dbf4224f568018895fecd4b404cd2e613cee3cdd315550aa9495efe794988dcd4e759675ffbe23db0592d3a2229fc73e7086081413cae2a514694c595440c0cab9559fcceb1e500bc8cfc2a83e47da5b16d0c283f8bdfbc9673a4e69acb259fd756429ab5e922b5fbe7feb8dd3ecf78877c5feb9ac097215cec9602480bd5cb9f6e772170d93626406faf926b79e5e2b3acd8361360ee56fd7bc17f5451f9a2cf76fbe1b107fd872436ae105e28d8f48ee8e4a249e809530432816396dffa6f93c2531cdbfd23ba340851fb4f8134fae1ea9cf6331362dc835a0af9f7349f5676d94a1aa61bf2ef9ec9684e8198faaa1240f76f23f8f26ffecdc188af75cbb9bd574ff0fd7aa6f144c39bf15e43907bc2186a5655b860bd685f8c447677aa84e162789e0da7d64ed4dfddbf24b2b4e2a41f5ad33c8dea2cd68774a3351280618450d67667b7e8918656921d4164dc236656f340f9272dccfa80e315c9b8d71102298fa99f7c3756f4a88cafb72b6253424b1f0b5e98c0c5ff99603ca9da6cbe57dfb807dede5baddc0e97087ba6cb76459be7f272e243249a31034bbbd192b9724891003c6401fbed558f8a99073030c0c0e3fcaf4463d1691dc6af17719c7e4a3ed2d0119135839893c24556ad4f74748f9534314a89e0aebacab1a5f0713576a76544b5ac711885e4d91191cb1ca778804d7c8685728d6d867c46cdf23645ef169e8bb506e426e995bf7cdefb855fb7c5fe42c4be0c07c1adb327ee20af9394bdbd9719576fc9d6336bde9b3a47526dc9d38866e9c8cefe961406979c8402f2b78e28e6a680cbf352e024467957ecd4f4d838e938f98f80b1b088e526ae278943159ff6d089e3de15f15313644490273585fc9e8e318c3cd382a58af3637bf5279712c6c93f3218ed43ff385262d5f04cd9165e319e0e02042ed98c0babe5cc317efe83201da6701cb2e118d488ed502ab3afe7953dc14a47f65391a2fbd0530309d509d1c4f14e1acd7eef2fbf95505dd11b8c9c61c8483ef303a7baccf0e6be7b6dcfc40b822d984c4f1bde19538132205c1c382969a21f8dbf35abea05661a03bc2c8dbba7d8105b7d0ef43f6f4ee0ed739b1391b963e13c890d21c385f1719da9567acfae93c973cf052bbc3e92abc62c50c2435fabf2fa5be5e04a617f7956b43bee9794df06a384317b15f68d0a60f9899ba8de3b0b5aaab6f82d6319b3f684e2ef20b6f34444f9918d8f43d5da7d8e4eb51deb0709b33f06124774eb0ac00ab50dcf3768a529ea4bfe0cd0a4755569b89a410435e3aa82e4e98e59d2dec7de24a04528b77e8a54c1471fe7e712d754a20e5a5c784b0f79c3e6ae2ecacb094e56565e79ba828690a524d621ec94cd843ff1295c2303640e70a74a6e6104ab163755da7ec16be48abc317cf3c76e1c37d2ff39d4ee2e8d9894eecd2c738df4a250c8217383011a98202b21fc7113ea837e0a0de016a94d3e53c902f202d7ae7c122f84ccbd333b25bedae128dfa7e573270a01e29e15146940cc07cf877b0a3febc2dd11de0f4fa1a5dde6cd1ef9dec4a7c467d63cb24d902918dd2397ab7de4f60aa7b50ce4569dcc193980fd5b0f60fa48c3b762c39a181b983e55d7eb9d15a8939eb6280a59bb3519339e4f8a0e8e4ccc4b047d2abcdc1ccffd9012532e925c62e85bc9dfa355b7729cc4b124647ad844f0b55140a3fc585a546ec5184969a7ae3bc335beb0f083b88f5c04de5de0f8a04a1b5eb9f6e1f98e792045aec7dd4f63c81b7e121dfb65ee3bf75bf97ebc45ff8fa4079ad351eee2f0866b8f17d80e2409bfe58bca2122deedbe18c6b7c4bba8925ec62626edc6e9cca76279facb3396500b8c2e55bf06b45e7c9f0d7ad2c6ccd571dbb8f66b174eba75b0de317ea90a21186c165ede5cf6777c2cf4ce24f5948f633e88b0e75cff7788ff0d28e54416626d629a27c452521540cd5a220c7396842d8ae7cc75220b52f385dd63881fb6ba5348518303d38ddee63a0e53737037015dcd12deb061140d97181b1bef8b53ccfb0ba9b4978b4819864a9111f2179d62a86e9797ea4cbc3722cad78cbf088f2ef90f787466c9e2d2fab394a746e6cd6eb236538ec6a4e8cd9c4bde5e36ba98fc65ed717a4840b8bcd5596473c7c9d2333bf80e6be76081e5354e3b58cbe347a129ce22a03dc15715d87b0195471713e4eba67e0b68302f9de59d9ed5e7af4b86396f9c527def12a18af05f4de8a67de41f25a0222c811647431d0872458e3cb0c2b6e205185ab179894afd15a0127063ebeeb4255dfc2ea6af9ae8cb6884d26f6cce82bb2fe560f1d267e369271bae59636e7a8866a82259274b14477c0d7e99006cc02611a0ad05371838f81c6e765e7f56f27b56764f3f759dc393ae7b7264d0463f21c042b5a41af304e7c17e4657189fd5a15b030b6612d83dd9e87588e97458b444169c6f546fc5ae83e3a05b0da73feda380b58f910cbe7055f387cab3b0f28b07d311f075e72cfd573dc86822db3831909c2c28de29678f5ff4aca6f8f8a38676814f3c3f7a60590bf46c2e996868b5b3143a8a22eeb4a4215d0da2d753476d6110dc39b7520ee4999da09f5eaabb4bfbcc8e291f3afa378810b55e337753e38b81aab1e218bc0edb4a0e88f12348c761f2e3ba7bf9acc84e6b970e04f5a8bd2c84e202dfff2eab6a380902f5b29cfd2c632ff2d16fda80a939cbdd3b60d23247a16bcdebdab15a763d5f289a48fb995fe63b77fd54d2461dc0e4d69d0f0eb34b72e9c2f70b27e2c4c1b5815f444b85189ca8735fb5b730206093035c53726197357fc8e5711aa7363462efd61807fb7372b03cd46e48c952d58a880cc0f75b1dfd824832b20c4181462da9c849e5de8447836db728ed2aa0627466709ae1411bc8c9e80699ec9a92ab60f8c32e296d85bb9ca9ff972e2471ae9739e5fed0edf2f23964b2d3f4d9eb5eb5428b53f0e872b44cb1257fbfe6246765cd637ff968d1110d953fd2c7da50525f4d6b4b410ef854252c62352f0494476982182340c515a2c8cd4a9a615ff2514c514aef8675efde0f2af1c979cb755da43eb340b7c1839254ab2b4d2cc354ac2be5947204f331855c13b5adde9335867db66721a82e49c48f572f09d58b8aeccff2cf52476136066e7637602680926ecc755735dcb5c96130be419698c8baafd29924be8e82ef70b0feb77b80b48fb76ad51a59ef6230629881952e4e2c22f84589c8b46f15a9b9f6fa94f911f8614e8ec61b74af96162836c49fe7ed8ea86e21eaa75b01c95aadd7ccb5b6f7e2337bf4954329e49b791339efc1fa229e93e3be7dba9ad0b9159fdc9fc8da2007e3033fb2b81896f88573433eda1a37e13ca1a2a7a960ab60c05d627d44145a8e0a9902a96e10b2fb227aa4c9d5d015f4591f678e9ab270bf4d997d8fdabe19cae4ab4e13f8f650a0b169fab70719dfdfe7cd533171715e80f576d4f6abb2feede394883dc4f85d0c13c23b2227e8ec711608474b384774c523d5d69dff8d429f6dd1fa67cd73c36c3724de2a0cd277a04da7e53fa6ae05cdca726a573f2c93d682c5d28bfefb19be6dd21c251d705786930563cbd94b3eb886b76434ee68205a5cf6df01d22b487743fcf3dadd5fc85dccb2fddb3974014e6aac675df8563f2b7ccd9fb97fc62872af7452504ee4d676399303486ca431ddc2f1b5e54a0f13a6429559ea34beba844e91073dc75ebe7f5aa7ac81e1ac76a8a9c97aac7d5b89b1e2a2f30012ba84098559a5721b8b7682881c574c57e60c55a38c41cab5ff6cd1ffe3e91321330d1e60fa8315904444c353ed0e459ac2882937dab305225622a3458da920b5c55edb5337cd7f7a1206baf482da6b7007971268463c9dbadfb161a9766087b975ec7d3f8e1440864fce4248516f397265df8d75eeb9e62ce446b6e637fbbea9f91bf277e3849d26f64c7f8a3a5f762e21d0536d60c35b5848db4a0f3766aba1c9c4cfaf4825e35fa63bf39f34acce6c3d14e998378e990a48994a1ef4891e19a3c03d69f52e9b49de58e5acf2e04042074feb123ec355c290d292a2751862d7a4440d64d8afe2bdc8511105fc551703640aca37102ff931095ad901c27e18f398cbf780f17a532959d17757d6772a9e4d1c2083f41f7c5085fa0c3b1630ec0f19eed40380cbdad2b3c4ce65f9120265424bf7038be936bd29b0bf3ec26d8d5349209928adb07f8f7afd201357c9cec7aef8b390c77eba7909ff90a1ef616d6d568e306a0c2db88b27493b977e45389ad4c4c4cfeceb72bd9de4e688695f254c83640aeb44895dd24f01a8b08013782a8525c5d79a96d2916a974d26f696a7742e00d1461672af2148270a1c660fb13c9e474298a57692e6724a0ac5b3ec3b1a13aa027bffe90a605ee08e23c1246c629856108020ba1955f0b03ef4ee81575fa563a454baaa252f1fe16cb067d4f02f7fef0e24f91c27264d2e84e56e246d121320cbd131907e04c21280922fc486592d6abbb5b357f031c7dfbcbead290ced9228760f525bcf1bed0e1629472f2e3989610e5528ea0d5219a82f5dc47e68e5f95229eeb032c1289f81d869220a9a99d9c1c9744262be1be746cf1dd2b076619849dcb65c90d920c11501eb91c5a1cf4584294114f5a7dde26ecba8537dee218d239f5474f326bbbc20df03d1057d08af13adc4b8543fbcae6df633fd218203d7f646a5c2d7d9c6c6fd0b24e52dcb8209d79cd746bf93b30c47af01a60b51448795909aa60ff2a88b6508b274e06c944566dc67148c47bf6196778fa9208b0c1a5e40312871c435875d703583da08436fdd2b71aa8c8e7aab8ec546662d78834e0adc7bc86e4fc15538067863974505971195515baa2e91d020cc374ba8ddd80b30bb3697bc7b3759ee6c508fe1807a4eebb60f3ef50f2a90a9b4c8133392824d91970ab6afd140c88572de41519e03337f204fd32f487041fa28f1e4a444b30b2de460168f97cff5ab3d2cf6dedceba52b772651eb2ade1ad7b467dd5b67aa4e8ee190149a92593c0ed722d4a04a559e30acb52bb466b1c7bf005a11704c059edc55cdd11fb097fb37c084ca6e457a8f88b549ff4a8f23748e056d298347d90540fc7cfecd93dbe29f404d42c8ab0b2e3464ace2dc009b7c8367816af4765615c608a0f86169729b2ebbd69f368bc5e01441fde7abafa66289d66d22d504f9f0c2614ba8c553dcc284ac881102b6a1dcde4b334c00b52141722df9bf5a03399131a064c9b3c204c97bcc6353955d18bd43fc591f448164f852eb388e5a8f837929b35027b8e7237e4aad9dcb6cd8a8ba450f36473058aa6022eac4babcb758bb118db754727f6bff59d71a1e4a9eb9e98a95f2b700c9cdfbb30d02a3459b7e9edacd7fb776eae769463c4de35f9e5b5fc01c58abb5cb4e6db6d12b2162c749e56569a11d2e670e6d88858239f5340a593b6b5c66f35f43124cd8ac2ae957bea619331682d8397a61b47e955064b119728fdb069d45559b0b3e37800728588c22f099c2f295827e9d5be5132731fbad258096dfae540cb11e1f2d3a461214873cb3d469b12a882ed96075b40c98b28dbfb4f2227f81c59da6090a0a851ac7be383847835905b04a0a2eeceaf0fc51b40a7e58907a5a6dd7832fece55b6579661cf15e57b51c68a5b95304ad5a5872b2957659db8aa4e1b6c3dccc3a5832523efd12caba7c41dcbd196faa227296043859f4de098fe8f817c00d90b86f3669fc11a955faa7a2dc1a68975998e1362c832707a0dc75e21bd0ea05548ae39d84ad05f03c1ca269e191868db4c57ec375816254d5c39e2d4cfcca1226c0139a5d96b4d0995db8217255201b7362073f76188550b529797aa42221a0d6748b9d375177c8f5670cd03adfdd6369ce4654201375c0a07f26bd1502acfaa812d258168c452dfba68aa270308e76ef40b1aa15436179b809341a2500a566a8bd54ca614fb2a245de69e76bc460e71823bb569256bf74d956f516aa08d01a1fceabbf4feda1cca25e75225e769825b608ab0148360d32d254248c84eb63235a0f91a0bf7c0c76b087b14987dea881e49a263d6461a12a35908a2190624e3e29c9fb093d8a0213eed48acc825c4a1d438d888ab104b446cac7dd6d4f89ce8ea0cfe1d703c97da02284dab0bf5234478124c788cf2757b1c2c256726662b8ac23aef5ab4c63edd6c5d3ac9b76768b57f2f79ac34154a32566e8c853d97bd66ae198459957c392f5cfc8d5b9171dc2bbe1e8da10ee5ef33ca2404d9715f02a480b13f69602f7b1f8a71e4ffea55b291fe852ff7f431a8c01739f22337c7aafa2184ec48159d6ae44bc1f9d3ec0de5b5bbc8dba36352f332a77a230d6a07a20c0de09ceea9312dab50b020705752a4704d945b9d066e2bd2aa86dfe1da8d253df3051752a3b76650279023f665c6fc46b01e9092dcbe0261a18694e4152550d7b4474ed0d373e1f460ad025fd393ab7035626755e1649a710f719d5b83765c6904cb4db7876dccd190db378e1a8973ff85354f9ce30136b62a729863bca5cb4aadf40f1bec4c8b9de8856111d24a11ecbd8c895059e3e823709b4936b5e86588f306f0d6eb185a4ef732d4d78e92cf3b23c2278fefb3b383feb8fc77611d4b17e136c628181f95a2028f52c04f7c3db83ca006b4b92f387cfcfb6631940c07362c38161358c0d5ffd7b7730a51acf034c631fda932a4530133a3e4f96d47ec4ac30e7ab464b4e241325e9651e86b57f5233d143ea4aeb45f06cf0a79d839c504d53470b43052bd6825a75f4583310945108d6670b4222f0eaed306e293b43412f883f88f93ac99be6bdc660ff70e450d6958bd5291f179b5c6ee8752d64d6c4c359c08d69e8dd41c261197a4abc33eca8c576bbb329057ae87976364f09f2c4b78ca79a80f37511027f4d1e9791d8ffa3ffb0ccfaa1dc031178cae81da62bbb7aa3c934dec1dd9c191b93079d997b28f95117832f7003d9c16a377ac5767b968f6dcdbf907c758f5c83ad0a55cd30c59ca94d846d8d01e15cd9aad9cfc6ffc42df2b670901430a48f46538d7c997e430703031211610b0d5d28500ed88811c977fe40b19a1d68f3bf3ee5dc003e3e95953d1e80fbe1d910587821811f5e6795eee6ad218a6df9d9182a898209b0853f9abd0bb95bd50ce4d6fd5ee00172687a8e508506a28f56fce7302ec4724f8f378efdc2827fe58e128691d375d2931227ad60dbd9d6c3f74f21b84a8633d5ea6077acdf51803c379f032bf45a3529976fe2d9f8103be28eb0cf3c63c868e0bbab5c8b602d26343ee998740ba06ff74f797fa228cd9a6deca6a723cb2e06e65aeadc8753fd99c1c3177765133874f4d558da2f5f20617482d531bbd83b8d461c154e4d13663cd57c618a81f906dafca2355a597b621eda70b38752b2c7e431c21114eb49643e0a1061847faa6bcd70197f5a4aa7730f16e6fc1dff6eb039636b9cc0c970cb0b1e310f33012d8585ca896cfa467b6b334958c3da4ab8bb76173eee5fe7f86100c8a83c28a534a2ba20022d770a0c997a8a3a74a44038398a288c2a954b90eb288cf0a0b003c9c0f320518f1efbb1d480ad82f8b8b8ee263eb42e168b260a51af103da44d29349ec789ce1bc4bce03273311d04ce6f9e3c79a607161b743ca8aa06da351c1b5c93172430c066e2b3a29b6eb507097362b18680f06a19e3ccdf6f3317335fc11f66044c31fcccf18e7aa522bf5431f89dd6158075d26164b8bf4187a8d9ed2589d9701f0096a519f47ae4d54cf5903e68e1d54a2b78ba5c0f0678eb4014507a3e46327a9296c6d847c5a627c73abb23a3c43749ab89915a6699d422d12eaba308a9a552b051b59b26406ad49315bb2310b3b9dca4af26f795bcaceafcfba71b056beaa02a1bbccf166d3454a2bcfc64336f90c2ce4fbe1269e363b40a0e37c4da3c8f2d24fcc7ae61dc25db18d9763ca92a2b397f0a1d7696b3592717c514e5007c9855b5c59aed758849a59785e80b24b252c091d73197fb97a7fcc19439054f0a62fa5e95ac9c86b7a1799a6bf39decaa94f8d00df1241b757bbcfc6c289fdf7e285b237352e32de8c85b62f20b92b0b0e78444aa346bec7b92c2dac4e32f20edb40ce009af0c86ae47c7a99140d442784fb966bba7a527a4c969c5008c37cd2ab5889a42771a9fee73103e9dd171409995b5c638d81d5012c84ef8243758fe51e0a130506a809b7deae338875ec061e58a75e58f028af247d3cbe9071d4e41bb6c4e326e17adb3eefb6ede041b8f5fddf9db84a400b1c271683cb6effb186ff6b247b60e198ea2b76a8f1a4ee1c4741ddf275ae298f94817fe6f82ac7bc04aaa43d7cc8e46514f1ffd1c149e6380a609e24419860a346451d273aa814f59eec05a8f59b05bd5428cf4b64efda45e58a1d2342a7ee792f93a08b952a6e66d54afa4e00a5359a802509ad212325d7eba339b27436c63f873f2c6c099d66725fcc64fe0b216b885a66437a7c42ac5852cf6fd6873ee1a79ca17614dae3c1d4b01c0767c317f556a663df9a17fa491106d7aca10204001ba263cbdbe0188550113113cc78b7c4a75a993222fad125761df024fc1d9c8c53b91e3f9d83efa2c349a07224ae7be4132dff1e82c5764ee3e598a5fd5d7cb4fd62f73ea4adc0cc99734ca049e0f24f6fd57c92dd4d34f8be07b798c9236053a05b347de99493137bee07fa140cd6c1a53582e24fc427664271b6b8f1e74209641d42f2207e5185ef842255c5e3b35613348f2c94c296da43c9f68af3143e0ffe20262cbea75d9413a8dde31e0085bf6cba22c3136e5fbf6584e4e926aadd7d32e1186b5f6357d981897d481509e68987bd0e86647cce2c373ec153515a9d92b6a1e19121c6d544147b03cb561386f5e04fb2a23268863c63198866003d21a278aef307922e86c8e32c1948ef82018c2396c10280fc916d43b8e49be7b1fcf8d2518d49dd758c60e800471bd34ee2390c05c5249ad41d576b5d7a3b430c6699eac3384bdacb86d5249717bdf4cc165be53a19e513f11f393044366f0f9a40e72df4ac889ed9f91261aeda08b8a59c58ce6d5f4bf8e6a7f21bfe52181c188d3b87af8c8de9904226c2736eb4f3a88d636de6077538006638c7d9c06a874de1ac5a310776d561c1d715486cbf8d81b766507a0fc23a2efc801a84ac734749ae3551ff19139f4420b2ef3101e56ac6b325acff7a3976d1d44fc037017469ca91d61ecb2c7535eacb13ddb37c8789239276a026bf47d97434905dc0e310b6db29fea4b2551fe54583b0522232ca2a4d94395069d51e6b9dc79b69a1d411287e2fee8c5799adbb8e1c4295d87e4aa58f69b7abc2cf0b56cab77f2b651d5897b40b22e9226c15f1498887643b865e1251e94f74a4cf19121f5bdc728b0608a16bf8c8e7907be1ce42000ecb686eb94bd8c4e9fabcff57dc10af394d7f7bf0ad5beee5a59abe022c607a6805006987ce9663d9b1f2901e904614bc9acc9bbe0aa99becd0cada82adbd9656b1962feedf68afd956bdcfb5ee21f62c6d55e9b98d4115b9faa5081844c3f545df74aaaf2c177171ff4168fe369c9041140485a5d982eb570f0cb8a8507efa85da0ee1c1aa4ed21d0b34ef31174626627992041c02592e1ba3df8a52f79e8f480456794c626b8ea36aebc19fe851b50aeccb53329dd7132f16f9c47aebc49fa82290a2676aba0059af8812b1beab117f09088c0a739f305f42b17585a652aa254c10d80720116568b577ee6fcc849e9c95c1b93a591c9022f11675702827ab7c12001ac207bbb9940333b8c9908a07f04e218a087a76784cdee7cc8f998daa5f237b93cdbea90cd1691bd9ec587c030bd25e72b9733f6a69dbf3bd55ff80b7b90d0990d51c4db8f6bd2c91bf2d5071fbfaf903acda74d2d4aa936f2ab17a5d5cd6b638e561a08922ea64b4f6e49f186383046866a5ac888d74265f802c9bc3f9f3b03af083e57c23a2d5f5839ffb42c2b6124de91f392cea7d71db5433152f529b2fb6414fe38926b9bed85353021ee62d78bd7e4a01ff0d9351f87d15a40cf207766abae42f439b3bc0531d36c85147161e27915f01a572f217ab477153ffdbd73bd4f86526958172165b571c81c17c78d3f13474823e925edc62b41124ff58e4a21fb8bc04cacbe0c2ddaebb0a8523a606926b8399ddf8d278d6cb5e3fb56fdf2c4295941bada3055d94881a1de69a9a9eb43a5233e727553de38cbe1685e78bdeb5dbe865b0e7cc4c907a1ddd468cb0a9621bebf3a6467d7edbdda712d40a0b73f378dea07cb6c1603ba0c64fa5900222e1427f511bd54eebc46bf8815fd67ba695f57a960b31a18ea4a64fcc0cd407f713c0dcd69d26d919966c901325c34ba27f1cdd535d1a27320b203760f3a51bbaf95d51977ba9241360b4f27d363a488dd618a83d89b6962a70f873efdbf9c8a9854bc4c5c10f3ae0c6b2c3c3a8673c57f50eb4c496451a696c98bde7bafeef97998c640b63c096e7be978c7d5f1896ace24a132a61b547ff518ae755949382cf2d450ba5bdaef12cdd342282ffad19bcead159b13c9a000b834c8560797998980b8ddab5233bef65fb23c4b50c3be198e68bb35304484ffd6f6900e88b1d72dc764dda1429d65d956992b730688676ffdf648638d4bfb124322928d6d8e4640640c516b402301cc5a8f71645f88fd3a75f53089892b2af32c01863a756d66b268097fd103b4f13cf5eb6abb7234f1f0f5d7b84fb1483151d9d2d4f492e5b8b91afc59bc9b12bb661e17adc147aaf2e27ac4ae522acd2679d7a6d644a1dbec7568b33fb6ed536ad2495e1d6c788e5d299845a07613769091d47f9a1942588640ade15185e89b570def2428b9a2c1cc426ccd54e9e1f8d9ac1ca74df38437c4bb495ddbbea548dc3f7c9f95a62c3c3670e14f7b5765c6f2f6005525cc4c9b5c72801bd3ccdfeba8a27daaf48c960ad45eac624e74def6b23528ee41c7db6f7478d8d134a691d1a6bd0d81ada8a3a041d2fc64b5eb75579db1b5656e783eec268f2428817274d41174c06f68e1624d5aba63c401c35b4085e8bd5f336a7dd7bb03895e964625fa0d52d3aa6cf14cf6d1d91caae5d5502259d3d5940f1520ae65959dcd0533bb63e251e695fb268ce690f4f4830a3b2a383402e0f83fbe41aced6483f7de6896d1a5bface39fff5fc8fa13395b4f27e4ab486c133cb24285f83a69888726b4fb8190264ac51952c6bd4677dbe76f7794e3c6f8bf0aefba334d1d2750ff9626077ab42c56904601513b193f5b935bfa0c8c5e14844f678afcf2567cc32ee3c835312cf53a81ddd323e48e7e7d5014ef6cee4edeabcf9fb3b58745b8fd60aa971d0729e46d393b9de683d91e526ef6bc2093f7d6a3162a2dd0c9f036de4f520908ce4b2ee44865a113b13df69069315ff68b5dd97009c37f0fc2baf24821d585c600bd8fe0c404fb24ec60b42895cff4d8a2172132751fca1a21e21f1d1095d6139975b7bd0bee8f81672c44df90129d1e5a08e21bb152bfb06d014874fcae4e333982532176715ea8077c7be69fd8ce40911c3510f7395b6827bfd9fccd34cf5eec2feb823e1f090eb049df453ba4941ca4819e1e6c6d4dad8f9917e9f3c94f707dc650441e3b0c742ec866b67bb70daa96601f1515549dd11cdaed614f424cd0dfcd9c7cb07bba5ef67bccdfb726ef4cb85b0e2670014780bfcf189f0545c65d002bfb7e9b81baf3cd80e6abf34fa7cbb4b8f7e61fb477293e65fb83fa417018dc4f716bf539df3b2385ea5ef7bb1fb12992433e913c711e8401fbb4dd5fccd3c364fbbde21671bb709fb270b38a5561c09e5adf8d5c03eeffd140ce4d7c433dd69e08c6b24c3850086b0b9746b5fa232fb013c78b0719a8f62a73a052c018d2229255707c766d698efe1c6fa12ce0385d66dbc52c88d24935a17ef48e404cad3dda24127813f5a16b19c30e0f11c6383d25bcbca7ff07f1e13b85c9f4855960a611ca3fdf034609e6e7ae39094880aed18eb708a9039a5a4e38d35fecafe5d12891a848028c034e9cf6f85fee72e1592b1a5e7d979392d19699bbc458c6d8afe2d5554d459ce531a1c8128d8a4cff52978b6a5d82b0dcde8410e4cbf49907a002cdb43e95915497d8d1912ede30b959220aab88380c835a564adff9017eb860a9b4085f98875e86343eb6424f481bb4dcfecac24ae297d4ededbb75bea97aa1e4e01a9a6369bad37e6fe794681d56e31b4cac8a3debee1f67a1356969abef7f07cd258af1018d8fa326039ea67f35db03b4cc8b20b592d0b9468fa85a2427052d79cfccbd8f16d951d32ce4515fa480f58711237b4cd564a5a15177991078937d876cedfc59622a386eb84d08ad82b42c137a4a424cf3debdbb1545585f583203c69753f70afd11e4fab101dbe1151d1f13f9c00d26d56b387bf8b055044b6c2cf66a11fa437599aab1bf56316f884c577dedb4829a7162938c4052acdf1f2efcc4bdfab48e065b90aa9c5e4df11fc57021d7f2ff6c54207f94cdc04c6f15b1eaf98280b1e6fac65688ac30ec416c83102a74faf412cfa4932ec6cdb806506481cc441ea104faf8dfe6da17c973385ed152c2477e3a9ed5a657490e057deffa7f17347a8d79fa03a8e2755112d02e14648f8a3eb03b0fc1cbab8ea1600eba33e58c058820686f967083aa55e106c028ec8895609760a1c741d31eb0bf0dc80279ca52a9cf4c3ce19b04c61736a69582aba8f11908a1e4b1a3bfa3c636d76d4ab28ad365881112210f0b7aa29bf20976ada3298c8c5431d6689454f1020bcb6c86c5296e6ce3d98de6ae595e131a49d90dd6b35692684171809135f2f5b92afb238b6753f98953a86584953fc2796f6dc67fa451e0f55efb5f15baea58b007a3fbfd02934f93347d647bbd39b11397531fde506262a60766c9dfaab18dd76c8c26a78aecea49ad72eb7f3d8bcb2fd87df321fe2f1b8475bcb2dc87fbbbd0eecffe6773a8719416a6d51ef01ab9e10d0eb1e227558ec1c57807d036a1834eca7db4b99738162bc21bd8cf7ce3bae26a239e79fe2eebf0f4babf2d2eb31538e574c07765c2668576e7203ba5a3c908457ada6301306e6f7769e4b22a5a39636eaddb978090a1447dd9e1b713beb61b2a7e6611634ef2620507502bc39634f76c2b32c899903a2fe1237857751cf41b0fb4ff0aa54c957b470d3a0d96b922a40c54ab449370d8fc853a00424ba25944f2a5d496270da1af91e8cdfa77f751379078306126a3adcdb0e3d1f48e936f13a52c17621686d333ea7931c36cea7daa33aa5497f7bf25ecfae74412cbe5edf6f2ed6324f78e30254e948f2d0e7c3c69739aa3e7946dd9a026b0159d71b024e37a14d937d40219b58234a2ba143185a9bb31b13b03020d73c7540212436a60bd687745c357f0afae3a40dcb7cdb0752393a1c678110e031992ff3fb819e5f7771b3b818949a8ac510f71d79d2d2db82528ae6bfb14bbe42a136d85f39b0432ae2121a8ebae7bb9777a53e272d8aff89da3a3c19a9acecf217883fb59b745467c75229b449d345f012b90ba590fbf8e73ade2cf7fa7ba8fb91daf2d9a11d7ad519f32c02b35661ef6e3f3f3fd7166e543630a88107e84cf861431ebdd8d8d01ef324b662f3b407c6deec491a7326ef66d3af54544bed0be2b15a2156b0c77a0d0a566b9ab45126f8ab9ac868a3eeda68a010491cdaefb03ae3a9a9535258474ea6e74f5589eaab96bbd6d49e9ceee1e98b0bc27421d29fd12d783871f1f0e41b67f9a9cd3868f246131e97e9414094f8815bb0fa917e531c2c6482221eb7c60508ac0ce81598b22f2967c689e97b28b04d7d6adb41d7f20a12f1a13eff72fb3dbffa1f9f7a611ff8abea8353c12d95f99358b47352e258e16c588146ffae12004ec74b428015b2ebaa8b968439509996e2f01eb491cb34dd033641653c2f7804051243a3287716f97df8143889995eacd08d1d45e4c13a192011b362d9145073e3645dbc84fdaf8f76be30fdd08ec48c0e812182794edbc87e0da4be8094b753767a0b27a92491268f9d9e239c99f4c336df61ba82b32b133ceab5e3e7b738b94b91b2b4584cce85c2ce2f075bea0bdaff89b1b5d23f199d56afe764ffbdc396b3759a1fafb6dd4e252ae092ddea9147bd835d6d003e4eb4d5a4e2d197bfec2ef30fd9f0eac2f7875d7625e2cb881dd9294e0279f271a29e4588900e6d688bcb7e09561fd4f6b6e4f531487f19479277d1544d4d3d969401e98111f46baa4c10b4cf14b10edad510b4c1e20500591993e1e2281eef736557436337c1ee54d7777102a006291ceaa20a3cdca2f25732dce84c4c8cad50fbe4e4ac5480d4d25c637c929c99bf2963244d5f064be509dfd064c055dc6a7f8e7c1db483cc36fbabdefc24cfbddd00ed907959781488a934823f34617bea0a8f8b85fc9db2980ee47cfa036c93f7f68a1d0f759af185d2bffd829209a9076304dbb015e623cb5120ece4bf278c28701fed7adff648f22d2b24b4fdf33a4f1c9bc2f0384d22430b19d73539b742e6e13a5fe70fa734c1e269123adfe4c0f1dd3470a532a7b0c95028669de6687f43ee9338096e0846605f4d10155854d2efae8c0535965f540e6cbd1dffbe98d70ba7a3d2189d99d15cc048bade6d9a8d321497c86b0621a383602faec0cb7b8e7463297947031100ebdac4c7e51e0e0a23c41558f5464b99cbef4145bf52b58898e1b4596206d65af3cecd9d376fa1767c0f4d351e5310fd5256fa8f4aef16266c3a4cc9fbe9d1b64e402cc27fb67226734ba26be7e0045c19d93f13149441530173778734ee90f758cbb1b1a8aab3e82c1079e80ee3a60c3982af874f722a05cc87956eaa0b4566314b13bad11aa9cf0bca0ac7275143926cb49c542e4475ae267dc14e3e2c40d0695081051ed699381a0437ddafe2288110ca0c374513b7f6afd292dc5678729b7b198d7d892ed5a1af1be486556cb4ceda2ca2d453003c280b090e14f8c7fbbef39879656a241acfec2846959f410af3c7234f146bda179c967684ea9e8aa63605052e016b476d5d5c72ad79083973bd9af4c37b9d4cc7eda0cfbe6541713e01610ec3ef9a41b9cc27977b735ff72099ce79cf5f255d10febf9a2d4d3bb702f415eaa18069fe475efa9de968d482affa418830296beecddd46694aeb3a2ef9dc2d2c9fefa9626bb2949d4dedc577a727c0b430a64333e71897d07902c28d094da1c9ac58e83c52dd028f4903c9d38b072cbccdfcf14ad773dcb4a807f1eba15c5a7cf53b78e86d4ea312d474a16fa7d89c49d76213baa2aa05689302033a9be096d6a4029a2d0b16cd08fe013c6bbb9abfccd64b808cbb9336a3ad7da9dbf6631b35b7b46d401013af514899913a2a7528ab8be0323e7bded62f975682c631d71509b9a5f1ca27efb431ac4e2c6c4dbfb2fd15b8cdc9c6d88553ab745206f50b6367ab4f33061701001aada2af5fcb927e2c937d8b7f9063c2a18364037d042cde7805756004a49a3a7ae0d7c592188f037b80db66ff18c7ea3b30798a313010f429bbed1fdab14479e50d1f267609f7d0e43d1f4c3046d77a16afa83aa4c219229418b452c6dc8237fa57416c3111cc20ba51aa1ad727899abfdcc358c23064bbe0fa41c7ea904573c91dcdd17834af86e1dcf9c038982e43d4cf01389a2dbbd36735c0699ea0c16484cf6460a44c4161193466642dc4adaaef5f035c4adecde1951ff962007999f99e8def45c114b0e0c5e9bcdd713b53a339da93f8c2e7d9243779690f80d85e2d0cf7211a27f5849a7c4b7477366c53c34067a83ea1b86cd3ecaf229db9e739109d3526bd9aeeab4db1510b015593ee4b506784c7423cd4d34ba337f083ccb42e8a77c101fd490c2885846d9aaa4d291a5635eb092a63c485ed293dc4460f5a27c4adb71938ce5271daf559f307bc85fbb2696524d8dc80e2d11b5c938a833be92c23aa460928608c02857ea52926e3ec2db955ea9e2ad3c2874a4a65f8b9a39a8bc1f9694516bea148c61b4388eb79993e5965fe22e9008c33be7425e6ed5de9f61deb020599d88509d9f45e8c4ef4cb8cbb178551c1f1f9bb198db50409c8d7fc9f1ffc47f4a0ad3e329585c0dbb9c45a90b0a3c5f0f94710a0cfc6fabd08324af5fbd3d45f3194f44409d1701c46ab3a1426429c17f0a214674ecd137508364fa4f72f7964e2287cca7cd78b58ec9caf9d19d7c2909a0aa92d27b466a130b823a6e93daab171e1d183ec1f28c9808d7b03a28bf5a7b408fe208cc61ceab4724d03335505bf6680b13acda7b7e306a847470b6605e867e22b429c7a0cf642f80a3285dabcbae2846695646057630f23c545418197c7777931f22554eb2dc9fbf9eacc81b84666f5ea37731f3e588ff4a25aff0816242224ae57f6fc4227816aa3b58a887f9fc2fd8062dee90d0bfa23e39a44b900b03d145d2719723a176844b4b4eabca1223624321ea91ef819b0ee36172ea2843dfaf07a8677a17a541bda03a7d3a7f14dc45e2a1b3c123286de4bba2b76d329198b8c55e354fb4253421f555619a5c6f8e0d793e2948fe3d039afd4c80292f1fc61ac0b45398d175a81b8d908c5dde68d1cf1882b903c0df08eff208e1f0577b610195045d265b2d6ae1d41532cbf3b05845b1e62552e5a6fa646055b6a154b3694281385b17b5317dc798c110878fd48c3c4308ba97eb46db36b136a72054a3ff9a5f2a10bb531644e379fdab99a2fef6a89696742f55b707696a64e79cd8487d303c306fa2f4cbf0b3114c8bc65fe337ae54a19c36aceb0299798aa9839dd0baab12995e81a9259200acb021f4b680bfc571309f0288473cd43ebc4cf88c354f749efa027748cee4d4b205c740579855764750df6feeee0d14cc66915caf8fdd3e3640e43cb85125e6428a77066b2dfaa643da76be749892d4039a586cdb01f8bca875f010fbf564ad31530e9b5dfa6887c2289bb28e0f8d98fa551df43a3b9835d3320bd92593431456c7f9d740dd7a7ad7007f18c54ae3b06daf6ee0085ea4b1d5759d32fa0091589835e9c50af09ce26dd7ed6f8e4a0189c5435eded9d7e366808b7058b8044ac05a9c232721c153b81879d00cf4fc334b149af3685f40435ea9a7af09a8c40a42b81bc11a6f6a571248b3d85e40f9cbdb4142e7bc9a0a71238e7aebe7a8d92eed96eed4341bb47e7fd9479b28789b2cd66899e6c5c5b07ca2243e44693674fbad3ced125faa040613e4329e6ac2dbdc381b5211de83fa2950b94ad169e2bd6fb233eb51453590da5479cc94d05cd619a795067929f447ab7e3684b94a3023b4434970f367a7654a3b2fa3b6491efa31e54671335fad4b6c5feb742e580dbc48b57efc8a68133424546a4b7c470f529a92254bdc48dc01f3b7fb5a2f5a0addef94ae55f2659010e867696ca55185492332c86f163e17cba0d126688eeedb4f64b7c251b54539c9a8b01a9a3e3e4fff49ac34406cc461c7103fcdfff04b20ca32e452c8ed1ee9d0b9b651c8071ae6ebb792d6d1b46dad7384692cb9e6dd4cc0a5219554a5aa5cf5097ed7a27decfacbf846da13588ee63bd337419ab641f8e0dd95b08c98a0940d4f932d660b981a8907fa581775b7501297f4b3622dca3b714ce7393eb99c587eb97bdf0df0c7f11a9b7675191467e7404f8f29eca3024387b6c6fd47b30072571a46fb067d513d89c32661f33632ee9bcef0e6a7758cef0fa29e11f90c33c0fdb491307ba5b7f1ae06c056378f4dc3863fe7577f66dcdf8c7fa8afae19654fb602e7ac324a0ecea87148021529570a8fb09d043dbe9ce17d69d9257cdaaa194d0f04eda84f40ab6bf645b968b313f70da0644ce69a8ed8ecbeb6651d4354f4b2564bf4e37179d9992f653b11079f24528253aa563b85cc5d19bb2b7a7ca21b641bcda2e0bfa741ffc4118bf9b9bbdc86159c8dc4b31be0b501ae2a4f1fd7863fc39ceb6e27c06d6969846301154a4249e36216c5479c00ffd08df924b6015c3444a0606af0f2caea24a8615798b98e70bfa89a6f2f8c494278413a4658a7daaa9019bc5e1b5e9c7718a2af0e7d82ae58c3c51f1cf4047269584ce980ff93f2385a5fabbe2483fc7f318c6e515fae2ef2a01ad184db7fe4d315454ca0e8bb484da468c34a15a3195e8617ad478b696a957d5f9c7d043d856d6b0d07993a0a51d55e07278535e8cafc44ebc70997b21e1ca5d8c0fe827b6ce3947f8780dbc253374a17ffdc357a71f30f297356c3fbcd72610f6e81030fd69e452d27dd4705f05e1def6565bc84929fd6f353ba131d4c5b1577dba598f26da8424f2e512855bb421e58de2a585f0038109bf6f41aac512e8959561b9498e6356f4a5d5d52ca30ea3e4d1528cffd42e3e91da2c957afc08cd862df8645c0fc00b7c16e5b82819408152f1a56ed0ed08f98e0170ae124991913d83cbbb17e57033a12894fd923bd66a373017b003ed49bf538959f9b63acd8a51b7e3128b8b058145212b643514526006bfc83062ba03190dbb5559e86182697f81b0d057b67a5617a11f57c79ba44a2ecfa060186661dac98da4e46bc4125664651662214e279f8394d4c8ea4d77bcb8ed065e4d6d480f10c25e2c848a68aa51ec92c23c67bdfcc1566d97ddc3fb4ab936b4bc8c5937f5e6d327b832a507b2f2e1c7c89cab2f74170a3776cd4336d250c1810a8f6b959592beea38ebd27ea2d6116f4ba2e7e78b7ee8df8ef6363928eb993f0b5e88a32fa5c14ec7adf55b48bfbc261b80da5a421e60911a72eda1da0472ece6dc7715e287d9608e1b687fc5c887fd8e9a094f2a9c2c392fd3cca32d500373c601aad8b4945f94bfbabc35c74f42eebe3e0defeea5d81b535e9b777c7a0f2300cb022cc34e689d18191c07c11fead8a35bbdda0fc6eb0608b474ffb28b78a5ee4d4465765c4b1fff20b248f2884f82c864f2353749cf41c4e1a34e56b69751411e560cad7c1e46ae6a4be6aebca455baabc1342f4de396dbca448c2f367c2592fde0726d895ef46d42cbfa62ec0bc9008e430103f0d4ea3a06bd64beb0365a52af97a19eb2fdd81d9c5e57c4e863a6421b397a6b263f91e3c0e7e7fbf1cee03fcdaad0dcefb4777940d8b0ab050f0d0b183620e4d4bd16040d843d06ee6e728fb7ca5ac9a74ce5f0ba1142097010f086ccccefc7710ea665392205a66a7d233b2b53483d21160d755f3f74e53650ae3fbd67ab5fa473fa3feac59766959801b31531e7050e060a9408565939d273e8e9c5930c45e9171162b8d9e974e44314b341740a2d213c06b3044502c62f930a860346079d45bc3e2ae62e13d2142dec6011b661d18ce5cb21834fb032c4954906e814a57d6e12a334a374870a92da26e753a9797ded088acd110284ebd177e58a3746596591a21871425aa7d632402523e856de3dd85040ce6661732818006d90daa04dfad0ee0c6dc0e812d7b441b839ac50d403dce2e1d645dcd5d7ff1e1ecc09d522c5d949b7990e52ea2aaccbb4993fff1be94e0c3310d45b19b82bd74de84ba7f9a51369114395ee9cd2be500be737d5b77153c7c86f02b13b5a41ae601b03588283403eaae32b483b2c1222d07a2d2d7e8865fc0c755df773f353b1ff51092185dcc7f87175c2a6ae0c5560265b9d25ad49c60b6abf8065bdb2d7e4ecf9d88e0310179fb2fa1d10e7eed09ed44bbdb6718611f8c4729a767bed63d06d8222e831004f670885f61166a18b795e26aa02b61ec3aae8f206d26e26f45a1e22fde87aa5c02c02d8161d3f1c48aa79a3535224420c6fcbe7585942d4d90252fab3d0dd82cc8d87099268576693a883ff14144b96e1920b6934401d20dff94d505f8461c6a3e483de34607ddf062e960e1c16f83d182e2128a6227eaf4660fd289241f79918f18a7797a72d87206569d41d5b0d8a2eb7c9361730ffea5f474ec48a48089092bc5616c4797eaf760e836f055c0a713e93363cebb84ffb210b907969e345fe78a2914228b5943816669569af01301eec1a6b96b68aa622bd470766d09386bba72d70c073708409ebbb0cbd15b0ceb613954166fbcca5df26357b2fcfc14fe7caf072ab1eb92cd30411b62ae2b5a72a1b3d341129a8754a1c27868b2a48f2710bcf9da040aa1d0376c67efaf2b4a763d7207450864dbda72d366ddcfb6da0f91e6e3eb838f434d6680d24903d216247b79eb733fb3eccee0e5aa5df5a710dc8fd284cb5462582285a5b1af690e19f038928c5aa9f0cdabe747f569226d6e5226760a371c06ad08da65c10a74354cb898d698b6b78d128f38ac02755156308f53387818eacd6a1057b032cf7b19bfeff52f63ec0eed57a217e121f5c86611e59dab94d506d7293110dac95ad94fde24a916bb8b8450aa62ce93bd7c49b31c9c21dd6b1bbc0c9bb5f68ca3519537166005f878c787822af246d83b29df9e0ba3ba658980b927f648a3297581d0bbfb20fe3e384c8fa8ca5553be5b844658fe518c40f85662b7f4178eaaeee4cc101d14d9c5005c8aa555379d8af9afd326d096eba0905e61578e380b6af948decfd19de31c144673d512771551ff83000cc9b07b2534f39a5e58d09dd9cc2c7b235a47b802f0e8015c2a23e35d477ebb1f2c136314758734a0e5463f2455403d221d8311a8b163c34e33ca60196c7986ab8c41698776b794bb2bd827b67edf54cf4bc072a4787de6743c5ec6d2adc75d1e503d8770d8a8877e29137aa91890021a58bc884f6a4bfb715c605b0b9f05d453210423dad9d1abdbd06245cadd98f3c94cb3e314ed420281eabf909aee76d1d0a9575a571b7902ad61bfa7544d27e15b96296a33ff295f38a43ad04a215efacd2ee543157721bddfa6a198a1b749ef284238d7ed93194341ae4327cb84da656bc69231b8ea0076856e271ba7b81d049e28c265a955fa734b12b37a99ef4b655aacf90bf2a827747adc0299e48f561ea4f581ff72b7de2f12a9d5f871aaf3eb61283bd194383b829bda377d35c22e9add7af78356047ef96c7e0992ca2845a6e9dd6d1ca72e57dde6a54be8c48bafc9722f1602717930efeded19a45e7a225c84491e16c0da103d8ca2e583652feef00c01adf54a82621b82c7c4be9e32bee9094f04d4e4ccb1dd8c417d8055595138f21b7d39d7753587fdf5ec5009d8e61f1f757dce796555b2d348beb8e4af1e51cb741c7a4727c4d99553dd5eb65f8d5cc9a14c154c4ee2e2f6bd230b61ddf9dfe85845dde2ab71afae9ef7ddc92f71caf040b8aabcdee9cc2f6f1f5475857de8678c5a50eb5e971f062c38195e9237f903c898bb2f80c4404780ec62c3684d251e0ada0888fef5e1d196da1aa8cb4088c853dc119638d58950728ac74127d3c0ef5f2e40d25f8c473b40544eae51347478f59d495dd182d56cbbf8afe9c948d18258e46abb4c8cb8580545f949c65d686e509a13e858494c0095c0253666c2d967ac3b3e5c1fcb807711437069de21d5cd2825116af83ad3eb61e7426139c76b58e1bebf28105184ccef769d55e6fc29307c7d62d4e8cdc46dd89467834e5786ea22195156f51b0b01cd8a5c7a92db4f8b58420be69a5cd360a27082c923c5907dcc557a7fcd0615b141226ee9f321773f5c6c3687c793c1f752f7f96f10115b8cd9734eda3674a3fd33f27bc625233477dd436221f3bfee0a00a7baddf06cb0821f8f76e3281ec82451c5e98ddfec67f207832016d9d707427ed2d07068d408b4b98b27a36d1d31be185560be87fde29172dca9116b29618fb16c8fa7e10d1ed5f1bd5a787f88690fbd18a3eba059dbe27788c80a93572c0f3a584589705d0cc0d36682fb13113e7311fea64ea9a96474681a8c70dcb6b97a490d4e08253c21365524995fbc15a5c670013e08db44c92977cf5a2cf9e144ea65369fc40ddbaef363d14ec7b664f9464357605133812a5f95ff26913c4a9afecb94d1fc6408dcaf5f6fe7542b99f5ebfcfb42f63004fbfe89427b82b647d06ca51cc0670209b6d133d09982d1e10b3c398dfe766fd0552c410524748caa247ab1cf43bf60b8487433887cb3d52a8d07d68d10f71c84eb5afda656d135ad5a1798ea456d866d0ede93dd602944063960d0ce4a052250ae9b9325946ed63b4e1077b1bbb8c4b4a305f5e01f4d3d58ac1ef707b9def5e210bdc9a85ea0c137db4d412a690b09566507a5152a5bb91eaa6018a9f6ba7693aef11332335446dee1374a82b9fd36649a099c0b1281b80c0496328603c88ab5674989fcab9a7f1e8a882a4af3e373824792ae364643eeaaf3fd1dff93495567c8e78a53116a8048048aae55727924aec6b54902270e71bf193a23aac9267f1797b74d7881d8a9c1029698e8bcda167afd5c7359c4a6a3ebb46d09efb2297823a6d44b7151d07975649a505f70c8645641cd397943b2d4d2c9cc5e6e1210698b5608dbfcea5102468c2cb05fe9ae97f6570644b10f92d1de8c22b667eff3eb42e57e6dfb4717e347b6e3f789b7a037f32efd3bf95ae6985845fe9a37e609629682c160a4f17be67807243f8980b2c8f6a77ca73d3f5f6330b41b6d0326ddf95a8c5839bf46194b5665327682044ac2f34bb4981fac6a0b79ac3cc2d0ec42e5deae75078805a2e3ad10541fcd48bbed8757c3a83f57a612dbd7a4bcc0a4fc07fe8b6b52b8bad01ff355b1306cc84850796b2f6f1d559ff9397bde36668b79329c15e5f1371163995235ed2a50cd8d92c40b510d2664e1a39ad5631a539c3bd442512ae50e7214f8d6b6dcfebb49f5e63717e8533810900fef44b3dd6365f4b10d8025a976c32a5f3ce87b9d31e5ff08d678ab1d699a056ed160518fe9a2d6e03c3f444e609897ed2be6df41fc703ae0b7d5afdbf7cb73724c03d1dd93976178e94726be277a7c0d6d4d2579b014d93a0ee76104c2b3e6a1d89e746dfdbde408b37582fe8d2b206a750044c008e455131340effd397b9aad4da6e49c8901209d6a1a228a18ebe76a1d0c66eb5fe0efe281eb45a360ad285f15cc0ccbdd060d767bcb8e3fe05d17dc47d691a441e1563b7c50df831301fd4c7a6cbd2034ab87875cebed1d6f187126fc0d7b83623f11f7d71f6d0f90eef4059e547c0573c8947df022cbb24dbfb0f2252b319ecc1748377b148ed5e54c166c477cbff291e55cb2db3d94cc2b050304bd0b9856b5627f378e61234a2eb859a5fc935e6425078e2a8159ba1fb7f921583e43b4dd309e75446a23f642f059f783cbbc03f33fe3af63e6e5df5b06a97f4fd053918834b454f264e25b1165795eaf5b329fd771a67a26846fd89d024b2c4945e8465349f54dcadb2329626b71372d9f9ca7de4e7c0320af89570f070ed923703c4e36c58c406efdd3c29b81d64198b75aa12b0ee6486b81ede666a963dcbdd0de56b98c712d7fb4e057707d1a50465cf7882354b89c0fd4c9b0ce4d1ed727b1f35c1ecf1b3e593140ef3562bc8db9692c56e408a2d0e69c04808ae0967ae3b5372815135d2adc1188a19f6a1a32794d39ce46dfc84834f9c5d2efe908bd0d65e2046c68ae63e12d10c480c3fbb4df5dd47b39080eaa2c35813a985bc5b75bd4ae2a20de4bbd7fba99f63f3af9b98498c559262ea12396a7a1413023d1e62b55e1531e1a3e185295686ed857ab14f5dd13f1eadb9a2d2e04f23b49a623584b839c0c1ee023c37608f0b384de6ada0477ec816e464dba6d4a4b100665684d72dfaa629e855f1ff8e779b7998752e3d4657e776c88f30f3dd80a97f69d1791ac5163cc7f5d401161d38472b2441b4d89697bb756a57ecdb56487aeab48b0b0d36814d42df8127624630199cd31d2859c71d35979bc1b479dc6b4a82847aa804cb95afabfe8193727f1d5686ca3fb8989920ef69941df33bcd7619abac41eb3a715e8e0f7cb102e833f6d2bb455a209bb3438e72d033e5086c94c2fea04d80ef13e32a7d94465b5fb02d714bd84c12de3c9aac859bbb3eb98f3a9ad73bf6fb04ca7783b936489082df54f4756a124c1d5dba04b429b6dacc3df5f33574e82be3ecb62a4e67135fc7e27b8e5109afe49db218866ffd0e40519cf08269625010e042c4d8eafbaf091a520e670055020903aa33b8ef3cea0cc531a9bdf3f94ffbee347f7ed783495a344af0fb875e9ee39ca21927383a1887700a001b13a346ffffd2e8857c6c1d62cbf31c4aa3a649dad73d2e08bffa37087cf6767da8dfbbde1c4cf001193caf2414c1b360eac804e170e504854d68a9012a678a2e77ac313d006a8f1131ab4fea1a3a304f360fb89269d85014edc8188537a629d1723811f5b8e2a4cbb15a30569a09116eaa0641b4e89ddd6bd91b09d4d03be8f7d8b1d10cb5cc910e6edb50100fdbbbd0155035a5cead1873190728f7a44bc15afa1964e5cfdc6c3779c796536b095c9c0a40157252a3d26adfba74d823209ead6c5597b775071fbcca04798d8401dc0ef859b328f5c802c50ee6dc30bfd79a301f7b1c0b46c150ab8f89073ad18d7d7a3fdee41a37598d076a74981b67ed50e3ae10f00dbd6c3d2ff20e0dae960b3c7c3b84eedae645b9175e26b8385f11b0547ea55082e9a67cb6c6357eb3858bd11e9b2c4438799d62527ff6a738eec2b658972362153c79f27dcc83c6d396038721279b84121a0dfd3825bc9a16ac6cc3bef5173f0d492be7cbc48e3670824d73287bfe8ab459528528afaf38baa339478218e35835592eae36b0fd00a5dfdb7928bb3fc711ec1a097b4e818b54c55c63156740fb87eede0548fe3121de8772b435009f8631216c04176bbd2143beea27b1550d13eeed2c5a4cd815cdb9cb5cb662a14bfbed66108dd12fd278134b8ba22cf3549ceaafff185571c32e316ede423d32a70b3c0d39c99e48548bf3cbde465831661200ec31d01827635dbe26e871c2097afda85d3a00fa177e5fc30f97c8054152cea105ccf5c13bc8a962238dd0b361ceecd97fb5f8ce0a3d6f89132a57358e95135375f756bb193840e9d4498f757c05613d20ce7eb8d49143bc5c4aa459e7dd7a32b9f596f84cf73be6cd639a6f55e9654c53158a231eb8e4b4ecc95a4492a00a5c2f23e2721d4257064a604554411d9d7482a0eafa24854e962834d8c0f7feadb8d52995fbfb40d29b79cf219e204522fb8dd7932df03f9c54e3d79831e5b736a48bcbc92539a80d32152f7d67177ca485d5eb3c4555aafd6920a1ebb0fe43143df7781270327f95499d4f16b8312118d1a16879a0dc9bc6bb2ec977368d2477bb2b530806dcc1848c9594861979bc17ddc83831583d95cf5403ecc7c388d7e2ee392e3237925b6708b58838223894ec9f7ebab85c2228006a887d3f9606005937c4afd5bbf55415c29ddb76a6004a19b7910ae175ae968eb10b75bd70a991b98ecaf7828217f330ace88daf52f06dae7e08320cbdebd6a75986a8c01cf9d8ad229028c558628ea58120f7237af5fcfbeaf63c8b20fd493eb5d59c773f8dde01abdf5b3e7c2baeab27cf4e728bd39c4d762946592e2fb1cfa7acc05e793f0593c8e396a84698c9a21bbf811835eb734b9ef543fc65e40132a1a74ebe899bc21348cea605ad91933f976d58bb0ffeb32ba050c6356522ea6a3b1f91a4925530e59310a648688d73b95c64b81b0ee854a037239e6f8a3e8c740238a632c05ff0bee54e9c51592dfe13dcdf684023be740b27652d1458c4424c007abf250eef35473956484c301753efc7cfa05c475873817989823071430b57cee6d756abca05274f2c64058a3769c339d327c3c026c2ce9ae514ed38bb10230e2e7b6b9aa3684ca479044e9baf7784e21fa7e25535c0428c6e2f7857b624cd55dc765fb7e18885b6cfa418c004266a5e6f37ac8510e562b1ec3cd7c4ea0491690b2383204d0d8a1ecfb2af9afbb3b9a833280cd7c94df97c46d133ab9bd71810bf3c9d93ee4073e2bed8adb279b72a3856115954369723800250c9a9bade6d53be417e36f67921d535a3d2b0688e33c7ad107fb4bc416444482c8efc4d9d139d20527b301d61977e0f61d0634267994c47948deb792c03b9aa553f9f5fe87d4ef3541ffee2f5610f61a89963e5cf5d82aafaea09c50f42b8d094a526a41438608ff03313b6de3f2155137ec017fc75c2af7df92dcf043de38875738ceaddba5f2162797d3ea74fd32134f815cab6a4f31c0e023e44ba80a1e0549d16105efa06018bcc2953c8423304efb8063babafbf71f7dd350876374de92e779f15f304c554cca8c709a3dca55f19b6aeb06806111ead16d15e2ef8f2606770b21d26f301c7e2a270cd488d463db560ab37709f04611a5c771b4786b29703cf7151ffebb7dd4fe4db2678e97877f9b8e4bf407a4bba0f85c1b47171e77ddb6c733e5ac6ca3ba2f6e9005eab43503d6ab2373c3d83523913fd814c37adbbc50f2d3bebcc5d9b4f76dda4e5c94fdac7668c9907bafe446520752586dc5ea2a1790e28ac66f5f3b4d86f2573b03c529e682818dd5e3dbc58d1870d6fe77351b7339b435a5492644cb90b273cca538c8c1527702d4b38af951354530d4ad0ed8815899d399028bbd13a57a1f7611d095a125a5a663bc2f87fdda566419306083ffe815dc8c88ddc15b19aa4247d137ab2ab1cce5ec7af9d38d8b58bd551331262c8a6def25c679bb05cec72dcb7e4139e2bcff02d398715fcc836fbf4707bde0cf6f17645249419a75f23346463d03fe3e3c1a3d8f492a7e0a4454abb1ef72f794c30c7002dbcfcdffc5ff557ca9aa1809d999423e240189b7a02a7675b0dfee1eef72e91bfdd0abf355229b8f9d7c6ad975a7d593a5f7cc5ec930c21d3e43ed984923baa6d15de01f5b5189a2de299394d0a6e9c82150edbd9918006c35383198a2dafe915f9ba251bb0464ad0e471372da2b4aae31683a52b2466d1bf5b4e25107128ff5c519f8d824ce7aed2dd9b39f8eea41311a1f4dc66f2bccbe7843f95f3a4f6e09ac88454fa93659355fb065545bba961f6d6cef839c1dd439e74061281d1a7bd0aa7273403a07ea8b92d38fb1b28bcb64c9b293984aea172acce3305cbadc115093d83a2b5c846faf91d9bcb29e61d1437bb4b5db59ecb11093babcefbd033d8662aca312101fbcff8b3f30940a4769b752c5ebac1ae68bbe2ff60c16abce1c68817728a125f5fadad33a10ef35ca9adb953163a1b85aaf82cf34278c1781069629dddd01c58ee4ab192c3f52f6b000795d0e644498d29ceaa51154d1a33f04005e1e554f90d2613af761b69248478d0b35b5a29807df93c50921140b77c207eae1cfcd8f610bf712580c0b9abb6cc1e155f6e90ed0a6a4339315b81a3f1c3f1fb4cb156a9ac16912445fdddc77f9c2c686eb69513f52721d8a508d83c853c81d349897ec89e9e4a4c0c760b3a20865bb0c5334c00d94b20da2ffad679bfc05d23fb5373fb841f26d16ee8155543b883c96a9f9b2fc874c5bef2a00f67bf96806cefccbfecbeb0e53260aee968dbfbc14fcf754a8de0083ac029c13bbf558d7b14ee895638254a4f76bf5846bf7b7c3e098e67770daff0f935de95f4261785faddacb489ac9e7780df6879c27c8ece97225fde36970417914f1f5075a495b4f5eb8d8c084e3391d1e529fdb36275caf02bb6b28bac8bd0a64026134eae4b2cb743f47700ea29aba678f7c96bb0593bd01aadeafc6610013438b00223597df951adeb4ed520aa92e6d909dcabb9f3578d83d036f51ba8186b6754e5f854eea31aa4f2bfe8c9b5dfcd8ceb03594e0505650db145873ccf0488d02793d7266222f3ddfb99fddac1f22e0e065f43aad6937a2e4981a2ebd85e087215a01e59f57e836b7f7a3c33d310084d6be973c7d38f8dd354aff51c59180b0e5e7159bf5b9c70ef5e9efb99e0d0d093218283da1bf22ad4a65774edccbc1e9d61b88607b186b8db55b5822cc3f5948b23669ba51767e1f3cc151ffd4dbece9753ff5af31ca67f6dd7229decc0eed5d7714d7692737ec9718e1a96913c19b66401dbb5356a9e93ad03329eaebda05dca874c5a3f5e38fdb4207d1bf0c6a877b3cb2d5087abb40ac3ff22f7cd139985d3c7707e478b8a5a9e61145bdb86517c2561730ce9d2b99d0eb35728c77b3f69a59720aa7d94af2ff8cf375a2f44013b6e459a6bb4a6b357fccbddd8416ceca2b59851fe0841e1b8d1f21c6fdc15fa6b9f7351cfc4753f2dd974dfcfdfee2895672c01ee32c49e0be5bab446938d28778bfb89cd15409110f1a24238b27785dc591b2460908c1ef0d8961c6d2660239cd2be9953d66658e0e95aa43bb9417859abe6bb5719753c91b5fc43d84be978c45a086c08c232b25adb05d666130bda3b4eb693c6dea8193ce8c866b3d878f1bfd24b710e860e663eadc151a319ceb5c534412399c22d8c1957584cab8bbb736f202445239d630232a83a4cfb6269b2ca77926c6dc2e60ed9b177fcabc56b0807647862dfec0d81d688ca1a1af9a6bb34a748d2ae7114966dd9d987496d2bc5e591c59df296bf89d0f6bf9851d90cd0dcd33161c4757ea0084351c20cb79e30e878266f5d5c851b8b9ba690533b7403ada51aef3d6951081d58f7b5f6e198fb8ee5e828fb7714288c70df5ca78811490590a429f3934ce74e8190bda09ed87ecb51582a7abe0a1835761d252d89a99ef6834f1f099689e2846f7489c1000ba00e37ffde71713a25a88c19f349272266db37e48752ec9b0677cbba35d6e83ae06d8cd5cc7462ba4c6d4cf96e3c2ff9bb81a007740670f325fd16328919a71cc783fb37d2e0ea417a5ef2a916b0dc74397fd6825dc2115715ee1e3c8083ba48007e03f4cd6a52264211e9fa6e1a19689aa7c2d849d55762b2b2cb03a95d737f4faa9244e8812eb934a651847eaf96eb2fa3cff0555ffb9ca2ca52ab245ec9527941ea5834cc8dd1767f029e19147a65636109014b246b52c24837d672d83c7bfee9d358fba57a661b4767a2799b4979bc631123d9cf125dd5389a5c43d76c690e49bd155dcc9360b41ae37de7daf222332cf2cafe164c31b8e610ab89396e7eb142861b6d4f95afcb1f5e17e6c1f104721afab393155c1b6908d555335b53cc0d71bc239ab6a62bf28482ecd95c797165d072c8cb56d791b28d6eea3a1219c6e151e38ca3b526d3231dd9fe27229db37c3655a127a599f0212c0ac2cf5f5d754acfe71765d2d2470833e483491cf5105e8899d6926102a837ed11b37c7310976e143c9f94c06d1a4dc041bd1ce1ae5f54e36ccc4989fa31f20115fb895d6c98a0150ece691f3ba796f113748be276643f62fe0dfc3e77be3fe2fca09c7b983ed44576cd6a5d6499a4be163a94027529253f8786bd6d2eb5b32b7d2466420326957ef5ba6095f9db2ffc626ecb30f25717025a4e6659593ae0d270731460504d30898d637b98e1394bcbc03713baff9b70b3969f4ea6604cb2ed687675b591a0de21e50c3618ba130dae419179f9fa638cdf2d71a73d110fa76c26c2a4e71596d2d82f3fba23ef156930b91cb5e45908a06a51b13483078e98fe6910ecabe08d9b05a9605c19ed5a85b2586036e8a7ef79db5dce837699571e5fbeeabb7171fffa88b0e62d189e6ee93cc18f71aaab2468164cb79627ac4b76174b27ea60f58317f383ae3db1c4c435436fa18930a875c8d90d7956f7b2c629e2f2bf2c149bc920b88dd14867d41e2d111813627d58d35bb09b307705da71c96b2e7fcda8204d2d4eb41d9e66604f147bd1643394f09807af9cacc8d450cb29c6af8f3ac00411622a7ca6af09092e5cdf6da4d510d48fda6db5506a945c5429582e41093f67c9ffc6e6dc5a0022b1b1929cc0104e2238cafb40d1e31e51a808d17c3ab7decbb651edd4df6cf977cd335981ae66d9f176e7db8319ba3d9cb9fb71049041ddbcdb8356134bd7afb955c4f87480029a46fd2be307bff26be6f7cdb4a07b0092985f452f5462dc1e65b826de2a349bc0520bebe8480c2ad3033c7293b2ce3666959727cc07d3fc0ecaf4182571d85023074b71e8f0ca5dd6f1026e35fbee05017953336815027d347cc8a6200be267cb594bca8f72e978f90f7c35fcfa49611e503295521e38d258399e642f2b9c926b5dfff0ee5b942ccf368a00aa0a2f20d655f896401869fa396966418168eafc0c4589b50e59d67ebb34a204d5eed6e0b5e344dc8516ca785fb4ae0dbc2e7a8ade5815471e593186224efb0a5256c78e3ab08eae3e1554f38adbc41e0b54c84291e473c9c07c070d93b21ce1fe6f186f1c6e3c8cf1d0dd924cb44d27bba0a5cb26201e838fd9f405c93aed1bc88d77ad452506dc9417897a8cd4ce466970133723bbf9764260d979338ce8583ec92c3e02ea2e25f6fe80e33e198e25b21e91da31f4c0edc627d3d04a3a25f6568cfc111b3cf83e8afe0dcaef3d1891ba1a20389b9fae262d76b4da45be25f5bd619af04e71b7f390d1707fa35190ce922b94bf6fd9bca073cfb1980fad3f2e144eec1152b48e7ab995419a387d1427dcfcf32e7483bade5aa8af0214b4d7aa1b3f2cf4a83edbea5bdd303ddde8af653b40c439b7663ec42c1c8196a20e9122a00f6c796b4a64efd306eac74e288dc54e49555d783ce448ad5509cde9ea897b8051eb4c08cb6157cfdd871690df8cd268c3b7e7d5dc90f232a58681f2ffc098ce5e0fc6937812516a52b70937ff5f84e078aa7610de22ec34e79b238372ab7ce563b11b4e596b3230ec9987f6cc50b6be2ac6038add2413fa94ef57377d11d3470ed79917901be42e65a5cb2aa16cee9bace3d56c10f96a266a89e9787553a8940112acb5332f24993fc512223ac5a36fa7fcce429e279549fad9fd42a34007f84b9b27c1a8320bea1985dd55736b83c25819b168efe39580bdd71f600638630622aba468280f47b367667e574c77d95552276d4bd8ca870c5be6adbed768b27e3983e8942577866a996c166a7592df35808eb238c69ee7467462dc59ab094bb556c1d6f1f282c3c9e2683f4ed951a16b65e2020b4afa3e8e55c160b318e5c56b1893225c37ef03a81bd01a371d6b00c7076c085ee02d6559797b4d3ea3f2d703676337e7525bfaf3e739d0f490f93595e3f69c8fddfb68f1ce73d365e310fd45e3dfd93aebe0b40bc9ffaca23ab90ad85e80ebe2821cc70e05d7e03e06fdf1c358743a39afe0d5bc8b3029dc5db268d579ab94fbf7268ec8b7f9c9999892db80992d32a34540e4293015244a9083edfbd010215a44d05ec2bc3f2402986abd7c0d8e569f75bf7b2eebe007fe57305d24c6f63007ecf78f51bb4931d625f0bcbac0a916cb6b291c78467787fb90bc11b5e277e0a278e3560af7e3056de5ec409995ae55e3df1d2047adfe362bdbce673b332d65b9dac13e8b80908613be988db7013fcc9a12a03de70f9dbf7827048f32fe729289c9869da14bdb0d0a7982df6e26ccf1153231f5c4f03f0082fadc37c2a2a57fd9a86525f7b9e64c97dc92f079fee9d27f42e67f739fda2be52cb78f2806f67d7416d7c0307e89378e5654654075de8b1808799264df9bf2714f23743530ea93de6b6063d0c01d5b885e7ca3cca32e05f4ee7df91e51b1850fe63d5eefd43a156bef486957d5074e4d3a2807e216d10ba5746ea41fe5a9dd09920fc543ff6d0892bbc3c66340fee683f32aa67a1d705808a18e0c9f36820816fb61e2ec1c4e06e4da39a06b85731709f9394b6499f2f73baaa8ff73e3</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Enter the password to read:</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["Others"]},{"title":"Mac环境下使用NDK编译FFmpeg","url":"/post/note/note-ffmpeg_build/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Mac环境下使用NDK编译FFmpeg\"><a href=\"#Mac环境下使用NDK编译FFmpeg\" class=\"headerlink\" title=\"Mac环境下使用NDK编译FFmpeg\"></a>Mac环境下使用NDK编译FFmpeg</h1><h2 id=\"1-环境和所需的文件\"><a href=\"#1-环境和所需的文件\" class=\"headerlink\" title=\"1. 环境和所需的文件\"></a>1. 环境和所需的文件</h2><p>先是环境：</p>\n<ul>\n<li>FFmpeg：3.3.9</li>\n<li>NDK：android-ndk-r14b</li>\n<li>系统：MacOS 10.15</li>\n<li>编译目标：给 Android 用的 ARM 平台</li>\n</ul>\n<p>再给出几个下载链接：</p>\n<ul>\n<li>FFmpeg：<a href=\"https://ffmpeg.org/download.html#releases\" title=\"@LINK\">点此下载</a></li>\n<li>NDK：<a href=\"https://developer.android.google.cn/ndk/downloads/index.html\" title=\"@LINK\">点此下载</a></li>\n</ul>\n<blockquote>\n<p><strong>不建议使用 AndroidStudio 自带的 ndk-bundle 编译，不建议使用最新版 FFmpeg，不建议使用最新版 NDK，理由不明（笑）。</strong></p>\n</blockquote>\n<p>使用最新的 FFmpeg 4.x，按照网上主流的做法，修改 <code>configure</code> 文件然后新建脚本 <code>build_android.sh</code> 的方法，会报如下错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Makefile:2: config.mak: No such file or directory</span><br><span class=\"line\">Makefile:67: /common.mak: No such file or directory</span><br><span class=\"line\">Makefile:114: /libavutil/Makefile: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">C compiler <span class=\"built_in\">test</span> failed.</span><br><span class=\"line\"></span><br><span class=\"line\">If you think configure made a mistake, make sure you are using the latest</span><br><span class=\"line\">version from Git.  If the latest version fails, report the problem to the</span><br><span class=\"line\">ffmpeg-user@ffmpeg.org mailing list or IRC <span class=\"comment\">#ffmpeg on irc.freenode.net.</span></span><br><span class=\"line\">Include the <span class=\"built_in\">log</span> file <span class=\"string\">&quot;config.log&quot;</span> produced by configure as this will <span class=\"built_in\">help</span></span><br><span class=\"line\">solve the problem.</span><br><span class=\"line\">sed: config.h: No such file or directory</span><br><span class=\"line\">sed: config.h: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">Makefile:2: config.mak: No such file or directory</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\">make: *** No rule to make target `/tests/Makefile<span class=\"string\">&#x27;.  Stop.</span></span><br></pre></td></tr></table></figure>\n\n<p>报了一堆 <code>No such file or directory</code> 错误，第一行的 <code>config.mak</code> 也可能是 <code>ffbuild/config.mak</code>，带着错误去搜也搜不到什么头绪，根据报错信息去 FFmpeg 的根目录下或者 <code>ffbuild/</code> 下也确实找不到所谓的 <code>config.mak</code>，一个解决方案是：</p>\n<ol>\n<li><p>先不要修改 <code>configure</code> 文件，直接执行：<code>./configure</code>，但是大概率会报这个错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nasm/yasm not found or too old. Use --disable-x86asm <span class=\"keyword\">for</span> a crippled build.</span><br></pre></td></tr></table></figure>\n\n<p>只要按照提示加上 <code>--disable-x86asm</code> 参数即可，重新执行完会自动生成缺失的文件。</p>\n</li>\n<li><p>再重新执行脚本：<code>sudo ./build_android.sh</code>。</p>\n</li>\n</ol>\n<p>但是这么做，如果是最新的 NDK 或者最新的 FFmpeg，执行完倒是不报错，但是并不会编译输出 SO 文件，所以还是老老实实用已有方案的版本吧！</p>\n<hr>\n<h2 id=\"2-编译SO文件\"><a href=\"#2-编译SO文件\" class=\"headerlink\" title=\"2. 编译SO文件\"></a>2. 编译SO文件</h2><h3 id=\"2-1-配置NDK\"><a href=\"#2-1-配置NDK\" class=\"headerlink\" title=\"2.1 配置NDK\"></a>2.1 配置NDK</h3><p>首先，NDK 下载好后，放到自定义目录中，需要添加到环境变量中去：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 如果用的是 bash 终端：</span></span><br><span class=\"line\">vim ~/.bash_profile</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果用的是 zsh 终端：</span></span><br><span class=\"line\">vim ~/.zshrc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 添加环境变量（按照实际目录）：</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> NDK_HOME=/Applications/AndroidStudio/android-ndk-r14b/build</span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$&#123;NDK_HOME&#125;</span>:<span class=\"variable\">$&#123;PATH&#125;</span>:</span><br></pre></td></tr></table></figure>\n\n<p>保存退出，然后刷新并测试环境变量，执行：<code>ndk-build</code>，如果有类似以下输出则表明配置成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Android NDK: Could not find application project directory !</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>还需要给所有文件加上权限，进入 NDK 的目录并执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod -R 777 ./*</span><br></pre></td></tr></table></figure>\n\n<p><strong>温馨提示：可千万不要把 <code>./*</code> 给打错了，要是不小心把“.”漏了可就麻烦了（请务必不要尝试）。</strong></p>\n<h3 id=\"2-2-配置FFmpeg\"><a href=\"#2-2-配置FFmpeg\" class=\"headerlink\" title=\"2.2 配置FFmpeg\"></a>2.2 配置FFmpeg</h3><p>把下载好的 FFmpeg 源码解压到任意目录，同样也按上述操作给所有文件加上权限，接下来再在 FFmpeg 根目录下创建一个脚本（命名随意）：<code>build_android.sh</code>，修改内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 以实际自定义临时目录为准，必须指定否则报错：Unable to create temporary file in</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> TMPDIR=/....../TEMP</span><br><span class=\"line\"><span class=\"comment\"># 以 NDK 实际路径为准</span></span><br><span class=\"line\">NDK=/Applications/Androidstudio/android-ndk-r14b</span><br><span class=\"line\"><span class=\"comment\"># 编译目标平台，本例选择最低 API 22 的 ARM 平台，输出 SO 文件放在 Android 项目的 libs/armeabi/ 目录下</span></span><br><span class=\"line\"><span class=\"comment\"># x86 架构则选择 arch-x86</span></span><br><span class=\"line\">PLATFORM=<span class=\"variable\">$NDK</span>/platforms/android-22/arch-arm</span><br><span class=\"line\"><span class=\"comment\"># 编译所需工具链，arm-linux-androideabi 对应上面的 ARM 平台，4.9 为版本号，以 NDK 中的实际版本为准</span></span><br><span class=\"line\">TOOLCHAIN=<span class=\"variable\">$NDK</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64</span><br><span class=\"line\"><span class=\"keyword\">function</span> build_one</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">./configure \\</span><br><span class=\"line\">    --prefix=<span class=\"variable\">$PREFIX</span> \\</span><br><span class=\"line\">    --target-os=linux \\</span><br><span class=\"line\">    --cross-prefix=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi- \\</span><br><span class=\"line\">    --arch=arm \\</span><br><span class=\"line\">    --sysroot=<span class=\"variable\">$PLATFORM</span> \\</span><br><span class=\"line\">    --extra-cflags=<span class=\"string\">&quot;-I<span class=\"variable\">$PLATFORM</span>/usr/include&quot;</span> \\</span><br><span class=\"line\">    --cc=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-gcc \\</span><br><span class=\"line\">    --nm=<span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-nm \\</span><br><span class=\"line\">    --disable-shared \\</span><br><span class=\"line\">    --enable-runtime-cpudetect \\</span><br><span class=\"line\">    --enable-gpl \\</span><br><span class=\"line\">    --enable-small \\</span><br><span class=\"line\">    --enable-cross-compile \\</span><br><span class=\"line\">    --disable-debug \\</span><br><span class=\"line\">    --enable-static \\</span><br><span class=\"line\">    --disable-doc \\</span><br><span class=\"line\">    --disable-asm \\</span><br><span class=\"line\">    --disable-ffmpeg \\</span><br><span class=\"line\">    --disable-ffplay \\</span><br><span class=\"line\">    --disable-ffprobe \\</span><br><span class=\"line\">    --disable-ffserver \\</span><br><span class=\"line\">    --disable-postproc \\</span><br><span class=\"line\">    --disable-avdevice \\</span><br><span class=\"line\">    --disable-symver \\</span><br><span class=\"line\">    --disable-stripping \\</span><br><span class=\"line\"><span class=\"variable\">$ADDITIONAL_CONFIGURE_FLAG</span></span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_LRINT 0/HAVE_LRINT 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_LRINTF 0/HAVE_LRINTF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_ROUND 0/HAVE_ROUND 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_TRUNC 0/HAVE_TRUNC 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_CBRT 0/HAVE_CBRT 1/g&#x27;</span> config.h</span><br><span class=\"line\">sed -i <span class=\"string\">&#x27;&#x27;</span> <span class=\"string\">&#x27;s/HAVE_RINT 0/HAVE_RINT 1/g&#x27;</span> config.h</span><br><span class=\"line\">make clean</span><br><span class=\"line\">make -j4</span><br><span class=\"line\">make install</span><br><span class=\"line\"><span class=\"variable\">$TOOLCHAIN</span>/bin/arm-linux-androideabi-ld \\</span><br><span class=\"line\">-rpath-link=<span class=\"variable\">$PLATFORM</span>/usr/lib \\</span><br><span class=\"line\">-L<span class=\"variable\">$PLATFORM</span>/usr/lib \\</span><br><span class=\"line\">-L<span class=\"variable\">$PREFIX</span>/lib \\</span><br><span class=\"line\">-soname libffmpeg.so -shared -nostdlib -Bsymbolic --whole-archive --no-undefined -o \\</span><br><span class=\"line\"><span class=\"variable\">$PREFIX</span>/libffmpeg.so \\</span><br><span class=\"line\">    libavcodec/libavcodec.a \\</span><br><span class=\"line\">    libavfilter/libavfilter.a \\</span><br><span class=\"line\">    libswresample/libswresample.a \\</span><br><span class=\"line\">    libavformat/libavformat.a \\</span><br><span class=\"line\">    libavutil/libavutil.a \\</span><br><span class=\"line\">    libswscale/libswscale.a \\</span><br><span class=\"line\">    -lc -lm -lz -ldl -llog --dynamic-linker=/system/bin/linker \\</span><br><span class=\"line\">    <span class=\"variable\">$TOOLCHAIN</span>/lib/gcc/arm-linux-androideabi/4.9.x/libgcc.a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 平台类型，可以是 arm 或 armv7-a 或 x86 等</span></span><br><span class=\"line\">CPU=armv7-a</span><br><span class=\"line\">OPTIMIZE_CFLAGS=<span class=\"string\">&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=<span class=\"variable\">$CPU</span> &quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 输出 SO 的目录</span></span><br><span class=\"line\">PREFIX=./android/<span class=\"variable\">$CPU</span></span><br><span class=\"line\">ADDITIONAL_CONFIGURE_FLAG=</span><br><span class=\"line\">build_one</span><br></pre></td></tr></table></figure>\n\n<p>接下来在当前目录执行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 按实际创建的脚本名</span></span><br><span class=\"line\">./build_android.sh</span><br></pre></td></tr></table></figure>\n\n<p>需要等一段编译时间，但总之是成功编译了，脚本配置中的“编译后 SO 文件输出目录” <code>PREFIX=./android/$CPU-vfp</code> 表示：<code>当前目录/android/平台类型</code>，比如我当前目录为 <code>/Applications/FFmpeg</code>，平台类型是 <code>arm</code>，则输出目录为：<code>/Applications/FFmpeg/android/arm/</code>。</p>\n<p>编译完可能会报如下错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">install: /usr/<span class=\"built_in\">local</span>/share/man/man1/ffmpeg.1: Permission denied</span><br><span class=\"line\">make: *** [install-man] Error 71</span><br></pre></td></tr></table></figure>\n\n<p>权限错误，也可能是 <code>man3</code> 报的错，简便一点的方法就是直接用 Super User 权限安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ./build_android.sh</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后，在 FFmpeg 根目录下的 <code>android/armv7-a/</code> 下即可看到 <code>libffmpeg.so</code> 文件，复制到 Android 项目中再配置 NDK 即可。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/dfe9404e001a\" title=\"@LINK\">Android Studio下编译FFmpeg so文件</a></li>\n<li><a href=\"https://blog.csdn.net/vichild/article/details/82686343\" title=\"@LINK\">win10子系统编译ffmpeg for android遇到的问题记录</a></li>\n<li><a href=\"https://www.jianshu.com/p/c8ad83dd5585\" title=\"@LINK\">Android编译ffmpeg常见错误</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000015631928\" title=\"@LINK\">Mac中编译FFmpeg教程(Android版)</a></li>\n</ul>\n","categories":["Android"],"tags":["编译","NDK","FFMPEG","SO库"]},{"title":"常用Git命令","url":"/post/note/note-git/","content":"<span id=\"more\"></span>\n\n<h1 id=\"常用Git命令\"><a href=\"#常用Git命令\" class=\"headerlink\" title=\"常用Git命令\"></a>常用Git命令</h1><h2 id=\"1-基本Git操作指令\"><a href=\"#1-基本Git操作指令\" class=\"headerlink\" title=\"1. 基本Git操作指令\"></a>1. 基本Git操作指令</h2><h3 id=\"1-1-创建仓库\"><a href=\"#1-1-创建仓库\" class=\"headerlink\" title=\"1.1 创建仓库\"></a>1.1 创建仓库</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将当前目录初始化为 Git 仓库</span></span><br><span class=\"line\">git init</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在当前目录下创建一个新的目录，并新目录初始化为 Git 仓库</span></span><br><span class=\"line\">git init [new dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从远程仓库克隆到本地</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> [url]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-查看仓库配置\"><a href=\"#1-2-查看仓库配置\" class=\"headerlink\" title=\"1.2 查看仓库配置\"></a>1.2 查看仓库配置</h3><p>Git 配置分为全局配置、以及各个仓库自己的局部配置，仓库的局部配置会与全局配置合并去重，重复的配置项以仓库局部配置为准。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看全局 Git 配置</span></span><br><span class=\"line\"><span class=\"comment\"># 全局 Git 配置保存在 ~/.gitconfig</span></span><br><span class=\"line\">git config --global --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前目录下仓库的 Git 局部配置</span></span><br><span class=\"line\"><span class=\"comment\"># 当前仓库的 Git 配置保存在 [仓库目录]/.git/config</span></span><br><span class=\"line\">git config --list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看接的远程仓库</span></span><br><span class=\"line\">git remote</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看连接的远程仓库的地址</span></span><br><span class=\"line\">git remote -v</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-分支管理\"><a href=\"#1-3-分支管理\" class=\"headerlink\" title=\"1.3 分支管理\"></a>1.3 分支管理</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 从远程连接仓库拉取最新数据到本地仓库</span></span><br><span class=\"line\">git fetch [name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有本地分支</span></span><br><span class=\"line\">git branch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有远程分支</span></span><br><span class=\"line\">git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有本地以及远程的分支</span></span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，但不切换</span></span><br><span class=\"line\">git branch [new branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切换到新的分支，并更新工作区文件（切换到新分支的改动记录）</span></span><br><span class=\"line\">git checkout [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 新建一个分支，并切换到该新分支，同时更新工作区文件</span></span><br><span class=\"line\">git checkout -b [new branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将指定的本地分支连接到远程分支</span></span><br><span class=\"line\">git branch --set-upstream [<span class=\"built_in\">local</span> branch name] [remote branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 删除一个本地分支</span></span><br><span class=\"line\">git branch -d [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 同时从本地和远程删除一个分支</span></span><br><span class=\"line\">git branch -dr [remote/branch]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将另一个本地分支的改动合并到当前分支</span></span><br><span class=\"line\">git merge [branch name]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下的某个改动提交记录同步到当前分支</span></span><br><span class=\"line\">git cherry-pick [commit id]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下多个改动提交记录同时同步到当前分支</span></span><br><span class=\"line\">git cherry-pick [commit id1] [commit id2]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下一段连续的改动提交记录同步到当前分支，范围左开右闭（即不包括 id1）</span></span><br><span class=\"line\">git cherry-pick [commit id1]..[commit id5]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前仓库下一段连续的改动提交记录同步到当前分支，范围左闭右闭（包括 id1）</span></span><br><span class=\"line\">git cherry-pick [commit id1]^..[commit id5]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-提交变更\"><a href=\"#1-4-提交变更\" class=\"headerlink\" title=\"1.4 提交变更\"></a>1.4 提交变更</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 将改动文件提交到暂存区</span></span><br><span class=\"line\">git add [file1] [file2]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将某个目录下所有改动文件提交到暂存区</span></span><br><span class=\"line\">git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将当前目录下所有改动文件提交到暂存区</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将暂存区的所有改动提交到仓库</span></span><br><span class=\"line\">git commit -a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 提交暂存区并同时显示每个改动的 Diff</span></span><br><span class=\"line\">git commit -v</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看所有文件变更状态</span></span><br><span class=\"line\">git status</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支的历史提交记录</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看当前分支的历史提交记录，并显示每次提交时发生变更的文件</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-其他命令\"><a href=\"#1-5-其他命令\" class=\"headerlink\" title=\"1.5 其他命令\"></a>1.5 其他命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Search branch name containing commit <span class=\"built_in\">hash</span>, and filter with text.</span></span><br><span class=\"line\">git branch [-r | -a] --contains &lt;commit-hash&gt; | grep [FILTER]</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-常见的跨仓库设置\"><a href=\"#2-常见的跨仓库设置\" class=\"headerlink\" title=\"2. 常见的跨仓库设置\"></a>2. 常见的跨仓库设置</h2><h3 id=\"2-1-同时Push到多个仓库\"><a href=\"#2-1-同时Push到多个仓库\" class=\"headerlink\" title=\"2.1 同时Push到多个仓库\"></a>2.1 同时Push到多个仓库</h3><p>通过 <code>git remote -v</code> 可以查看当前仓库拉取（fetch）和推送（push）的远程仓库的链接：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin https://XXX.git (fetch)</span><br><span class=\"line\">origin https://XXX.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>如果想同时 Push 到多个仓库可以通过如下方式添加多个目标仓库地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote set-url --add [name] [url]</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>[name]</code> 对应的是远程仓库的别名，例如上述的 <code>origin</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote set-url --add origin https://new-push-url.git</span><br></pre></td></tr></table></figure>\n\n<p>设置后再次用 <code>git remote -v</code> 查看远程仓库链接，即可看到已经有两个 Push 地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin https://XXX.git (fetch)</span><br><span class=\"line\">origin https://XXX.git (push)</span><br><span class=\"line\">origin https://new-push-url.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>实际上也可以通过直接修改当前仓库的局部配置文件添加，修改 <code>仓库目录/.git/config</code> 文件，在 <code>[remote]</code> 部分内添加一个 <code>url</code> 配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[core]</span><br><span class=\"line\">        ......</span><br><span class=\"line\">[remote <span class=\"string\">&quot;origin&quot;</span>]</span><br><span class=\"line\">        url = https://XXX.git</span><br><span class=\"line\">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class=\"line\">        url = https://new-push-url.git</span><br><span class=\"line\">[branch <span class=\"string\">&quot;master&quot;</span>]</span><br><span class=\"line\">        ......</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-同时连接到多个远程仓库\"><a href=\"#2-2-同时连接到多个远程仓库\" class=\"headerlink\" title=\"2.2 同时连接到多个远程仓库\"></a>2.2 同时连接到多个远程仓库</h3><p>假如有一个本地仓库，出于容灾、备份、等目的，同时推送到了两个远程托管平台，以 GitHub 和 Coding 为例：</p>\n<ul>\n<li>假设 GitHub 上的远程仓库地址为 <code>https://XXX.github.git</code></li>\n<li>假设 Coding 上的远程仓库地址为 <code>https://XXX.coding.git</code>。</li>\n</ul>\n<p>而其他人分别基于不同的平台各自推送了特性分支，此时两个远程仓库的分支列表分别为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># GitHub 的分支列表：</span></span><br><span class=\"line\">* develop</span><br><span class=\"line\">  main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Coding 的分支列表：</span></span><br><span class=\"line\">* release</span><br><span class=\"line\">  main</span><br></pre></td></tr></table></figure>\n\n<p>假设基于 GitHub 的远程仓库克隆了本地仓库，此时如果直接在 <code>develop</code> 分支上尝试合并 <code>release</code> 分支，会因为找不到 <code>release</code> 分支而失败：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">merge: release - not something we can merge</span><br></pre></td></tr></table></figure>\n\n<p>想要对这两个来自不同平台的独立的分支做合并，就需要让本地仓库同时连接多个远程仓库了。</p>\n<p>通过 <code>git remote -v</code> 查看本地仓库当前的远程连接地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin https://XXX.github.git (fetch)</span><br><span class=\"line\">origin https://XXX.github.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>给本地仓库再添加 Coding 的远程仓库连接地址，为了方便区分将新的远程仓库命名为 <code>coding</code>，则对应命令为：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># git remote add &lt;option&gt; [name] [url]</span></span><br><span class=\"line\">git remote add coding https://XXX.coding.git</span><br></pre></td></tr></table></figure>\n\n<p>再次通过 <code>git remote -v</code> 即可看到该本地仓库已经同时连接到了两个远程仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">origin http://XXX.github.git (fetch)</span><br><span class=\"line\">origin http://XXX.github.git (push)</span><br><span class=\"line\">coding https://XXX.coding.git (fetch)</span><br><span class=\"line\">coding https://XXX.coding.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>接下来同时把两个远程仓库的数据都拉取下来：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 拉取名为 origin 的仓库，即 GitHub 上的</span></span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 拉取名为 coding 的仓库，即 Coding 上的</span></span><br><span class=\"line\">git fetch coding</span><br></pre></td></tr></table></figure>\n\n<p>再次尝试在 <code>develop</code> 分支上合并 <code>release</code> 分支即可正常合并，当然如果有冲突也会进入常规流程：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 切换到 develop 分支</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 合并 release 分支</span></span><br><span class=\"line\">git merge release</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"2-3-跨仓库Cherry-Pick\"><a href=\"#2-3-跨仓库Cherry-Pick\" class=\"headerlink\" title=\"2.3 跨仓库Cherry-Pick\"></a>2.3 跨仓库Cherry-Pick</h3><p>通常来说 Cherry-Pick 发生在仓库内的不同分支，用于将其他分支的改动同步到当前分支。</p>\n<p>如果一个仓库 <code>GitHub</code> 想要在 Cherry-Pick 另一个仓库 <code>Coding</code> 的提交（例如 commit123fromsource），就会报错：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">fatal: bad revision <span class=\"string\">&#x27;commit123fromsource&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果这两个仓库是 Fork 的关系，或者只是同一个仓库在不同托管平台的备份，本质上它们是同源的，想要互相支持 Cherry-Pick 的话就需要通过上文 2.2 中的方法，给本地仓库同时添加两份远程仓库的连接，然后就能随意 Cherry-Pick 了，当然如果发生冲突也会进入常规流程。</p>\n<p>实际上，一个本地仓库可以随意添加多个远程仓库的地址，然后就能随意操作其他仓库的分支或 Commit，但是 Cherry-Pick 需要满足一定的条件，例如涉及到的改动文件具有同源的改动记录，否则就会失败，只能从最开始文件创建的时候开始 Cherry-Pick 才行。</p>\n","categories":["Note"],"tags":["Git","Cherry-Pick","仓库","分支"]},{"title":"客户端开发工程师技能表","url":"/post/note/note-work_skill/","content":"<span id=\"more\"></span>\n\n<h1 id=\"客户端开发工程师技能表\"><a href=\"#客户端开发工程师技能表\" class=\"headerlink\" title=\"客户端开发工程师技能表\"></a>客户端开发工程师技能表</h1><h2 id=\"1-Android\"><a href=\"#1-Android\" class=\"headerlink\" title=\"1. Android\"></a>1. Android</h2><h3 id=\"Android原生机制\"><a href=\"#Android原生机制\" class=\"headerlink\" title=\"Android原生机制\"></a>Android原生机制</h3><p>（1）运行时机制</p>\n<ul>\n<li><a href=\"/post/android/android-touch_event/\" title=\"@LINK\">Android-触摸事件</a></li>\n<li><a href=\"/post/android/android-render/\" title=\"@LINK\">Android-渲染机制</a></li>\n<li><a href=\"/post/android/android-window/\" title=\"@LINK\">Android-Window机制</a></li>\n<li>Android 动画类型：补间动画、属性动画、帧动画</li>\n</ul>\n<p>（2）编译时机制</p>\n<ul>\n<li><a href=\"/post/android/android-apt/\" title=\"@LINK\">Android-APT</a></li>\n<li><a href=\"/post/android/android-hotfix/\" title=\"@LINK\">热更新和热修复</a></li>\n<li><a href=\"/post/android/android-build_install/\" title=\"@LINK\">App编译打包流程</a></li>\n<li><a href=\"/post/android/android-multidex/\" title=\"@LINK\">MultiDex</a></li>\n<li><a href=\"/post/android/android-apk_protect/\" title=\"@LINK\">Android-APK保护</a></li>\n</ul>\n<h3 id=\"Android原生组件\"><a href=\"#Android原生组件\" class=\"headerlink\" title=\"Android原生组件\"></a>Android原生组件</h3><p>（1）四大组件</p>\n<ul>\n<li><a href=\"/post/android/android-activity_lifecycle/\" title=\"@LINK\">Activity生命周期</a></li>\n<li><a href=\"/post/android/android-activity_startup/\" title=\"@LINK\">Activity启动流程</a></li>\n<li><a href=\"/post/android/android-service/\" title=\"@LINK\">Service</a></li>\n<li><a href=\"/post/android/android-broadcast/\" title=\"@LINK\">Broadcast</a></li>\n<li><a href=\"/post/android/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n</ul>\n<p>（2）五大存储</p>\n<ul>\n<li><a href=\"/post/android/android-sharedpreference/\" title=\"@LINK\">SharedPreferences</a></li>\n<li><a href=\"/post/android/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n<li>SQLite</li>\n<li>文件存储</li>\n<li>网络存储</li>\n</ul>\n<h3 id=\"Android消息和通信机制\"><a href=\"#Android消息和通信机制\" class=\"headerlink\" title=\"Android消息和通信机制\"></a>Android消息和通信机制</h3><ul>\n<li>消息处理机制：<ul>\n<li><a href=\"/post/android/android-message/\" title=\"@LINK\">Message</a></li>\n<li><a href=\"/post/android/android-messagequeue/\" title=\"@LINK\">MessageQueue</a></li>\n<li><a href=\"/post/android/android-looper/\" title=\"@LINK\">Looper</a></li>\n<li><a href=\"/post/android/android-handler/\" title=\"@LINK\">Handler</a></li>\n</ul>\n</li>\n<li><a href=\"/post/android/android-itc/\" title=\"@LINK\">Android-ITC</a></li>\n<li><a href=\"/post/android/android-binder/\" title=\"@LINK\">Android-Binder</a></li>\n<li><a href=\"/post/android/android-messenger/\" title=\"@LINK\">Messenger</a></li>\n<li>AIDL</li>\n<li><a href=\"/post/network/network-socket/\" title=\"@LINK\">Socket</a></li>\n<li><a href=\"/post/android/android-broadcast/\" title=\"@LINK\">Broadcast</a></li>\n<li><a href=\"/post/android/android-contentprovider/\" title=\"@LINK\">ContentProvider</a></li>\n<li>文件共享：多进程读写同一文件是难以控制、不安全的。</li>\n<li><del>SharedPrefernces：公共读（<code>MODE_WORLD_READABLE</code>）模式、公共写（<code>MODE_WORLD_WRITEABLE</code>）模式、跨进程（<code>MODE_MULTI_PROCESS</code>）模式均已弃用，多进程读写同一文件是难以控制、不安全的，Google 推荐使用基于 ContentProvider 的 FileProvider 来实现。</del></li>\n</ul>\n<h3 id=\"Android性能和优化\"><a href=\"#Android性能和优化\" class=\"headerlink\" title=\"Android性能和优化\"></a>Android性能和优化</h3><ul>\n<li><a href=\"/post/android/android-anr/\" title=\"@LINK\">Android-ANR</a></li>\n<li><a href=\"/post/android/android-oom/\" title=\"@LINK\">Android-OOM</a></li>\n<li><a href=\"/post/android/android-memory/\" title=\"@LINK\">Android-内存优化</a></li>\n</ul>\n<h3 id=\"Android应用层框架\"><a href=\"#Android应用层框架\" class=\"headerlink\" title=\"Android应用层框架\"></a>Android应用层框架</h3><ul>\n<li><a href=\"/post/android/android-architecture/\" title=\"@LINK\">Android-应用架构</a></li>\n<li><a href=\"/post/android/android-design_pattern/\" title=\"@LINK\">Android-设计模式</a></li>\n<li><a href=\"/post/android/android-router/android-router\" title=\"@LINKS\">Android-Router路由框架浅析</a></li>\n<li>Glide（虚拟碎片监视时间周期）</li>\n<li>EventBus</li>\n<li>Retrofit</li>\n<li>RXJava：<a href=\"http://gank.io/post/560e15be2dca930e00da1083\">http://gank.io/post/560e15be2dca930e00da1083</a></li>\n<li>OKHttp、基于 OKHttp 二次封装（拦截器设计模式）</li>\n</ul>\n<h3 id=\"Android其他细节\"><a href=\"#Android其他细节\" class=\"headerlink\" title=\"Android其他细节\"></a>Android其他细节</h3><ul>\n<li><a href=\"/post/android/android-issues/\" title=\"@LINK\">Android-疑难杂症</a></li>\n<li>SparseArray 的改进</li>\n<li>自己设计一个图片浏览器（图片加载器）：<ul>\n<li>首先要考虑到会加载多图和大图的情况。</li>\n<li>对于多图，采用预览图和本地缓存的形式，首次进入后，先从本地读取图片并加载预览小图，然后写入本地缓存，下次进入时，先从本地加载小图缓存，然后异步获取图片的更新，图片有更新时再重新缓存。并且在进入 App 后，根据显示的范围，缓存上下两行或者左右两列的图片，滑动时能提供更好的视觉效果，如果是纯粹的图片浏览器，其图片变动不大，则还可以将预览小图缓存到内存中。</li>\n<li>对于大图，采用优化加载的方式，点击小图进入大图时，先预加载图片的宽高信息，如果图片和实际显示范围差别不大，则可以直接加载进来，如果图片远大于实际可显示范围，则首先压缩到当前可显示范围的大小，或者将 BitMap 裁剪到当前的显示范围再显示，然后用户双击放大的时候，利用 <code>BitmapRegionDecoder</code> 绘制实际原图的局部，并且配合 GestureDetector 监听手势滑动，来不断的绘制不同的位置，用户在缩小后，如果用户马上切换另一个大图，则将前一个大图的 Bitmap 清空，然后复用，否则设置一个定时方法，在一定时间内，保存前一个大图 Bitmap 的缓存，这样用户再次打开时就不用重复加载，如果超时，再回收该 Bitmap 对象。</li>\n<li>对于 App 整体，还要有个队列或者链表，用来记录整体内存占用，例如在大图模式下，假如内存占用接近或超过了预期的最大值，则释放掉之前小图模式下的内存，用户再退出大图模式后再重新加载图片列表。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"2-iOS\"><a href=\"#2-iOS\" class=\"headerlink\" title=\"2. iOS\"></a>2. iOS</h2><h3 id=\"iOS其他细节\"><a href=\"#iOS其他细节\" class=\"headerlink\" title=\"iOS其他细节\"></a>iOS其他细节</h3><ul>\n<li><a href=\"/post/ios/ios-issues/\" title=\"@LINK\">iOS-疑难杂症</a></li>\n</ul>\n<hr>\n<h2 id=\"3-Java\"><a href=\"#3-Java\" class=\"headerlink\" title=\"3. Java\"></a>3. Java</h2><p><a href=\"/post/java/java-standard/\" title=\"@LINK\">Java思想规范</a></p>\n<h3 id=\"Java原生框架\"><a href=\"#Java原生框架\" class=\"headerlink\" title=\"Java原生框架\"></a>Java原生框架</h3><ul>\n<li><a href=\"/post/java/java-hashmap/\" title=\"@LINK\">Java-HashMap</a></li>\n<li><a href=\"/post/java/java-string/\" title=\"@LINK\">Java-String</a></li>\n<li><a href=\"/post/java/java-lru/\" title=\"@LINK\">LRU算法及其优化</a></li>\n<li><a href=\"/post/java/java-hashcode/\" title=\"@LINK\">Java-HashCode</a></li>\n<li><a href=\"/post/java/java-threadlocal/\" title=\"@LINK\">Java-ThreadLocal</a></li>\n</ul>\n<h3 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h3><ul>\n<li><a href=\"/post/java/java-class/\" title=\"@LINK\">Java类加载机制</a></li>\n<li>Java反射原理</li>\n<li><a href=\"/post/java/java-jvm_memory/\" title=\"@LINK\">JVM内存模型和内存分区</a></li>\n<li><a href=\"/post/java/java-gc/\" title=\"@LINK\">JVM的GC策略</a></li>\n<li><a href=\"/post/java/java-reference/\" title=\"@LINK\">Java中的引用</a></li>\n<li><a href=\"/post/java/java-lock/\" title=\"@LINK\">Java同步锁</a></li>\n<li><a href=\"/post/java/java-finally/\" title=\"@LINKS\">Java-finally关键字</a></li>\n</ul>\n<hr>\n<h2 id=\"4-Linux操作系统\"><a href=\"#4-Linux操作系统\" class=\"headerlink\" title=\"4. Linux操作系统\"></a>4. Linux操作系统</h2><ul>\n<li><a href=\"/post/linux/linux-io_block/\" title=\"@LINK\">Linux-IO阻塞模型</a></li>\n<li>Linux 是怎么知道 App 崩溃的？如果想要在被 Kill 前做一些耗时操作该怎么做？</li>\n<li>怎么定位 Native Crash？如果上报过程中再次产生 Crash 能不能捕捉到？</li>\n<li>如何设计一个 Crash 捕获模块？</li>\n<li><a href=\"https://blog.csdn.net/ljheee/article/details/53191397\" title=\"@LINK\">App 沙箱化</a></li>\n</ul>\n<hr>\n<h2 id=\"5-Network\"><a href=\"#5-Network\" class=\"headerlink\" title=\"5. Network\"></a>5. Network</h2><ul>\n<li><a href=\"/post/network/network-tcp_udp/\" title=\"@LINK\">TCP和UDP</a></li>\n<li><a href=\"/post/network/network-http_https/\" title=\"@LINK\">HTTP和HTTPS</a></li>\n<li><a href=\"/post/network/network-socket/\" title=\"@LINK\">Socket</a></li>\n<li><a href=\"/post/network/network-rtmp/\" title=\"@LINK\">Network-RTMP</a></li>\n<li>如何防止DNS劫持</li>\n</ul>\n<hr>\n<h2 id=\"6-常见算法\"><a href=\"#6-常见算法\" class=\"headerlink\" title=\"6. 常见算法\"></a>6. 常见算法</h2><ul>\n<li><a href=\"/post/algorithm/algorithm-find_from_series/\" title=\"@LINK\">算法-数列查找</a></li>\n<li><a href=\"/post/algorithm/algorithm-sum_of_numbers/\" title=\"@LINK\">算法-求和问题</a></li>\n<li><a href=\"/post/algorithm/algorithm-substring/\" title=\"@LINK\">算法-查找子串</a></li>\n<li><a href=\"/post/algorithm/algorithm-sort/\" title=\"@LINK\">算法-排序算法</a></li>\n<li><a href=\"/post/algorithm/algorithm-binary_tree/\" title=\"@LINK\">算法-二叉树</a></li>\n<li>数组最大堆</li>\n<li>LCS</li>\n<li>洗牌功能</li>\n<li>二叉树中两个节点的最近公共父节点</li>\n<li>大数相乘</li>\n<li>int 变量存 ip 地址</li>\n<li>10 亿数据找到出现最多次数的数字</li>\n<li>100 万个数字求 100 个最大值</li>\n<li>打印回环数组</li>\n<li>递归非递归反转链表</li>\n<li>找到一个字符串中出现最多的字母</li>\n<li>给定无序数组和一个值，找到两个数和为值的元素，不能使用额外空间复杂度（不使用 HashMap）：<a href=\"https://blog.csdn.net/suibianshen2012/article/details/51923477\">https://blog.csdn.net/suibianshen2012/article/details/51923477</a></li>\n<li>已知两条链表都是升序的，合并这两条链表，并保持升序状态（归并）</li>\n<li><a href=\"/post/algorithm/algorithm-find_pictures/\" title=\"@LINK\">算法-数据库中查找图片</a></li>\n<li><a href=\"/post/algorithm/algorithm-transport_and_consume/\" title=\"@LINK\">算法-运输和消耗最优解问题</a></li>\n</ul>\n","categories":["Note"],"tags":["iOS","Android","Java","Network","Note","网络","Interview"]},{"title":"算法-二叉树","url":"/post/algorithm/algorithm-binary_tree/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-二叉树\"><a href=\"#算法-二叉树\" class=\"headerlink\" title=\"算法-二叉树\"></a>算法-二叉树</h1><h2 id=\"1-二叉树的遍历\"><a href=\"#1-二叉树的遍历\" class=\"headerlink\" title=\"1. 二叉树的遍历\"></a>1. 二叉树的遍历</h2><p>说明：假设给定二叉树的树形结构以及对应节点的数据结构如下：</p>\n<p><img data-src=\"./binary_tree_ergodic.svg\" alt=\"二叉树的遍历\" title=\"@ASSET\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    Node left;</span><br><span class=\"line\">    Node right;</span><br><span class=\"line\">    Node(<span class=\"keyword\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-前序遍历\"><a href=\"#1-1-前序遍历\" class=\"headerlink\" title=\"1.1 前序遍历\"></a>1.1 前序遍历</h3><p>前序遍历（父 - 左 - 右）指：对每一个节点，都优先遍历父节点；然后是左子节点；最后是右子节点。对应图例的二叉树，则遍历顺序为：</p>\n<ul>\n<li>从根结点 A 出发，遍历 A</li>\n<li>A 具有左子节点 B，遍历 B</li>\n<li>B 具有左子节点 D，遍历 D</li>\n<li>D 不具有左子节点，但具有右子节点 H，遍历 H</li>\n<li>H 不具有左子节点，但具有右子节点 K，遍历 K</li>\n<li>K 不具有左子节点，也不具有右子节点，返回 H</li>\n<li>H 遍历完毕，返回 D</li>\n<li>D 遍历完毕，返回 B</li>\n<li>B 具有右子节点 E，遍历 E</li>\n<li>E 不具有左子节点，也不具有右子节点，返回 B</li>\n<li>B 遍历完毕，返回 A</li>\n<li>A 具有右子节点 C，遍历 C</li>\n<li>......</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">A -&gt; B -&gt; D -&gt; H -&gt; K -&gt; E -&gt; C -&gt; F -&gt; I -&gt; L -&gt; G -&gt; J</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinaryTreeErgodic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preOrder</span><span class=\"params\">(Node parent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 优先遍历父节点，用 println 表示遍历到。</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Val: &quot;</span> + parent.val);</span><br><span class=\"line\">        <span class=\"comment\">// 然后遍历左子节点。</span></span><br><span class=\"line\">        preOrder(parent.left);</span><br><span class=\"line\">        <span class=\"comment\">// 最后遍历右子节点。</span></span><br><span class=\"line\">        preOrder(parent.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-中序遍历\"><a href=\"#1-2-中序遍历\" class=\"headerlink\" title=\"1.2 中序遍历\"></a>1.2 中序遍历</h3><p>中序遍历（左 - 父 - 右）指：对每一个节点，都优先深度遍历左子节点，直到某个节点没有左子节点；然后遍历父节点；最后遍历右子节点。对应图例的二叉树，则遍历顺序为：</p>\n<ul>\n<li>从根结点 A 出发，A 具有左子节点 B</li>\n<li>B 具有左子节点 D</li>\n<li>D 不具有左子节点，遍历 D 自己</li>\n<li>D 具有右子节点 H</li>\n<li>H 不具有左子节点，遍历 H 自己</li>\n<li>H 具有右子节点 K</li>\n<li>K 不具有左子节点，遍历 K 自己</li>\n<li>K 不具有右子节点，遍历完毕返回 H</li>\n<li>H 遍历完毕，返回 D</li>\n<li>D 遍历完毕，返回 B</li>\n<li>B 左子节点遍历完毕，遍历 B 自己</li>\n<li>B 具有右子节点 E</li>\n<li>E 不具有左子节点，遍历 E 自己</li>\n<li>E 不具有右子节点，遍历完毕返回 B</li>\n<li>B 遍历完毕，返回 A</li>\n<li>A 左子节点遍历完毕，遍历 A 自己</li>\n<li>A 具有右子节点 C</li>\n<li>......</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">D -&gt; H -&gt; K -&gt; B -&gt; E -&gt; A -&gt; F -&gt; L -&gt; I -&gt; C -&gt; G -&gt; J</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinaryTreeErgodic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">midOrder</span><span class=\"params\">(node parent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 优先深度遍历左子节点。</span></span><br><span class=\"line\">        preOrder(parent.left);</span><br><span class=\"line\">        <span class=\"comment\">// 直到左子节点遍历完毕，则遍历自己，用 println 表示遍历到。</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Val: &quot;</span> + parent.val);</span><br><span class=\"line\">        <span class=\"comment\">// 最后遍历右子节点。</span></span><br><span class=\"line\">        preOrder(parent.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-后序遍历\"><a href=\"#1-3-后序遍历\" class=\"headerlink\" title=\"1.3 后序遍历\"></a>1.3 后序遍历</h3><p>后序遍历（左 - 右 - 父）指：对每一个节点，都优先深度遍历左子节点，直到某个节点没有左子节点；然后深度遍历右子节点；最后遍历父节点。对应图例的二叉树，则遍历顺序为：</p>\n<ul>\n<li>从根结点 A 出发，A 具有左子节点 B</li>\n<li>B 具有左子节点 D</li>\n<li>D 不具有左子节点，但具有右子节点 H</li>\n<li>H 不具有左子节点，但具有右子节点 K</li>\n<li>K 不具有左子节点，也不具有右子节点，遍历 K 自己</li>\n<li>K 遍历完毕，返回 H</li>\n<li>H 左子节点遍历完毕，右子节点遍历完毕，遍历 H 自己</li>\n<li>H 遍历完毕，返回 D</li>\n<li>D 左子节点遍历完毕，右子节点遍历完毕，遍历 D 自己</li>\n<li>D 遍历完毕，返回 B</li>\n<li>B 左子节点遍历完毕，具有右子节点 E</li>\n<li>E 不具有左子节点，也不具有右子节点，遍历 E 自己</li>\n<li>E 遍历完毕，返回 B</li>\n<li>B 左子节点遍历完毕，右子节点遍历完毕，遍历 B 自己</li>\n<li>B 遍历完毕，返回 A</li>\n<li>A 左子节点遍历完毕，具有右子节点 C</li>\n<li>C 具有左子节点 F</li>\n<li>F 不具有左子节点，但具有右子节点 I</li>\n<li>I 具有左子节点 L</li>\n<li>L 不具有左子节点，也不具有右子节点，遍历 L 自己</li>\n<li>......</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">K -&gt; H -&gt; D -&gt; E -&gt; B -&gt; L -&gt; I -&gt; F -&gt; J -&gt; G -&gt; C -&gt; A</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BinaryTreeErgodic</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">midOrder</span><span class=\"params\">(node parent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 优先深度遍历左子节点。</span></span><br><span class=\"line\">        preOrder(parent.left);</span><br><span class=\"line\">        <span class=\"comment\">// 然后遍历右子节点。</span></span><br><span class=\"line\">        preOrder(parent.right);</span><br><span class=\"line\">        <span class=\"comment\">// 直到左右子节点都遍历完毕，最后遍历自己，用 println 表示遍历到。</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Val: &quot;</span> + parent.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["Algorithm"],"tags":["Algorithm","算法","二叉树"]},{"title":"算法-数列查找","url":"/post/algorithm/algorithm-find_from_series/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-数列查找\"><a href=\"#算法-数列查找\" class=\"headerlink\" title=\"算法-数列查找\"></a>算法-数列查找</h1><h2 id=\"1-从两个正序数组中找出中位数\"><a href=\"#1-从两个正序数组中找出中位数\" class=\"headerlink\" title=\"1. 从两个正序数组中找出中位数\"></a>1. 从两个正序数组中找出中位数</h2><p>说明：给定两个正序（从小到大）整数数组：<code>nums1 = int[n]</code>、<code>nums2 = int[m]</code>，找出这两个数组全部元素的中位数，假定两个数组均非空（<code>n, m &gt;= 0</code>），且不同时为空数组（<code>n + m &gt;= 1</code>）。</p>\n<blockquote>\n<p>例 1：</p>\n<p><code>nums1 = [1,3]</code>、<code>nums2 = [2]</code>；则合并后数组为 <code>[1, 2, 3]</code>，中位数为 2。</p>\n<p>例 2：</p>\n<p><code>nums1 = [1,2]</code>、<code>nums2 = [3,4]</code>；则合并后数组为 <code>[1, 2, 3, 4]</code>，中位数为 <code>(2 + 3) / 2 = 2.5</code>。</p>\n</blockquote>\n<h3 id=\"1-1-数组归并法\"><a href=\"#1-1-数组归并法\" class=\"headerlink\" title=\"1.1 数组归并法\"></a>1.1 数组归并法</h3><p>首先「归并」两个有序数组，假设数组长度分别为 <code>length1</code> 和 <code>length2</code>，归并后中位数下标为 <code>midIndex</code>。</p>\n<ul>\n<li>由于归并后元素个数 <code>sum</code> 可能为奇数或偶数，所以 <code>midIndex</code> 需要取更大的，确保包括中位数，<ul>\n<li>奇数个的中位数位于 <code>(sum / 2) + 1</code>，下标为 <code>sum / 2</code>；</li>\n<li>偶数个的中位数位于 <code>sum / 2</code> 和 <code>(sum / 2) + 1</code>，下标为 <code>(sum / 2) - 1</code> 和 <code>sum / 2</code>；</li>\n<li>取最大的，也就是 <code>midIndex = sum / 2</code>。</li>\n</ul>\n</li>\n<li>所以偶数个 <code>isEven == true</code> 时，可以记录 <code>value = merge[midIndex - 1]</code>，再累加 <code>value += merge[midIndex]</code>，然后遍历结束后，如果 <code>isEven == true</code>，则 <code>value /= 2</code>。</li>\n<li>但实际上，由于题目只需要查找中位数，所以只需要保证中位数及之前的元素有序即可，因此只需要排序 <code>midIndex + 1</code> 个元素，可以通过循环 <code>for (i = 0; i &lt;= midIndex; i++)</code> 来控制。由于题目给出两个数组都是正序排列（从小到大），可以每次都从两个数组中取一位最小的，直到一共取了 <code>midIndex + 1</code> 个元素为止，因此需要两个变量 <code>index1</code> 和 <code>index2</code> 分别记录两个数组下一次从哪个元素开始取。</li>\n<li>由于 <code>midIndex</code> 是两个数组归并后的中位数下标，所以从逻辑上可以确定一个特征：<ul>\n<li>如果循环到第 <code>i</code> 次时，一个数组已被取完，即 <code>index1 &gt;= length1</code> 或 <code>index2 &gt;= length2</code> 下标越界，但归并后数组元素个数仍然小于 <code>midIndex + 1</code> 个，则另一个数组的下标 <code>i</code> 一定还未越界。换句话说，从 <code>i = 0</code> 循环到 <code>i = midIndex</code> 的过程中，两个数组对下标 <code>i</code> 的取值不可能同时越界。</li>\n</ul>\n</li>\n<li>归并时从哪个数组取了元素，就将对应数组的 <code>index</code> 更新到该元素的下标，表示数组剩余元素最小值的下标。</li>\n</ul>\n<p>例如 <code>[1, 2]</code> 和 <code>[0, 3, 4, 5, 6]</code>，用 &gt; 表示两个数组归并过程中的的 <code>index</code>，一共有 7 个元素，则归并后的中位数下标 <code>midIndex == 3</code>；也即一共只需要归并 4 个元素即可：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">归并下标 <code>i</code></th>\n<th align=\"center\">merge</th>\n<th align=\"center\">nums1</th>\n<th align=\"center\">nums2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">初始化</td>\n<td align=\"center\"><code>[]</code></td>\n<td align=\"center\"><code>[&gt;1, 2]</code> <code>index1 = 0</code></td>\n<td align=\"center\"><code>[&gt;0, 3, 4, 5, 6]</code> <code>index2 = 0</code></td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>[0]</code></td>\n<td align=\"center\"><code>[&gt;1, 2]</code> <code>index1 = 0</code></td>\n<td align=\"center\"><code>[0, &gt;3, 4, 5, 6]</code> <code>index2 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code>[0, 1]</code></td>\n<td align=\"center\"><code>[1, &gt;2]</code> <code>index1 = 1</code></td>\n<td align=\"center\"><code>[0, &gt;3, 4, 5, 6]</code> <code>index2 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>[0, 1, 2]</code></td>\n<td align=\"center\"><code>[1, 2 &gt;]</code> <code>index1 = 2</code> 越界</td>\n<td align=\"center\"><code>[0, &gt;3, 4, 5, 6]</code> <code>index2 = 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>[0, 1, 2, 3]</code></td>\n<td align=\"center\"><code>[1, 2 &gt;]</code> <code>index1 = 2</code> 越界</td>\n<td align=\"center\"><code>[0, 3, &gt;4, 5, 6]</code> <code>index2 = 2</code></td>\n</tr>\n</tbody></table>\n<p>归并完成，中位数即为 <code>merge[midIndex] == merge[3] == 3</code>，如果元素总数为偶数，思路也是一样的，只是最终计算中位数为 <code>(merge[midIndex - 1] + merge[midIndex]) / 2</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_Merge</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span>[] nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((nums1 == <span class=\"keyword\">null</span> || nums1.length == <span class=\"number\">0</span>) &amp;&amp; (nums2 == <span class=\"keyword\">null</span> || nums2.length == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 元素总个数：</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sumLength = nums1.length + nums2.length;</span><br><span class=\"line\">        <span class=\"comment\">// 是否总共有偶数个元素，如果是，则需要累加中间的两个元素并除以二：</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isEven = (sumLength % <span class=\"number\">2</span> == <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 中位数下标，如果共有奇数个则代表中位数本身，如果是偶数个则代表中间两个元素中下标更大的：</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> midIndex = sumLength / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于记录两个数组分别归并到了第几位元素，也即接下来需要归并的第一位元素的下标：</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index1 = <span class=\"number\">0</span>, index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于记录实际中位数的值，注意因为精确到小数，所以要用 double：</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> midValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用于记录最新一个被归并的元素的值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">        <span class=\"comment\">// 只需要归并 midIndex + 1 次</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= midIndex; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index1 &gt;= nums1.length) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 数组 1 越界说明已经被归并完了，则下一位被归并的就是从数组 2 取接下来的第 1 位元素</span></span><br><span class=\"line\">                value = nums2[index2++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (index2 &gt;= nums2.length) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 数组 2 越界说明已经被归并完了，则下一位被归并的就是从数组 1 取接下来的第 1 位元素</span></span><br><span class=\"line\">                value = nums1[index1++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则如果数组 1 接下来一位比数组 2 接下来一位更小，则取数组 1 的接下来一位</span></span><br><span class=\"line\">                value = nums2[index2++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 否则如果数组 2 接下来一位比数组 1 接下来一位更小，则取数组 2 的接下来一位</span></span><br><span class=\"line\">                value = nums1[index1++];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果共有偶数个元素，则中位数需要取中间两位，因此在 i == midIndex - 1 时先赋值，</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则不处理相当于先赋了默认值 0。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isEven &amp;&amp; i == midIndex - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                midValue = value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不论共有奇数个还是偶数个，都需要加上 midIndex 元素的值，为了兼容两种情况所以使用累加</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == midIndex) &#123;</span><br><span class=\"line\">                midValue += value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 此时如果共有奇数个，则 midValue 就是最终中位数，否则 midValue 等于中间两个数的和，</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以如果是偶数个，还需要除以二：</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isEven) &#123;</span><br><span class=\"line\">            midValue /= <span class=\"number\">2.0d</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> midValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-从数组中找出和为给定值的两个元素\"><a href=\"#2-从数组中找出和为给定值的两个元素\" class=\"headerlink\" title=\"2. 从数组中找出和为给定值的两个元素\"></a>2. 从数组中找出和为给定值的两个元素</h2><p>说明：给定一个整型数组 <code>nums</code>，找出「和为给定整数 <code>target</code>」的「两个」元素下标（忽略顺序）。数组中的每个元素不能被重复选择，假定每个输入有且仅有一个解。</p>\n<blockquote>\n<p>例 1:</p>\n<p><code>nums = [2, 7, 11, 15]</code>、<code>target = 9</code>，则输出 <code>[0, 1]</code> 或 <code>[1, 0]</code>。</p>\n<p>例 2:</p>\n<p><code>nums = [3, 3]</code>、<code>target = 6</code>，则输出 <code>[0, 1]</code> 或 <code>[1, 0]</code>。</p>\n</blockquote>\n<h3 id=\"2-1-双重循环暴力法\"><a href=\"#2-1-双重循环暴力法\" class=\"headerlink\" title=\"2.1 双重循环暴力法\"></a>2.1 双重循环暴力法</h3><p>用双重循环比较任意两个元素的和是否与给定的 <code>target</code> 相等，如果相等则直接返回两个元素对应的下标组成的新数组，否则返回一个默认值 <code>[0, 0]</code>，由于题目假定每个输入都会有且仅有一个解，因此可以假定一定会返回有效解。</p>\n<p>注意：由于双重循环，判断两个元素之和在内层循环中，找到有效解时应当直接跳出外层循环，所以应该使用「定义循环名」的方式，避免多用一个 <code>Flag</code> 变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_DoubleLoop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 定义外层循环名</span></span><br><span class=\"line\">        outer:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 题目给出了 2 &lt;= nums.length &lt;= 10^4，所以不用判断 j = i + 1 是否越界</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 找到了，直接跳出外层循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span> outer;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;i, j&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Map哈希法\"><a href=\"#2-2-Map哈希法\" class=\"headerlink\" title=\"2.2 Map哈希法\"></a>2.2 Map哈希法</h3><p>因为主要目标是找到和等于 <code>target</code> 的两个元素，所以在确定其中一个元素 <code>nums[i]</code> 时，另一个元素「应该的取值」就已经确定为 <code>nums[j] = target - nums[i]</code>，假如存在则结果就为 <code>[i, j]</code>。所以问题可以转换为：每遍历到一个元素 <code>nums[i]</code> 时，都查找是否存在 <code>nums[j] = target - nums[i]</code>：</p>\n<ul>\n<li>遍历时将每个遍历过的元素及其对应下标都存入一个 Map；</li>\n<li>每遍历一个新的元素 <code>nums[i]</code> 时，计算 <code>nums[i]</code>「应该」匹配的数为 <code>diff = target - nums[i]</code>；</li>\n<li>判断是否存在 <code>Map.contains(diff)</code>；<ul>\n<li>如果存在，则获取这个数的下标 <code>j = Map.get(diff)</code>，然后返回 <code>[i, j]</code>。</li>\n<li>否则继续遍历，直到最终仍找不到匹配的两个元素，返回默认值（依照题意则不会遇到这种情况）。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_MapHash</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; nums.length; index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> diff = target - nums[index];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(diff)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123;index, map.get(diff)&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[index], index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-数据库中查找图片","url":"/post/algorithm/algorithm-find_pictures/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-数据库中查找图片\"><a href=\"#算法-数据库中查找图片\" class=\"headerlink\" title=\"算法-数据库中查找图片\"></a>算法-数据库中查找图片</h1>","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-排序算法","url":"/post/algorithm/algorithm-sort/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-排序算法\"><a href=\"#算法-排序算法\" class=\"headerlink\" title=\"算法-排序算法\"></a>算法-排序算法</h1><p>说明：假设给定的一组数列为：<code>5, 2, 4, 9, 1, 3, 7, 6, 8</code>。</p>\n<h2 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1. 冒泡排序\"></a>1. 冒泡排序</h2><p>冒泡排序是指：依次比较相邻的两个元素，如果后一个比前一个小（或大），则交换两个数的位置，则一轮遍历后，最大（或最小）的数就排在了最后一位。然后再重复该过程，把第二大（或小）的数排在倒数第二位，直到所有数都有序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span> || array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 优化，用来记录某一轮遍历是否没有任何元素交换位置，如果是说明已经排好了，不再需要遍历后序。</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isSorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 外层循环用来控制一共要遍历几次，因为相邻两个依次比较，所以一共需要比较 n - 1 次</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            isSorted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 每次遍历都从头开始比较，直到比较到上一次排序好的元素为止。</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为外层循环每一次遍历都会排序好一个，所以第 i 轮只需要比较前 n - 1 - i 个</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(array[j] &gt; array[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    isSorted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = array[j];</span><br><span class=\"line\">                    array[j] = array[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                    array[j + <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果某一轮遍历时，两两比较没有任何一个元素发生交换，说明已经排好了，则不需要继续遍历。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isSorted) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2. 选择排序\"></a>2. 选择排序</h2><p>选择排序是指：按顺序遍历每一个数，每一轮遍历都向后寻找，找到最小（或最大）的数的下标，当前轮次 i 遍历完后，如果找到的最小（或最大）的数不在第 i 下标的为止，则交换到第 i 个。也就是第 i 轮遍历会找到第 i 小（或大）的数，并放到下标 i 处。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span> || array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 每一次都把当前需要排序的最小元素下标指向 i，并且初始让当前轮次最小数下标 minIndex 指向 i</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, minIndex = i; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从当前第 i 个数开始，找出最小的数的下标，存为 minIndex</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 查找完毕后，如果 minIndex != i，说明第 minIndex 的数小于当前轮次的第 i 个数，则交换位置，使得前 i 个数有序。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != minIndex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = array[i];</span><br><span class=\"line\">                array[i] = array[minIndex];</span><br><span class=\"line\">                array[minIndex] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3. 插入排序\"></a>3. 插入排序</h2><p>插入排序是指：顺序取出每一个元素，然后遍历该元素前的所有元素，将该元素有序插入到位于其之前的元素中，直到所有元素都有序插入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">insertionSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span> || array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 第一个元素不需要排序，所以从第二个元素开始</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每一次排下一个元素，都相当于从这个元素开始往前做一轮冒泡</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= <span class=\"number\">1</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &gt; array[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = array[j];</span><br><span class=\"line\">                array[j] = array[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                array[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-快速排序\"><a href=\"#4-快速排序\" class=\"headerlink\" title=\"4. 快速排序\"></a>4. 快速排序</h2><p>快速排序是指：选定一个分割元素，将比这个元素小的所有元素都放到其左侧，比这个元素大的所有元素都放到其右侧，然后再对该分割元素的左右两段元素分别递归重复上述流程，直到最终无法再分割为止。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sort</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span> || array.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        doSort(array, <span class=\"number\">0</span>, array.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">doSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right || left &lt; <span class=\"number\">0</span> || right &gt; array.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">        <span class=\"comment\">// 分割元素的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> splitIndex = right;</span><br><span class=\"line\">        <span class=\"comment\">// 下一个用来存放【小于分割元素的元素】的下标，也就是查找到下一个比分割元素小的元素后，需要将这个目标元素与哪一位的元素交换</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextLessIndex = left;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历整个范围内的数组，将所有比分割元素小的元素依次从数组的开头开始交换，交换完成后，n 个比分割元素小的元素就位于数组的开头 n 位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从数组第 1 位开始判断，如果小于分割元素，就交换到 nextLessIndex 的位置。</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果是第 1 位元素则不需要交换，所以添加了 i != nextLessIndex 的判断条件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[i] &lt;= array[splitIndex] &amp;&amp; i != nextLessIndex) &#123;</span><br><span class=\"line\">                temp = array[i];</span><br><span class=\"line\">                array[i] = array[nextLessIndex];</span><br><span class=\"line\">                array[nextLessIndex] = temp;</span><br><span class=\"line\">                nextLessIndex++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历完后，所有比 split 对应元素小的都在 nextLessIndex 左侧，所以可以直接把 split 对应元素与 nextLessIndex 对应元素交换。</span></span><br><span class=\"line\">        temp = array[nextLessIndex];</span><br><span class=\"line\">        array[nextLessIndex] = array[split];</span><br><span class=\"line\">        array[split] = temp;</span><br><span class=\"line\">        <span class=\"comment\">// 交换后，也更新 split 索引值，变成了原来的 nextLessIndex</span></span><br><span class=\"line\">        split = nextLessIndex;</span><br><span class=\"line\">        <span class=\"comment\">// 对 split 左侧段递归</span></span><br><span class=\"line\">        doSort(array, left, split - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 对 split 右侧段递归</span></span><br><span class=\"line\">        doSort(array, split, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["Algorithm"],"tags":["Algorithm","算法","排序"]},{"title":"算法-求和问题","url":"/post/algorithm/algorithm-sum_of_numbers/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-求和问题\"><a href=\"#算法-求和问题\" class=\"headerlink\" title=\"算法-求和问题\"></a>算法-求和问题</h1><h2 id=\"1-两个List表示的数字求和\"><a href=\"#1-两个List表示的数字求和\" class=\"headerlink\" title=\"1. 两个List表示的数字求和\"></a>1. 两个List表示的数字求和</h2><p>说明：给定两个「非空」链表，「逆序」存储两个「非负」整数，每个节点仅存储「一位」数字，除了数字 0 以外都不会以 0 开头，请以相同方式返回一个新的链表，表示两个数的和。</p>\n<blockquote>\n<p>例 1：</p>\n<p>[2 -&gt; 4 -&gt; 3] + [5 -&gt; 6 -&gt; 4] = [7 -&gt; 0 -&gt; 8]</p>\n<p>题解：342 + 465 = 807</p>\n</blockquote>\n<p>列表节点的数据结构为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode(<span class=\"keyword\">int</span> val, ListNode next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.val = val;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-循环解法\"><a href=\"#1-1-循环解法\" class=\"headerlink\" title=\"1.1 循环解法\"></a>1.1 循环解法</h3><p>由于题目给出链表是「逆序」，因此头部节点表示的是实际数字的末位，所以可以直接从两个链表的头部节点开始循环，逐个节点位移，每次都对两个链表同一位的节点求和，并判断进位，如果其中一个链表已经结束，则可以视其对应位的值为 0，直到两个链表都已结束。</p>\n<p>注意：对两个链表按位遍历求和结束后，还需要对最终结果判断一次进位。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_Loop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode result = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">        ListNode resultNext = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needAdd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"keyword\">null</span> || l2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 对 result 的扩展需要在下一轮的循环初始判断，如果能进入下一轮循环说明 result 还需要新增节点，</span></span><br><span class=\"line\">            <span class=\"comment\">// 否则在尾部扩展可能下一轮循环不满足条件退出，导致 result 多出一个 0 节点（默认值）。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resultNext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// resultNext == null 说明是第一次进入循环，则 next 就等于头节点。</span></span><br><span class=\"line\">                resultNext = result;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// resultNext != null 说明进入新一轮循环，说明还有节点需要求和，</span></span><br><span class=\"line\">                <span class=\"comment\">// 则令创建一个新的 result 节点并拼接到 result 链表的尾部。</span></span><br><span class=\"line\">                resultNext.next = <span class=\"keyword\">new</span> ListNode();</span><br><span class=\"line\">                resultNext = resultNext.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果任意一条链表已经结束，则按 0 取值。</span></span><br><span class=\"line\">            sum = getVal(l1) + getVal(l2);</span><br><span class=\"line\">            <span class=\"comment\">// 上一轮循环是否需要进位，如果需要则 + 1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (needAdd) &#123;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 对当前位的节点求和并加了进位后，再判断是否大于等于 10，是则继续进位。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">                sum %= <span class=\"number\">10</span>;</span><br><span class=\"line\">                needAdd = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                needAdd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            resultNext.val = sum;</span><br><span class=\"line\">            <span class=\"comment\">// 为下一轮循环准备需要求和的节点。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 循环结束后，还需要对是否有最后一个进位做判断，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此需要确保最后进位的是链表最末端的 next 节点，</span></span><br><span class=\"line\">        <span class=\"comment\">// 但有可能没有进循环导致 resultNext 为空，所以需要多一层判断。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resultNext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            resultNext = result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needAdd) &#123;</span><br><span class=\"line\">            resultNext.next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getVal</span><span class=\"params\">(ListNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (node == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-递归解法\"><a href=\"#1-2-递归解法\" class=\"headerlink\" title=\"1.2 递归解法\"></a>1.2 递归解法</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_Recursion</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 记录是否需要进位</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> needAdd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * 使用递归的方式，将该方法的返回值作为结果链表的「next」节点。</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果两个链表均便利完成，且没有进位，说明运算结束，也即「next」为 null。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span> &amp;&amp; l2 == <span class=\"keyword\">null</span> &amp;&amp; !needAdd) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 计算 l1 和 l2 当前节点的和（以及前一项是否有进位）</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = getVal(l1) + getVal(l2) + (needAdd ? <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// sum 除以 10 大于零表示需要进位</span></span><br><span class=\"line\">        needAdd = (sum / <span class=\"number\">10</span>) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 记录「next」节点的值，如果是第一个节点，则「next」就表示首个节点。</span></span><br><span class=\"line\">        ListNode next = <span class=\"keyword\">new</span> ListNode(sum %= <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 递归获取「next.next」节点</span></span><br><span class=\"line\">        next.next = addTwoNumbers((l1 == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : l1.next), (l2 == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : l2.next));</span><br><span class=\"line\">        <span class=\"comment\">// 所有节点的「next」节点都递归获取后，返回首节点。</span></span><br><span class=\"line\">        <span class=\"comment\">// 由于递归时声明的 next 是在方法体内的，所以最终返回的 next 是最外层的 next，即首节点。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getVal</span><span class=\"params\">(ListNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (node == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-大数相加\"><a href=\"#2-大数相加\" class=\"headerlink\" title=\"2. 大数相加\"></a>2. 大数相加</h2>","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-字符串问题","url":"/post/algorithm/algorithm-string/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-查找子串\"><a href=\"#算法-查找子串\" class=\"headerlink\" title=\"算法-查找子串\"></a>算法-查找子串</h1><h2 id=\"1-最长无重复字符子串\"><a href=\"#1-最长无重复字符子串\" class=\"headerlink\" title=\"1. 最长无重复字符子串\"></a>1. 最长无重复字符子串</h2><p>给定一个字符串，找出不含重复字符的最长子串的长度。</p>\n<blockquote>\n<p>示例：</p>\n<ul>\n<li>&quot;abcabcbb&quot; 最长非重复子串为 &quot;abc&quot;，长度为 3。</li>\n<li>&quot;&quot; 最长非重复子串为 &quot;&quot;，长度为 0。</li>\n</ul>\n</blockquote>\n<h3 id=\"1-1-双重循环暴力法\"><a href=\"#1-1-双重循环暴力法\" class=\"headerlink\" title=\"1.1 双重循环暴力法\"></a>1.1 双重循环暴力法</h3><p>遍历每一个字符，并以该字符为起点，向后再次遍历整个字符串，如果下一个字符是新字符则当前子串长度 + 1，否则跳出内层循环，并比较当前子串和记录的最大子串长度，如果当前子串更长，则更新最长子串的长度记录。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_DoubleLoop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.length() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArray = s.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 外层循环遍历整个字符串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> charIndex = <span class=\"number\">0</span>; charIndex &lt; charArray.length; charIndex++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> maxSubCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">            String maxSubStr = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 内层循环从</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> subIndex = charIndex; subIndex &lt; charArray.length; subIndex++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (maxSubStr.contains(<span class=\"string\">&quot;&quot;</span> + charArray[subIndex])) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    maxSubCount++;</span><br><span class=\"line\">                    maxSubStr += charArray[subIndex];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (maxSubCount &gt; maxCount) &#123;</span><br><span class=\"line\">                maxCount = maxSubCount;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-滑动窗口法（List）\"><a href=\"#1-2-滑动窗口法（List）\" class=\"headerlink\" title=\"1.2 滑动窗口法（List）\"></a>1.2 滑动窗口法（List）</h3><p>用「窗口」的概念表示一段子串，左侧表示子串的起始字符，右侧表示子串的终止字符，窗口初始宽度为 0，遍历字符串，每次将右侧一个字符加入窗口，即窗口「右侧」向右「扩张」一个字符；</p>\n<ul>\n<li>如果窗口内子串仍符合条件，且长度大于记录的最大子串长度，则更新最大子串长度记录。</li>\n<li>否则窗口的「左侧」向右不断「缩小」，直到窗口内的子串再次符合条件为止。</li>\n</ul>\n<p>由于滑动窗口需要频繁修改窗口的起始和终止范围，所以可以用 List 来作为窗口，List 可以很方便操作首位和末尾，用 List 的首位表示窗口起始下标，List 的末位表示窗口终止下标。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_SlidingWindow_List</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Character&gt; charList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; s.length(); index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (charList.contains(s.charAt(index))) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> repeatIndex = charList.indexOf(s.charAt(index));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> rmIndex = <span class=\"number\">0</span>; rmIndex &lt;= repeatIndex; rmIndex++) &#123;</span><br><span class=\"line\">                    charList.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                charList.add(s.charAt(index));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                charList.add(s.charAt(index));</span><br><span class=\"line\">                max = Math.max(max, charList.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-滑动窗口法（Map）\"><a href=\"#1-3-滑动窗口法（Map）\" class=\"headerlink\" title=\"1.3 滑动窗口法（Map）\"></a>1.3 滑动窗口法（Map）</h3><p>用「窗口」的概念表示一段子串，左侧表示子串的起始字符，右侧表示子串的终止字符，窗口初始宽度为 0，遍历字符串，每次将右侧一个字符加入窗口，即窗口「右侧」向右「扩张」一个字符；</p>\n<ul>\n<li>如果窗口内子串仍符合条件，且长度大于记录的最大子串长度，则更新最大子串长度记录。</li>\n<li>否则窗口的「左侧」向右不断「缩小」，直到窗口内的子串再次符合条件为止。</li>\n</ul>\n<p>使用 List 解法最大的问题在于，如果新加入一个字符后，窗口内子串不满足条件，也即与窗口内第 <code>i</code> 个字符重复，则需要一个内层循环从窗口的首位 0 一直 <code>remove</code> 到第 <code>i</code> 个元素。因此可以改用 Map，用一个单独的变量 <code>left</code> 保存窗口的起始下标（终止下标就是当前遍历的字符下标）；</p>\n<ul>\n<li>每次窗口成功扩张时（说明新字符加入后满足条件），都记录新的字符 <code>char</code> 及其对应的下标 <code>i</code>，并且比较 <code>left</code> 到新字符下标的长度是否大于记录的最大子串长度，如果是则更新最大子串长度记录。</li>\n<li>否则可以直接通过 <code>Map.get(char)</code> 一步获取到子串中重复字符的下标 <code>i</code>;<ul>\n<li>直接将 <code>left</code> 指向子串中重复字符的下一位 <code>i + 1</code>；</li>\n<li>将新的字符（即重复的字符）的下标更新到 Map 中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注意：<code>left</code> 始终只会向右移动。</strong> 由于采用 Map 记录字符及对应下标，所以发现重复字符时，<code>left</code> 直接移动到窗口内子串的重复字符下一位，这就导致 <code>last left</code> 到 <code>new left</code> 中间的字符，在 Map 中的下标并没有更新也没有被移除，而下一个字符有可能命中这中间的字符，也即 <code>Map.contains(char) == true</code>，但实际上窗口已经不包括这些字符了，也即 <code>left</code> 指向的下标已经大于这些重复字符的下标，因此这种情况下即使 <code>Map.contains(char) == true</code>，也不应该视为字符重复，所以仅当 <code>Map.get(char) &gt;= left</code> 时，才应该更新 <code>left</code>。</p>\n<p>例如 &quot;abba&quot;，用 <code>[]</code> 表示滑动窗口，其包括的就是满足条件的子串；<code>left</code> 表示窗口左侧字符的下标；<code>max</code> 表示满足条件的最长子串长度：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">遍历下标 <code>i</code></th>\n<th align=\"center\">滑动窗口</th>\n<th align=\"center\">窗口状态</th>\n<th align=\"center\">left</th>\n<th align=\"center\">max</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">初始化</td>\n<td align=\"center\"><code>[]abba</code></td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>[a]bba</code></td>\n<td align=\"center\">正确，<code>Map(a) = 0</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>i - left + 1 == 1</code></td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code>[ab]ba</code></td>\n<td align=\"center\">正确，<code>Map(b) = 1</code></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>i - left + 1 == 2</code></td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>[abb]a</code></td>\n<td align=\"center\">字符重复，将 left 指向重复字符下一位</td>\n<td align=\"center\"><code>Map(b) + 1 == 2</code></td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>ab[b]a</code></td>\n<td align=\"center\">更新重复字符的 Map 下标，<code>Map(b) = 2</code></td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>ab[ba]</code></td>\n<td align=\"center\">正确，尽管字符 &quot;a&quot; 重复，但不在窗口内（<code>Map(a) == 0 &lt; left == 2</code>），不更新 <code>left</code></td>\n<td align=\"center\">2</td>\n<td align=\"center\">2</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_SlidingWindow_Map</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录遍历过的字符及对应的下标，用于遇到重复字符时，直接移动窗口起始下标到子串重复位的下一位。</span></span><br><span class=\"line\">        Map&lt;Character, Integer&gt; charMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 表示当前有效子串的起始下标，配合最新字符下标可计算窗口范围（即子串长度）。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 最大窗口范围（即子串长度）。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; s.length(); index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> next = s.charAt(index);</span><br><span class=\"line\">            <span class=\"comment\">// 只有存在该字符「且记录的位置大于当前窗口起始坐标时」才移动窗口，否则例如 abba：</span></span><br><span class=\"line\">            <span class=\"comment\">//   - 当 index == 2，left = get(b) + 1 = 2，</span></span><br><span class=\"line\">            <span class=\"comment\">//   - 当 index == 3，left = get(a) + 1 = 1，显然不对，此时应该让 left 保持为 2。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (charMap.containsKey(next) &amp;&amp; charMap.get(next) &gt;= left) &#123;</span><br><span class=\"line\">                left = charMap.get(next) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                max = Math.max(max, (index - left + <span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 不论是否重复都需要记录，如果重复了就需要更新</span></span><br><span class=\"line\">            charMap.put(next, index);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-最长回文子串\"><a href=\"#2-最长回文子串\" class=\"headerlink\" title=\"2 最长回文子串\"></a>2 最长回文子串</h2><p>从给定的字符串中找出最长的回文子串，假定字符串一定不为空，即 <code>s.length() &gt;= 1</code>。</p>\n<blockquote>\n<p>示例：</p>\n<ul>\n<li>输入 &quot;babad&quot;，输出 &quot;bab&quot; 或 &quot;aba&quot;</li>\n<li>输入 &quot;cbbd&quot;，输出 &quot;bb&quot;</li>\n</ul>\n</blockquote>\n<h3 id=\"2-1-中心扩散法\"><a href=\"#2-1-中心扩散法\" class=\"headerlink\" title=\"2.1 中心扩散法\"></a>2.1 中心扩散法</h3><p>遍历每个字符，比较「中心字符」向左和向右 n 个字符是否相等；</p>\n<ul>\n<li>如果相等并且长度大于记录的最大长度，则更新最大长度记录；<ul>\n<li>重复该比较，直到遇到不想等的字符为止。</li>\n</ul>\n</li>\n<li>否则遍历到下一个字符重复上述判断。</li>\n</ul>\n<p>注意：因为同一个字符重复也可以算作回文，所以「中心字符」并不一定只是「1 个」字符，也可能是几个重复的字符，因此在寻找下一个中心字符时，需要先向左右判断是否有重复字符，如果有则合并到「中心」，因此开始扩散前，需要先记录「中心字符」的左侧下标和右侧下标。</p>\n<p>例如 <code>s = &quot;acbbcd&quot;</code>，用 <code>[]</code> 表示中心字符，<code>max</code> 表示当前中心字符最长子串长度，<code>maxSub</code> 表示最终解的最长子串长度：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">遍历下标 <code>i</code></th>\n<th align=\"center\">扩散中心</th>\n<th align=\"center\">中心范围</th>\n<th align=\"center\">状态</th>\n<th align=\"center\"><code>sub</code></th>\n<th align=\"center\"><code>maxSub</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">初始化</td>\n<td align=\"center\"><code>[]acbbcd</code></td>\n<td align=\"center\"><code>left = 0</code> <code>right = 0</code></td>\n<td align=\"center\">初始化</td>\n<td align=\"center\">&quot;&quot;</td>\n<td align=\"center\">&quot;&quot;</td>\n</tr>\n<tr>\n<td align=\"center\">0</td>\n<td align=\"center\"><code>[a]cbbcd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">&quot;a&quot;</td>\n<td align=\"center\">&quot;a&quot;</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code>a[c]bbcd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">&quot;c&quot;</td>\n<td align=\"center\">&quot;c&quot;</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>ac[b]bcd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[i] == s[right]</code> 需要向右合并中心</td>\n<td align=\"center\">&quot;b&quot;</td>\n<td align=\"center\">&quot;b&quot;</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>ac[bb]cd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right++</code></td>\n<td align=\"center\"><code>s[left] == s[right]</code> 可以向左右扩散</td>\n<td align=\"center\">&quot;bb&quot;</td>\n<td align=\"center\">&quot;bb&quot;</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>a[cbbc]d</code></td>\n<td align=\"center\"><code>left--</code> <code>right++</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">&quot;cbbc&quot;</td>\n<td align=\"center\">&quot;cbbc&quot;</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>acb[b]cd</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[i] == s[left]</code> 需要向左合并中心</td>\n<td align=\"center\">&quot;b&quot;</td>\n<td align=\"center\">&quot;cbbc&quot;</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>ac[bb]cd</code></td>\n<td align=\"center\"><code>left--</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] == s[right]</code> 可以向左右扩散</td>\n<td align=\"center\">&quot;bb&quot;</td>\n<td align=\"center\">&quot;cbbc&quot;</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"><code>a[cbbc]d</code></td>\n<td align=\"center\"><code>left--</code> <code>right++</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">&quot;cbbc&quot;</td>\n<td align=\"center\">&quot;cbbc</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\"><code>acbb[c]d</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">&quot;c&quot;</td>\n<td align=\"center\">&quot;cbbc&quot;</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\"><code>acbbc[d]</code></td>\n<td align=\"center\"><code>left = i - 1</code> <code>right = i + 1</code></td>\n<td align=\"center\"><code>s[left] != s[right]</code> 扩散终止</td>\n<td align=\"center\">&quot;d&quot;</td>\n<td align=\"center\">&quot;cbbc&quot;</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_CenterSpread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 最长回文子串</span></span><br><span class=\"line\">        String maxSub = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 每一轮遍历中当前中心字符的回文子串</span></span><br><span class=\"line\">        String sub = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 每一轮遍历中当前中心字符的左侧下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 每一轮遍历中当前中心字符的右侧下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            left = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            right = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 最长子串至少也是当前字符</span></span><br><span class=\"line\">            sub = <span class=\"string\">&quot;&quot;</span> + s.charAt(i);</span><br><span class=\"line\">            <span class=\"comment\">// 先向左寻找，与当前字符重复的字符都纳入「中心字符」，直到遇到第一个不重复的为止。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &gt;= <span class=\"number\">0</span> &amp;&amp; s.charAt(left) == s.charAt(i)) &#123;</span><br><span class=\"line\">                sub = s.charAt(left) + sub;</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 再向右寻找，与当前字符重复的字符都纳入「中心字符」，直到遇到第一个不重复的为止。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (right &lt; s.length() &amp;&amp; s.charAt(right) == s.charAt(i)) &#123;</span><br><span class=\"line\">                sub = sub + s.charAt(right);</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 然后同时向两边扩散，如果两侧字符相等，则都纳入子串，直到遇到不相等的一对。</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (left &gt;= <span class=\"number\">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class=\"line\">                sub = s.charAt(left) + sub + s.charAt(right);</span><br><span class=\"line\">                left--;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 如果当前「中心字符」的回文子串大于记录的最长子串，则更新记录。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sub.length() &gt; maxSub.length()) &#123;</span><br><span class=\"line\">                maxSub = sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSub;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-动态规划法\"><a href=\"#2-2-动态规划法\" class=\"headerlink\" title=\"2.2 动态规划法\"></a>2.2 动态规划法</h3><p>中心扩散法最主要的问题，是每次遍历时都需要重复向左右两边合并中心、比较两侧、判断扩散等。但实际上，如果有一段回文子串 <code>sub</code>，并且该子串的左侧字符 <code>s[left]</code> 和右侧字符 <code>s[right]</code> 相等，那么 <code>s[left] + sub + s[right]</code> 也是一段回文子串。</p>\n<p>反过来说，假如 <code>s[left] + sub + s[right]</code> 是一段回文子串，则需要满足 <code>s[left] == s[right]</code>，以及 <code>sub</code> 也是一段回文子串。</p>\n<p>再进一步：</p>\n<ul>\n<li>当 <code>s[left] != s[right]</code> 时，则 <code>s[left]...s[right]</code> 这段范围的子串「一定不是」回文子串。</li>\n<li>当 <code>s[left] == s[right]</code> 时，假设被 <code>s[left]</code> 和 <code>s[right]</code> 包住的中间的字符串是 <code>sub</code>，那么如果 <code>sub</code> 是回文子串，则 <code>s[left]...s[right]</code> 就是回文子串，否则就不是。</li>\n</ul>\n<p>因此，如果 <code>s[left]...s[right]</code> 是回文子串，则需要满足 <code>s[left] == s[right]</code>，并且 <code>s[left + 1]...s[right - 1]</code> 也是回文子串，这就产生了递归推导。</p>\n<p>注意：这种思路下，需要规定 <code>right</code> 一定不小于 <code>left</code>，可以通过两层循环控制。此外，还需要区分不同情况：</p>\n<ul>\n<li>只选中 1 个字符，即 <code>left == right</code>，这种情况肯定是回文子串。</li>\n<li>选中 2 个字符，即 <code>right - left == 1</code>，这种情况如果 <code>s[left] == s[right]</code> 则是回文子串，否则不是。</li>\n<li>选中 3 个或以上字符，即 <code>right - left &gt;= 2</code>，这种情况则仅当 <code>s[left] == s[right]</code> 并且 <code>s[left + 1]...s[right - 1]</code> 也是回文子串时，<code>s[left]...s[right]</code> 才是回文子串；<ul>\n<li>然后再对 <code>s[left + 1]...s[right - 1]</code> 同样采用上述步骤递归判断。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution_DynamicProgramming</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 最长回文子串在原字符串的起始下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSubLeft = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 最长回文子串的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxSubLength = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 用一个二维数组 dp[left][right] 表示从 s[left]...s[right] 是否为回文子串，</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[left][right] 初始化时默认值全为 false。</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> [][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[s.length()][s.length()];</span><br><span class=\"line\">        <span class=\"comment\">// 因为 dp[left][right] 数组的定义，right 一定大于等于 left</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> right = <span class=\"number\">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> left = <span class=\"number\">0</span>; left &lt;= right; left++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果 s[left] == s[right]，分为三种情况</span></span><br><span class=\"line\">                <span class=\"comment\">// （1）left == right</span></span><br><span class=\"line\">                <span class=\"comment\">//     表示当前 1 个字符，则肯定是回文子串，dp[left][right] = true</span></span><br><span class=\"line\">                <span class=\"comment\">// （2）right - left = 1</span></span><br><span class=\"line\">                <span class=\"comment\">//     表示 2 个相邻重复字符，既然相等则肯定也是回文子串，dp[left][right] = true</span></span><br><span class=\"line\">                <span class=\"comment\">// （3）right - left &gt; 1</span></span><br><span class=\"line\">                <span class=\"comment\">//     表示子串至少包含 3 个字符，例如 aba 或 abba，则这个子串是否为回文子串，</span></span><br><span class=\"line\">                <span class=\"comment\">//     依赖于 s[left + 1]...s[right - 1] 是否为回文子串，</span></span><br><span class=\"line\">                <span class=\"comment\">//     即依赖于 dp[left + 1][right - 1] 是否为 true。</span></span><br><span class=\"line\">                <span class=\"comment\">// 以上情况（1）和情况（2），都能直接确定 dp[left][right] = true</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(left) == s.charAt(right)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 对应情况（1）和情况（2）</span></span><br><span class=\"line\">                        dp[left][right] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dp[left + <span class=\"number\">1</span>][right - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 对应情况（3）</span></span><br><span class=\"line\">                        dp[left][right] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// dp[left][right] 数组初始化时默认所有元素都是 false，</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以如果 dp[left][right] == true，</span></span><br><span class=\"line\">                <span class=\"comment\">// 就表示上面的条件种判断了 s[left]...s[right] 为回文子串，</span></span><br><span class=\"line\">                <span class=\"comment\">// 则如果这个回文子串的长度大于记录的最大长度，就可以更新记录。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[left][right] &amp;&amp; right - left + <span class=\"number\">1</span> &gt; maxSubLength) &#123;</span><br><span class=\"line\">                    maxSubLeft = left;</span><br><span class=\"line\">                    maxSubLength = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// String#substring(startIndex, endIndex) 返回的是一个 [左闭, 右开) 区间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(maxSubLeft, maxSubLeft + maxSubLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-正则匹配\"><a href=\"#3-正则匹配\" class=\"headerlink\" title=\"3. 正则匹配\"></a>3. 正则匹配</h2><p>给定一串文本 <code>text</code> 和一串正则表达式 <code>regular</code>，判断表达式是否匹配（需匹配整串文本，而非部分字串）。</p>\n<ul>\n<li>文本仅包含小写字母；正则表达式仅包含小写字母、&#39;.&#39;、&#39;*&#39;；</li>\n<li>&#39;.&#39; 可以匹配任意单个字符；</li>\n<li>&#39;*&#39; 可以匹配零个或多个其前面的字符；</li>\n</ul>\n<blockquote>\n<p>示例：</p>\n<ul>\n<li>例 1：<code>text == &quot;aa&quot;, regular == &quot;a&quot;</code> 输出 false，<code>&quot;a&quot;</code> 无法匹配完整字符串 <code>&quot;aa&quot;</code>；</li>\n<li>例 2：<code>text == &quot;abb&quot;, regular == &quot;abc*b&quot;</code> 输出 true，<code>&quot;c*&quot;</code> 可以匹配零个 <code>&quot;c&quot;</code>；</li>\n<li>例 3：<code>text == &quot;abcde&quot;, regular == &quot;.*&quot;</code> 输出 true，<code>&quot;.*&quot;</code> 表示可以匹配任意数量个（<code>&quot;*&quot;</code>）任意字符（<code>&quot;.&quot;</code>）；</li>\n</ul>\n<p>原题链接：<a href=\"https://leetcode.cn/problems/regular-expression-matching/\" title=\"@LINK\">正则表达式匹配</a></p>\n</blockquote>\n<h3 id=\"3-1-动态规划法\"><a href=\"#3-1-动态规划法\" class=\"headerlink\" title=\"3.1 动态规划法\"></a>3.1 动态规划法</h3><h4 id=\"3-1-1-分析匹配过程\"><a href=\"#3-1-1-分析匹配过程\" class=\"headerlink\" title=\"3.1.1 分析匹配过程\"></a>3.1.1 分析匹配过程</h4><p>动态规划法的核心思想即为：通过已获取到的信息决定下一步策略。分析该正则匹配可以发现其具有明显的「顺序匹配」特征，文本与正则表达式总是从左至右开始匹配的，因此前一步是否匹配决定了下一步能否匹配。例如假设 <code>text == &quot;abccd&quot;, regular == &quot;a*bd&quot;</code>，根据从左至右匹配的顺序有：</p>\n<ul>\n<li>第 1 步：<code>text[0] == &quot;a&quot;, regular[0] == &quot;a&quot;</code>，匹配；</li>\n<li>第 2 步：<code>text[1] == &quot;b&quot;, regular[1] == &quot;*&quot;</code>，判断通配符与前一字符作为整体 <code>regular[0~1] == &quot;a*&quot;</code> 匹配 <code>text[0]</code>；<ul>\n<li>因此如果此前所有部分（<code>text[0]</code> 与 <code>regular[0]</code>）均匹配，则截至当前部分都是匹配的；</li>\n</ul>\n</li>\n<li>第 3 步：<code>text[1] == &quot;b&quot;, regular[2] == &quot;b&quot;</code>，匹配；<ul>\n<li>因此如果此前所有部分（<code>text[0]</code> 与 <code>regular[0~1]</code>）均匹配，则截至当前部分都是匹配的；</li>\n</ul>\n</li>\n<li>第 4 步：<code>text[2] == c, regular[3] == &quot;d&quot;</code>，匹配失败，且不存在 <code>regular[4] == *</code> 无法组成 <code>&quot;d*&quot;</code>；</li>\n</ul>\n<p>观察上述过程可以发现，「截止到前 n 部分是否匹配」的结果由「第 (n - 1) 步是否匹配」与「第 n 步是否匹配」共同组成，这是一个不断迭代的过程。</p>\n<h4 id=\"3-1-2-抽象匹配问题\"><a href=\"#3-1-2-抽象匹配问题\" class=\"headerlink\" title=\"3.1.2 抽象匹配问题\"></a>3.1.2 抽象匹配问题</h4><p>假设迭代至某一步时目标需要匹配的文本串下标为 <code>i</code>、需要匹配的正则式下表为 <code>j</code>，用 <code>matchedLength[i+1][j+1]</code> 表示 <code>text[0~i]</code> 与 <code>regular[0~j]</code> 是否匹配，则原问题转变为如何判断 <code>matchedLength[n][m]</code>。</p>\n<blockquote>\n<p>特别提示：</p>\n<ul>\n<li><code>matchedLength</code> 记录的是对应 <strong>长度</strong> 的文本串与正则式是否匹配，因此当 text 与 regular 分别匹配到下标为 i 和 j 的字符时，对应长度则为 <code>n = i + 1</code> 及 <code>m = j + 1</code>，因此对应已匹配的长度则记录为 <code>matchedLength[n][m]</code>；</li>\n<li>反之，<code>matchedLength[i][j]</code> 记录的是「text 的前 i 个字符与 regular 的前 j 个字符是否匹配」，因此其记录的字符串范围为 <code>text[0~(i-1)]</code> 与 <code>regular[0~(j-1)]</code>；</li>\n<li>对于 <code>matchedLength[n][m]</code>，当 <code>n == 0</code> 或 <code>m == 0</code> 时则对应了 text 为空或 regular 为空的情况；</li>\n</ul>\n</blockquote>\n<p>因此当 <code>n == text.length(), m == regular.length()</code> 时，<code>matchedLength[n][m]</code> 即为判断完整文本串与完整正则式是否匹配了。</p>\n<h4 id=\"3-1-3-拆解匹配规则\"><a href=\"#3-1-3-拆解匹配规则\" class=\"headerlink\" title=\"3.1.3 拆解匹配规则\"></a>3.1.3 拆解匹配规则</h4><p>根据上文可知，对于匹配过程中的某一步，假设此时待匹配的字符分别为 <code>text[i]</code> 与 <code>regular[j]</code>，则推算的目标为：<code>matchedLength[i+1][j+1]</code>，此时可将推算拆解为以下规则：</p>\n<p>（0）已知定义</p>\n<p>当 text 为空时，regular 仅在以下条件时才可与之匹配：</p>\n<ul>\n<li>regular 也为空，此时即为：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// When: text == regular == empty</span></span><br><span class=\"line\">matchedLength[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>,</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>regular 不为空，但全部由通配体（即字符 + <code>&quot;*&quot;</code> 或 <code>&quot;.*&quot;</code>）组成，由于每一个通配体占 2 字符，换言之如果 regular 遍历到 <code>&quot;*&quot;</code> 时，则直接删去 2 字符，如果剩余的前面部分为空、或仍旧全部由通配体组成，则整串正则式也可以与空文本匹配：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// When: text == empty, regular[j] == &quot;*&quot;</span></span><br><span class=\"line\">matchedLength[<span class=\"number\">0</span>][j+<span class=\"number\">1</span>] = matchedLength[<span class=\"number\">0</span>][j-<span class=\"number\">1</span>],</span><br></pre></td></tr></table></figure>\n\n<p>（1）字符匹配</p>\n<blockquote>\n<p>例如：<code>text = &quot;abcaa&quot;, regular = &quot;abc*&quot;</code>，当 <code>i == 1, j == 1</code> 时，<code>text[1] == regular[1] == &quot;b&quot;</code>。</p>\n</blockquote>\n<p>当字符匹配（<code>text[i] == regular[j] || regular[j] == &quot;.&quot;</code>）时，意味着如果该字符之前的部分（<code>text[0~(i-1)]</code> 与 <code>regular[0~(j-1)]</code>）可以匹配，则 <code>text[0~i]</code> 与 <code>regular[0~j]</code> 就能匹配，也即：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// When: text[i] == regular[j]</span></span><br><span class=\"line\">matchedLength[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = matchedLength[i][j],</span><br></pre></td></tr></table></figure>\n\n<p>（2）字符不匹配</p>\n<blockquote>\n<p>例如：<code>text = &quot;abcaa&quot;, regular = &quot;ac*bc&quot;</code>，当 <code>i == 1, j == 1</code> 时，<code>text[1] == &quot;b&quot;, regular[1] == &quot;c&quot;</code>。</p>\n</blockquote>\n<p>当字符不匹配（<code>text[i] != regular[j]</code>）时，<code>matchedLength[i+1][j+1] = false</code>。</p>\n<p>当然，如果后面跟随了通配符 <code>&quot;*&quot;</code> 则可以作为整体匹配 <strong>零次或多次</strong>，但因为匹配是从前往后的顺序，因此在下一轮匹配到 <code>&quot;*&quot;</code> 时再区分这种情况。</p>\n<p>（3）遇到通配符</p>\n<p>当遇到通配符时，其必须与前一个字符作为整体，可与字符匹配  <strong>零次或多次</strong>，因此分情况考虑：</p>\n<ul>\n<li>通配符前一位字符与文本仅匹配一次：例如 <code>text = &quot;abc&quot;, regular = &quot;abc*&quot;</code>，当 <code>&quot;c&quot;</code> 与 <code>&quot;c*&quot;</code> 相匹配时，意味着各自去掉这部分后，如果各自剩下的前面部分互相匹配，则整整串文本与整串正则就能匹配：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// When: regular[j] == &quot;*&quot; &amp;&amp; text[i] == regular[j - 1]</span></span><br><span class=\"line\">matchedLength[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = matchedLength[i][j-<span class=\"number\">1</span>],</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通配符前一位字符与文本匹配多次（以 2 次为例）：例如 <code>text = &quot;abcc&quot;, regular = &quot;abc*&quot;</code>，当 <code>text[2] == text[3] == &quot;c&quot;</code> 与 <code>&quot;c*&quot;</code> 相匹配时，意味着如果去掉文本串中当前匹配的 <code>text[3]</code>，剩余的前面部分与正则相匹配（在这个小例中是必然的），则整串文本与整串正则就能匹配：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// When: regular[j] == &quot;*&quot; &amp;&amp; text[i-1] == text[i] == regular[j-1]</span></span><br><span class=\"line\">matchedLength[i+<span class=\"number\">1</span>][j+<span class=\"number\">1</span>] = matchedLength[i][j+<span class=\"number\">1</span>],</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通配符前一位字符与文本不匹配：例如 <code>text = &quot;ab&quot;, regular = &quot;abc*&quot;</code>，当 <code>&quot;c*&quot;</code> 作为整体被匹配零次时，意味着如果去掉正则中的这一部分，剩余前面的部分与文本相匹配，则整串文本与整串正则就能相匹配：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// When: regular[j] == <span class=\"string\">&quot;*&quot;</span> &amp;&amp; text[i] != regular[j-1]</span><br><span class=\"line\">matchedLength[i+1][j+1] = matchedLength[i+1][j-1],</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通配符前一位字符与文本能匹配但作为整体不匹配：例如 <code>text = &quot;ab&quot;, regula = &quot;abb*&quot;</code>，当 <code>&quot;b*&quot;</code> 作为整体被匹配零次时，同样意味着去掉正则中的这一部分，剩余前面的部分与文本相匹配则整串文本与整串正则就能相匹配：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">// When: regular[j] == <span class=\"string\">&quot;*&quot;</span> &amp;&amp; text[i] == regular[j-1] &amp;&amp; text[0~i] matched regular[0~(j-2)]</span><br><span class=\"line\">matchedLength[i+1][j+1] = matchedLength[i+1][j-1],</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-1-4-代码实现\"><a href=\"#3-1-4-代码实现\" class=\"headerlink\" title=\"3.1.4 代码实现\"></a>3.1.4 代码实现</h4><p>经过上文的拆解，可以总结出代码实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RegularExpressMatcher</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatch</span><span class=\"params\">(String text, String regular)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 尽管按照题意 text 与 regular 不会为空，但作为代码仍需对边界值保护。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (text == <span class=\"keyword\">null</span> || text.length() &lt;= <span class=\"number\">0</span> || regular == <span class=\"keyword\">null</span> || regular.length() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (regular.equals(<span class=\"string\">&quot;.*&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> [][]matchedLength = <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[text.length() + <span class=\"number\">1</span>][regular.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 0. 已知定义：</span></span><br><span class=\"line\">        <span class=\"comment\">//   - 当 text 与 regular 均为空时，视作匹配；</span></span><br><span class=\"line\">        matchedLength[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//   - 否则仅当 regular 全部由通配体组成时才匹配；</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; regular.length(); j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (regular.charAt(j) == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                matchedLength[<span class=\"number\">0</span>][j + <span class=\"number\">1</span>] = matchedLength[<span class=\"number\">0</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; regular.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (regular.charAt(j) == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (isCharMatched(text, i, regular, j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 1. 当遇到通配符、且其前一个字符与文本相同时，则可能匹配零次、一次、多次：</span></span><br><span class=\"line\">                        <span class=\"comment\">//   - 零次：&quot;ab&quot; 与 &quot;abb*&quot;，说明可以去掉正则部分</span></span><br><span class=\"line\">                        <span class=\"comment\">//   - 一次：&quot;ab&quot; 与 &quot;ab*&quot;，说明可以各自去掉文本与正则部分</span></span><br><span class=\"line\">                        <span class=\"comment\">//   - 多次：&quot;abbb&quot; 与 &quot;ab*&quot;，说明可以去掉一个文本部分</span></span><br><span class=\"line\">                        matchedLength[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>]</span><br><span class=\"line\">                                = matchedLength[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] <span class=\"comment\">// 零次</span></span><br><span class=\"line\">                                || matchedLength[i][j - <span class=\"number\">1</span>] <span class=\"comment\">// 一次</span></span><br><span class=\"line\">                                || matchedLength[i][j + <span class=\"number\">1</span>]; <span class=\"comment\">// 多次</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 2. 当遇到通配符、且前一个字符与文本不同时，则通配体匹配了零次，相当于去掉通配体：</span></span><br><span class=\"line\">                        matchedLength[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = matchedLength[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isCharMatched(text, i, regular, j)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 3. 当普通字符相同或为 &quot;.&quot; 时，则如果各自去掉字符后剩余的匹配，则整串匹配：</span></span><br><span class=\"line\">                    matchedLength[i + <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] = matchedLength[i][j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 最终需要知道的是整串文本（text[0~i]）与整串正则（regular[0~j]）是否匹配，</span></span><br><span class=\"line\">        <span class=\"comment\">// 因此返回的即为 matchedLength[n][m]，其中 n == i+1 == text.length(), m == j+1 == regular.length()。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> matchedLength[text.length()][regular.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCharMatched</span><span class=\"params\">(String text, <span class=\"keyword\">int</span> txtIndex, String regular, <span class=\"keyword\">int</span> regIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (regular.charAt(regIndex) == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (text.charAt(txtIndex) == regular.charAt(regIndex));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"算法-运输和消耗最优解问题","url":"/post/algorithm/algorithm-transport_and_consume/","content":"<span id=\"more\"></span>\n\n<h1 id=\"算法-运输和消耗最优解问题\"><a href=\"#算法-运输和消耗最优解问题\" class=\"headerlink\" title=\"算法-运输和消耗最优解问题\"></a>算法-运输和消耗最优解问题</h1>","categories":["Algorithm"],"tags":["Algorithm","算法"]},{"title":"HashingEncoder-多进程支持","url":"/post/python/python-hashingencoder_optimization/","content":"<span id=\"more\"></span>\n\n<h1 id=\"HashingEncoder-多进程支持\"><a href=\"#HashingEncoder-多进程支持\" class=\"headerlink\" title=\"HashingEncoder-多进程支持\"></a>HashingEncoder-多进程支持</h1><p>对数据做特征工程时哈希编码器是常用分类器，Scikit-Learn 扩展工具包提供了一个默认基于 MD5 的哈希工具，可以将特征转换为指定长度的数字特征；但这个工具包的默认哈希有一个很致命的问题：慢。</p>\n<p>测试发现慢主要原因是没有利用多核 CPU 的并行能力，基于该结论通过增加并发的方式来提高编码速度，完整源码参阅：<a href=\"https://github.com/scikit-learn-contrib/category_encoders/blob/master/category_encoders/hashing.py\" title=\"@LINK\">ScikitLearn_Contrib - hashing.py</a>。</p>\n<hr>\n<h2 id=\"1-源码\"><a href=\"#1-源码\" class=\"headerlink\" title=\"1. 源码\"></a>1. 源码</h2><p>遇到问题第一步：查接口。通常 Python 中支持并行处理的接口都会有类似 <code>n_thread</code> 的参数，可惜 sklearn 内置的 HashingEncoder 并没有。</p>\n<p>遇到问题第二部：看源码。HashingEncoder 的核心源码部分如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@staticmethod</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hashing_trick</span>(<span class=\"params\">X_in, hashing_method=<span class=\"string\">&#x27;md5&#x27;</span>, N=<span class=\"number\">2</span>, cols=<span class=\"literal\">None</span>, make_copy=<span class=\"literal\">False</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;A basic hashing implementation with configurable dimensionality/precision</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Performs the hashing trick on a pandas dataframe, `X`, using the hashing method from hashlib</span></span><br><span class=\"line\"><span class=\"string\">    identified by `hashing_method`.  The number of output dimensions (`N`), and columns to hash (`cols`) are</span></span><br><span class=\"line\"><span class=\"string\">    also configurable.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Parameters</span></span><br><span class=\"line\"><span class=\"string\">    ----------</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    X_in: pandas dataframe</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    hashing_method: string, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    N: int, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    cols: list, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\">    make_copy: bool, optional</span></span><br><span class=\"line\"><span class=\"string\">        description text</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Returns</span></span><br><span class=\"line\"><span class=\"string\">    -------</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    out : dataframe</span></span><br><span class=\"line\"><span class=\"string\">        A hashing encoded dataframe.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    References</span></span><br><span class=\"line\"><span class=\"string\">    ----------</span></span><br><span class=\"line\"><span class=\"string\">    Cite the relevant literature, e.g. [1]_.  You may also cite these</span></span><br><span class=\"line\"><span class=\"string\">    references in the notes section above.</span></span><br><span class=\"line\"><span class=\"string\">    .. [1] Kilian Weinberger; Anirban Dasgupta; John Langford; Alex Smola; Josh Attenberg (2009). Feature Hashing</span></span><br><span class=\"line\"><span class=\"string\">    for Large Scale Multitask Learning. Proc. ICML.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hashing_method <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> hashlib.algorithms_available:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&#x27;Hashing Method: %s Not Available. Please use one from: [%s]&#x27;</span> % (</span><br><span class=\"line\">                hashing_method,</span><br><span class=\"line\">                <span class=\"string\">&#x27;, &#x27;</span>.join([<span class=\"built_in\">str</span>(x) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> hashlib.algorithms_available])</span><br><span class=\"line\">            ))</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            _ = hashlib.new(hashing_method)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&#x27;Hashing Method: %s Not Found.&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> make_copy:</span><br><span class=\"line\">        X = X_in.copy(deep=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        X = X_in</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cols <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">        cols = X.columns.values</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hash_fn</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">        tmp = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(N)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> val <span class=\"keyword\">in</span> x.values:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> val <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">                hasher = hashlib.new(hashing_method)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> sys.version_info[<span class=\"number\">0</span>] == <span class=\"number\">2</span>:</span><br><span class=\"line\">                    hasher.update(<span class=\"built_in\">str</span>(val))</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    hasher.update(<span class=\"built_in\">bytes</span>(<span class=\"built_in\">str</span>(val), <span class=\"string\">&#x27;utf-8&#x27;</span>))</span><br><span class=\"line\">                tmp[<span class=\"built_in\">int</span>(hasher.hexdigest(), <span class=\"number\">16</span>) % N] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pd.Series(tmp, index=new_cols)</span><br><span class=\"line\"></span><br><span class=\"line\">    new_cols = [<span class=\"string\">&#x27;col_%d&#x27;</span> % d <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(N)]</span><br><span class=\"line\"></span><br><span class=\"line\">    X_cat = X.loc[:, cols]</span><br><span class=\"line\">    X_num = X.loc[:, [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> X.columns.values <span class=\"keyword\">if</span> x <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> cols]]</span><br><span class=\"line\"></span><br><span class=\"line\">    X_cat = X_cat.apply(hash_fn, axis=<span class=\"number\">1</span>)</span><br><span class=\"line\">    X_cat.columns = new_cols</span><br><span class=\"line\"></span><br><span class=\"line\">    X = pd.concat([X_cat, X_num], axis=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> X</span><br></pre></td></tr></table></figure>\n\n<p><del>一个 <code>for</code> 冲到底，什么叫简单粗暴啊（后仰）</del></p>\n<p>默认情况 Python 没有对多核环境做多线程优化，这意味着多个线程一定跑在同一个核心上，这在处理 UI、IO 密集型任务时可以更彻底发挥单核性能，但对于特征工程这种计算密集型任务来说，GIL 全局锁就是 Debuff。</p>\n<hr>\n<h2 id=\"2-改进思路\"><a href=\"#2-改进思路\" class=\"headerlink\" title=\"2. 改进思路\"></a>2. 改进思路</h2><h3 id=\"2-1-理论支持\"><a href=\"#2-1-理论支持\" class=\"headerlink\" title=\"2.1 理论支持\"></a>2.1 理论支持</h3><p>关于什么是哈希编码的内容网上有很多了。但在开始优化之前，需要考虑一个问题：</p>\n<blockquote>\n<p>按顺序依次编码，和多进程分别编码再拼接，最后的结果是一样的吗？</p>\n<p>换言之，哈希编码是否依赖数据之间的联系？如果多进程编码会导致结果变化，那一切都是白费功夫。</p>\n</blockquote>\n<p>幸运的是，哈希编码是对数据原始信息的编码，与数据间的联系无关，只要规定好输入特征和输出维度，最终的输出是确定的。也就是说，每一次送去编码的进程，其数据都是独立的，并且完全可以分开编码而不需要考虑别的数据，只要给每个进程设置相同的编码算法和输出维度，最后再将每个独立的数据块按照原数据的顺序重新排列即可。</p>\n<blockquote>\n<p>哈希编码的大致核心思想：</p>\n<ol>\n<li>哈希表把输入散列到指定的输出范围内</li>\n<li>对于不在训练数据的散列表中的输入，依然可以通过同样的哈希算法计算出散列值</li>\n<li>只要指定了相同的散列范围，新的输入也会具有相同的输出特征维度</li>\n<li>新输入可以直接进行哈希编码，而不需要再对整体数据重新处理，因此支持在线学习</li>\n<li>只有原始值非零，哈希编码才有效，因此可以保持编码前后的稀疏性</li>\n</ol>\n<p>参考的理论基础资料：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_33762321/article/details/88275111\">数据特征处理之特征哈希（Feature Hashing）</a></li>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1593454269874725931\">人工智能之机器学习篇——哈希学习learning to hash</a></li>\n<li><a href=\"http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html\">特征哈希（Feature Hashing）</a></li>\n<li><a href=\"https://www.datalearner.com/blog/1051537932880901\">数据特征处理之特征哈希（Feature Hashing）</a></li>\n<li><a href=\"https://blog.csdn.net/laolu1573/article/details/79410187\">Feature hashing(特征哈希)</a></li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-代码思想\"><a href=\"#2-2-代码思想\" class=\"headerlink\" title=\"2.2 代码思想\"></a>2.2 代码思想</h3><p>既然是多核性能没发挥出来，那就从并行的角度出发，大致的实现逻辑如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multithreading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashingEncoder</span>:</span></span><br><span class=\"line\">    self.multi_data = []</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 每个线程调用的方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>():</span></span><br><span class=\"line\">        get_data() <span class=\"comment\"># 每个线程都从整体数据中获取一部分数据</span></span><br><span class=\"line\">        hashing_data = hashing() <span class=\"comment\"># 每个线程都单独进行哈希编码</span></span><br><span class=\"line\">        self.multi_data.append(hashing_data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">transform</span>():</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> thread <span class=\"keyword\">in</span> multi_num</span><br><span class=\"line\">            multithreading.Thread.Thread(target=work).start</span><br><span class=\"line\"></span><br><span class=\"line\">        data = pandas.concat(multi_data, ignore_index=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n\n<p>简单来说我想做的事情是：</p>\n<ol>\n<li>允许用户自定义并行线程数以及每个线程每次编码的样本数</li>\n<li>根据参数创建 n 个进程</li>\n<li>每个线程都依次从所有数据中不重复地顺序取出参数定义数量的数据</li>\n<li>每个线程都独立对自己取到的数据进行哈希编码</li>\n<li>每个线程哈希编码完后将返回数据存储进一个列表内</li>\n<li>将列表内的数据拼接成回一个整体。</li>\n</ol>\n<hr>\n<h2 id=\"3-踩过的坑\"><a href=\"#3-踩过的坑\" class=\"headerlink\" title=\"3. 踩过的坑\"></a>3. 踩过的坑</h2><h3 id=\"3-1-多线程和多进程问题\"><a href=\"#3-1-多线程和多进程问题\" class=\"headerlink\" title=\"3.1 多线程和多进程问题\"></a>3.1 多线程和多进程问题</h3><p>可以看到上面的 Demo 伪代码，由于客户端开发的习惯使我想当然地认为多线程可以解决 CPU 利用率的问题，因此第一次优化时我在一个小型样本 Demo 上选择了 multithreading，尽管从 <code>print</code> 看起来似乎确实是并行处理，但上数据压测就发现一切都还在单核上，因此只能利用 multiprocessing 解决。</p>\n<h3 id=\"3-2-并行顺序读取数据问题\"><a href=\"#3-2-并行顺序读取数据问题\" class=\"headerlink\" title=\"3.2 并行顺序读取数据问题\"></a>3.2 并行顺序读取数据问题</h3><p>与其他平台的并发工具类似，Python 中多进程管理也有两种方式，一个是自行创建实例，另一个是创建实例「池」。相比之下使用进程池有以下特点：</p>\n<ul>\n<li>不必关心每个进程的生命周期；</li>\n<li>可以指定进程执行完成后的返回值；</li>\n<li>ProcessPool 内部维护的进程都是由公共 Process 创建的，每个进程的上下文天然具有继承关系，因此可以互相共享进程锁等资源；</li>\n<li>内部已经通过 Pickle 中的 <code>dump(obj, file, protocol=None,)</code> 方法对参数进行了封装处理，已经实现了拷贝的支持；</li>\n<li>比手动管理要多一些调度 / 资源分配，会略微损失一些性能；</li>\n</ul>\n<blockquote>\n<p>不过由于 Python 较少用在对性能敏感的场景，因此在很多时候进程池其实是更好的方案，此处选择手动管理仅是为了更好的示例。</p>\n</blockquote>\n<p>现在假设我们开启 4 个进程同时执行一个任务，代码应该大致如下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>():</span></span><br><span class=\"line\">    get_data() <span class=\"comment\"># 每个线程都从整体数据中获取第 index 部分的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">process_list = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>):</span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=()))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    p.join()</span><br></pre></td></tr></table></figure>\n\n<p>由于在多核环境下，多进程是真正的并发，因此需要考虑数据异步读写的同步性问题。高端的框架往往使用简单的逻辑，加锁 + 分治就是处理低并发最经济的方式。为了确保每个进程能自己判断所需的数据范围，需要一个变量用于存放已被读取的范围，还需要注意一下锁的范围、锁重入、锁粗化的问题。代码思路就变成了（省略一些校验、判断细节）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self, done_index</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.lock.acquire():</span><br><span class=\"line\">        start = done_index</span><br><span class=\"line\">        end = done_index + max_samples  <span class=\"comment\"># max_samples 是用户定义的每个进程单次读取数据量</span></span><br><span class=\"line\">        done_index = end  <span class=\"comment\"># 更新已完成的下标</span></span><br><span class=\"line\">        self.lock.release()</span><br><span class=\"line\">        get_data(start, end)</span><br><span class=\"line\">        hashing()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\">done_index = <span class=\"number\">0</span>  <span class=\"comment\"># 初始化下标为从 0 开始</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=(done_index)))</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>聪明的你一定会发现一个问题：由于进程在创建时会为自己创建一份上下文拷贝，并运行在自己的独立内存中，所以每个进程在执行完成后，修改的 <code>done_index</code> 都只是自己内存中的引用（即便用 <code>global</code> 修饰为全局变量也同样），因此为了在进程间共享，就需要用 <code>multiprocessing.Value()</code> 实现：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Lock()</span><br><span class=\"line\">    self.done_index = multiprocessing.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    self.data_lines = <span class=\"built_in\">len</span>(data)  <span class=\"comment\"># 样本总数目</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> self.lock.acquire():  <span class=\"comment\"># 加锁，已确保自己获取到的 done_index 是最新的</span></span><br><span class=\"line\">        start = self.done_index.value</span><br><span class=\"line\">        end = start + max_samples  <span class=\"comment\"># max_samples 是用户定义的每个进程单次读取数据量</span></span><br><span class=\"line\">        self.done_index.value = end  <span class=\"comment\"># 更新已完成的下标</span></span><br><span class=\"line\">        self.lock.release() <span class=\"comment\"># 释放锁，允许其他进程操作更新 done_index</span></span><br><span class=\"line\">        get_data(start, end)</span><br><span class=\"line\">        hashing()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> end &lt; self.data_lines:  <span class=\"comment\"># 尚有未完成的数据，再次调用分配</span></span><br><span class=\"line\">            self.work()</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        self.lock.release()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-编码后数据的保存问题\"><a href=\"#3-3-编码后数据的保存问题\" class=\"headerlink\" title=\"3.3 编码后数据的保存问题\"></a>3.3 编码后数据的保存问题</h3><p>现在并发已经正常了，数据一致性也保证了，只要能在编码完成后把最终结果通知给主进程即可。</p>\n<blockquote>\n<p>这体现了进程池的好处之一：可以指定进程的返回值。</p>\n</blockquote>\n<p>由于手动管理模式并没有返回值，因此想借鉴上面的方法使用一个共享变量来存放，但查了一下 Api 发现 <code>multiprocessing.Value()</code> 只支持几种基本类型，而需要收集的数据类型复杂：</p>\n<blockquote>\n<p>表格来源：</p>\n<ul>\n<li><a href=\"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Value\" title=\"@LINK\">multiprocessing — Process-based parallelism</a></li>\n<li><a href=\"https://docs.python.org/3/library/array.html#module-array\" title=\"@LINK\">array — Efficient arrays of numeric values</a></li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Type code</th>\n<th align=\"center\">C Type</th>\n<th align=\"center\">Python Type</th>\n<th align=\"center\">Minimm size in bytes</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">&#39;c&#39;</td>\n<td align=\"center\">char</td>\n<td align=\"center\">character</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;b&#39;</td>\n<td align=\"center\">signed char</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;B&#39;</td>\n<td align=\"center\">unsigned char</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;u&#39;</td>\n<td align=\"center\">Py_UNICODE</td>\n<td align=\"center\">Unicode character</td>\n<td align=\"center\">2 (see note)</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;h&#39;</td>\n<td align=\"center\">signed short</td>\n<td align=\"center\">int</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;H&#39;</td>\n<td align=\"center\">unsigned short</td>\n<td align=\"center\">int</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;i&#39;</td>\n<td align=\"center\">signed int</td>\n<td align=\"center\">int</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;I&#39;</td>\n<td align=\"center\">unsigned int</td>\n<td align=\"center\">long</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;l&#39;</td>\n<td align=\"center\">signed long</td>\n<td align=\"center\">int</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;L&#39;</td>\n<td align=\"center\">unsigned long</td>\n<td align=\"center\">long</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;f&#39;</td>\n<td align=\"center\">float</td>\n<td align=\"center\">float</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">&#39;d&#39;</td>\n<td align=\"center\">double</td>\n<td align=\"center\">float</td>\n<td align=\"center\">8</td>\n</tr>\n</tbody></table>\n<p>不过 multiprocessing 提供了一个非常好的内置方案：<code>Queue</code>。<code>multiprocessing.Queue</code> 允许进程通过加锁以 FIFO 的顺序使用 <code>put()</code> 或 <code>get()</code> 读写对象，且允许设置读写超时后中断锁并放弃操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    data = hashing()</span><br><span class=\"line\">    self.hashing_parts.put(data)</span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主线程等待所有子线程执行完毕</span></span><br><span class=\"line\">list_data = []</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> hashing_parts.empty():</span><br><span class=\"line\">    list_data.append(hashing_parts.get())</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-结果数据顺序问题\"><a href=\"#3-4-结果数据顺序问题\" class=\"headerlink\" title=\"3.4 结果数据顺序问题\"></a>3.4 结果数据顺序问题</h3><p>到这一步，已经可以将各个进程的编码结果存在 <code>list_data</code> 中，只需要使用 <code>pandas.concat(list_data, ignore_index = 0)</code> 就能把所有数据拼起来成为完整的编码后数据，但聪明的你一定又会想到，并发处理的返回顺序是不可预知的，直接按进程完成的顺序拼接很可能会改变原始样本数据的顺序：</p>\n<blockquote>\n<p>With return_df=False, a different ordering of the samples could lead into nasty surprises, because numpy.ndarray doesn&#39;t preserve index -&gt; the training data would not be aligned with the labels anymore.</p>\n</blockquote>\n<p>因此还需要利用字典来存放当前数据块的索引位置与数据块的关系，最后主进程获取所有的字典数据，并按照键值顺序排序后再拼接：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    start = ...  <span class=\"comment\"># 当前数据块起始下标</span></span><br><span class=\"line\">    end = ...  <span class=\"comment\"># 当前数据块结束下标</span></span><br><span class=\"line\">    data = hashing()</span><br><span class=\"line\">    part_index = <span class=\"built_in\">int</span>(math.ceil(end_index / self.max_sample))</span><br><span class=\"line\">    self.return_data.put(&#123;part_index: data&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">list_data = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">not</span> hashing_parts.empty():</span><br><span class=\"line\">    list_data.update(hashing_parts.get())  <span class=\"comment\"># 取出所有的代码块（无序状态）</span></span><br><span class=\"line\">sort_data = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> part_index <span class=\"keyword\">in</span> <span class=\"built_in\">sorted</span>(list_data):  <span class=\"comment\"># 将所有字典型数据块按照 key 排序后把 value 取出</span></span><br><span class=\"line\">    sort_data.append(list_data[part_index])</span><br><span class=\"line\">data = pandas.concat(sort_data, ignore_index=<span class=\"literal\">True</span>)  <span class=\"comment\"># 拼接数据</span></span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>part_index</code> 的算法是用当前已完成的下标除以每个进程单次处理的下标，并向上取整（为了让结果更直观地从 1 开始），来作为当前数据块的定位。</p>\n<h3 id=\"3-5-子进程调用问题\"><a href=\"#3-5-子进程调用问题\" class=\"headerlink\" title=\"3.5 子进程调用问题\"></a>3.5 子进程调用问题</h3><p>到了这一步，终于 Demo 测试已经完整支持了并发，但聪明的你一定会问：我们写代码不仅要能用还要足够鲁棒，你测试过代码吗？</p>\n<blockquote>\n<p><del>好了小明你出去，这里不允许提问。</del></p>\n</blockquote>\n<p>由于 sklearn-category_encoders 的 CI 接入了 nose 单元测试，流水线在跑单元测试代码时报了这么一个错误：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runtime Error: Lock objects should only be shared between processes through inheritance.</span><br><span class=\"line\"></span><br><span class=\"line\">意思大致是进程锁只能被锁的创建者的子进程共享。</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这体现了进程池的好处之一：每个进程天然具有继承关系，可以共享进程锁等资源。</p>\n</blockquote>\n<p>为了解决这个问题，可以通过 <code>multiprocessing.Manager.XXX</code> 来代替所有需要进程共享的资源：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Manager.Lock()</span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Manager.Queue()</span><br><span class=\"line\">    self.done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-6-深拷贝问题\"><a href=\"#3-6-深拷贝问题\" class=\"headerlink\" title=\"3.6 深拷贝问题\"></a>3.6 深拷贝问题</h3><p>现在数据测试已经通过，CI 测试也已经通过，可当使用这套 HashingEncoder 运行一个大数据量的基准测试时，multiprocessing 的 Manager 又报错了（省略部分信息）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">180</span>, <span class=\"keyword\">in</span> deepcopy</span><br><span class=\"line\">        y = _reconstruct(x, memo, *rv)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">280</span>, <span class=\"keyword\">in</span> _reconstruct</span><br><span class=\"line\">        state = deepcopy(state, memo)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">150</span>, <span class=\"keyword\">in</span> deepcopy</span><br><span class=\"line\">        y = copier(x, memo)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py&quot;</span>, line <span class=\"number\">240</span>, <span class=\"keyword\">in</span> _deepcopy_dict</span><br><span class=\"line\">        y[deepcopy(key, memo)] = deepcopy(value, memo)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">multiprocessing.managers.RemoteError:</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">Unserializable message: Traceback (most recent call last):</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/managers.py&quot;</span>, line <span class=\"number\">289</span>, <span class=\"keyword\">in</span> serve_client</span><br><span class=\"line\">        send(msg)</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/connection.py&quot;</span>, line <span class=\"number\">206</span>, <span class=\"keyword\">in</span> send</span><br><span class=\"line\">        self._send_bytes(_ForkingPickler.dumps(obj))</span><br><span class=\"line\">    File <span class=\"string\">&quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/reduction.py&quot;</span>, line <span class=\"number\">51</span>, <span class=\"keyword\">in</span> dumps</span><br><span class=\"line\">        cls(buf, protocol).dump(obj)</span><br><span class=\"line\">TypeError: can<span class=\"string\">&#x27;t pickle _thread.lock objects</span></span><br></pre></td></tr></table></figure>\n\n<p>Traceback 中的信息不够清晰，但是发现了一个关键信息：<strong>deepcopy</strong>，为了验证写个小测试：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> copy <span class=\"keyword\">import</span> deepcopy</span><br><span class=\"line\"></span><br><span class=\"line\">he = HashingEncoder()</span><br><span class=\"line\">he_cp = deepcopy(he)</span><br></pre></td></tr></table></figure>\n\n<p>报错复现，看来主要问题就出在深拷贝上。从网上搜，能参考的信息实在太少了，不过参考 Pickle 模块的作用（用于 Python 特有数据类型和基本数据类型转换），聪明的你一定又想到了：这不就是序列化吗？</p>\n<blockquote>\n<p>这体现了进程池的好处之一：内部对参数进行了封装处理，实现了拷贝的支持。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock = multiprocessing.Manager.Lock()</span><br><span class=\"line\">    self.hashing_parts = multiprocessing.Manager.Queue()</span><br><span class=\"line\">    self.done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">    self.lock ...</span><br><span class=\"line\">    self.hashing_parts ...</span><br><span class=\"line\">    self.done_index ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(multiprocessing.Process(target=work, args=()))</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p><code>lock</code>, <code>hashing_parts</code>, <code>done_index</code>，都是在 HashingEncoder 初始化时定义的，虽然这些都不是我的自定义类对象，但报错信息的最后一行：<code>TypeError: can&#39;t pickle \\_thread.lock objects</code> 明确指出：进程锁 Lock 是不能被 pickle 转化的，事实上，另外两种 Value 和 Queue 都不可以，只不过因为执行到 pickle Lock 的时候就报错中断了而已。</p>\n<p>不过因为这几个参数的目的只是为了运行时记录一下数据处理进度并不需要实现得太复杂，既然造成这个错误的原因是开启子进程时，参数带有自定义类对象（通常是不可被 pickle 的），那就把这些 Manager() 下的对象都放到创建子进程之前，并通过参数传递进去即可：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">work</span>(<span class=\"params\">self, _lock, _hashing_parts, _done_index</span>):</span></span><br><span class=\"line\">    _lock ...</span><br><span class=\"line\">    _hashing_parts ...</span><br><span class=\"line\">    _done_index ...</span><br><span class=\"line\"></span><br><span class=\"line\">lock = multiprocessing.Manager.Lock()  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\">hashing_parts = multiprocessing.Manager.Queue()  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\">done_index = multiprocessing.Manager.Value(<span class=\"string\">&#x27;d&#x27;</span>, <span class=\"number\">0</span>)  <span class=\"comment\"># 创建为局部变量</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(max_process):  <span class=\"comment\"># max_process 是用户定义的最大并行进程数</span></span><br><span class=\"line\">    process.append(</span><br><span class=\"line\">        <span class=\"comment\"># 通过参数传递</span></span><br><span class=\"line\">        multiprocessing.Process(target=work,</span><br><span class=\"line\">                                args=(lock, hashing_parts, done_index)))</span><br></pre></td></tr></table></figure>\n\n<p>另外，在查找 multiprocessing 相关内容的时候，无意间看到一个因为 <code>logging</code> 导致多进程死锁的问题，出现概率较低，记录在附录【10】。作者自己的解答为：</p>\n<blockquote>\n<p>由于主进程中使用了thread+mutiprocessing(fork)，导致logging出现死锁，现象就是遇到子进程里第一句logging就hang住。问题只会发生在Linux下。</p>\n</blockquote>\n<p>以及在本地进行单元测试时通常使用 nose 模块测试，但在提交 PR 时测试是部署在 CI 上进行的，这里面也遇到了一些问题，例如代码文件内的 example 的输入和输出必须是真实运行结果，CI 检测时会真实运行 example 的输入，并且所写的输出也要和 CI 运行结果一致。</p>\n<hr>\n<h2 id=\"4-优化效果\"><a href=\"#4-优化效果\" class=\"headerlink\" title=\"4. 优化效果\"></a>4. 优化效果</h2><p>释放多核能力，相比单核的提升当然是巨大的，不信你问问 Intel 和 AMD。放上一些毫无悬念的对比测试：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">样本数量</th>\n<th align=\"center\">特征数量</th>\n<th align=\"center\">CPU 物理核心数</th>\n<th align=\"center\">优化前编码耗时</th>\n<th align=\"center\">优化后编码耗时</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">100,000</td>\n<td align=\"center\">2</td>\n<td align=\"center\">8</td>\n<td align=\"center\">166.02 s</td>\n<td align=\"center\">25.79 s</td>\n</tr>\n<tr>\n<td align=\"center\">1,000,000</td>\n<td align=\"center\">8</td>\n<td align=\"center\">8</td>\n<td align=\"center\">1.89 h</td>\n<td align=\"center\">15.56 min</td>\n</tr>\n<tr>\n<td align=\"center\">50,000,000</td>\n<td align=\"center\">4</td>\n<td align=\"center\">12</td>\n<td align=\"center\">48.22 h</td>\n<td align=\"center\">4.39 h</td>\n</tr>\n</tbody></table>\n<p>（测试都是在 ECS 上跑出来的，真金白银……）</p>\n<p>The End</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://blog.csdn.net/chenyulancn/article/details/77836593\" title=\"@LINK\">python多进程共享变量Value使用tips</a></li>\n<li><a href=\"https://blog.csdn.net/qq_27292549/article/details/78929296\" title=\"@LINK\">python中的multiprocessing在map函数中的加锁lock处理方式</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_41935140/article/details/81153611\" title=\"@LINK\">使用进程池时遇到的坑...</a></li>\n<li><a href=\"https://blog.csdn.net/qq_38765321/article/details/88376031\" title=\"@LINK\">TypeError: can&#39;t pickle _thread.lock objects</a></li>\n<li><a href=\"https://www.cnblogs.com/SuKiWX/p/8804974.html\" title=\"@LINK\">python中的GIL详解</a></li>\n<li><a href=\"https://www.cnblogs.com/kaituorensheng/p/4445418.html\" title=\"@LINK\">Python多进程编程</a></li>\n<li><a href=\"https://www.cnblogs.com/gengyi/p/8647950.html\" title=\"@LINK\">python学习笔记——multiprocessing 多进程组件-队列Queue</a></li>\n<li><a href=\"https://blog.csdn.net/u013066730/article/details/82763115\" title=\"@LINK\">python多进程（multiprocessing）中的Queue，Pipe</a></li>\n<li><a href=\"https://www.cnblogs.com/sch01ar/p/8215042.html\" title=\"@LINK\">Python多进程-进程间数据的传递</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000005919174\" title=\"@LINK\">使用multiprocessing.Process调用start方法后，有较小的几率子进程中run方法未执行</a></li>\n<li><a href=\"https://www.jianshu.com/p/8978aceac3b6\" title=\"@LINK\">基于travis-ci的单元自测</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_33762321/article/details/88275111\" title=\"@LINK\">数据特征处理之特征哈希（Feature Hashing）</a></li>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1593454269874725931&wfr=spider&for=pc&isFailFlag=1\" title=\"@LINK\">人工智能之机器学习篇——哈希学习learning to hash</a></li>\n<li><a href=\"http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html\" title=\"@LINK\">特征哈希（Feature Hashing）</a></li>\n<li><a href=\"https://www.datalearner.com/blog/1051537932880901\" title=\"@LINK\">数据特征处理之特征哈希（Feature Hashing）</a></li>\n<li><a href=\"https://blog.csdn.net/laolu1573/article/details/79410187\" title=\"@LINK\">Feature hashing(特征哈希)</a></li>\n<li><a href=\"https://blog.csdn.net/vim_wj/article/details/78300239\" title=\"@LINK\">github----向开源框架提交pr的过程</a></li>\n</ul>\n","categories":["Python"],"tags":["AI","SKLearn","HashingEncoder","哈希编码","多线程"]},{"title":"Python中的下划线与函数的花式调用","url":"/post/python/python-underline/","content":"<span id=\"more\"></span>\n\n<h1 id=\"Python中的下划线与函数的花式调用\"><a href=\"#Python中的下划线与函数的花式调用\" class=\"headerlink\" title=\"Python中的下划线与函数的花式调用\"></a>Python中的下划线与函数的花式调用</h1><p>前言：今天在看一个 TF 程序的时候，发现很多例程都喜欢把 main 函数定义为：<code>main(_)</code>，而不是 <code>main(argv=None)</code>，当然对于一个 Python 程序而言，一切皆为对象，用下划线当做参数变量并没什么好奇怪的（毕竟连 <code>...</code> 都是一个 Ellipsis 对象，甚至可以修改其默认值），但如此广泛应用，应当是有一定原因的，找了找论坛和 SOF，简略看了一下 TF 中 <code>run()</code> 函数的源码（主要是复杂的看不懂），算是初步了解了 Python 中下划线的应用，而且还无意间看到了一篇关于 Python 函数“花式”调用的文章，受益匪浅。</p>\n<hr>\n<h2 id=\"1-来源\"><a href=\"#1-来源\" class=\"headerlink\" title=\"1. 来源\"></a>1. 来源</h2><p>最开始有这个疑问是因为今天 <del>突发奇想心血来潮自我膨胀差点上天的</del> 看了看 TinyMind 里面的云平台，进去还送了 2 点平台点数，本着不用白不用的心态，想想亚马逊和阿里比较昂贵的价格，准备试试看这里效果怎么样，然后点开官方文档就看到了一个巨经典的例程：mnist 手写识别，虽然写是写过，不过自己是基于 C++ 写的，Python 的代码还是可以好好看看，这一看就发现了简介中的现象，作为一个码（fei）农（zhai），遇到问题当然是问。。哦对了，千万不要再汤很凉上搜索“_”这个关键词。</p>\n<hr>\n<h2 id=\"2-Python基础语法中的下划线\"><a href=\"#2-Python基础语法中的下划线\" class=\"headerlink\" title=\"2. Python基础语法中的下划线\"></a>2. Python基础语法中的下划线</h2><p>如果写过 Python，其他下划线不多说，至少 <code>__name__</code> 和 <code>__init__</code> 是见过的，以前只想过这是语法规定以及一点都不优雅，这回是好好整理了一把，先列出 Python 中可能存在的 5 种下划线的情况：</p>\n<ol>\n<li>单前下划线：<code>_sample</code></li>\n<li>单后下划线：<code>sample_</code></li>\n<li>双前下划线：<code>__sample</code></li>\n<li>前后双下划线：<code>__sample__</code></li>\n<li>单独下划线：<code>_</code></li>\n</ol>\n<h3 id=\"2-1-单前下划线：-sample\"><a href=\"#2-1-单前下划线：-sample\" class=\"headerlink\" title=\"2.1 单前下划线：_sample\"></a>2.1 单前下划线：_sample</h3><p>单前下划线的写法非常“约定俗成”——纯粹只是一种习惯和写法的延续，用于表示该变量是个 函数/类 的内部变量，写不写完全看个人习惯。但在一种特殊情况下，单前下划线是有特殊作用的，下面用代码说明。<br>首先定义一个类 ClassA，重写构造方法并定义两个变量：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;PreUnderline&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.normal + <span class=\"string\">&quot; | &quot;</span> + a._pre)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal | PreUnderline</span><br></pre></td></tr></table></figure>\n\n<p>运行输出也很正常，这说明单前下划线并不影响一个变量被访问，这时我们考虑一种情况，假设在一个 module：im_module.py 中有两个函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># im_module.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">normal_func</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pre_func</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;PreUnderline&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>接着在别的地方把这个 module 导入并调用其函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> im_module <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(normal_func())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_pre_func())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal</span><br><span class=\"line\">NameError: <span class=\"string\">&quot;name &#x27;_pre_func&#x27; is not defined&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是一种虽然不好但很常见的导入方式，但结果呢？是的，在使用通配符 <em> 导入的时候，解释器会过滤掉单前下划线的成员。 <em>*但！</em></em> 前文也说了，通配符导入并不是良好的编码习惯，这种导入方式非常容易导入 无关/冲突/未知/... 的部分，因此通常还是应该手动选择需要导入的部分，如果需要导入全体，则应该使用如下方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> im_module</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(normal_func())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_pre_func())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Normal</span><br><span class=\"line\">PreUnderline</span><br></pre></td></tr></table></figure>\n\n<p>这次的输出结果一切正常。</p>\n<p>也就是说，除非使用通配符 <code>*</code> 的方式进行导入，会导致单前下划线修饰的成员被忽略，否则与不带下划线的成员没有区别。</p>\n<p>除了这种特殊情况之外，就像 Java 中喜欢用 m 前缀来表示成员变量一样，这仅仅只是一种提醒功能，具体好不好、对不对、有没有用呢，那就仁者见仁了，一般是根据团队项目最初定的标准来决定，个人项目就纯粹看习惯了。顺便提一句，在 Google 官方的 <a href=\"https://google.github.io/styleguide/javaguide.html\" title=\"@LINK\">Java Style Guide</a> 中并不推荐这种写法，当然这也跟如今 IDE 的智能有关，如果使用的编辑器没有代码高亮或者提示功能，还是建议加上吧，这篇文档的中译版可参考附录【2】。</p>\n<h3 id=\"2-2-单后下划线：sample\"><a href=\"#2-2-单后下划线：sample\" class=\"headerlink\" title=\"2.2 单后下划线：sample_\"></a>2.2 单后下划线：sample_</h3><p>单后下划线相对而言可能使用场景还比较多，它的主要功能是“规避”关键字冲突。Python 中有许多关键字，例如 <code>class</code>，<code>sum</code>，<code>len</code>，<code>type</code> 等，但在许多时候，我们自己定义的变量、方法等，很难找到更适合的表示单词，或是改变写法又太麻烦/不直观，例如学校、师生类中的“班级属性 class”，商品的“种类 type”，这时候如果我们不想费时间写出像 class_num 或者 type_name 这样的标识符，或许可以直接用 <code>class_</code> 和 <code>type_</code> 代替，这样既避免了和关键字的冲突，又能很直观地表示其含义。</p>\n<h3 id=\"2-3-双前下划线：-sample\"><a href=\"#2-3-双前下划线：-sample\" class=\"headerlink\" title=\"2.3 双前下划线：__sample\"></a>2.3 双前下划线：__sample</h3><p>这个就有点意思了，用双前下划线标识的属性，解释器会重写名称，以避免子类中的命名冲突，其效果对属性和函数是一样的，以下代码仅用属性举例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Normal&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;PreUnderline&quot;</span></span><br><span class=\"line\">        self.__double_pre = <span class=\"string\">&quot;DoublePreUnderline&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用 dir() 函数查看 ClassA 对象的属性</span></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"built_in\">dir</span>(a)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"string\">&#x27;_ClassA__double_pre&#x27;</span>, <span class=\"string\">&#x27;__class__&#x27;</span>, <span class=\"string\">&#x27;__delattr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__dict__&#x27;</span>, <span class=\"string\">&#x27;__dir__&#x27;</span>, <span class=\"string\">&#x27;__doc__&#x27;</span>, <span class=\"string\">&#x27;__eq__&#x27;</span>, <span class=\"string\">&#x27;__format__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ge__&#x27;</span>, <span class=\"string\">&#x27;__getattribute__&#x27;</span>, <span class=\"string\">&#x27;__gt__&#x27;</span>, <span class=\"string\">&#x27;__hash__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init__&#x27;</span>, <span class=\"string\">&#x27;__init_subclass__&#x27;</span>, <span class=\"string\">&#x27;__le__&#x27;</span>, <span class=\"string\">&#x27;__lt__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__module__&#x27;</span>, <span class=\"string\">&#x27;__ne__&#x27;</span>, <span class=\"string\">&#x27;__new__&#x27;</span>, <span class=\"string\">&#x27;__reduce__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__reduce_ex__&#x27;</span>, <span class=\"string\">&#x27;__repr__&#x27;</span>, <span class=\"string\">&#x27;__setattr__&#x27;</span>, <span class=\"string\">&#x27;__sizeof__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__str__&#x27;</span>, <span class=\"string\">&#x27;__subclasshook__&#x27;</span>, <span class=\"string\">&#x27;__weakref__&#x27;</span>, <span class=\"string\">&#x27;_pre&#x27;</span>, <span class=\"string\">&#x27;normal&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>在输出的结尾，<code>_pre</code> 和 <code>normal</code> 都在，唯独不见了 <code>__double_pre</code>？其实并不是没有，而是解释器自动改变了其内部形式，就在输出的第一个：<code>_ClassA__double_pre</code>，解释器自动为这个属性增加了一个当前所属类的类名标识 <code>_ClassA</code>。</p>\n<p>这也意味着，即使在 ClassA 所在的当前 module 内，如果需要调用这个属性，用 <code>ClassA().__double_pre</code> 也会报错 <code>AttributeError: &quot;&#39;ClassA&#39; object has no attribute &#39;__double_pre&#39;&quot;</code> ，而应该使用 <code>ClassA()._ClassA__double_pre</code> 的方式调用。</p>\n<p>为什么要这样，又有什么用呢，用下面的代码就可以说明：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassB</span>(<span class=\"params\">ClassA</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"comment\"># 继承自 ClassA</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>(ClassB, self).__init__()</span><br><span class=\"line\">        <span class=\"comment\"># 也可以直接覆写</span></span><br><span class=\"line\">        <span class=\"comment\"># super().__init__()</span></span><br><span class=\"line\">        self.normal = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\">        self._pre = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\">        self.__double_pre = <span class=\"string\">&quot;Override&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"string\">&#x27;_ClassA__double_pre&#x27;</span>, <span class=\"string\">&#x27;_ClassB__double_pre&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__class__&#x27;</span>, <span class=\"string\">&#x27;__delattr__&#x27;</span>, <span class=\"string\">&#x27;__dict__&#x27;</span>, <span class=\"string\">&#x27;__dir__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__doc__&#x27;</span>, <span class=\"string\">&#x27;__eq__&#x27;</span>, <span class=\"string\">&#x27;__format__&#x27;</span>, <span class=\"string\">&#x27;__ge__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__getattribute__&#x27;</span>, <span class=\"string\">&#x27;__gt__&#x27;</span>, <span class=\"string\">&#x27;__hash__&#x27;</span>, <span class=\"string\">&#x27;__init__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init_subclass__&#x27;</span>, <span class=\"string\">&#x27;__le__&#x27;</span>, <span class=\"string\">&#x27;__lt__&#x27;</span>, <span class=\"string\">&#x27;__module__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ne__&#x27;</span>, <span class=\"string\">&#x27;__new__&#x27;</span>, <span class=\"string\">&#x27;__reduce__&#x27;</span>, <span class=\"string\">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__repr__&#x27;</span>, <span class=\"string\">&#x27;__setattr__&#x27;</span>, <span class=\"string\">&#x27;__sizeof__&#x27;</span>, <span class=\"string\">&#x27;__str__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__subclasshook__&#x27;</span>, <span class=\"string\">&#x27;__weakref__&#x27;</span>, <span class=\"string\">&#x27;_pre&#x27;</span>, <span class=\"string\">&#x27;normal&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>不论是继承自 ClassA 也好，还是直接覆写也好，其最终的输出中都既有 <code>_ClassA__double_pre</code>，也有 <code>_ClassB__double_pre</code>，同样，也是因为解释器自动给 <code>__double_pre</code> 增加了一个当前所属类的类名标识 <code>_ClassB</code>，因此父类 ClassA 中的 <code>__double_pre</code> 并不会被重写：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(b.normal)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._pre)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._ClassA__double_pre)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b._ClassB__double_pre)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Override</span><br><span class=\"line\">Override</span><br><span class=\"line\">DoublePreUnderline</span><br><span class=\"line\">Override</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，被前双下划线标识的属性是不会被重写的</p>\n<p>此外，还有一个特别有意思的应用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ClassC__double_pre = <span class=\"string\">&quot;DoublePreinClassC&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassC</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call</span>():</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> __double_pre</span><br><span class=\"line\"></span><br><span class=\"line\">ClassC.call()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">DoublePreinClassC</span><br></pre></td></tr></table></figure>\n\n<p>乍一看在 ClassC 的 <code>call()</code> 方法中返回的 <code>__double_pre</code> 根本没有定义啊，应该报 NameError 错误才对，实际上，因为在上面手动定义的 <code>_ClassC__double_pre</code> 具有 <code>_ClassC</code> 前缀，因此程序调用 call 方法的时候，解释器会自动给 <code>__double_pre</code> 加上 <code>_ClassC</code> 前缀，而又恰好存在这么个变量，因此可以正常输出。</p>\n<p>这也说明，如果某个类内有属性/方法是以双前下划线修饰，则解释器会自动给双前下划线的成员添加其所属类的前缀，这种转换适用于整个类内所有以双前下划线开头的任何名称，而不论它是一个变量还是方法还是其他。</p>\n<h3 id=\"2-4-前后双下划线：-sample\"><a href=\"#2-4-前后双下划线：-sample\" class=\"headerlink\" title=\"2.4 前后双下划线：__sample__\"></a>2.4 前后双下划线：__sample__</h3><p>这个就好解释多了，也常见的多了，Python 保留了许多用前后双下划线修饰的属性/方法，像 __name__ 或是 __init__()，当然只要我们愿意，并且命名不冲突，我们也可以自行定义前后双下划线修饰的成员，这本身是没有错的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">__test__ = <span class=\"string\">&quot;Test&quot;</span></span><br><span class=\"line\">__test__</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Test</span><br></pre></td></tr></table></figure>\n\n<p>但不太推荐这么做，主要原因是 Python 官方保留了这么命名的做法，因此可能现在没有发生冲突的一些命名，在未来 Python 经过更新后由于官方加入了对应的保留成员而导致冲突。</p>\n<p>因此，干脆就不要使用自定的前后双下划线成员，并且记住这样修饰的都是 Python 保留命名就好了。</p>\n<p>不过我觉得一般也没什么人愿意如此麻烦的加上四个下划线吧，说不定 Python 当年就是考虑到这个才这么设计呢（逃）。</p>\n<h3 id=\"2-5-单下划线：\"><a href=\"#2-5-单下划线：\" class=\"headerlink\" title=\"2.5 单下划线：_\"></a>2.5 单下划线：_</h3><p>说实话我第一次见到这个写法的时候还以为是源码写错了，不过其实通俗的讲，既然 Python 一切皆为对象，当然也就可以把 <code>_</code> 当做很普通的成员使用，事实也确实如此：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ = <span class=\"string\">&quot;Underline&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">_ = <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a + b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_(<span class=\"number\">5</span>, <span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Underline</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">11</span></span><br><span class=\"line\">ab</span><br></pre></td></tr></table></figure>\n\n<p>玩上瘾了，我相信如果你在团队项目里面大量使用 <code>_</code> 作为变量/方法名，明年就该有坟头草了。<br>正经的解释：如果某个变量、方法、参数没有实际用途，可以使用 <code>_</code> 来代替，以表明这是个可以忽略的部分。说起来好像没什么用，其实在真正的源码中，这个用法可以大幅提高阅读感，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">user = (<span class=\"string\">&#x27;ZhangSan&#x27;</span>, <span class=\"string\">&#x27;20岁&#x27;</span>, <span class=\"string\">&#x27;Male&#x27;</span>, <span class=\"string\">&#x27;80分&#x27;</span>, <span class=\"string\">&#x27;野鸡大学&#x27;</span>, <span class=\"string\">&#x27;计算机专业&#x27;</span>, <span class=\"string\">&#x27;物联网工程&#x27;</span>)</span><br><span class=\"line\">name, _, _, _, college, _, _ = user</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(name)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(college)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ZhangSan</span><br><span class=\"line\">野鸡大学</span><br><span class=\"line\">物联网工程</span><br></pre></td></tr></table></figure>\n\n<p>这么写出来的代码，阅读时可以非常直观地看出来，这些消息里面我关注的只有 name 和 college，其中 <code>_</code> 被多次赋值，因此输出的值是最后一次赋值“物联网工程”。</p>\n<p>另外，<code>_</code> 还是大多数 Python REPL 中的一个特殊变量，它不仅可以当做普通的变量、方法正常调用，还会自动保存你最后一次计算的结果，例如：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;ABCD&quot;</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ABCD</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">ABCD</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">list</span>()</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">_.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">_.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">_.append(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n\n<p><strong>但请注意</strong>：如果你已经手动给 <code>_</code> 赋值，则它在当前上下文范围内不会再自动保存你的计算结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span> + <span class=\"number\">2</span></span><br><span class=\"line\">a</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">_ = <span class=\"string\">&quot;A&quot;</span></span><br><span class=\"line\">a += <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(_)</span><br><span class=\"line\">[Out]:</span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\">A</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，<code>_</code> 在未被手动赋值前，当前上下文内每次计算的记过都会赋值给 <code>_</code>，直到你手动给 <code>_</code> 赋值使其称为一个常规成员。</p>\n<h3 id=\"2-6-name-的应用\"><a href=\"#2-6-name-的应用\" class=\"headerlink\" title=\"2.6 __name__的应用\"></a>2.6 __name__的应用</h3><p>__name__ 可以说是 Python 中的一大常客了，最常见的形式就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>通常这个语句会作为一个程序的入口，但为什么会有这么奇怪的一个条件语句呢？用代码一下就能解释明白。首先创建一个 module：rate.py，内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">LEARNING_RATE = <span class=\"number\">1.005</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call_rate</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Rate is :&quot;</span>, LEARN_RATE)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;Value of __name__ :&quot;</span>, __name__)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    call_rate()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果：</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Value of __name__ : __main__</span><br><span class=\"line\">Rate <span class=\"keyword\">is</span> : <span class=\"number\">1.005</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到此时 <code>__name__ == &quot;__main__&quot;</code>，如果再新建一个 module：test.py，内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> rate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(rate.LEARNING_RATE * <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果</span></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Value of __name__ : rate</span><br><span class=\"line\"><span class=\"number\">2.01</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，rate.py 中的 <code>__name__</code> 变成了 &quot;rate&quot;，因此条件语句没有执行。</p>\n<p>因此，<code>__name__</code> 可以用来判断该 module 是直接执行的还是被其他 module 引入后执行的。</p>\n<h3 id=\"2-7-TensorFlow中的run-方法\"><a href=\"#2-7-TensorFlow中的run-方法\" class=\"headerlink\" title=\"2.7 TensorFlow中的run()方法\"></a>2.7 TensorFlow中的run()方法</h3><p>先来看看 TF 中 run() 方法的源码：</p>\n<p><img data-src=\"./code_of_run_in_tf.png\" alt=\"TF 中 run() 方法源码\" title=\"@ASSET\"></p>\n<p>从图中可以看出来，当传的参数 main 为空时，跳过执行，如果不为空，则调用 main 函数，因此想要调用 <code>tf.app.run()</code> 方法，则需要在模型程序中定义 <code>main(argv)</code> 函数，并且接收参数 args，如果模型不需要使用这些参数，就可以用 <code>main(_)</code> 来表示，也就回答了最开始的问题。</p>\n<hr>\n<h2 id=\"3-Python中方法的花式调用\"><a href=\"#3-Python中方法的花式调用\" class=\"headerlink\" title=\"3. Python中方法的花式调用\"></a>3. Python中方法的花式调用</h2><p>首先，几乎在所有的程序中，调用函数/方法的步骤无非就两个：① 定义，② 调用。在 Python 中也是如此，使用关键字 def 来声明一个方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span>():</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n\n<p>似乎我们所熟知的函数/方法调用也就只有这一种，但 Python 还有一种很好玩的调用方式：根据名称调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_a</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function A&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_b</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function B&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func_c</span>():</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Method function C&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(<span class=\"string\">&quot;func_a&quot;</span>)()</span><br><span class=\"line\"><span class=\"built_in\">locals</span>()[<span class=\"string\">&quot;func_b&quot;</span>]()</span><br><span class=\"line\"><span class=\"built_in\">globals</span>()[<span class=\"string\">&quot;func_c&quot;</span>]()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[Out]:</span><br><span class=\"line\">Method function A</span><br><span class=\"line\">Method function B</span><br><span class=\"line\">Method function C</span><br></pre></td></tr></table></figure>\n\n<p>eval() 函数可以直接转换成函数调用，而 <code>locals()</code> 和 <code>globals()</code> 可以通过字典的方式访问局部、全局变量。之所以 Python 支持这种形式的调用，是因为 Python 使用 <strong>名字空间</strong> 来记录变量的变化。每个函数都有自已的名字空间，称为局部名字空间，其记录了函数的变量，包括函数的参数和局部定义的变量；每个 module 也都有自已的名字空间，称为全局名字空间，其记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量；还有一个内置名字空间，任何 module 均可访问，其存放了内置的函数和异常。名字空间是一个字典，键 key 就是变量名，值 value 就是变量的值，名字空间就像 Python 的普通字典一样可以进行访问。当某行代码要使用变量 x 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序：</p>\n<ol>\n<li>局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python 将使用这个变量，然后停止搜索。</li>\n<li>全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用这个变量然后停止搜索。</li>\n<li>内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。</li>\n</ol>\n<p>如果Python在这些名字空间找不到 x，就会放弃查找并引发一个 NameError 的异常，同时传递 “There is no variable named &#39;x&#39;” 错误信息。</p>\n<p>在 Java 或 C/C++ 等编译语言中，编译器会将代码编译为二进制文件执行，在程序内部，是没有“变量名”这个概念的，所以我们的代码只能通过变量名取值，而不能通过具体的变量获得变量名（当然可以用 Map 的方式手动保存，但这本身脱离了原意），但在 Java 中，有一种很类似的样例就是 <a href=\"/post/android/android-objectanimator/android-objectanimator\" title=\"@LINK\">ObjectAnimator</a> 中的属性名 Attr，调用该方法会通过设置的属性名去获取对应控件下的 setAttr() 方法，和此处的命名空间有着异曲同工之妙。</p>\n<hr>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ul>\n<li><a href=\"https://google.github.io/styleguide/javaguide.html\" title=\"@LINK\">Google Java Style Guild</a></li>\n<li><a href=\"https://blog.csdn.net/harrytsz/article/details/63328086\" title=\"@LINK\">Google Java Style Guide中文版</a></li>\n<li><a href=\"https://www.cnblogs.com/amou/p/9530932.html\" title=\"@LINK\">18式优雅你的Python</a></li>\n</ul>\n","categories":["Python"],"tags":["Python","Underline","下划线","同名函数"]},{"title":"ML入门-线性回归简介","url":"/post/machinelearning/ml-linear/ml-linear-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-线性回归简介\"><a href=\"#ML入门-线性回归简介\" class=\"headerlink\" title=\"ML入门-线性回归简介\"></a>ML入门-线性回归简介</h1><h2 id=\"1-什么是回归\"><a href=\"#1-什么是回归\" class=\"headerlink\" title=\"1. 什么是回归\"></a>1. 什么是回归</h2><p>假设有一数据集 $D = \\{ X_i, y_i \\}^N_{i = 1}$，其中 N 为训练样本数目，i 为样本索引，$X_i$ 为第 i 个样本的输入特征，$y_i$ 为第 i 个样本的输出/响应，那么：</p>\n<p><strong>根据训练样本 D，学习一个从输入 $X$ 到输出 $y$ 的映射 $f$，使得 $y_i = f(X_i)$，且 $y_i \\in R$，这就是回归任务。</strong></p>\n<blockquote>\n<p>没有特殊说明的情况下，$W$、$X$、$y$ 等均为矩阵（一维矩阵有时作为向量使用）形式，在强调向量性质时使用 $\\vec{X}$、$\\vec{W}$、$\\vec{y}$ 表示。</p>\n</blockquote>\n<p>回归任务的一个重要特征即为 $y_i \\in R$，当 $y_i$ 取类别型数值时，就变成了分类任务。</p>\n<p>当学习到回归任务的映射 f 后，即可对新的输入数据 $X$ 预测其输出 $\\hat{y} = f(X)$。</p>\n<hr>\n<h2 id=\"2-什么是线性回归\"><a href=\"#2-什么是线性回归\" class=\"headerlink\" title=\"2. 什么是线性回归\"></a>2. 什么是线性回归</h2><p>线性回归是最简单的回归模型之一：即从输入 $X$ 到输出 $y$ 的映射 $f$ 为线性关系：</p>\n<p>$<br>\\begin{aligned}<br>y &amp;= f(X) = W^T X<br>\\\\ &amp;= [w_0, w_1, ..., w_D] \\begin{bmatrix} 1 \\\\ x_1 \\\\ ... \\\\ x_D \\end{bmatrix} = w_0 + \\sum^D_{j = 1} w_j x_j<br>\\end{aligned}<br>$</p>\n<p>$X = (1, x_1, ..., x_D)^T$</p>\n<p>其中，$w_0$ 为截距项/偏置（bias），$w_j$ 为第 j 维特征的权重/回归系数，$x_j$ 为第 j 维特征，D 为特征维数，j 为特征索引，$X$ 为特征向量。</p>\n<p>$X$ 在 D 维特征的基础上，再增加一个常数项1，与 $w_0$ 相乘作为截距项，是为了表达式更简洁。也即，$b（bias）= w_0$。</p>\n<p>假设有这么一个例子：根据在线广告投入费用预测每月电子商务销售量，其数据分布和预测直线如下图所示：</p>\n<p><img data-src=\"./linear_predict.png\" alt=\"线性回归模型例\" title=\"@ASSET\"></p>\n<p>在 Scikit-Learn 中，线性回归模型的建立过程大致如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用默认参数初始化</span></span><br><span class=\"line\">lr = LinearRegression()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 训练</span></span><br><span class=\"line\">lr.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>\n\n<p>在图例中，所有的广告费用构成了 <code>X_train</code>，所有的销售量构成了 <code>y_train</code>，将数据对应输入到 <code>fit()</code> 方法中即可，以例中的数据解得最后的直线方程为：</p>\n<p>$$<br>y = 123.94 + 167.89 \\cdot x<br>$$</p>\n<p>其中 $w_0 = 123.94$，将需要预测的的输入 <code>2.8</code> 代入 x 即可求得 $\\hat{y} = 593.78$。</p>\n<p>不过需要注意的一点是，Scikit-Learn 中训练数据 $X$ 是一个二维数组，在本例中，输入只是长度为 6 的一维数组，因此需要先转换成 n 行 m 列的形式，使用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">X_train = X_train.reshape(-<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>来指定列数为 1，行数自动调整。</p>\n<p><code>fit()</code> 完后，<code>lr</code> 这个实例化的线性回归模型对象内就会具有一个默认配置的线性回归参数 $W$，这些参数在经过 <code>fit()</code> 训练后就存在了 <code>lr</code> 对象内部，根据这些参数生成的直线即为图中绿色直线，这就是一个简单的线性回归模型了。</p>\n<hr>\n<h2 id=\"3-线性回归损失函数\"><a href=\"#3-线性回归损失函数\" class=\"headerlink\" title=\"3. 线性回归损失函数\"></a>3. 线性回归损失函数</h2><p>仍然以 “广告投入 - 销售量” 为例，在上文使用默认配置训练后得到了绿色的直线，假设通过手动配置，训练出了另一条蓝色直线：</p>\n<p><img data-src=\"./two_predict_lines.png\" alt=\"两条回归直线\" title=\"@ASSET\"></p>\n<p>显然，蓝色直线也是符合线性回归的定义的，因此需要使用预测残差来评价哪个线性模型更优。</p>\n<h3 id=\"3-1-预测残差\"><a href=\"#3-1-预测残差\" class=\"headerlink\" title=\"3.1 预测残差\"></a>3.1 预测残差</h3><p>根据例中表格数据可以求得：</p>\n<ul>\n<li>绿色直线在训练集上的预测残差为：-41.20, -35.64, 33.92, -8.92, -11.08, 62.91</li>\n<li>蓝色直线在训练集上的预测残差为：14, 10, 70, 204, 25, 142</li>\n</ul>\n<p><img data-src=\"./two_lines_residual.png\" alt=\"两条直线预测残差\" title=\"@ASSET\"></p>\n<p>由于绿色直线的预测残差有负值，在计算残差总和时会发生抵消，因此考虑使用平方计数，也就得到残差平方：</p>\n<p>$$<br>r^2 = (y - \\hat{y})^2<br>$$</p>\n<p>用残差平方来计算残差总和，就得到残差平方和 RSS（Residual Sum of Squares），根据定义显然可得其表达式为：</p>\n<p>$$<br>RSS = \\sum^N_{i = 1} r^2_i = \\sum^N_{i = 1} (y_i - \\hat{y}_i)^2<br>$$</p>\n<p>根据定义求得：</p>\n<ul>\n<li>绿色直线 RSS = 8277.32</li>\n<li>蓝色直线 RSS = 67601</li>\n</ul>\n<p>RSS 可以表示模型预测的整体性能，RSS 最小亦称为为最小二乘 OLS（Ordinary Least Square）。RSS 越小的直线预测越准确，因此显然，绿色直线比蓝色直线要好得多。</p>\n<h3 id=\"3-2-三种损失函数\"><a href=\"#3-2-三种损失函数\" class=\"headerlink\" title=\"3.2 三种损失函数\"></a>3.2 三种损失函数</h3><p>在机器学习中，用 <strong>损失函数 L（Loss Function）</strong> 来 <strong>度量</strong> 样本真实值与模型预测值之间的差异，该差异用预测残差 r（Residual）来表示：$r = y - \\hat{y}$。</p>\n<p>常见的损失函数有三种：</p>\n<ul>\n<li>L2 损失</li>\n<li>L1 损失</li>\n<li>Huber 损失</li>\n</ul>\n<p>损失函数的意义在于，使得模型趋向于<strong>最小训练集上的损失（经验风险最小）</strong>，也即在模型训练时给予一个训练目标，使得训练出来的模型在训练集上的损失总和最小。由于模型的参数即为 $W$，因此定义一个目标函数：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i)<br>$$</p>\n<p>则模型训练的目标也就是求：$J(W)$ 最小。</p>\n<h4 id=\"3-2-1-L2损失\"><a href=\"#3-2-1-L2损失\" class=\"headerlink\" title=\"3.2.1 L2损失\"></a>3.2.1 L2损失</h4><p>在前面的例中，当损失函数采用 RSS 时，损失函数为二次函数，范数为 2，因此也称为 L2 损失（差的平方即为距离的 L2 模长），表达式为：</p>\n<p>$$<br>L(y, \\hat{y}) = (y - \\hat{y})^2 = r^2<br>$$</p>\n<p>此时目标函数即为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i) = \\sum^N_{i = 1} r^2_i<br>$$</p>\n<p>L2 损失是二次函数，因此最大的优点就是：处处可导，优化计算方便。但缺点也很明显：对噪声敏感。若数据中某点的预测残差 r 特别大（下图红点），经过平方放大后 $ r^2 $ 会更大，则会在模型中占主导作用，由于模型的训练目标是使得目标函数最小，在 L2 损失的模型中，也即使得 RSS 最小，因此会导致模型向该噪声点偏移（变为下图橙线）：</p>\n<p><img data-src=\"./noise_in_l2.png\" alt=\"L2 损失对噪声敏感\" title=\"@ASSET\"></p>\n<p>Scikit-Learn 中使用 L2 损失的线性回归模型：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 L2 损失（线性回归默认使用 L2 损失）</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\">lr = LinearRegression()</span><br><span class=\"line\">lr.fit(X_train, y_train)</span><br><span class=\"line\">y_train_pred_lr = lr.predict(X_train)  <span class=\"comment\"># 预测</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-2-L1损失\"><a href=\"#3-2-2-L1损失\" class=\"headerlink\" title=\"3.2.2 L1损失\"></a>3.2.2 L1损失</h4><p>为了减弱噪声点对模型的影响，同时保留损失函数“避免抵消正负”的特性，除了采用平方之外，还可以采用绝对值。当损失函数采用绝对值计量预测误差总和时，损失函数为绝对值函数，范数为 1，因此也称为 L1 损失（差的绝对值即为距离的 L1 模长），表达式为：</p>\n<p>$$<br>L(y, \\hat{y}) = |y - \\hat{y}| = |r|<br>$$</p>\n<p>此时目标函数即为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i) = \\sum^N_{i = 1} |r|_i<br>$$</p>\n<p>L1 函数是绝对值函数，因此最大的有点是：对噪声不敏感：</p>\n<p><img data-src=\"./l2_l1_residual.png\" alt=\"L1 损失对噪声不敏感\" title=\"@ASSET\"></p>\n<p>但缺点同样明显：在零点处左右导数不相等，因此不可导，不便于优化计算。</p>\n<h4 id=\"3-2-3-Huber损失\"><a href=\"#3-2-3-Huber损失\" class=\"headerlink\" title=\"3.2.3 Huber损失\"></a>3.2.3 Huber损失</h4><p>为了结合 L2 和 L1 损失的优点，同时规避二者的缺点，可以考虑选择一个新的损失函数：其在靠近零点处表达式为 L2 损失，具有“可导”的优点，在远离零点处表达式为 L1 损失，具有“抗噪声”的优点，得到如下表达式：</p>\n<p>$$<br>L_{\\delta} (r) = \\left \\{<br>\\begin{aligned}<br>&amp; \\frac {1} {2} r^2 &amp;&amp; {|r| \\le \\delta}<br>\\\\<br>\\delta |r| &amp; - \\frac {1} {2} \\delta^2 &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>或代入预测残差：</p>\n<p>$$<br>L_{\\delta} (r) = \\left \\{<br>\\begin{aligned}<br>&amp; \\frac {1} {2} (y - \\hat{y})^2 &amp;&amp; {|r| \\le \\delta}<br>\\\\<br>\\delta |y &amp; - \\hat{y}| - \\frac {1} {2} \\delta^2 &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>Huber 损失的图像如下：</p>\n<p><img data-src=\"./l1_l2_huber_lines.png\" alt=\"L1 损失对噪声不敏感\" title=\"@ASSET\"></p>\n<p>Huber 表达式中对 L2 和 L1 损失部分均有变形：</p>\n<ul>\n<li>取 L2 损失的部分，添加系数 $\\frac {1} {2}$ 的目的是抵消 $r^2$ 在求导时产生的系数 2。</li>\n<li>取 L1 损失的部分，添加一项 $- \\frac {1} {2} \\delta^2$ 的目的是使得函数在交点 δ 处（图中黑点标识）连续（当取 $|r| = \\delta$ 时，代入函数两段函数值相等）。</li>\n</ul>\n<p>Scikit-Learn 中实现了采用 Huber 损失的回归模型：HuberRegressor，其调用接口几乎相同：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 Huber 损失</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> HuberRegressor</span><br><span class=\"line\">huber = HuberRegressor()</span><br><span class=\"line\">huber.fit(X_train, y_train)</span><br><span class=\"line\">y_train_pred_huber = huber.predict(X_train)  <span class=\"comment\"># 预测</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-Scikit-Learn中的线性回归\"><a href=\"#4-Scikit-Learn中的线性回归\" class=\"headerlink\" title=\"4. Scikit-Learn中的线性回归\"></a>4. Scikit-Learn中的线性回归</h2><p>最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只考虑了模型对训练样本的拟合程度：</p>\n<p>$$<br>J(W = \\sum^N_{i = 1} L(y_i, f(X_i; W))^2 = ||y - X W||^2_2<br>$$</p>\n<p>其中 $f(X_i; W) = \\hat{y}$</p>\n<p>Scikit-Learn 中的线性回归模型 <code>LinearRegression</code> 就是最小二乘线性回归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LinearRegression</span></span><br><span class=\"line\">LinearRegression(fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                 normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                 copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                 n_jobs=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-LinearRegression类参数\"><a href=\"#4-1-LinearRegression类参数\" class=\"headerlink\" title=\"4.1 LinearRegression类参数\"></a>4.1 LinearRegression类参数</h3><p><code>fit_intercept</code>：<br>模型是否包含截距项。<br>如果数据在预处理时已经中心化（训练样本集 y 均值为0，则训练结果 $W_0$ 即为0），则可设置为 <code>False</code>。</p>\n<p><code>normalize</code>：<br>是否对输入特征 $X$ 做归一化。<br>对每一条样本，减去均值并除以 L2 模，使得模长变为 1，因此对数据归一化处理会使得超参数学习更加 Robust，且几乎和样本数目没有关系。但在回归中对样本归一化用的比较少，通常对特征标准化。</p>\n<p><code>copy_X</code>：<br>是否拷贝数据 $X$。<br>当设置为 <code>False</code> 时，对 $X$ 的操作会在原始数据集上完成从而覆盖原始数据。当原始数据后续不再需要使用时可以设置为 <code>False</code> 节省内存。</p>\n<p><code>n_jobs</code>：<br>并行计算时使用 CPU 的数目。<br>设置为 -1 表示使用所有 CPU 核，与显示设置为 CPU 核数目的效果相同。</p>\n<h3 id=\"4-2-LinearRegression类属性\"><a href=\"#4-2-LinearRegression类属性\" class=\"headerlink\" title=\"4.2 LinearRegression类属性\"></a>4.2 LinearRegression类属性</h3><p><code>coef_</code>：<br>回归系数，与特征维数相同。<br>也即特征权重 $\\hat{W}_0$，如果是多任务回归，则与标签 y 的维度相同。</p>\n<p><code>intercept_</code>：<br>截距项。<br>也即偏置（bias）：$b = \\hat{W}_0$</p>\n<h3 id=\"4-3-LinearRegression类方法\"><a href=\"#4-3-LinearRegression类方法\" class=\"headerlink\" title=\"4.3 LinearRegression类方法\"></a>4.3 LinearRegression类方法</h3><p><code>fit(X, y[, sample_weight])</code>：<br>训练模型。<br>X, y 为训练特征和标签，可通过 sample_weight 设置每个样本的权重。例如某个数据由多个设备采集，则高精度设备采集到的数据可以提高权重。</p>\n<p><code>predict(X)</code>：<br>使用已训练完成的模型进行预测。<br>输出即为预测值 $\\hat{y}$</p>\n<p><code>score(X, y[, sample_weight])</code>：<br>评估模型性能，返回模型预测的 $R^2$ 分数（y 与 $\\hat{y}$ 的差异）。<br>根据输入 X 利用模型计算出预测值 $\\hat{y}$ 并和真实值 y 比较。详见回归模型评价指标部分。</p>\n<blockquote>\n<p>关于归一化、标准化、中心化的参考理解：</p>\n<ul>\n<li>归一化：（1）把数据映射到区间 (0, 1) 或 (-1, 1)，主要为了数据处理方便。（2）把有量纲表达式转换为无量纲表达式，便于不同量级或单位的指标能进行比较和加权。</li>\n<li>标准化：将数据转换为均值为 0（每个特征都减掉原始数据中该特征的均值），且标准差为 1。</li>\n<li>中心化：将样本数据的输出 y 转换为均值为 0。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"5-欠拟合与过拟合\"><a href=\"#5-欠拟合与过拟合\" class=\"headerlink\" title=\"5. 欠拟合与过拟合\"></a>5. 欠拟合与过拟合</h2><p>OLS 中，目标函数只考虑了模型对 <strong>训练样本</strong> 的拟合程度：</p>\n<p>$$<br>J(f) = RSS(f) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2<br>$$</p>\n<p>因此在训练样本集上残差和可以接近甚至等于零。原则上，任意复杂的模型，若能完全拟合训练数据，则称为过拟合。反之若模型连训练样本都无法较好的拟合，则称为欠拟合：</p>\n<ul>\n<li>过拟合（Overfitting）：过于复杂的模型与训练数据拟合的太好，导致推广性和扩展性较差，因此和测试数据拟合的较差。</li>\n<li>欠拟合（Underfitting）：过于简单的模型与训练数据尚且拟合的较差，更加不足以拟合测试数据。</li>\n</ul>\n<blockquote>\n<p>线性回归采用的线性模型比较简单，因此当特征维数不太高时，线性回归的过拟合现象通常不太严重。</p>\n</blockquote>\n<h3 id=\"5-1-sin-函数曲线实例\"><a href=\"#5-1-sin-函数曲线实例\" class=\"headerlink\" title=\"5.1 $\\sin$函数曲线实例\"></a>5.1 $\\sin$函数曲线实例</h3><p>假设数据产生模型为：$y = \\sin (2 \\pi x) + \\varepsilon$，其中 $\\sin$ 函数如下：</p>\n<p><img data-src=\"./sin_function.png\" alt=\"sin 函数部分\" title=\"@ASSET\"></p>\n<p>$\\varepsilon$ 为白噪声（随机噪声），假设方差为 0.03：</p>\n<p>$<br>\\varepsilon \\sim N (0, 0.03^2)<br>$</p>\n<p>通常，$\\sin$ 函数需要使用无穷多阶多项式拟合，在此给定 $N = 10$ 共 10 个样本点，如上图中蓝点所示，采用 M 阶多项式拟合数据：</p>\n<p>$<br>y = \\sum^M_{j = 0} w_j x^j<br>$</p>\n<p>当有 10 个样本时，最多可以解出 10 个未知数（$M = 9$ 时可取 $w_0, ..., w_9$ 共 10 个系数），分别取 $M = 0, 1, 3, 9$ 并绘制图形如下：</p>\n<p><img data-src=\"./different_m_in_sin.png\" alt=\"sin 函数部分\" title=\"@ASSET\"></p>\n<p>（1）当 $M = 0$ 时，$y = w_0$，此时为了使 RSS 最小，则训练结果 $w_0 = \\bar{y}$。</p>\n<p>（2）当 $M = 9$ 时，可看出函数已经完全拟合了所有 10 个样本（函数通过每个样本点），此时训练集上 $RSS = 0$，但显然，该多项式并没有较好地表达数据的分布。</p>\n<h3 id=\"5-2-训练误差与测试误差\"><a href=\"#5-2-训练误差与测试误差\" class=\"headerlink\" title=\"5.2 训练误差与测试误差\"></a>5.2 训练误差与测试误差</h3><p>评价模型性能不能在训练集上评估，而应该在新的测试数据集上评估其 <strong>推广性</strong> / <strong>泛化能力（Generalization）</strong>。理论上，随着模型训练的进行，训练误差总是会越来越小，直到为零。根据如下误差计算公式：</p>\n<p>$$<br>E_{RMS} = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2}<br>$$</p>\n<p>统计各样本点的训练误差和测试误差：</p>\n<p><img data-src=\"./loss_of_train_and_test.png\" alt=\"训练误差和测试误差\" title=\"@ASSET\"></p>\n<p>从 $M = 3$ 开始，当模型复杂度继续增加时，训练误差继续下降，甚至为 0，而测试误差反而增大，此时发生了过拟合。在本例中，取 $M = 3$ 时的模型最理想，当 $M \\in [4, 8]$ 时，虽然测试误差没有增加，但模型复杂度增加，这是没有必要的（奥卡姆剃刀原理）。</p>\n<h3 id=\"5-3-过拟合时的模型参数\"><a href=\"#5-3-过拟合时的模型参数\" class=\"headerlink\" title=\"5.3 过拟合时的模型参数\"></a>5.3 过拟合时的模型参数</h3><p>统计当 $M$ 分别取 $0 \\sim 9$ 时训练出来的模型系数 $w_0 \\sim w_M$：</p>\n<p><img data-src=\"./all_w_in_sin.png\" alt=\"所有 W 取值\" title=\"@ASSET\"></p>\n<p>可以看到，随着阶数的增加，系数 $W$ 的绝对值越来越大，发生过拟合时，回归系数的 绝对值 / 平方值 很大，即使输入 $x$ 变化很小也可能带来 $y$ 很大的变化，函数的抖动很剧烈。</p>\n<h3 id=\"5-4-抑制过拟合\"><a href=\"#5-4-抑制过拟合\" class=\"headerlink\" title=\"5.4 抑制过拟合\"></a>5.4 抑制过拟合</h3><p>（1）增加训练样本数</p>\n<p>当训练数据增多时，同样使用九阶多项式拟合，也不会产生明显的过拟合现象：</p>\n<p><img data-src=\"./add_train_data_set.png\" alt=\"增加训练样本\" title=\"@ASSET\"></p>\n<p>通常，样本数 N 为系数数量（特征维度）D 的 5 ~ 10 倍时训练效果比较好。</p>\n<p>（2）目标函数增加正则项</p>\n<p>在给定有限训练样本数时，可通过在目标增加正则项减弱过拟合现象。同样 10 个样本，使用 9 阶多项式拟合，但加入 <strong>L2 正则项</strong>，即可得到 <strong>岭回归（Ridge Regression）</strong>：</p>\n<p>$$<br>J_{Ridge} (W, \\lambda) = \\sum^N_{i = 0} \\left( y_i - \\sum^M_{j = 0} w_j, x^j_i \\right)^2 + \\lambda \\sum^M_{j = 1} w^2_j<br>$$</p>\n<p>得到的拟合结果如下：</p>\n<p><img data-src=\"./add_r_function.png\" alt=\"增加正则项\" title=\"@ASSET\"></p>\n<p>统计模型系数 W 随正则参数 $\\lambda$ 的变化表：</p>\n<p><img data-src=\"./change_of_w_with_lambda.png\" alt=\"W 随 $\\lambda$ 变化表\" title=\"@ASSET\"></p>\n<p>当 $\\ln \\lambda = - \\infty$ 时，$\\lambda = 0$，此时相当于没有正则项。从表格可以看出，$\\ln \\lambda$ 越大，也即 $\\lambda$ 越大，对模型复杂度惩罚越多，回归系数的 绝对值 / 平方值 越小，模型越简单。训练误差及测试误差与正则参数的关系如下图：</p>\n<p><img data-src=\"./loss_with_lambda.png\" alt=\"训练误差和测试误差与 $\\lmabda$ 的关系\" title=\"@ASSET\"></p>\n<p>常用的正则项如下：</p>\n<p>① L2 正则（L2 范数：平方距离）：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$</p>\n<p>② L1 正则（L1 范数：绝对值距离）：$R(W) = ||W||_1 = \\sum^D_{j = 1} |w_j|$</p>\n<p>其中 $W$ 为模型参数，D 为参数的维数。<strong>这里需要注意，正则项求和中，只对 $1 \\sim D$ 求和，也即不惩罚截距项（Bias）$b = w_0$，因此在实际任务中，通常需要先对数据作中心化处理，去掉截距项的影响。</strong></p>\n<p>还有一种 L0 正则（L0 范数：向量中非零元素数目）：$R(W) = ||W||_0$，但因为 L0 正则是 NP 问题，优化计算不方便，且 L1 范数是 L0 范数的最优凸近似，更方便优化计算，因此常用 L1 正则去近似 L0 正则。</p>\n<p>L1 / L0 正则可以得到稀疏解，因此可以起到特征选择的作用，这是因为当确定某个系数 $w_j = 0$ 时，对应的特征 $x_j$ 是无用的，在某些场景（如医学等）下，下一次采样可考虑去掉该特征。</p>\n<p>（3）减少噪声</p>\n<p>另一种抑制过拟合的方法是减少噪声，但在实际面对的任务中，大部分情况下训练数据是给定的，因此增加或调整正则项是抑制过拟合最常用的手段。</p>\n<blockquote>\n<p><strong>正则项发挥作用的理解：对于目标函数 $J(W, \\lambda) = Loss + \\lambda R(W)$，若模型过拟合，由于模型的训练目标是目标函数最小，过拟合时虽然 $Loss$ 可能较小，但模型过于复杂，回归系数的 绝对值 / 平方值 过大，导致目标函数整体较大，则增大 $\\lambda$，为了使得目标函数最小，模型会趋于减小 $W$，从而减小模型复杂度（$W$ 元素的值减小或非零元素减少都是减小模型复杂度）。当处于欠拟合状态，则 $Loss$ 较大，模型复杂度尚且不够拟合训练数据，此时减小 $\\lambda$，以增加模型复杂度。通常，训练的过程分为系数 $W$ 的训练和超参数 $\\lambda$ 的训练，使用某个超参数训练出系数后，模型复杂度即确定下来，再去搜索最优的超参数即可。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"6-带正则的线性回归\"><a href=\"#6-带正则的线性回归\" class=\"headerlink\" title=\"6. 带正则的线性回归\"></a>6. 带正则的线性回归</h2><p>最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只包括训练集上的损失和（经验风险），也即仅考虑了模型对训练样本的拟合程度，因此可能会导致模型太过于复杂，甚至训练误差为0，产生过拟合。为此可在原目标函数中加入正则项，使得模型不会太复杂。则目标函数变为损失和 + 正则项：</p>\n<p>$$<br>J(W, \\lambda) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>$$</p>\n<p>其中 R 为 Risk，表示 $W$ 复杂度的风险，新的目标函数也称为 <strong>结构风险</strong>。正则项的加入使目标函数符合奥拉姆剃刀（Occam&#39;s Razor）原理：简单有效，选择能解释数据的模型中最简单的一个。</p>\n<p>常用的正则项有：L2 正则、L1 正则。</p>\n<p>（1）L2 正则：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$</p>\n<p>（2）L1 正则：$R(W) = ||W||_1 = \\sum^D_{j = 1} |w_j|$</p>\n<p>其中 $W$ 为模型参数，D 为参数的维数。</p>\n<h3 id=\"6-1-岭回归\"><a href=\"#6-1-岭回归\" class=\"headerlink\" title=\"6.1 岭回归\"></a>6.1 岭回归</h3><p>岭回归（Ridge）：L2 损失 + L2 正则 + LinearRegression。</p>\n<p>岭回归正则项对截距项不施加惩罚，也即：</p>\n<p>$$<br>R(W) = \\sum^D_{j = 1} w^2_j，（j 从 1 开始）<br>$$</p>\n<p>线性模型中增加常数项 $x_0 = 1$ 用于表示截距项：</p>\n<p>$$<br>f(X; W) = W^T X = \\sum^D_{j = 0} w_j x_j，（j 从 0 开始）<br>$$</p>\n<p>当 j = 0 时，$x_0 = 1 \\rightarrow w_0 x_0 = w_0$ 作为截距项。因此而得岭回归目标函数（目标函数的损失和部分不惩罚截距项，所以目标函数不需要从 0 开始）：</p>\n<p>$$<br>\\begin{aligned}<br>J(W; \\lambda) &amp;= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>\\\\ &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j<br>\\\\ &amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\end{aligned}<br>$$</p>\n<p>Scikit-Learn 中的岭回归：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Ridge</span></span><br><span class=\"line\">Ridge(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      solver=<span class=\"string\">&#x27;auto&#x27;</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-1-1-Ridge类参数\"><a href=\"#6-1-1-Ridge类参数\" class=\"headerlink\" title=\"6.1.1 Ridge类参数\"></a>6.1.1 Ridge类参数</h4><p><code>alpha</code>：<br>正则参数，也即正则项中的 λ。<br>目标：求 $\\arg_W \\min (||X W - y||^2_2 + \\alpha ||W||^2_2)$</p>\n<p>部分参数与 LinearRegression 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<h4 id=\"6-1-2-Ridge类属性\"><a href=\"#6-1-2-Ridge类属性\" class=\"headerlink\" title=\"6.1.2 Ridge类属性\"></a>6.1.2 Ridge类属性</h4><p>与 LinearRegression 相同。</p>\n<h4 id=\"6-1-3-Ridge类方法\"><a href=\"#6-1-3-Ridge类方法\" class=\"headerlink\" title=\"6.1.3 Ridge类方法\"></a>6.1.3 Ridge类方法</h4><p>与 LinearRegression 相同。</p>\n<h3 id=\"6-2-Lasso\"><a href=\"#6-2-Lasso\" class=\"headerlink\" title=\"6.2 Lasso\"></a>6.2 Lasso</h3><p>Lasso（Least <strong>Absolute</strong> <strong>Shrinkage</strong> and <strong>Selection</strong> Operator）：L2 损失 + L1 正则 + LinearRegression。</p>\n<p>Lasso 有三个关键点：</p>\n<ul>\n<li>Absolute：表示用的是 L1 正则，绝对值的模。</li>\n<li>Shrinkage：相比普通的线性回归，L1 正则会使得 $W$ 有一定收缩。</li>\n<li>Selection：L1 正则可能使得 $W$ 中某些元素变为 0 得到稀疏解，从而起到特征选择的作用。</li>\n</ul>\n<p>Lasso 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W; \\lambda) &amp;= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>\\\\<br>&amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |w_j|<br>\\\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||_1<br>\\end{aligned}<br>$$</p>\n<p>Scikit-Learn 中的 Lasso：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Lasso</span></span><br><span class=\"line\">Lasso(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-1-Lasso类参数\"><a href=\"#6-2-1-Lasso类参数\" class=\"headerlink\" title=\"6.2.1 Lasso类参数\"></a>6.2.1 Lasso类参数</h4><p>大部分与 Ridge 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<h4 id=\"6-2-2-Lasso类属性\"><a href=\"#6-2-2-Lasso类属性\" class=\"headerlink\" title=\"6.2.2 Lasso类属性\"></a>6.2.2 Lasso类属性</h4><p>与 LinearRegression 相同。</p>\n<h4 id=\"6-2-3-Lasso类方法\"><a href=\"#6-2-3-Lasso类方法\" class=\"headerlink\" title=\"6.2.3 Lasso类方法\"></a>6.2.3 Lasso类方法</h4><p>与 LinearRegression 相同。</p>\n<h3 id=\"6-3-弹性网络\"><a href=\"#6-3-弹性网络\" class=\"headerlink\" title=\"6.3 弹性网络\"></a>6.3 弹性网络</h3><p>弹性网络：L2 损失 + （L1 正则 + L2 正则） + LinearRegression。</p>\n<p>在 性网络中，使用 ρ 表示 L1 正则所占比例，$\\dfrac {(1 - \\rho)} {2}$ 表示 L2 正则所占比例：</p>\n<p>$$<br>R(W) = \\sum^D_{j = 1} \\left( \\rho |w_j| + \\dfrac {(1 - \\rho)} {2} w^2_j \\right)<br>$$</p>\n<p>弹性网络的目标函数：</p>\n<p>$$<br>J(W; \\lambda; \\rho) = \\dfrac {1} {2N} ||y - X W||^2_2 + \\lambda \\left( \\rho ||W||_1 + \\dfrac {(1 - \\rho)} {2} ||W||^2_2 \\right),\\ \\ \\ \\ \\ 0 \\le \\rho \\le 1<br>$$</p>\n<p>Scikit-Learn 中使用 ElasticNet 实现弹性网络：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.ElasticNet</span></span><br><span class=\"line\">ElasticNet(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">           l1_ratio=<span class=\"number\">0.5</span>,</span><br><span class=\"line\">           fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">           normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">           copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">           tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">           warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           postive=<span class=\"literal\">False</span>,</span><br><span class=\"line\">           random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">           selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-1-ElasticNet类参数\"><a href=\"#6-3-1-ElasticNet类参数\" class=\"headerlink\" title=\"6.3.1 ElasticNet类参数\"></a>6.3.1 ElasticNet类参数</h4><p><code>l1_ratio</code>：<br>即正则比例参数 ρ。</p>\n<p>大部分参数与 Lasso 相同。<br>其他参数与优化计算有关（详见优化求解部分）。</p>\n<h4 id=\"6-3-2-ElasticNet类属性\"><a href=\"#6-3-2-ElasticNet类属性\" class=\"headerlink\" title=\"6.3.2 ElasticNet类属性\"></a>6.3.2 ElasticNet类属性</h4><p>与 LinearRegression 相同。</p>\n<h4 id=\"6-3-3-ElasticNet类方法\"><a href=\"#6-3-3-ElasticNet类方法\" class=\"headerlink\" title=\"6.3.3 ElasticNet类方法\"></a>6.3.3 ElasticNet类方法</h4><p>与 LinearRegression 相同。</p>\n<p>当取 ρ = 0 时，正则项仅为 L2 正则，当取 ρ = 1 时，正则项仅为 L1 正则。弹性网络的正则项有如下效果：</p>\n<ul>\n<li>L2 正则使得线性回归系数 $W$ 收缩，模型稳定。</li>\n</ul>\n<p>当输入特征之间存在共线性时，使用 L2 正则。</p>\n<ul>\n<li>L1 正则也会收缩回归系数 $W$。当正则参数取合适值时，L1 正则使得有些回归系数为 0，得到稀疏模型。</li>\n</ul>\n<p>当输入特征比较多，优先特征和目标便梁志坚相关性很弱时，L1 正则可能只选择强相关的特征，模型解释性较好。若 $\\lambda_{max}$ 为某临界值，当取 $\\lambda \\ge \\lambda_{max}$ 时，$W = 0$。</p>\n<p><strong>注意</strong>：由于正则项中对不同维度的 $W_j$ 同等对待，对输入特征 $X$ 最好做去量纲（Scaling）处理，使得不同维度的特征取值范围大致相同（如标准化：<code>sklearn.preprocessiong.StandardScaler</code>）。</p>\n<blockquote>\n<p>去量纲的常用方法：</p>\n<ul>\n<li>归一化（Normalization）：例如 Min-Max Scaler</li>\n<li>标准化（Standardization）：例如 Z-Score</li>\n</ul>\n</blockquote>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-损失和正则的概率解释","url":"/post/machinelearning/ml-linear/ml-linear-loss-regular/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-损失和正则的概率解释\"><a href=\"#ML入门-损失和正则的概率解释\" class=\"headerlink\" title=\"ML入门-损失和正则的概率解释\"></a>ML入门-损失和正则的概率解释</h1><p>结论：最小 L2、L1 损失均等价于极大似然估计；带正则的回归等价于贝叶斯估计。</p>\n<hr>\n<h2 id=\"1-损失函数的概率解释\"><a href=\"#1-损失函数的概率解释\" class=\"headerlink\" title=\"1. 损失函数的概率解释\"></a>1. 损失函数的概率解释</h2><h3 id=\"1-1-L2损失与极大似然估计\"><a href=\"#1-1-L2损失与极大似然估计\" class=\"headerlink\" title=\"1.1 L2损失与极大似然估计\"></a>1.1 L2损失与极大似然估计</h3><p>对采用 L2 损失的模型，目标函数为：</p>\n<p>$$<br>J(W) = RSS(W) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2<br>$$</p>\n<p>在回归任务重，令模型中的真实值 $y_i$ 和预测值 $\\hat{y_i}$ 之间的差异为白噪声 $\\varepsilon$，假设噪声（随机变量）$\\varepsilon$ 符合 0 均值的正态分布：$\\varepsilon \\sim N(0, \\sigma^2)$。</p>\n<p>用 $y | X$ 表示给定输入 $X$ 的情况下的输出 $y$，当输入$X$ 给定时，$f(X) = W^T X$ 是一个常数，因此 $y = f(X) + \\varepsilon$ 也是一个随机变量：$y | X \\sim N(f(X), \\sigma^2)$</p>\n<blockquote>\n<p>随机变量加上一个常数，只改变分布的均值，不改变分布的方差。</p>\n</blockquote>\n<p>对于正态分布，其概率密度函数为：</p>\n<p>$$<br>p(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {\\left( y - f(X) \\right)^2} {2 \\sigma^2} \\right)<br>$$</p>\n<blockquote>\n<p>很多分布的概率密度函数为指数函数形式，因此通常取 log 运算，log 函数为单调函数，对似然函数取 log 不影响极值点位置。</p>\n</blockquote>\n<p>似然函数（Likelihood）为：$likelihood(f) = p(D)$，定义为数据出现的概率。在回归任务中，通常假定所有数据都是独立同分布的，因而对所有数据 $D$，其联合概率等于每个独立样本概率的积：</p>\n<p>$$<br>p(D) = \\prod^N_{i = 1} p(y_i | x_i)<br>$$</p>\n<p>对似然函数取 $\\log$ 运算（$\\log$ 是单调函数，不改变极值点位置，与似然函数等价）得到 $\\log$ 似然函数（积取 log 等于 log 再取和，）即为：</p>\n<p>$$<br>\\begin{aligned}<br>l(f) &amp;= \\log p(D) = \\sum^N_{i = 1} \\log p(y_i | x_i)<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\log \\left[ \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\log \\left[ (2 \\pi)^{- \\dfrac {1} {2}} \\cdot \\sigma^{-1} \\cdot \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\left[ - \\dfrac {1} {2} \\log (2 \\pi) - \\log \\sigma - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right]<br>\\\\<br>&amp;= - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x))^2} {2 \\sigma^2}<br>\\end{aligned}<br>$$</p>\n<p>去掉 $l(f)$ 中常数项（不影响极值点位置），当 $l(f)$ 取最大值时可得 <strong>极大似然估计</strong>：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\max l(f)<br>\\\\<br>= &amp; \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\dfrac {1} {2 \\sigma^2} \\min \\sum^N_{i = 1} (y_i - f(x_i))^2<br>\\end{aligned}<br>$$</p>\n<p>同样，去掉系数 $\\dfrac {1} {2 \\sigma^2}$ 不影响极值点位置，而其中的似然项</p>\n<p>$<br>\\sum^N_{i = 1} (y_i - f(x_i))^2 = RSS(f)<br>$</p>\n<p>恰好 是残差平方和 / 训练集上的 L2 损失和，因此：</p>\n<p>$$<br>\\begin{aligned}<br>\\max l(f) &amp;<br>\\\\<br>极大似然估计 &amp;<br>\\end{aligned}<br>\\begin{aligned}<br>\\Longleftrightarrow \\min \\sum^N_{i = 1} (y_i - f(x_i))^2 \\Longleftrightarrow<br>\\\\<br>\\quad<br>\\end{aligned}<br>\\begin{aligned}<br>&amp; \\min RSS(f)<br>\\\\<br>&amp; 最小二乘<br>\\end{aligned}<br>$$</p>\n<p><strong>极大似然估计等价于最小二乘。</strong></p>\n<p>又由于 log 似然即：$l(f)$，与极大似然有：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\max l(f)：极大似然估计<br>\\\\<br>= &amp; \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)<br>\\\\<br>= &amp; \\min - l(f)：负 log 似然最小<br>\\end{aligned}<br>$$</p>\n<p><strong>极大似然估计等价于负 log 似然最小。</strong></p>\n<p>因此负 log 似然也被成为一种损失函数：负 log 似然损失。</p>\n<ul>\n<li>L2 损失是负 log 似然损失。</li>\n<li>分类任务中的 Logistic 回归使用的也是负 log 似然损失。</li>\n</ul>\n<p>将上述极大似然估计推广为一般形式：</p>\n<p>$$<br>l(\\theta) = \\log (D | \\theta) = \\sum^N_{i = 1}\\log p(X_i | \\theta)<br>$$</p>\n<p>其中 $\\theta$ 为需要求解的分布的参数，$X$ 为每条样本。</p>\n<p>统计中需要根据观测数据 $D= \\{ X_i \\}^N_{i = 1}$ 估计分布的参数 $\\theta$，一种常用的参数估计即为 <strong>极大似然估计</strong>，即，使得 log 似然函数 $l(f)$ 最大时的 $\\theta$ 作为估计值：</p>\n<p>$$<br>\\hat{\\theta} = \\arg_{\\theta} \\max l(\\theta)<br>$$</p>\n<h3 id=\"1-2-L1-损失与极大似然估计\"><a href=\"#1-2-L1-损失与极大似然估计\" class=\"headerlink\" title=\"1.2 L1 损失与极大似然估计\"></a>1.2 L1 损失与极大似然估计</h3><p>L1 损失最小也等价于极大似然估计，此时噪声模型为 Laplace 分布：</p>\n<p>$$<br>\\varepsilon \\sim Laplace(\\mu, b) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|x - \\mu|} {b} \\right)<br>$$</p>\n<hr>\n<h2 id=\"2-正则项的概率解释\"><a href=\"#2-正则项的概率解释\" class=\"headerlink\" title=\"2. 正则项的概率解释\"></a>2. 正则项的概率解释</h2><h3 id=\"2-1-L2正则与正态分布先验\"><a href=\"#2-1-L2正则与正态分布先验\" class=\"headerlink\" title=\"2.1 L2正则与正态分布先验\"></a>2.1 L2正则与正态分布先验</h3><p>在损失函数的概率解释中已经推出：假设数据产生模型为</p>\n<p>$<br>y = f(X) + \\varepsilon, \\quad \\varepsilon \\sim N(0, \\sigma^2)<br>$</p>\n<p>则 $y | X \\sim N(f(X; W), \\sigma^2)$，即</p>\n<p>$<br>p(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y - f(X; W))^2} {2 \\sigma^2} \\right)<br>$</p>\n<p><strong>似然函数为：</strong></p>\n<p>$$<br>似然 \\quad likelihood(f) = p(D | W) = \\prod^N_{i = 1} p(y_i | x_i) = \\prod^N_{i = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x_i; W))^2} {2 \\sigma^2} \\right)<br>$$</p>\n<p>为了模型不太复杂，增加一个参数的先验：$w_j$ 的值不能太大，也即 $w_j$ 取 0 附近的值概率更高，假设 $W$ 为独立同分布，此时可用正态分布来表示 $w_j$ 的取值分布：$w_j \\sim N(0, \\tau^2)$</p>\n<p><img data-src=\"./w_distribution.png\" alt=\"W 取值分布\" title=\"@ASSET\"></p>\n<p>则对每一个 $w_j$，其概率密度函数为：</p>\n<p>$<br>p(w_j) = \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)<br>$</p>\n<p>因此对 $W$，其联合概率密度函数即为 <strong>先验</strong>：</p>\n<p>$$<br>先验 \\quad p(W) = \\prod^D_{j = 1} p(w_j) = \\prod^D_{j = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)<br>$$</p>\n<p>根据 <a href=\"https://baike.baidu.com/item/贝叶斯公式\" title=\"@LINK\">贝叶斯公式</a>，参数的 <strong>后验分布</strong> 正比于 <strong>先验 x 似然</strong>：</p>\n<p>$$<br>后验 \\quad p(W | D) \\propto p(W) p(D | W)<br>$$</p>\n<p>去掉正比系数（不影响极值点位置）并两边同取 log 运算可得：</p>\n<p>$<br>\\begin{aligned}<br>&amp; \\log p(W | D) = \\log p(W) + \\log p(D | W)<br>\\\\<br>&amp;= - \\dfrac {D} {2} \\log (2 \\pi) - D \\log \\tau - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2}<br>\\end{aligned}<br>$</p>\n<p>贝叶斯最大后验估计（Maximun A Posteriori estimation, MAP）为</p>\n<p>$<br>\\hat{W} = \\arg_W \\max \\log p(W | D)<br>$</p>\n<p>将上述 $\\log p(W | D)$ 代入并去掉与 $W$ 无关的常数项（不影响极值点位置）后得：</p>\n<p>$<br>\\begin{aligned}<br>\\hat{W} &amp;= \\arg_W \\max \\log p(W | D)<br>\\\\<br>&amp;= \\arg_W \\max \\left( - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)<br>\\\\<br>&amp;= \\arg_W \\min \\left( \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} + \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)<br>\\\\<br>乘以 2 \\sigma^2 &amp;= \\arg_W \\min \\left( \\dfrac {\\sigma^2} {\\tau^2} \\sum^D_{j = 1} w^2_j + \\sum^N_{i = 1} (y_i - f(x_i; w))^2 \\right)<br>\\end{aligned}<br>$</p>\n<p>上式令 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 得：</p>\n<p>$$<br>\\hat{W} = \\arg_W \\min \\left( \\sum^N_{i = 1} (y_i - f(x_i; w))^2 + \\lambda \\sum^D_{j = 1} w^2_j \\right)<br>$$</p>\n<p><strong>等价于岭回归的目标参数</strong>，因此有结论：</p>\n<p><strong>L2 正则等价于正态分布先验 $N(0, \\tau^2)$。</strong></p>\n<p>由于 $\\sigma^2$ 控制了噪声分布，而 $\\tau^2$ 控制了先验，因此 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 实际上控制了先验的强度（$w_j$ 靠近 0 的程度）。</p>\n<h2 id=\"2-2-L1正则与Laplace分布先验\"><a href=\"#2-2-L1正则与Laplace分布先验\" class=\"headerlink\" title=\"2.2 L1正则与Laplace分布先验\"></a>2.2 L1正则与Laplace分布先验</h2><p>L1 正则等价于 Laplace 先验，此时先验分布为 Laplace 分布：</p>\n<p>$$<br>p(w_j) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|w_j|} {b} \\right)<br>$$</p>\n<p><img data-src=\"./laplace_distribution.png\" alt=\"Laplace 分布\" title=\"@ASSET\"></p>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-线性回归三种求解","url":"/post/machinelearning/ml-linear/ml-linear-solutions/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-线性回归三种求解\"><a href=\"#ML入门-线性回归三种求解\" class=\"headerlink\" title=\"ML入门-线性回归三种求解\"></a>ML入门-线性回归三种求解</h1><h2 id=\"1-解析法\"><a href=\"#1-解析法\" class=\"headerlink\" title=\"1. 解析法\"></a>1. 解析法</h2><p>在给定正则参数（超参数）λ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W)$，满足最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W)} {\\partial W} = 0$。</p>\n<h3 id=\"1-1-OLS最优解析解\"><a href=\"#1-1-OLS最优解析解\" class=\"headerlink\" title=\"1.1 OLS最优解析解\"></a>1.1 OLS最优解析解</h3><h4 id=\"1-1-1-正规方程组\"><a href=\"#1-1-1-正规方程组\" class=\"headerlink\" title=\"1.1.1 正规方程组\"></a>1.1.1 正规方程组</h4><p>对 OLS 目标函数矩阵形式展开：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= ||y - X W||^2_2 = (y - X W)^T (y - X W)<br>\\\\<br>&amp;= y^T y - y^T X W - W^T X^T y + W^T X^T X W<br>\\end{aligned}<br>$$</p>\n<p>根据矩阵的转置运算有：$A^T B = B^T A$，也即 $y^T X W = W^T X^T y$，因此上式等价于：</p>\n<p>$$<br>J(W) = y^T y - 2 W^T X^T y + W^T X^T X W<br>$$</p>\n<p>因此满足 OLS 最优解即：</p>\n<p>$$<br>\\begin{aligned}<br>&amp;\\dfrac {\\partial J(W)} {\\partial W} = 0<br>\\\\<br>\\Longrightarrow \\quad &amp;\\dfrac { \\partial (y^T y - 2 W^T X^T y + W^T X^T X W)} { \\partial W } = 0 \\quad（0 矩阵）<br>\\end{aligned}<br>$$</p>\n<p>根据矩阵的微分运算有：</p>\n<p>$<br>\\begin{aligned}<br>&amp;① \\quad \\dfrac {\\partial (A^T B)} {\\partial A} = B<br>\\\\<br>&amp;② \\quad \\dfrac {\\partial (A^T B A)} {\\partial A} = (B^T + B) A<br>\\end{aligned}<br>$</p>\n<p>进而得到下式：</p>\n<p>$$<br>0 - 2 X^T y + [ (X^T X)^T + (X^T X) ] W = 0<br>$$</p>\n<p>根据矩阵的运算法则有：</p>\n<p>$<br>\\begin{aligned}<br>\\because \\quad &amp;X^T X = (X)^T (X^T)^T = (X^T X)^T<br>\\\\<br>\\therefore \\quad &amp;X^T X 为对称矩阵<br>\\\\<br>\\Longrightarrow \\quad &amp;X^T X = (X^TX)^T<br>\\end{aligned}<br>$</p>\n<p>进一步合并得：</p>\n<p>$$<br>\\begin{aligned}<br>&amp;-2 X^T y + 2 X^T X W = 0<br>\\\\<br>&amp;\\Longrightarrow X^T X W = X^T y \\quad （正规方程组）<br>\\\\<br>&amp;\\Longrightarrow \\hat{W}_{OLS} = (X^T X)^{-1} X^T y<br>\\end{aligned}<br>$$</p>\n<p>这种求解方式也称为用正规方程组解析求解最小二乘线性回归。但在解析 $ \\hat{W}_{OLS} $ 的过程中涉及到了逆矩阵的计算，应当避免。</p>\n<h3 id=\"1-1-2-Moore-Penrose广义逆\"><a href=\"#1-1-2-Moore-Penrose广义逆\" class=\"headerlink\" title=\"1.1.2 Moore-Penrose广义逆\"></a>1.1.2 Moore-Penrose广义逆</h3><p>通常，训练的目标是 OLS 目标函数 $J(W) = ||y - XW||^2_2$ 最小，通俗来讲也即 $y$ 与 $X W$ 越接近越好，最好的情况即求解：$y = X W$。</p>\n<p>（1）假如 $X$ 为方阵，则可以求其逆：$W = X^{-1} y$，</p>\n<p>（2）假如 $X$ 不为方阵，则求其逆矩阵无意义，可求 Moore-Penrose 广义逆：$W = X^+ y$</p>\n<blockquote>\n<p>广义逆的符号为：</p>\n<p><img data-src=\"./pseudoinverse.png\" alt=\"广义逆符号\" title=\"@ASSET\"> </p>\n<p>LaTeX 代码为 <code>X^&#123;\\dag&#125;</code>，但 Hexo 不支持引入宏包无法显示，因此使用 $X^+$ 代替。</p>\n</blockquote>\n<p>Moore-Penrose 广义逆可采用奇异值分解（Singular Value Decomposition, SVD）实现：</p>\n<p>$<br>\\begin{aligned}<br>&amp;若有：X = U \\Sigma V^T,<br>\\\\<br>&amp;其中 U, V 为正交阵，\\Sigma 为对角阵（不一定为方阵）<br>\\\\<br>&amp;则：X^+ = V \\Sigma^+ V^T<br>\\end{aligned}<br>$</p>\n<p>对角阵 $\\Sigma$ 求伪逆，则将非零元素求倒数即可：</p>\n<p>$$<br>\\Sigma = \\left(<br>\\begin{matrix}<br> \\lambda_1 &amp; 0         &amp; \\cdots &amp; 0<br> \\\\<br> 0         &amp; \\lambda_2 &amp; \\cdots &amp; 0<br> \\\\<br> \\vdots    &amp; \\vdots    &amp; \\ddots &amp; \\vdots<br> \\\\<br> 0         &amp; 0         &amp; \\cdots &amp; 0<br> \\\\<br>\\end{matrix}<br>\\right),<br>\\Sigma^+ = \\left(<br>\\begin{matrix}<br> \\dfrac 1 \\lambda_1 &amp; 0                  &amp; \\cdots &amp; 0<br> \\\\<br> 0                  &amp; \\dfrac 1 \\lambda_2 &amp; \\cdots &amp; 0<br> \\\\<br> \\vdots             &amp; \\vdots             &amp; \\ddots &amp; \\vdots<br> \\\\<br> 0                  &amp; 0                  &amp; \\cdots &amp; 0<br> \\\\<br>\\end{matrix}<br>\\right),<br>$$</p>\n<p>这也是 Scikit-Learn 中 LinearRegression 推荐的求解方式。</p>\n<h3 id=\"1-2-Ridge最优解析解\"><a href=\"#1-2-Ridge最优解析解\" class=\"headerlink\" title=\"1.2 Ridge最优解析解\"></a>1.2 Ridge最优解析解</h3><p>Ridge 比 OLS 多一个 L2 正则，目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\\\<br>&amp;= (y - X W)^T (y - X W) + \\lambda W^T W<br>\\end{aligned}<br>$$</p>\n<p>其最优解也采用 SVD 分解的方式实现。求解偏导数等于零：</p>\n<p>$$<br>\\begin{aligned}<br>\\dfrac {\\partial J(W)} {\\partial W} &amp;= -2 X^T y + 2 (X^T X) W + 2 \\lambda W = 0<br>\\\\<br>\\Longrightarrow \\hat{W}_{Ridge} &amp;= (X^T X + \\lambda I)^{-1} X^T y<br>\\\\<br>&amp;（其中 I 为 D \\times D 的单位阵）<br>\\end{aligned}<br>$$</p>\n<p>对比 OLS 的解：</p>\n<p>$$<br>\\hat{W}_{OLS} = (X^T X)^{-1} X^T y<br>$$</p>\n<p>对 Ridge 的解进行变形，配出一个 $\\hat{W}_{OLS}$：</p>\n<p>$$<br>\\begin{aligned}<br>\\hat{W}_{Ridge} &amp;= (X^T X + \\lambda I)^{-1} X^T y<br>\\\\<br>&amp;= (X^T X + \\lambda I)^{-1} (X^T X) (X^T X)^{-1} X^T y<br>\\\\<br>&amp;= (X^T X + \\lambda I)^{-1} (X^T X) \\hat{W}_{OLS}<br>\\end{aligned}<br>$$</p>\n<p>将 $(X^T X + \\lambda I)^{-1}$ 看成是分母，将 $(X^T X)$ 看成分子，由于 $(X^T X + \\lambda I) &gt; (X^T X)$，因此有 $\\hat{W}_{Ridge} &lt; \\hat{W}_{OLS}$。</p>\n<p>因此 $\\hat{W}_{Ridge} $ 在 $ \\hat{W}_{OLS}$ 的基础上进行了收缩，L2 正则也称为权重收缩。</p>\n<h3 id=\"1-3-总结\"><a href=\"#1-3-总结\" class=\"headerlink\" title=\"1.3 总结\"></a>1.3 总结</h3><p>（1）OLS 的解为：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，需要对矩阵 $X^T X$ 求逆。</p>\n<ul>\n<li>当输入特征存在共线性（某些特征可以用其他特征的线性组合表示），矩阵 X 是接近不满秩，矩阵 $X^T X$ 接近奇异，求逆不稳定。</li>\n</ul>\n<p>（2）Ridge 的解为：$\\hat{W}_{Ridge} = (X^T X + \\lambda I)^{-1} X^T y$，需要对矩阵 $(X^T X + \\lambda I)$ 求逆。</p>\n<ul>\n<li>即使输入特征存在共线性，矩阵 $X$ 不满秩，矩阵 $X^T X$ 对角线存在等于 0 或接近于 0 的元素，但 $0 + \\lambda \\ne 0$，$(X^T X + \\lambda I)$ 求逆仍可得到稳定解。因此岭回归 Ridge 在输入特征存在共线性的情况仍然能得到稳定解。</li>\n</ul>\n<p>（3）Lasso 无法无法求得解析解，可以用迭代求解。</p>\n<hr>\n<h2 id=\"2-梯度下降法\"><a href=\"#2-梯度下降法\" class=\"headerlink\" title=\"2. 梯度下降法\"></a>2. 梯度下降法</h2><h3 id=\"2-1-梯度下降法思想\"><a href=\"#2-1-梯度下降法思想\" class=\"headerlink\" title=\"2.1 梯度下降法思想\"></a>2.1 梯度下降法思想</h3><p>解析求解法对 N x D 维矩阵 X 进行 SVD 分解的复杂度为：$O(N^2 D)$。</p>\n<ul>\n<li>当样本数 N 很大或特征维度 D 很大时，SVD 计算复杂度高，或机器的内存根本不够。</li>\n<li>可采用迭代求解的方法：梯度下降法、随机梯度下降法、次梯度法、坐标轴下降法等。</li>\n<li>梯度下降法（Gradient Descent）是求解无约束优化问题最常采用的方法之一。</li>\n</ul>\n<p>在微积分中，一元函数 $f(x)$ 在 $x$ 处的梯度为函数在该点的导数 $\\dfrac {df} {dx}$。</p>\n<p>对应在多元函数 $f(x_1, ..., x_D)$ 中，在点 $x = (x_1, ..., x_D)$ 处共有 D 个偏导数：$\\dfrac {\\partial f} {\\partial x_1}, ..., \\dfrac {\\partial f} {\\partial x_D}$。将这 D 个偏导数组合成一个 D 维的矢量 $(\\dfrac {\\partial f} {\\partial x_1}, ..., \\dfrac {\\partial f} {\\partial x_D})^T$，即称为函数 $f(x_1, ..., x_D)$ 在点 $x$ 处的梯度，一般记为 $\\nabla$ 或 $grad$，即：</p>\n<p>$$<br>\\nabla f(x_1, ..., x_D) = grad \\ f(x_1, ..., x_D) = (\\dfrac {\\partial f} {\\partial x_1}, ..., \\dfrac {\\partial f} {\\partial x_D})^T<br>$$</p>\n<p>（1）从几何意义上讲，某点的梯度是函数在该点变化最快的地方。</p>\n<p>（2）沿着梯度方向，函数增加最快，更容易找到函数的最大值</p>\n<p>（3）沿负梯度方向，函数减少最快，更容易找到函数的最小值。</p>\n<blockquote>\n<p>$\\nabla$ 发音为 nabla，表示微分，不属于希腊字符，只是一个记号。</p>\n</blockquote>\n<p>正负梯度的例子如下：</p>\n<p><img data-src=\"./gradient_demo.png\" alt=\"梯度示意图\" title=\"@ASSET\"></p>\n<p>在计算 $f(x)$ 的最小值时，当函数形式比较简单且数据量小，可用解析计算 $ f&#39;(x) = 0 $，否则可用迭代法求解：</p>\n<p>（1）从 t = 0 开始，随机寻找一个值 $x^{t = 0}$ 为初始值；</p>\n<p>（2）找到下一个点 $x^{t + 1}$，使得函数值越来越小，即 $f(x^{t + 1}) &lt; f(x^t)$；</p>\n<p>（3）重复，直到函数值不再见小，则已经找到函数的 <strong>局部极小值</strong>。</p>\n<blockquote>\n<p>该方法仅能找到局部极小值。</p>\n</blockquote>\n<p>为此，可以对该迭代方案进行改进：</p>\n<ul>\n<li>随机寻找初始值时，初始化多个点；</li>\n<li>最后从多个局部极小值中取最小的作为最终的极小值。</li>\n</ul>\n<h3 id=\"2-2-梯度下降法数学解释\"><a href=\"#2-2-梯度下降法数学解释\" class=\"headerlink\" title=\"2.2 梯度下降法数学解释\"></a>2.2 梯度下降法数学解释</h3><p>对函数 $f(x)$ 进行一节泰勒展开得到：</p>\n<p>$$<br>f(x + \\Delta x) \\approx f(x) + \\Delta x \\nabla f(x)<br>$$</p>\n<p>要找到函数的最小值，也即每一次步进 $\\Delta x$ 后的函数值均小于原函数值，因此有：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; f(x + \\Delta x) &lt; f(x)<br>\\\\<br>\\Longrightarrow &amp; \\Delta x \\nabla f(x) &lt; 0<br>\\end{aligned}<br>$$</p>\n<p>假设令 $\\Delta x = - \\eta \\nabla f(x), \\ \\ (\\eta &gt; 0)$，其中步长 $\\eta$ 为一个较小的正数，从而有：</p>\n<p>$$<br>\\Delta x \\nabla f(x) = - \\eta \\left( \\nabla f(x) \\right)^2 &lt; 0<br>$$</p>\n<p>令 $\\Delta x = - \\eta \\nabla f(x)$ 即可确保 $\\left( \\nabla f(x) \\right)^2 &gt; 0$。</p>\n<p>因此，对 $x$ 的更新为：$x^{t + 1} = x + \\Delta x = x^t - \\eta \\nabla f(x)$，也即 $x$ 向负梯度方向 $- \\eta \\nabla f(x)$ 移动步长 $\\eta$，会使得$f(x^{t + 1}) &lt; f(x^t)$，$\\eta$ 也称为学习率。</p>\n<p>由于只对 $f(x)$ 进行一阶泰勒展开，因此梯度下降法是一阶最优化算法。</p>\n<h3 id=\"2-3-OLS的梯度下降\"><a href=\"#2-3-OLS的梯度下降\" class=\"headerlink\" title=\"2.3 OLS的梯度下降\"></a>2.3 OLS的梯度下降</h3><p>OLS 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2<br>\\\\<br>&amp;= ||y - X W||^2_2<br>\\\\<br>&amp;= (y - X W)^T (y - X W)<br>\\end{aligned}<br>$$</p>\n<p>其梯度为：</p>\n<p>$$<br>\\nabla J(W) = -2 X^T y + 2 X^T X W = -2 X^T (y - X W)<br>$$</p>\n<p>梯度下降：</p>\n<p>$$<br>\\begin{aligned}<br>W^{t + 1} &amp;= W^t - \\eta \\nabla J(W^t)<br>\\\\<br>&amp;= W^t + 2 \\eta X^T (y - X W^T)<br>\\end{aligned}<br>$$</p>\n<p>其中 $(y - X W^T)$ 即为预测残差 r，说明参数的更新量与输入 X 和预测残差 r 的相关性有关。$X^T$ 与 r 的相关性较强时需要把 $\\eta$ 调大一些，则 r 逐渐与输入 $X^T$ 无关，直到无需再更新 W。</p>\n<p>OLS 的梯度下降过程：</p>\n<p>（1）从 t = 0 开始，随机寻找一个值 $W^{t = 0}$ 为初始值（或 0）；</p>\n<p>（2）计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$；</p>\n<p>（3）根据学习率 $\\eta$，更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$；</p>\n<p>（4）判断是否满足迭代终止条件。若满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t + 1})$，否则跳转至第 2 步。</p>\n<p>迭代终止条件有：</p>\n<p>（1）迭代次数达到预设的最大次数。</p>\n<p>（2）迭代过程中目标函数的变化值小于预设值：$\\dfrac{J(W^t) - J(W^{t + 1})}{J(W^t)} \\le \\varepsilon$。</p>\n<h3 id=\"2-4-Ridge的梯度下降\"><a href=\"#2-4-Ridge的梯度下降\" class=\"headerlink\" title=\"2.4 Ridge的梯度下降\"></a>2.4 Ridge的梯度下降</h3><p>Ridge 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j<br>\\\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||^2_2<br>\\end{aligned}<br>$$</p>\n<p>其梯度为：</p>\n<p>$$<br>\\nabla J(W) = -2 X^T y + 2 X^T X W + 2 \\lambda W<br>$$</p>\n<p>Ridge 的梯度下降过程与 OLS 的相同。</p>\n<h3 id=\"2-5-Lasso次梯度法\"><a href=\"#2-5-Lasso次梯度法\" class=\"headerlink\" title=\"2.5 Lasso次梯度法\"></a>2.5 Lasso次梯度法</h3><p>Lasso 的目标函数为：</p>\n<p>$$<br>\\begin{aligned}<br>J(W) &amp;= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |W_j|<br>\\\\<br>&amp;= ||y - X W||^2_2 + \\lambda ||W||_1<br>\\end{aligned}<br>$$</p>\n<p>绝对值函数 &amp;||W||_1&amp; 在原点 $W = 0$ 处不可导，无法使用梯度下降求解。</p>\n<p>（1）可用次梯度概念替换梯度，得到次梯度法。</p>\n<p>（2）或用坐标轴下降求解。</p>\n<h3 id=\"2-6-梯度下降的实用Tips\"><a href=\"#2-6-梯度下降的实用Tips\" class=\"headerlink\" title=\"2.6 梯度下降的实用Tips\"></a>2.6 梯度下降的实用Tips</h3><p>（1）梯度下降中的学习率 η 需要小心设置。太大可能引起目标函数震荡，太小收敛速度过慢，可以采用自适应学习率的方案：</p>\n<p><img data-src=\"./different_eta.png\" alt=\"不同 η 的影响\" title=\"@ASSET\"></p>\n<p>（2）梯度下降对特征的取值范围敏感，建议对输入特征 X 做去量纲处理（可用 sklearn.preprocessing.StandardScaler 实现）：</p>\n<p>$$<br>W^{t + 1} = W^t + 2 \\eta X^T (y - X W^t) \\ \\ \\ \\ （与输入 X 的取值有关）<br>$$</p>\n<p>梯度下降算法延伸阅读：<a href=\"https://www.analyticsvidhya.com/blog/2017/03/introduction-to-gradient-descent-algorithm-along-its-variants/\" title=\"@LINK\">Introduction to Gradient Descent Algorithm (along with variants) in Machine Learning</a></p>\n<h3 id=\"2-7-随机梯度下降\"><a href=\"#2-7-随机梯度下降\" class=\"headerlink\" title=\"2.7 随机梯度下降\"></a>2.7 随机梯度下降</h3><p>在机器学习模型中，目标函数形式为：</p>\n<p>$$<br>J(W) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)<br>$$</p>\n<p>梯度形式为：</p>\n<p>$$<br>\\nabla J(W^t) = \\sum^N_{i = 1} \\nabla L \\left( y_i, f(X_i; W^t) \\right) + \\lambda \\nabla R(W^t)<br>$$</p>\n<p>当样本中存在信息冗余（正负抵消或梯度相似）时效率不高，因此可以使用随机梯度下降，即每次梯度下降更新时只计算一个样本上的梯度：</p>\n<p>$$<br>\\nabla J(W^t) = \\nabla L \\left( y_t, f(X_t; W^t) \\right) + \\lambda \\nabla R(W^t)<br>$$</p>\n<p>通俗而言，每一次迭代时，随机选择一个样本，向该样本的负梯度方向移动一步。梯度下降法每一次迭代都需要计算所有样本的梯度，随机梯度下降每一次迭代仅需计算单个样本的梯度：</p>\n<p>（1）为了确保收敛，相比于同等条件下的梯度下降，随机梯度下降需要采用更小的步长和更多的迭代轮数。</p>\n<p>（2）相比于非随机算法，随机梯度下降在前期的迭代效果卓越。</p>\n<p>小批量梯度下降法：介于一次使用所有样本（批处理梯度下降）和一次只是用一个样本（随机梯度下降）之间，也即在随机梯度下降中，每次使用一个小批量的样本代替单个样本。实践中常采用小批量样本（mini-batch）下降。</p>\n<blockquote>\n<p>随机梯度下降参考文章：</p>\n<p>① &quot;Stochastic Gradient Descent&quot; L. Bottou - Website, 2010<br>② &quot;The Tradeoffs of Large Scale Machine Learning&quot; L. Bottou - Website, 2011</p>\n</blockquote>\n<h2 id=\"2-8-Ridge和SGDRegressor\"><a href=\"#2-8-Ridge和SGDRegressor\" class=\"headerlink\" title=\"2.8 Ridge和SGDRegressor\"></a>2.8 Ridge和SGDRegressor</h2><h3 id=\"2-8-1-Ridge\"><a href=\"#2-8-1-Ridge\" class=\"headerlink\" title=\"2.8.1 Ridge\"></a>2.8.1 Ridge</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Ridge</span></span><br><span class=\"line\">Ridge(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.001</span>,</span><br><span class=\"line\">      solver=’auto’,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p>（1）其中与优化计算有关的参数如下：</p>\n<ul>\n<li><p><code>max_iter</code>: 共轭梯度求解器的最大迭代次数。</p>\n<p>对于优化算法 solver 为 &#39;sparse_cg&#39; 和 &#39;lsqr&#39;，则默认值由 <code>scipy.sparse.linalg</code> 确定，对于 &#39;sag&#39; 求解器，默认值为 1000。</p>\n</li>\n<li><p><code>tol</code>: 解的精度，判断迭代收敛与否的阈值。</p>\n<p>当（loss &gt; previous_loss - tol）时迭代终止。</p>\n</li>\n<li><p><code>solver</code>: 求解最优化问题的算法。</p>\n<p>可取：&#39;auto&#39;，&#39;svd&#39;，&#39;cholesky&#39;，&#39;lsqr&#39;，&#39;sparse_cg&#39;，&#39;sag&#39;，&#39;saga&#39;。</p>\n</li>\n<li><p><code>random_state</code>: 数据洗牌时的随机种子。</p>\n<p>仅用于 &#39;sag&#39; 求解器。</p>\n</li>\n</ul>\n<p>（2）其中求解器 <code>solver</code> 可选的算法如下：</p>\n<ul>\n<li><p><code>auto</code>: 根据数据类型自动选择求解器。</p>\n<p>默认算法。</p>\n</li>\n<li><p><code>svd</code>: 使用 X 的奇异值分解来计算 Ridge 系数。</p>\n<p>对于奇异矩阵，比 &#39;cholesky&#39; 更稳定。</p>\n</li>\n<li><p><code>cholesky</code>: 使用标准的 <code>scipy.linalg.solve</code> 函数获得解析解。</p>\n</li>\n<li><p><code>sparse_cg</code>: 使用 <code>scipy.sparse.linalg.cg</code> 中的共轭梯度求解器。</p>\n<p>对大规模数据，比“cholesky”更合适。</p>\n</li>\n<li><p><code>lsqr</code>: 使用专用的正则化最小二乘常数 <code>scipy.sparse.linalg.lsqr</code>。</p>\n<p>速度最快。</p>\n</li>\n<li><p><code>sag</code>: 使用随机平均梯度下降。</p>\n<p>当样本数 n_samples 和特征维数 n_feature 都很大时，通常比其他求解器更快。</p>\n</li>\n<li><p><code>saga</code>: &#39;sag&#39; 的改进算法。</p>\n<p>当 <code>fit_intercept</code> 为 <code>True</code> 时，&#39;sag’ 和 &#39;saga&#39; 只支持稀疏输入。&#39;sag&#39; 和 &#39;saga&#39; 快速收敛仅在具有近似相同尺度的特征上被保证，因此数据需要标准化。</p>\n</li>\n</ul>\n<h4 id=\"2-8-2-SGDRegressor\"><a href=\"#2-8-2-SGDRegressor\" class=\"headerlink\" title=\"2.8.2 SGDRegressor\"></a>2.8.2 SGDRegressor</h4><p>Scikit-Learn 中实现了随机梯度下降回归：SGDRegressor，其对大数据量训练集（n_sample &gt; 10000）的回归问题合适。</p>\n<p>SGDRegressor 的目标函数为：</p>\n<p>$$<br>J(W) = \\dfrac {1} {N} \\sum^N_{i = 1} L \\left( y_i, f(X_i) \\right) + \\alpha R(W)<br>$$</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.SGDRegressor</span></span><br><span class=\"line\">SGDRegressor(loss=<span class=\"string\">&#x27;squared_loss&#x27;</span>,</span><br><span class=\"line\">             penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">             alpha=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">             l1_ratio=<span class=\"number\">0.15</span>,</span><br><span class=\"line\">             fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             tol=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             shuffle=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">             epsilon=<span class=\"number\">0.1</span>,</span><br><span class=\"line\">             random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             learning_rate=<span class=\"string\">&#x27;invscaling&#x27;</span>,</span><br><span class=\"line\">             eta0=<span class=\"number\">0.01</span>,</span><br><span class=\"line\">             power_t=<span class=\"number\">0.25</span>,</span><br><span class=\"line\">             warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             average=<span class=\"literal\">False</span>,</span><br><span class=\"line\">             n_iter=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<p>（1）参数 <code>loss</code> 支持的损失函数包括：</p>\n<ul>\n<li><code>squared_loss</code>: L2 损失。</li>\n<li><code>huber</code>: Huber 损失。</li>\n<li><code>epsilon_insensitive</code>: ɛ 不敏感损失 (如：SVM)</li>\n<li><code>squared_epsilon_insensitive</code></li>\n</ul>\n<p>（2）参数 <code>penalty</code> 支持的正则函数包括：</p>\n<ul>\n<li><code>none</code>: 无正则</li>\n<li><code>l2</code>: L2正则</li>\n<li><code>l1</code>: L1正则</li>\n<li><code>elasticnet</code>: L1 正则 + L2 正则（配合参数 <code>l1_ratio</code> 为 L1 正则的比例）</li>\n</ul>\n<p>（3）参数 <code>epsilon</code> 是某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）需要的额外参数。</p>\n<p>（4）参数 <code>alpha</code> 是正则惩罚系数，也用于学习率计算。</p>\n<p>（5）优化算法有关的参数包括：</p>\n<ul>\n<li><p><code>max_iter</code>: 最大迭代次数（访问训练数据的次数，Epoches 的次数），默认值 5。</p>\n<p>一个迭代循环只使用一个随机样本的梯度，并且循环所有的样本，则称为一个 Epoches。SGD 在接近 $10^6$ 的训练样本时收敛。因此可将迭代数设置为 np.ceil($10^6$ / 𝑁)，其中 𝑁 是训练集的样本数目。参数 <code>n_iter</code> 意义相同，已被抛弃。</p>\n</li>\n<li><p><code>tol</code>: 停止条件。</p>\n<p>如果不为 &#39;None&#39;，则当（loss &gt; previous_loss - tol）时迭代终止。</p>\n</li>\n<li><p><code>shuffle</code>: 每轮 SGD 之前是否重新对数据进行洗牌。</p>\n</li>\n<li><p><code>random_state</code>: 随机种子，Scikit-Learn 中与随机有关的算法均有此参数，含义相同。</p>\n<p>当参数 <code>shuffle == True</code> 时使用。如果随机种子相同，每次洗牌得到的结果一样。可设置为某个整数以复现结果。</p>\n</li>\n<li><p><code>learning_rate</code>: 学习率。</p>\n<p>支持 3 种选择：</p>\n<ol>\n<li>&#39;constant&#39;：$\\eta = \\eta_0$。</li>\n<li>&#39;optimal&#39;：$\\eta = 1.0 / \\alpha * (t + t_0)$，分类任务中随机梯度下降默认值。</li>\n<li>&#39;invscaling&#39;：$\\eta = \\eta_0 / pow(t, \\ power_t)$，回归任务重随机梯度下降默认值。</li>\n</ol>\n</li>\n<li><p><code>warm_start</code>: 是否从之前的结果继续。</p>\n<p>随机梯度下降中初始值可以是之前的训练结果，支持在线学习，即可以在原来的学习基础上继续学习新加入的样本并更新模型参数（输出）。初始值可在 <code>fit</code> 函数中作为参数传递。</p>\n</li>\n<li><p><code>average</code>: 是否采用平均随机梯度下降法（ASGD）。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-次梯度法\"><a href=\"#3-次梯度法\" class=\"headerlink\" title=\"3. 次梯度法\"></a>3. 次梯度法</h2><h3 id=\"3-1-什么是次梯度法\"><a href=\"#3-1-什么是次梯度法\" class=\"headerlink\" title=\"3.1 什么是次梯度法\"></a>3.1 什么是次梯度法</h3><p>当函数可导时，梯度下降法是非常有效的优化算法。但 Lasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$，其中正则项 $||W||_1$ 为绝对值函数，在 $W_j = 0$ 处不可导，无法计算梯度，也无法用梯度下降法求解。因此需要将梯度扩展为次梯度，用次梯度法求解该问题。</p>\n<p>为了处理不平滑函数，扩展导数的表示。定义一个凸函数 $f$ 在点 $x_0$ 处的 <strong>次导数</strong> 为一个标量 g，使得：</p>\n<p>$<br>f(x) - f(x_0) \\ge g(x - x_0), \\forall x \\in \\mathrm{I}<br>$</p>\n<p>其中 $\\mathrm{I}$ 为包含 $x_0$ 的某个区间。如下图所示，对于定义域中的任何 $x_0$，总可以做一条直线通过点 $(x_0, f(x_0))$，且直线要么接触 $f$，要么在其下方：</p>\n<p><img data-src=\"./subderivative.png\" alt=\"次导数\" title=\"@ASSET\"></p>\n<p>上式等价于：</p>\n<p>$<br>\\Delta f(x) \\ge g \\Delta x \\Rightarrow g \\le \\dfrac {\\Delta f(x)} {\\Delta x}<br>$</p>\n<p>从该直线方程可知，$g$ 也就是在直线 $y = f(x_0)$ 下方的直线的斜率，所有 $g$ 的解（斜率）都称为函数的次导数（Subderivative），所有次导数（$g$ 的解）的集合称为函数 $f$ 在 $x_0$ 处的次微分（Subdifferential），记为 $\\partial f(x_0)$。</p>\n<p>次微分是次导数的集合，定义该集合为区间 $[a, b]$：</p>\n<p>$$<br>a = \\lim_{x \\rightarrow x^-_0} \\dfrac {f(x) - f(x_0)} {x - x_0}, \\quad b = \\lim_{x \\rightarrow x^+_0} \\dfrac {f(x) - f(x_0)} {x - x_0}<br>$$</p>\n<p>也即 $x_0$ 点的次微分的集合左边界 $a$ 是从点 $x_0$ 的左侧逼近函数值，右边界 $b$ 是从点 $x_0$ 的右侧逼近函数值。<strong>当函数在 $x_0$ 处可导时，该点的次微分只有一个点组成，也就是函数在该点的导数。</strong></p>\n<p>例如求凸函数 $f(x) = |x|$ 的次微分，由于 $f(x)$ 在点 $x = 0$ 处不可导，因此该点的次微分区间左边界为 $f(0^-) = -1$，右边界为 $f(0^+) = 1$：</p>\n<p>$$<br>\\partial f(x) = \\left \\{<br>\\begin{aligned}<br>\\{ -1 \\}, &amp;&amp; {x &lt; 0}<br>\\\\<br>[-1, +1], &amp;&amp; {x = 0}<br>\\\\<br>\\{ +1 \\}, &amp;&amp; {x &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>若求解多维点的次微分，则分别求解每个分量的次微分并组成向量，即作为函数在该点的次梯度。</p>\n<h3 id=\"3-2-梯度法与次梯度法的区别\"><a href=\"#3-2-梯度法与次梯度法的区别\" class=\"headerlink\" title=\"3.2 梯度法与次梯度法的区别\"></a>3.2 梯度法与次梯度法的区别</h3><p>对可导函数，最优解的条件为 $f(x) = 0$，对此类仅局部可导，需要使用次微分的函数，最优解的条件为：</p>\n<p>$<br>0 \\in \\partial f(x^<em>) \\Longleftrightarrow f(x^</em>) = \\min_x f(x)<br>$</p>\n<p>当且仅当 0 属于函数 $f$ 在点 $x^<em>$ 处次梯度集合时，$x^</em>$ 为极值点。当然，因为函数在可导的点的次微分等于其导数，因此该条件可扩展到全局可导函数。</p>\n<blockquote>\n<p>Python 可用 <code>numpy.sign</code> 函数实现绝对值函数的次梯度。</p>\n</blockquote>\n<p>将梯度下降法中的梯度换成次梯度就得到次梯度法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">梯度下降法</th>\n<th align=\"left\">次梯度法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1. 从 $t = 0$ 开始，初始化 $w^0$</td>\n<td align=\"left\">1. 从 $t = 0$ 开始，初始化 $w^0$</td>\n</tr>\n<tr>\n<td align=\"left\">2. 计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$</td>\n<td align=\"left\">2. 计算目标函数 $J(W)$ 在当前值的次梯度：$\\partial J(W^t)$</td>\n</tr>\n<tr>\n<td align=\"left\">3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$</td>\n<td align=\"left\">3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\partial J(W^t)$</td>\n</tr>\n<tr>\n<td align=\"left\">4. 判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步</td>\n<td align=\"left\">判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步</td>\n</tr>\n</tbody></table>\n<p><strong>结论：</strong></p>\n<p>与梯度下降算法不同，次梯度算法并不是下降算法（每次对参数的更新，并不能保证目标函数单调递减）。因此一般情况下会从多个点同时应用次梯度法，最后选择最小值：</p>\n<p>$$<br>f(x^*) = \\min_{1, ..., t} f(x^t)<br>$$</p>\n<p>虽然次梯度法不能保证迭代过程中目标函数保持单调下降，但可以证明，满足一定条件的凸函数，次梯度法可以保证收敛，只是收敛速度比梯度下降法慢。因此 Lasso 通常使用 <strong>坐标轴下降法</strong> 求解。</p>\n<hr>\n<h2 id=\"4-坐标轴下降法求解\"><a href=\"#4-坐标轴下降法求解\" class=\"headerlink\" title=\"4. 坐标轴下降法求解\"></a>4. 坐标轴下降法求解</h2><p>次梯度法收敛速度慢，Lasso 求解推荐使用坐标轴下降法。</p>\n<p>坐标轴下降法即：沿着坐标轴方向搜索。和梯度下降法与随机梯度下降法的概念类似，例如对 D 维样本参数 $W_0, ..., W_D$，坐标轴下降法是每次仅对其中一个 $W_j$ 搜索最优值。循环使用不同的坐标轴（不同维度），一个周期的以为搜索迭代过程相当于一个梯度迭代。</p>\n<p>坐标轴下降发利用当前坐标系统进行搜索，无需计算目标函数的导数，只按照某一坐标方向进行搜索最小值，而梯度下降法验目标函数的负梯度方向搜索，因此梯度方向通常不与任何坐标轴平行。</p>\n<p>坐标轴下降法在系数矩阵上的计算速度非常快。</p>\n<h3 id=\"4-1-Lasso坐标轴下降的数学解释\"><a href=\"#4-1-Lasso坐标轴下降的数学解释\" class=\"headerlink\" title=\"4.1 Lasso坐标轴下降的数学解释\"></a>4.1 Lasso坐标轴下降的数学解释</h3><p>Lasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$。</p>\n<p>将 Lasso 目标函数中的损失和及正则项分别应用坐标轴下降法搜索，每次仅搜索一个维度。定义 $w_{-j}$ 为 $W$ 去掉 $w_j$ 后的剩余 $(D - 1)$ 维向量。</p>\n<p>（1）对 RSS 的第 j 维坐标轴下降（可导，直接计算梯度）：</p>\n<p>$$<br>\\begin{aligned}<br>\\dfrac {\\partial} {\\partial w_j} RSS(W) &amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T X_i)^2<br>\\\\<br>&amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - (W^T_{-j} X_{i, -j} + w_j x_{ij}))^2<br>\\\\<br>&amp;= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_j x_{ij})^2<br>\\\\<br>（复合函数求导） &amp;= -2 \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_i x_{ij}) \\cdot x_{ij}<br>\\\\<br>&amp;= 2 \\sum^N_{i = 1} x^2_{ij} w_j - 2 \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})<br>\\\\ \\\\<br>令：a_j &amp;= 2 \\sum^N_{i = 1} x^2_{ij}, \\quad c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})<br>\\\\ \\\\<br>\\Longrightarrow \\dfrac {\\partial} {\\partial w_j} RSS(W) &amp;= a_j w_j - c_j<br>\\end{aligned}<br>$$</p>\n<p>（2）再对 $R(W)$ 的第 j 维坐标轴下降（计算次梯度）：</p>\n<p>$$<br>\\dfrac {\\partial} {\\partial w_j} R(W) = \\dfrac {\\partial} {\\partial w_j} \\lambda |w_j| =<br>\\left \\{<br>\\begin{aligned}<br>&amp; \\dfrac {\\partial} {\\partial w_j} (- w_j \\lambda) = \\{ - \\lambda \\}, &amp;&amp; {w_j &lt; 0}<br>\\\\<br>&amp; [- \\lambda, + \\lambda], &amp;&amp; {w_j = 0}<br>\\\\<br>&amp; \\dfrac {\\partial} {\\partial w_j} (w_j \\lambda) = \\{ \\lambda \\}, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>（3）合并为对 $J(W, \\lambda)$ 的第 j 维坐标轴下降：</p>\n<p>$$<br>\\begin{aligned}<br>&amp; \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda) = \\dfrac {\\partial} {\\partial w_j} (RSS + R(W))<br>\\\\<br>&amp;= \\left \\{<br>\\begin{aligned}<br>&amp; \\{ a_j w_j - c_j - \\lambda \\}, &amp;&amp; {w_j &lt; 0}<br>\\\\<br>&amp; [a_j w_j - c_j - \\lambda, a_j w_j - c_j + \\lambda] = [- c_j - \\lambda, - c_j + \\lambda], &amp;&amp; {w_j = 0}<br>\\\\<br>&amp; \\{ a_j w_j - c_j + \\lambda \\}, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>\\end{aligned}<br>$$</p>\n<p>（4）最优解需满足：$0 \\in \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$，对于可导部分，则为 $0 = \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$：</p>\n<p>$$<br>\\Longrightarrow \\left \\{<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j - \\lambda, &amp;&amp; {w_j &lt; 0}<br>\\\\<br>&amp; 0 \\in [- c_j - \\lambda, - c_j + \\lambda], &amp;&amp; {w_j = 0}<br>\\\\<br>&amp; 0 = a_j w_j - c_j + \\lambda, &amp;&amp; {w_j &gt; 0}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<p>其中：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 \\in [- c_j - \\lambda, - c_j + \\lambda]<br>\\\\<br>&amp; \\Longrightarrow \\left \\{<br>\\begin{aligned}<br>0 \\ge - c_j - \\lambda<br>\\\\<br>0 \\le - c_j + \\lambda<br>\\end{aligned}<br>\\right.<br>\\\\<br>&amp; \\Longleftrightarrow c_j \\in [- \\lambda, \\lambda]<br>\\end{aligned}<br>$</p>\n<p>由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij} &gt; 0$，</p>\n<p>① 当 $w_j &lt; 0$ 时有：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j - \\lambda<br>\\\\<br>&amp; w_j = \\dfrac {c_j + \\lambda} {a_j} &lt; 0<br>\\\\<br>&amp; \\Longrightarrow c_j &lt; - \\lambda<br>\\end{aligned}<br>$</p>\n<p>② 同理，当 $w_j &gt; 0$ 时有：</p>\n<p>$<br>\\begin{aligned}<br>&amp; 0 = a_j w_j - c_j + \\lambda<br>\\\\<br>&amp; w_j = \\dfrac {c_j - \\lambda} {a_j} &gt; 0<br>\\\\<br>&amp; \\Longrightarrow c_j &gt; \\lambda<br>\\end{aligned}<br>$</p>\n<p>因此可以转换为下式：</p>\n<p>$$<br>\\hat{w_j}(c_j) = \\left \\{<br>\\begin{aligned}<br>&amp; \\dfrac {c_j + \\lambda} {a_j}, &amp;&amp; {c_j &lt; - \\lambda}<br>\\\\<br>&amp; 0, &amp;&amp; {c_j \\in [- \\lambda, \\lambda]}<br>\\\\<br>&amp; \\dfrac {c_j - \\lambda} {a_j}, &amp;&amp; {c_j &gt; \\lambda}<br>\\end{aligned}<br>\\right.<br>$$</p>\n<h3 id=\"4-2-Lasso坐标轴下降步骤\"><a href=\"#4-2-Lasso坐标轴下降步骤\" class=\"headerlink\" title=\"4.2 Lasso坐标轴下降步骤\"></a>4.2 Lasso坐标轴下降步骤</h3><p>由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$ 对于已知的输入 $X$ 是可以预计算的，因此 Lasso 坐标轴下降的步骤如下：</p>\n<p>① 预计算 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$</p>\n<p>② 初始化参数 $W$（全 0 或随机）</p>\n<p>③ 选择变化幅度最大的维度、或随机选择、或轮流选择需要更新的参数 $w_j$</p>\n<p>④ 计算 $c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$</p>\n<p>⑤ 计算 $\\hat{w_j}(c_j) = \\left \\{<br>\\begin{aligned}<br>&amp; \\dfrac {c_j + \\lambda} {a_j}, &amp;&amp; {c_j &lt; - \\lambda}<br>\\\\<br>&amp; 0, &amp;&amp; {c_j \\in [- \\lambda, \\lambda]}<br>\\\\<br>&amp; \\dfrac {c_j - \\lambda} {a_j}, &amp;&amp; {c_j &gt; \\lambda}<br>\\end{aligned}<br>\\right.$</p>\n<p>⑥ 重复第 3 ~ 5 步直到收敛</p>\n<p>⑦ 根据训练好的 $W$ 调整 $\\lambda$ 的取值。</p>\n<p><strong>注意：</strong></p>\n<p>$c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$，其中的 $W^T_{-j} X_{i, -j}$ 本质上是分别从 $W$ 和 $X$ 中各去掉了一维后的向量/矩阵相乘，但从另一方面理解，也可以认为是去掉了第 j 维特征后用剩下的特征计算出来的预测值，因此 $y_i - W^T_{-j} X_{i, -j}$ 实际上也是第 i 个样本的预测残差 $r_i$，而 $c_j = X_j \\cdot r$ 可以表示输入特征 $X$ 和预测残差 $r$ 的相关性。</p>\n<p><strong>（1）当特征与预测残差强相关时，表示该输入特征的取值（实际上由权重 $w_j$ 控制）对预测结果（残差）有很大影响（例如 $r_j$ 下降很快），则说明这个特征很重要（即权重 $w_j$ 是必须的）。</strong></p>\n<p><strong>（2）当特征与预测残差弱相关时，则表示有没有该特征对预测结果没有什么影响，因此直接使得 $w_j = 0$，这也是 L1 正则起到特征选择作用的原理。</strong></p>\n<p><strong>（3）这也印证了目标函数 $J(W, \\lambda) = \\sum Loss + \\lambda R(W)$ 中正则参数 $\\lambda$ 的理解：$\\lambda$ 为正则项的惩罚，$\\lambda$ 越大，对应的 $[ -\\lambda, \\lambda]$ 区间也越宽，则 $w_j = 0$ 的可能性越大，因此得到的解越稀疏，从而 $W$ 的复杂度越低。</strong></p>\n<p><strong>（4）是否 $c_j \\in [- \\lambda, \\lambda]$ 决定了 $w_j$ 是否为 0，而 $c_j$ 同样表示输入特征和预测残差之间的相关性。当 $\\lambda$ 大于某个最值时，会导致所有的权重均为零 $w_j = 0$。这个最大值同样是可以预计算的：当 $\\lambda$ 取最大值时，所有权重均为零，因此每条样本的预测值全为 0，对应的每条样本的预测残差即为真实值本身：$r_i = y_i$，因此 $c_j$ 即可用输入特征和真实值的相关性来代替：$c_j = X^T_{: j} y$，其中 $X_{: j}$ 表示所有样本的第 j 维特征值，因此当 $\\lambda \\ge \\max_j (X^T_{: j} y)$ 时，可得所有 $w_j = 0$。</strong></p>\n<h3 id=\"4-3-Scikit-Learn中的Lasso\"><a href=\"#4-3-Scikit-Learn中的Lasso\" class=\"headerlink\" title=\"4.3 Scikit-Learn中的Lasso\"></a>4.3 Scikit-Learn中的Lasso</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.Lasso</span></span><br><span class=\"line\">Lasso(alpha=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">      fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">      normalize=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      precompute=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      copy_X =<span class=\"literal\">True</span>,</span><br><span class=\"line\">      max_iter=<span class=\"number\">1000</span>,</span><br><span class=\"line\">      tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">      warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      positive=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">      selection=<span class=\"string\">&#x27;cyclic&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>precompute</code>: 是否使用预计算的 Gram 矩阵来加速计算。</p>\n<p>可取值：&#39;True&#39;, &#39;False&#39;, ‘auto’ 或数组（array-like）。若设置为 &#39;auto&#39; 则由机器决定。</p>\n</li>\n<li><p><code>max_iter</code>: 最大迭代次数。</p>\n</li>\n<li><p><code>tol</code>: 解的精度，判断迭代收敛与否的阈值。</p>\n<p>当更新量小于tol时，优化代码检查优化的 dual gap 并继续直到小于 tol 为止。</p>\n</li>\n<li><p><code>warm_start</code>: 是否从之前的结果继续。</p>\n<p>初始值可以是之前的训练结果，支持在线学习。初始值可在 fit 函数中作为参数传递。</p>\n</li>\n<li><p><code>positive</code>: 是否强制使系数 $W$ 为正。</p>\n</li>\n<li><p><code>random_state</code>: 随机选择特征的权重进行更新的随机种子。</p>\n<p>仅当参数 <code>selection == &#39;random&#39;</code> 时有效。</p>\n</li>\n<li><p><code>selection</code>: 选择特征权重更新的方式。</p>\n<p>可选项有：</p>\n<ol>\n<li>&#39;cyclic&#39;：循环更新</li>\n<li>&#39;random&#39;：随机选择特征进行更新，通常收敛更快，尤其当参数 tol &gt; (10 - 4) 时。</li>\n</ol>\n</li>\n</ul>\n","categories":["MachineLearning","LinearRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","线性回归"]},{"title":"ML入门-多类分类任务","url":"/post/machinelearning/ml-logistic/ml-logistic-multiclassify/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-多类分类任务\"><a href=\"#ML入门-多类分类任务\" class=\"headerlink\" title=\"ML入门-多类分类任务\"></a>ML入门-多类分类任务</h1>","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-Logistic回归简介","url":"/post/machinelearning/ml-logistic/ml-logistic-introduction/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-Logistic回归简介\"><a href=\"#ML入门-Logistic回归简介\" class=\"headerlink\" title=\"ML入门-Logistic回归简介\"></a>ML入门-Logistic回归简介</h1><h2 id=\"1-Logistic回归简介\"><a href=\"#1-Logistic回归简介\" class=\"headerlink\" title=\"1. Logistic回归简介\"></a>1. Logistic回归简介</h2><p>回归任务和分类任务都属于有监督学习（Supervised Learning），其训练数据的格式为：$D = \\{ X_i, y_i \\}^N_{i = 1}$。回归任务中 $y_i \\in R$，而分类任务中 $y_i \\in C, C = \\{ 1, \\cdots c \\}$，任务目标都为：学习一个从输入 $X$ 到输出 $y$ 的映射 $f$。分类任务的图示如下：</p>\n<p><img data-src=\"./classify_demo.png\" alt=\"分类任务图示\" title=\"@ASSET\"></p>\n<p>典型的分类任务有：垃圾邮件过滤、手写数字/文本识别、语音识别、人脸识别、医疗诊断、金融风控等。</p>\n<p>贝努力（Bernoulli）分布：$y \\sim Bernoulli(\\mu)$，其中 $\\mu$ 为分布的期望，表示 $y = 1$ 的概率。则该分布的概率密度函数为：</p>\n<p>$<br>p(y; \\mu) = \\mu^y (1 - \\mu)^{(1 - y)}<br>$</p>\n<p>以两类分类为例。两类分类任务中，假设样本的输出为 $y_i \\in \\{ 0, 1 \\}$，当给定输入 $X$ 的情况下，输出 y 符合贝努力分布：</p>\n<p>$<br>y | X \\sim Bernoulli(\\mu (X))<br>$</p>\n<p>其中期望 $\\mu (X)$ 表示在给定 $X$ 的情况下，$y = 1$ 的概率。则其概率密度函数为：</p>\n<p>$<br>p(y | X; \\mu) = \\mu (X)^y (1 - \\mu (X))^{1 - y}<br>$</p>\n<p>$<br>p(y = 1) = \\mu(X), \\quad p(y = 0) = 1 - \\mu (X)<br>$</p>\n<h3 id=\"1-1-Sigmoid函数\"><a href=\"#1-1-Sigmoid函数\" class=\"headerlink\" title=\"1.1 Sigmoid函数\"></a>1.1 Sigmoid函数</h3><p>当选择最简单的线性模型来表示期望 $\\mu (X)$ 时，即 $\\mu (X) = W^T X$，期望 $\\mu(X)$ 表示 $y = 1$ 的概率，因此 $\\mu (X) \\in [0, 1]$，而 $W^T X \\in (- \\infty, + \\infty)$，因此需要把 $(- \\infty, + \\infty)$ 缩放到 $[0, 1]$：Sigmoid 函数。</p>\n<p>Sigmoid 函数表达式为：$\\sigma (z) = \\dfrac {1} {1 + e^{-z}}$，其图形如下：</p>\n<p><img data-src=\"./sigmoid.png\" alt=\"Sigmoid 函数\" title=\"@ASSET\"></p>\n<p><strong>Sigmoid 函数亦被称为 Logistic 函数或 Logit 函数，Logistic 回归亦被称为 Logit 回归。</strong></p>\n<blockquote>\n<p>LogisticRegression 虽然名字上用了“回归”，但实际上是分类算法。</p>\n</blockquote>\n<p>使用 Sigmoid 函数对 $W^T X$ 缩放后得到：</p>\n<p>$<br>p(y = 1 | X) = \\mu (X) = \\sigma (W^T X)<br>$</p>\n<p>$<br>p(y = 0 | X) = 1 - \\mu (x) = 1 - \\sigma (W^T X)<br>$</p>\n<p>定义一个事件的几率（Odd，与概率 Probability 不是一个概念）为该事件发生的概率与不发生的概率的比值：</p>\n<p>$<br>\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\dfrac {\\sigma (W^T X)} {1 - \\sigma (W^T X)} = \\dfrac {\\dfrac {1} {1 + e^{- W^T X}}} {\\dfrac {e^{- W^T X}} {1 + e^{- W^T X}}} = e^{W^T X}<br>$</p>\n<p>两边同取 $\\log$ 运算，得到 <strong>对数几率</strong>：$\\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\log (e^{W^T X}) = W^T X$。</p>\n<p>当 $p(y = 1 | X) &gt; p(y = 0 | X)$ 时，如果取最大后验概率，即输入 $X$ 的类别取 $y = 1$，则有：</p>\n<p>$<br>\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} &gt; 0, \\Longrightarrow \\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = W^T X &gt; 0<br>$</p>\n<p>  ① 当 $W^T X &gt; 0$ 时，$p(y = 1 | X) &gt; p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 1$。</p>\n<p>  ② 当 $W^T X &lt; 0$ 时，$p(y = 1 | X) &lt; p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 0$。</p>\n<p>  ③ 当 $W^T X = 0$ 时，$p(y = 1 | X) = p(y = 0 | X)$，输入 $X$ 对应的类别可以是 1 或 0，此时 $X$ 位于决策面上，可以将 $X$ 分类到任意类别，或拒绝作出判断。</p>\n<p>令决策函数 $f(X) = W^T X$，其根据 $W^T X$ 的符号将输入控件 $X$ 分出两个区域。由于 $W^T X$ 为线性函数，因此 Logistic 回归模型是一个线性分类器。一个线性分类模型实例如下：</p>\n<p><img data-src=\"./linear_classify.png\" alt=\"线性分类实例\" title=\"@ASSET\"></p>\n<h3 id=\"1-2-决策边界\"><a href=\"#1-2-决策边界\" class=\"headerlink\" title=\"1.2 决策边界\"></a>1.2 决策边界</h3><p>更一般地：根据需要划分的类别，分类器将输入控件 $X$ 划分为一些互不相交的区域。这些区域的边界叫决策边界（Decision Boundaries）。根据预测函数 $f$ 的不同，会使得决策面或光滑、或粗糙。</p>\n<p>当决策面是输入 $X$ 的线性函数时，称为线性决策面，对应的分类器就是线性分类器。</p>\n<p>分类器为每个类别分配一个判别函数，根据判别函数来判断一个新样本属于该类别的可能性，然后将新样本归类为可能性最大的一类。假设有 C 个类别，则对应有 C 个判别函数：$\\delta_c (X), c \\in \\{ 1, \\cdots, C \\}$。</p>\n<p>对一个新样本 $X$，通常是找到最大的 $\\delta_c (X)$，即该样本的类别为：</p>\n<p>$$<br>\\hat{y} = \\arg_c \\max \\delta_c (X)<br>$$</p>\n<p>判别函数 $\\delta_c (X)$ 和  $\\delta_k (X)$ 相等的点的集合，就是分类 C 和分类 K 之间的决策面：</p>\n<p><img data-src=\"./decision_separating_hyperplane.png\" alt=\"分类决策面\" title=\"@ASSET\"></p>\n<p>例如两类分类问题中，决策函数 $f_1 = p(y = 1 | X)$ 即为类别 $y = 1$ 的判别函数，决策函数 $f_0 = p(y = 0 | X)$ 即为类别 $y = 0$ 的判别函数。若对一新样本 $X$，有 $f_1 (X) &gt; f_0 (X)$，则新样本 $X$ 被分入类别 $y = 1$。</p>\n<hr>\n<h2 id=\"2-Logistic损失函数\"><a href=\"#2-Logistic损失函数\" class=\"headerlink\" title=\"2. Logistic损失函数\"></a>2. Logistic损失函数</h2><h3 id=\"2-1-负log似然损失\"><a href=\"#2-1-负log似然损失\" class=\"headerlink\" title=\"2.1 负log似然损失\"></a>2.1 负log似然损失</h3><p>以两类分类问题为例，直观地，可以定义一种损失：0 / 1 损失，预测类别正确时预测损失为 0，否则为 1。记为：</p>\n<p>$<br>L(y, \\hat{y}) = \\left \\{<br>\\begin{aligned}<br>0, &amp;&amp; {y = \\hat{y}}<br>\\\\<br>1, &amp;&amp; {y \\ne \\hat{y}}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>但 0 / 1 损失不连续，优化计算不方便。因此需要寻找其他 <strong>替代损失函数（Surrogate Loss Function）</strong>。替代损失函数应当符合几个特征：</p>\n<ul>\n<li>通常是凸函数，计算方便。</li>\n<li>与 0 / 1 损失函数具有等效性。</li>\n</ul>\n<p>下图列举了几种不同的损失函数：</p>\n<p><img data-src=\"./some_loss_functions.png\" alt=\"多种损失函数图\" title=\"@ASSET\"></p>\n<p>图中横轴为 $y \\hat{y}$ 取值，纵轴为损失。</p>\n<p>定义两类分类中，真值 $y$ 只有两种取值：$y \\in \\{ 1, -1 \\}$，而预测值可取连续值：$\\hat{y} \\in \\{ - \\infty, + \\infty \\}$，以符号区分预测值的预测类别（正数对应类别 1，负数对应类别 -1），当 $y$ 和 $\\hat{y}$ 符号相同时（即 $y \\hat{y} &gt; 0$，对应图中横坐标右半部分）表示预测正确，此时损失为 0。反之亦然。</p>\n<p>可以看出，浅蓝色曲线 L2 损失并不能很好地代替 0 / 1 损失，因此优化 L2 损失并不能很好地优化模型的准确度。</p>\n<p>整理 Logistic 回归模型：$y | X \\sim Bernoulli (\\mu (X))$，对应的概率密度函数为：</p>\n<p>$<br>p(y | X; \\mu (X)) = \\mu (X)^y (1 - \\mu (X))^{(1 - y)}<br>$</p>\n<p>其中，$\\mu (X)$ 是线性模型经过 Sigmoid 变化而来：$\\mu (X) = \\sigma (W^T X)$。</p>\n<p>Logistic 的似然函数为：$likelihood (f) = p(D) = \\prod^N_{i = 1} p(y_i | x_i)$，则 $\\log$ 似然函数为：</p>\n<p>$<br>\\begin{aligned}<br>l(\\mu) &amp;= \\log p(D) = \\log \\prod^N_{i = 1} p(y_i | x_i) = \\sum^N_{i = 1} \\log p(y_i | x_i)<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\log \\left( \\mu (X_i)^{y_i} (1 - \\mu (X_i))^{(1 - y_i)} \\right)<br>\\\\<br>&amp;= \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i))<br>\\end{aligned}<br>$</p>\n<p>取极大似然估计        ：</p>\n<p>$<br>\\begin{aligned}<br>\\max l(\\mu) &amp;= - \\min l(\\mu)<br>\\\\<br>&amp;= \\min - \\left( \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i)) \\right)<br>\\\\<br>&amp;= \\min \\sum^N_{i = 1} - y_i \\log (\\mu (X_i)) - (1 - y_i) \\log (1 - \\mu (X_i))<br>\\end{aligned}<br>$</p>\n<p><strong>因此极大似然估计等价于最小训练集上的负 $\\log$ 损失。而负 $\\log$ 似然损失亦被称为 Logistic 损失。</strong></p>\n<h3 id=\"2-2-交叉熵损失\"><a href=\"#2-2-交叉熵损失\" class=\"headerlink\" title=\"2.2 交叉熵损失\"></a>2.2 交叉熵损失</h3><p>Logistic 损失亦被称为 <strong>交叉熵损失（Corss Entropy Loss, CE）</strong>。</p>\n<p>交叉熵损失：两个分布之间的差异（已知真实分布的情况下，预测分布与真实分布之间的差异）。定义交叉熵 $H(p, q)$ 如下：</p>\n<p>$$<br>\\begin{aligned}<br>H(p, q) &amp;= \\sum_x p(x) \\log (\\dfrac {1} {q(x)})<br>\\\\<br>&amp;= - \\sum_x p(x) \\log (q(x))<br>\\end{aligned}<br>$$</p>\n<p>假设预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，即 $\\hat{y} \\sim Bernoulli (\\mu (X))$，则预测值 $\\hat{y} = 0$ 的概率为 $1 - \\mu (X)$。</p>\n<p>（1）假设已知真值 $y = 1$，即 $y | X \\sim Bernoulli (1)$，即在已知真值 $y = 1$ 的情况下，$y$ 取 1 的概率 $\\mu = p(y = 1) = 1$，因此 $y = 0$ 的概率 $p(y = 0) = 0$。则这两个分布之间的交叉熵为：</p>\n<p>$<br>\\begin{aligned}<br>CE(y = 1, \\hat{y}) &amp;= - \\sum_y p(y | X) \\log p(\\hat{y} | X)<br>\\\\<br>&amp;= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)<br>\\\\<br>&amp;= - \\log \\mu (X)<br>\\end{aligned}<br>$</p>\n<p>（2）同理，假设已知真值 $y = 0$，即 $y | X \\sim Bernoulli (0)$，因此 $\\mu = p(y = 1) = 0$，$p(y = 0) = 1$，此时这两个分布之间的交叉熵为：</p>\n<p>$<br>\\begin{aligned}<br>CE(y = 0, \\hat{y}) &amp;= - \\sum_y p(y | X) \\log p(\\hat{y} | X)<br>\\\\<br>&amp;= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)<br>\\\\<br>&amp;= - \\log (1 - \\mu (X))<br>\\end{aligned}<br>$</p>\n<p>整理合并得：</p>\n<p>$<br>CE(y, \\hat{y}) = \\left \\{<br>\\begin{aligned}<br>&amp; - \\log \\mu (X), &amp;&amp; {y = 1}<br>\\\\<br>&amp; - \\log (1 - \\mu (X)), &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>定义 $p_t$（Probability of Ground Truth Class）为：</p>\n<p>$<br>p_t = \\left \\{<br>\\begin{aligned}<br>&amp; \\mu (X), &amp;&amp; {if (y = 1)}<br>\\\\<br>&amp; 1 - \\mu (X), &amp;&amp; {Otherwise}<br>\\end{aligned}<br>\\right.<br>$</p>\n<p>则可得到交叉熵损失简洁表达式：</p>\n<p>$$<br>CE(y, \\hat{y}) = - \\log (p_t)<br>$$</p>\n<p>交叉熵损失与 $p_t$ 的关系曲线如下：</p>\n<p><img data-src=\"./cross_entropy_and_pt.png\" alt=\"交叉熵损失曲线\" title=\"@ASSET\"></p>\n<blockquote>\n<p><strong>对 $p_t$ 的理解：根据 $p_t$ 的表达式，当真实值 $y = 1$ 时，$p_t = \\mu (X)$。由于 $\\mu (X)$ 表示的是预测值 $\\hat{y} = 1$ 的概率，因此 $p_t$ 即表示预测分布接近真实分布的概率。因此 $p_t$ 越大，表示预测越准确，同时对应的交叉熵损失 $Loss = - \\log (p_t)$ 也就越小，与图中曲线含义相同。</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"3-Logistic正则项\"><a href=\"#3-Logistic正则项\" class=\"headerlink\" title=\"3. Logistic正则项\"></a>3. Logistic正则项</h2><p>Logistic 回归采用 Logistic 损失 / 交叉熵损失，由于预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，因此可使用 $\\mu (X)$ 表示 $\\hat{y}$：</p>\n<p>$<br>\\begin{aligned}<br>&amp; L(y, \\mu(X)) = -y \\log (\\mu (X)) - (1- y) \\log (1 - \\mu (X))<br>\\\\<br>&amp; \\mu (X) = \\sigma (W^T X)<br>\\end{aligned}<br>$</p>\n<p>Logistic 回归的目标函数同样包括训练集上的损失和与正则项，正则项同样可选 L1 正则、L2 正则、或 L1 + L2 正则。</p>\n<p>假设有一个两类分类任务，且训练样本完全可分（即所有同类样本均可被分对），为了使 Logistic 损失和最小（完全可分时最小损失和即为 0），则对每个样本有：$L(y_i, \\mu (x_i)) = 0$。当想要使得每个样本损失均为 0 时，即：</p>\n<blockquote>\n<p>① 对于每个真实值 $y_i = 1$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 1（必定预测分类为 1），也即 $\\mu (X) = 1$。</p>\n<p>② 而对于每个真实值 $y_i = 0$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 0（不可能预测分类为 1），也即 $\\mu (X) = 0$。</p>\n</blockquote>\n<p>由于 $\\mu (X) = \\sigma (W^T X)$ 是将线性模型 $W^T X$ 经过 Sigmoid 变化而来，Sigmoid 图形如下：</p>\n<p><img data-src=\"./sigmoid.png\" alt=\"Sigmoid 函数\" title=\"@ASSET\"></p>\n<p><strong>当 $\\mu (X)$ 取 $\\pm 1$ 时，$W^T X$ 取 $\\pm \\infty$，也即 $|W_j| = \\infty$，这样的模型是无意义的。</strong></p>\n<p><strong>因此 Logistic 回归必须加正则！</strong></p>\n<blockquote>\n<p>Scikit-Learn 中实现的 Logistic 回归 <code>LogisticRegression</code> 默认为 L2 正则。</p>\n</blockquote>\n<p>与 SVM 类似的是，Logistic 回归的超参数 $C$ 加在损失函数上：</p>\n<p>$$<br>J(W; \\lambda) = C \\sum^N_{i = 1} L(y_i, \\mu (x_i; W)) + R(W)<br>$$</p>\n<hr>\n<h2 id=\"4-Scikit-Learn中的Logistic\"><a href=\"#4-Scikit-Learn中的Logistic\" class=\"headerlink\" title=\"4. Scikit-Learn中的Logistic\"></a>4. Scikit-Learn中的Logistic</h2><p>Scikit-Learn 中实现了 3 种 Logistic 回归：</p>\n<ul>\n<li><code>LogisticRegression</code>: 最原始的 Logistic 回归模型，超参数调优时需要手动搭配 <code>GridSearchCV</code> 使用。</li>\n<li><code>LogisticRegressionCV</code>: Scikit-Learn 提供的已集成了交叉验证的 Logistic 回归模型，可以直接使用内置的交叉验证对超参数调优。</li>\n<li><code>SGDClassifier</code>: 随机梯度下降分类，则是在样本数很大（样本数 $N &gt; 10^5$，特征数 $M &gt; 10^5$）时效果更好。</li>\n</ul>\n<h3 id=\"4-1-LogitsicRegression\"><a href=\"#4-1-LogitsicRegression\" class=\"headerlink\" title=\"4.1 LogitsicRegression\"></a>4.1 LogitsicRegression</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LogisticRegression</span></span><br><span class=\"line\"></span><br><span class=\"line\">LogisticRegression(penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">                   dual=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                   tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">                   C=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                   fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                   intercept_scaling=<span class=\"number\">1</span>,</span><br><span class=\"line\">                   class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                   random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                   solver=<span class=\"string\">&#x27;liblinear&#x27;</span>,</span><br><span class=\"line\">                   max_iter=<span class=\"number\">100</span>,</span><br><span class=\"line\">                   multi_class=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                   verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                   warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                   n_jobs=<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-1-LogitsicRegression的参数\"><a href=\"#4-1-1-LogitsicRegression的参数\" class=\"headerlink\" title=\"4.1.1 LogitsicRegression的参数\"></a>4.1.1 LogitsicRegression的参数</h4><ul>\n<li><p><code>penalty</code>: 惩罚函数 / 正则函数，默认：&#39;L2&#39;。</p>\n<p>支持 L2 正则和 L1 正则。选择 L1 正则时优化器可选 &#39;liblinear&#39; 和 &#39;saga&#39;。</p>\n</li>\n<li><p><code>dual</code>: 是否是对偶问题求解，默认：<code>False</code>。</p>\n<p>是原问题（primal）还是对偶问题（dual）求解。对偶问题只支持 L2 正则和 &#39;liblinear&#39; 优化器。</p>\n</li>\n<li><p><code>tol</code>: 迭代终止判据的误差范围，默认：$10^{-4}$。</p>\n</li>\n<li><p><code>C</code>: 交叉熵损失函数系数，默认：1。</p>\n</li>\n<li><p><code>fit_intercept</code>: 是否在决策函数中加入截距项。默认：<code>True</code>。</p>\n<p>如果数据已经中心化，则不需要拟合截距项。</p>\n</li>\n<li><p><code>intercept_scaling</code>: 截距缩放因子。</p>\n<p>当 <code>fit_intercept</code> 为 <code>True</code> 且优化器 <code>solver</code> 设置为 <code>liblinear</code> 时有效。输入为 <code>[X, self.intercept_scaling]</code>，即对输入特征插入 1 维常数项。由于增加的常数项系数也受到 L1 / L2 正则的惩罚，因此要适当增大常数项。</p>\n</li>\n<li><p><code>class_weight</code>: 不同类别样本的权重。默认：<code>None</code>。</p>\n<p>可指定每类样本权重，或设置为 &#39;balanced&#39;，则每类样本权重与该类别样本数比例成反比。</p>\n</li>\n<li><p><code>random_state</code>: 随机种子，默认：<code>None</code>。</p>\n</li>\n<li><p><code>solver</code>: 优化求解算法，默认：&#39;liblinear&#39;。</p>\n<p>可选：&#39;newton-cg&#39;，&#39;lbfgs&#39;，&#39;liblinear&#39;，&#39;sag&#39;，&#39;saga&#39;。</p>\n<ul>\n<li>L1 正则优化器仅可选 &#39;liblinear&#39; 和 &#39;saga&#39;，L2 正则可使用所有优化器。</li>\n</ul>\n</li>\n<li><p><code>max_iter</code>: 最大迭代次数，默认：100。</p>\n<p>仅当 <code>solver</code> 设置为 &#39;newton-cg&#39;，&#39;sag&#39;，或 &#39;lbfgs&#39; 时有效。</p>\n</li>\n<li><p><code>multi_class</code>: 多类分类处理策略，默认：&#39;ovr&#39;。</p>\n<p>可选：&#39;ovr&#39;，&#39;multinomial&#39;。</p>\n<ul>\n<li><p>&#39;ovr&#39;：One-Versus-Rest，一对多。将 C 类分类问题转化为 C 个两类分类问题，每一次分类当前类别样本为正样本，其余样本视为负样本。</p>\n</li>\n<li><p>&#39;multinomial&#39;：即 softmax 分类器。使用 &#39;multinomial&#39; 时，优化器仅可选 &#39;newton-cg&#39;，&#39;lbfgs&#39;，&#39;sag&#39;。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>OVO：One-Versus-One，一对一。</p>\n</blockquote>\n<p>OVR 相对简单但分类效果相对略差。MVM 分类相对精确，但分类速度比 OVR 慢。</p>\n<ul>\n<li><p><code>verbose</code>: 是否详细输出。</p>\n</li>\n<li><p><code>warm_start</code>: 是否热启动，默认：<code>False</code>。</p>\n<ul>\n<li><code>solver</code> 设置为 &#39;liblinear&#39; 时无效。</li>\n</ul>\n</li>\n<li><p><code>n_jobs</code>: 多线程控制，默认：-1.</p>\n<p>取 -1 时算法自动检测可用 CPU 核，并使用全部核。</p>\n</li>\n</ul>\n<h4 id=\"4-1-2-LogitsicRegression的属性\"><a href=\"#4-1-2-LogitsicRegression的属性\" class=\"headerlink\" title=\"4.1.2 LogitsicRegression的属性\"></a>4.1.2 LogitsicRegression的属性</h4><ul>\n<li><p><code>coef</code>: 回归系数 / 权重。</p>\n<p>与特征的维数相同。如果是多任务回归，标签 $y$ 为 m 维数组，则回归系数也为 m 维数组。</p>\n</li>\n<li><p><code>intercept_</code>: 截距项。</p>\n</li>\n<li><p><code>n_iter_</code>: 每个类的迭代此时。</p>\n</li>\n</ul>\n<h4 id=\"4-1-3-LogitsicRegression的方法\"><a href=\"#4-1-3-LogitsicRegression的方法\" class=\"headerlink\" title=\"4.1.3 LogitsicRegression的方法\"></a>4.1.3 LogitsicRegression的方法</h4><ul>\n<li><p><code>fit(X, y[, sample_weight])</code>: 模型训练。</p>\n<p>参数 X，y 为训练数据，也可以通过 <code>sample_weight</code> 设置每个样本的权重。</p>\n</li>\n<li><p><code>predict(X)</code>: 返回 X 对应的预测值（类别标签）。</p>\n</li>\n<li><p><code>predict_log_proba(X)</code>: 返回 X 对应的预测值（每个类别对应的概率的 $log$ 值）。</p>\n</li>\n<li><p><code>predict_proba(X)</code>: 返回 X 对应的预测值（每个类别对应的概率）。</p>\n</li>\n<li><p><code>score(X, y[, sample_weight])</code>: 评估模型预测性能，返回模型预测的正确率。</p>\n</li>\n<li><p><code>decision_function(X)</code>: 预测的置信度（样本到分类超平面的带符号距离）。</p>\n<p>在分对的情况下，正样本得到的应为正值，负样本得到的应为负值。</p>\n</li>\n<li><p><code>densify()</code>: 如果之前将系数矩阵变成了稀疏模式，再将其变回稠密模式（<code>fit</code> 函数要求系数矩阵为稠密模式）。</p>\n</li>\n<li><p><code>sparsify()</code>: 将系数矩阵变成了稀疏模式。</p>\n</li>\n</ul>\n<h3 id=\"4-2-LogisticRegressionCV\"><a href=\"#4-2-LogisticRegressionCV\" class=\"headerlink\" title=\"4.2 LogisticRegressionCV\"></a>4.2 LogisticRegressionCV</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.LogisticRegressionCV</span></span><br><span class=\"line\"></span><br><span class=\"line\">LogisticRegressionCV(Cs=<span class=\"number\">10</span>,</span><br><span class=\"line\">                     fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                     cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     dual=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                     penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">                     scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     solver=<span class=\"string\">&#x27;lbfgs&#x27;</span>,</span><br><span class=\"line\">                     tol=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">                     max_iter=<span class=\"number\">100</span>,</span><br><span class=\"line\">                     class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                     n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">                     verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                     refit=<span class=\"literal\">True</span>, i</span><br><span class=\"line\">                     ntercept_scaling=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                     multi_class=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                     random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-1-LogisticRegressionCV的参数\"><a href=\"#4-2-1-LogisticRegressionCV的参数\" class=\"headerlink\" title=\"4.2.1 LogisticRegressionCV的参数\"></a>4.2.1 LogisticRegressionCV的参数</h4><ul>\n<li><p><code>Cs</code>: 超参数调优范围。</p>\n<p>在区间 $[10^{-4}, 10^4]$ 的 $log$ 域均匀取 Cs 个值作为正则参数 C 的搜索空间。</p>\n</li>\n<li><p><code>cv</code>: 交叉校验划分策略。</p>\n</li>\n<li><p><code>solver</code>: 与 <code>LogisticRegression</code> 相同，但默认为 &#39;lbfgs&#39;。</p>\n</li>\n<li><p><code>multi_class</code>: 对多类分类问题，采用的是 &#39;ovr&#39; 的方式，用交叉验证得到每个类的最佳正则参数。</p>\n</li>\n<li><p>其余参数与 <code>LogisticRegression</code> 相同。</p>\n</li>\n</ul>\n<h4 id=\"4-2-2-LogisticRegressionCV的属性\"><a href=\"#4-2-2-LogisticRegressionCV的属性\" class=\"headerlink\" title=\"4.2.2 LogisticRegressionCV的属性\"></a>4.2.2 LogisticRegressionCV的属性</h4><p>与 <code>LogisticRegression</code> 相同。</p>\n<h4 id=\"4-2-3-LogisticRegressionCV的方法\"><a href=\"#4-2-3-LogisticRegressionCV的方法\" class=\"headerlink\" title=\"4.2.3 LogisticRegressionCV的方法\"></a>4.2.3 LogisticRegressionCV的方法</h4><p>与 <code>LogisticRegression</code> 相同。</p>\n<h3 id=\"4-3-SGDClassifier\"><a href=\"#4-3-SGDClassifier\" class=\"headerlink\" title=\"4.3 SGDClassifier\"></a>4.3 SGDClassifier</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.linear_model.SGDClassifier</span></span><br><span class=\"line\"></span><br><span class=\"line\">SGDClassifier(loss=<span class=\"string\">&#x27;hinge&#x27;</span>,</span><br><span class=\"line\">              penalty=<span class=\"string\">&#x27;l2&#x27;</span>,</span><br><span class=\"line\">              alpha=<span class=\"number\">0.0001</span>,</span><br><span class=\"line\">              l1_ratio=<span class=\"number\">0.15</span>,</span><br><span class=\"line\">              fit_intercept=<span class=\"literal\">True</span>,</span><br><span class=\"line\">              max_iter=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              tol=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              shuffle=<span class=\"literal\">True</span>,</span><br><span class=\"line\">              verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">              epsilon=<span class=\"number\">0.1</span>,</span><br><span class=\"line\">              n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">              random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              learning_rate=<span class=\"string\">&#x27;optimal&#x27;</span>, </span><br><span class=\"line\">              ta0=<span class=\"number\">0.0</span>,</span><br><span class=\"line\">              power_t=<span class=\"number\">0.5</span>,</span><br><span class=\"line\">              class_weight=<span class=\"literal\">None</span>,</span><br><span class=\"line\">              warm_start=<span class=\"literal\">False</span>,</span><br><span class=\"line\">              average=<span class=\"literal\">False</span>,</span><br><span class=\"line\">              n_iter=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-1-SGDClassifier的参数\"><a href=\"#4-3-1-SGDClassifier的参数\" class=\"headerlink\" title=\"4.3.1 SGDClassifier的参数\"></a>4.3.1 SGDClassifier的参数</h4><ul>\n<li><p><code>lose</code>: 损失函数。</p>\n<p>可选：&#39;hinge&#39;（合页损失，SVM 中常用），&#39;log&#39;（负 $log$ 似然损失，即 Logistic 回归使用的损失），&#39;modified_huber&#39;（对噪声不损失），&#39;squared_hinge&#39;，&#39;perceptron&#39;，还有回归中使用的损失函数：&#39;squared_loss&#39;，&#39;huber&#39;，&#39;epsilon_insensitive&#39;，&#39;squared_epsilon_insensitive&#39;。</p>\n<p>使用回归的方式也可以实现分类。在分类中，$f(X)$ 表示样本输入 $X$ 取某个类别的概率，当使用回归的方式进行分类时，$f(X)$ 为一具体数值，可通过数值判断分类。例如二分类任务中，对 $f(X) &gt; 0.5$，分为类别 1，对 $f(X) &lt; 0.5$，分为类别 0。</p>\n</li>\n<li><p><code>epsilon</code>: 额外参数项。</p>\n<p>某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）所需要的额外参数。</p>\n</li>\n<li><p><code>penalty</code>: 正则项。</p>\n<p>可选：&#39;none&#39;，&#39;l2&#39;，&#39;l1&#39;，&#39;elasticnet&#39;（弹性网络，L1 + L2）。</p>\n</li>\n<li><p><code>alpha</code>: 正则惩罚系数。</p>\n<p>对应为目标函数中的 $\\lambda$，也用于学习率的计算。</p>\n</li>\n<li><p><code>l1_ratio</code>: L1 正则比例。</p>\n<p>仅当正则项为 &#39;elasticnet&#39; 时有效，用于控制 L1 正则所占比例。</p>\n</li>\n</ul>\n<p>优化相关参数如下：</p>\n<ul>\n<li><p><code>max_iter</code>: 最大迭代次数（访问所有训练数据的次数 / epoches 次数），默认：5。</p>\n<p>SGD 在接近 $10^6$ 的训练样本时收敛，因此可将 <code>max_iter</code> 设置为 <code>np.ceil(10^6 / N)</code>（$\\dfrac {10^6} {N}$），其中 N 为训练集样本数。</p>\n</li>\n<li><p><code>tol</code>: 迭代停止条件。</p>\n<p>若非 <code>None</code>，则当 (loss &gt; previous_loss - tol) 时迭代终止。</p>\n</li>\n<li><p><code>learning_rate</code>: 学习率。</p>\n<p>对应为迭代优化算法中的 $\\alpha$。</p>\n<p>可选：&#39;constant&#39;，&#39;optimal&#39;，&#39;invscaling&#39;。</p>\n<ul>\n<li>&#39;constant&#39;：eta = eta0</li>\n<li>&#39;optimal&#39;：eta = 1.0 / (alpha * (t + t0))</li>\n<li>&#39;invscaling&#39;：eta = eta0 / pow(t, power_t)</li>\n</ul>\n</li>\n<li><p><code>shuffle</code>: 每轮 SGD 之前是否洗牌。</p>\n<p>默认为 <code>True</code>。</p>\n</li>\n<li><p><code>warm_start</code>: 是否热启动。</p>\n<p>随机梯度下降中初始值可以是之前的训练结果，支持在线学习。初始值可在 <code>fit()</code> 函数中作为参数传递。</p>\n</li>\n<li><p><code>average</code>: 是否采用平均随机梯度下降法（随机梯度下降法的改进）ASGD。</p>\n</li>\n<li><p>其他参数与 <code>LogisticRegression</code> 相同。</p>\n</li>\n</ul>\n<p>关于“随机梯度下降实现”的参考文献：</p>\n<blockquote>\n<ul>\n<li>&quot;Stochastic Gradient Descent&quot; L. Bottou - Website, 2010</li>\n<li>&quot;The Tradeoffs of Large Scale Machine Learning&quot; L. Bottou - Website, 2011</li>\n</ul>\n</blockquote>\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-Logistic优化求解与牛顿法","url":"/post/machinelearning/ml-logistic/ml-logistic-optimization/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-Logistic优化求解与牛顿法\"><a href=\"#ML入门-Logistic优化求解与牛顿法\" class=\"headerlink\" title=\"ML入门-Logistic优化求解与牛顿法\"></a>ML入门-Logistic优化求解与牛顿法</h1><p>前言：在机器学习的优化求解算法中，梯度下降法是无约束优化问题优化求解最常用的方法之一，还有一种求解方法就是牛顿法。相比梯度下降法，牛顿法的收敛速度更快，但同时，每次迭代需要的计算量也更大。</p>\n<p>在牛顿法之前，需要先了解：<a href=\"https://baike.baidu.com/item/泰勒公式/7681487?fr=aladdin\" title=\"@LINK\">泰勒公式</a>。泰勒公式通俗地讲，就是当函数 $f$ 在点 $x$ 处的一阶导数、二阶导数……n 阶导数已知时，即可使用 n 阶泰勒展开来逼近函数 $f$ 在点 $x$ 的 <strong>邻域</strong> 的函数值，因此泰勒公式求的是一个点的邻域的近似函数值。</p>\n<p>对应优化求解中，通常我们习惯于使用迭代法来求解，而迭代法的本质即：每次向正确的方向移动一小段，直到达到给定条件。这就与泰勒公式不谋而合——每次移动一小段之后的函数值可以使用移动前该点的泰勒展开来逼近，因此牛顿法或拟牛顿法都是在泰勒公式的基础上进行的。</p>\n<hr>\n<h2 id=\"1-牛顿法\"><a href=\"#1-牛顿法\" class=\"headerlink\" title=\"1. 牛顿法\"></a>1. 牛顿法</h2><p>牛顿法（Newton - Raphson，牛顿 - 拉夫逊）是牛顿在 17 世纪提出的用于求解方程的根的方法。其求解思想如下：</p>\n<ol>\n<li>假设点 $x^{\\ast}$ 为函数 $f(x)$ 的根，则 $f(x) = 0$。</li>\n<li>将函数 $f(x)$ 在点 $x_0$ 处进行一阶泰勒展开有：$f(x) \\approx f(x_0) + (x - x_0) f&#39;(x_0)$</li>\n<li>假设点 $x$ 为 $x_0$ 邻域内一点，且 $x$ 为函数的根，则有：$f(x) \\approx f(x_0) + (x - x_0) f&#39;(x_0) = 0$</li>\n<li>将上式变换即可得：$x = x_0 - \\dfrac {f(x_0)} {f&#39;(x_0)}$</li>\n</ol>\n<p>上述牛顿法得到的结论，拓展到迭代的过程中，假设当前处在迭代第 t 轮，则可以得到下一轮 (t + 1) 时刻的解的表达式为：</p>\n<p>$<br>x^{(t + 1)} = x^{(t)} - \\dfrac {f(x^{(t)})} {f&#39;(x^{(t)})}<br>$</p>\n<p>这就是牛顿法优化求解的基本思想。下图展示了牛顿法求解方程 $f(x) = 0$ 的根的过程（图自 Wiki）：</p>\n<p><img data-src=\"./newton_iteration.png\" alt=\"牛顿法迭代过程\" title=\"@ASSET\"></p>\n<p>回到最优化问题中，通常会将问题转化成求极小值（误差、损失最小等），极小值对应了函数的导数为 0，因此需要适当调整牛顿法的目标，从求 $f(x) = 0$ 变为求 $f&#39;(x) = 0$，因此原问题变为求 $f&#39;(x)$ 的根。</p>\n<p>令 $g(x) = f&#39;(x)$，则关于 $x$ 的迭代条件变为：</p>\n<p>$<br>x^{(t + 1)} = x^{(t)} - \\dfrac {g(x^{(t)})} {g&#39;(x^{(t)})} = x^{(t)} - \\dfrac {f&#39;(x^{(t)})} {f&#39;&#39;(x^{(t)})}<br>$</p>\n<p>在实际问题中，通常输入 $X$ 的维度都大于 1，因此将一阶导数替换为梯度（即 $f$ 分别对每个 $x_i$ 求偏导后组成向量）：</p>\n<p>$<br>\\nabla f(x_1, \\cdots, x_D)<br>$</p>\n<p>将二阶导数替换为海森（Hessian）矩阵 H：</p>\n<p>$<br>H(X) = \\left[<br>\\begin{matrix}<br>\\dfrac {\\partial^2 f} {\\partial^2 x^2_1} &amp; \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_D}<br>\\\\<br>\\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_1} &amp; \\dfrac {\\partial^2 f} {\\partial^2 x^2_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_D}<br>\\\\<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots<br>\\\\<br>\\dfrac {\\partial^2 f} {\\partial x_D \\partial x_1} &amp; \\dfrac {\\partial^2 f} {\\partial x_D \\partial x_2} &amp; \\cdots &amp; \\dfrac {\\partial^2 f} {\\partial^2 x^2_D}<br>\\end{matrix}<br>\\right]<br>$</p>\n<p>Hessian 矩阵即：第 i 行第 j 列的元素为 $f$ 先对 $x_i$ 求偏导后再对 $x_j$ 求偏导。由于 $f$ 先对 $x_i$ 再对 $x_j$ 求偏导和 $f$ 先对 $x_j$ 再对 $x_i$ 求偏导相等，即 $\\dfrac {\\partial^2 f} {\\partial x_i \\partial x_j} = \\dfrac {\\partial^2 f} {\\partial x_j \\partial x_i}$，因此 Hessian 矩阵是对称的。</p>\n<p>这样，牛顿法的迭代公式就变换为：</p>\n<p>$$<br>x^{(t + 1)} = x^{(t)} - H^{-1} (X^{(t)}) \\ \\nabla f(X^{(t)})<br>$$</p>\n<blockquote>\n<p>二阶导转换为 Hessian 矩阵 $H(X^{(t)})$ 后作为分母，使用逆运算 $H^{-1} (X^{(t)})$ 来表示。</p>\n</blockquote>\n<p>总结牛顿法求解目标函数极值的迭代步骤如下：</p>\n<ol>\n<li>从 $t = 0$ 开始，初始化 $X^{(0)}$ 为随机值</li>\n<li>计算目标函数 $f(X)$ 在点 $X^{(t)}$ 的梯度：$g^{(t)} = \\nabla f(X^{(t)})$，以及 Hessian 矩阵：$H^{(t)} = H(X^{(t)})$</li>\n<li>计算移动方向：$d^{(t)} = (H^{(t)})^{-1} \\ g^{(t)}$</li>\n<li>根据迭代公式更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$</li>\n<li>判断是否满足迭代终止条件（是否到达最大迭代次数，或相邻两次迭代的相对变化量或绝对变化量小于预设值，通常使用绝对量：$\\dfrac {f(X^{(t + 1)}) - f(X^{(t)})} {f(X^{(t)})} \\le \\varepsilon$），若满足则循环计数，返回最佳参数 $X^{(t + 1)}$ 和目标函数极小值 $f(X^{(t + 1)})$，否则跳转到第 2 步</li>\n</ol>\n<p>其中，第 3 步计算移动方向 $d^{(t)}$ 时，由于矩阵的逆求解困难，因此常用线性方程组计算：$H^{(t)} d^{(t)} = g^{(t)}$，当 $X$ 维度比较小时，可采用解析法求解 $d^{(t)}$，当 $X$ 维度比较高时，可采用梯度下降法或共而梯度下降法求解，因此对 $d^{(t)}$ 的求解又是一个迭代的计算过程。</p>\n<p>对比梯度下降法中的移动方向：$d^{(t)} = - \\eta g^{(t)}$，牛顿法：$d^{(t)} = - (H^{(t)})^{-1} \\ g^{(t)}$，Hessian 矩阵相比学习率（步长）$\\eta$ 包含的信息更多，因此牛顿法收敛速度更快，但从上述步骤也可明显看出牛顿法每次迭代的计算量都大幅增加。</p>\n<p>由于梯度下降法仅使用了一阶导数，而牛顿法使用了二阶导数矩阵，因此梯度下降法是一阶最优化算法，而牛顿法是二阶最优化算法。</p>\n<hr>\n<h2 id=\"2-拟牛顿法\"><a href=\"#2-拟牛顿法\" class=\"headerlink\" title=\"2. 拟牛顿法\"></a>2. 拟牛顿法</h2><p>牛顿法虽然收敛速度比梯度下降法更快，但在高维的情况下，计算目标函数二阶偏导数的复杂度很大，而且有时候目标函数的 Hessian 矩阵无法保持正定，不存在逆矩阵，此时牛顿法将不再能使用。</p>\n<p>为此提出：拟牛顿法（Quasi-Newton Methods），拟牛顿法旨在：不用二阶偏导数，而构造出可以近似 Hessian 矩阵（或 Hessian 矩阵的逆矩阵）的正定对称矩阵，再逐步优化目标函数。不同的近似 Hessian 矩阵构造方法产生了不同的拟牛顿法：BFGS / L-BFGS。</p>\n<blockquote>\n<p>扩展阅读：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/aws3217150/article/details/50548177\" title=\"@LINK\">谈谈常见的迭代优化方法</a></li>\n<li><a href=\"https://www.scipy-lectures.org/advanced/mathematical_optimization/\" title=\"@LINK\">Mathematical optimization: finding minima of functions</a></li>\n</ol>\n</blockquote>\n<p>重新考虑迭代条件，假设有某点 $x_0$，目标函数 $f(x)$ 在该点（已知点）进行二阶泰勒展开：</p>\n<p>$<br>f(x) \\approx f(x_0) + f&#39;(x_0) (x - x_0) + \\dfrac {1} {2} f&#39;&#39;(x_0) (x - x_0)^2<br>$</p>\n<p>当 $X$ 为 向量 / 矩阵 时，导数即为梯度，上式转换为：</p>\n<p>$<br>f(X) \\approx f(X_0) + \\nabla f(X_0) (X - X_0) + \\dfrac {1} {2} (X - X_0)^T \\nabla^2 f(X_0) (X - X_0)<br>$</p>\n<p>对上式取梯度运算（$X_0$ 为已知点，因此其与其导数均可视为常数项）得：</p>\n<p>$<br>\\nabla f(X) \\approx \\nabla f(X_0) + \\nabla^2 f(X_0) (X - X_0)<br>$</p>\n<p>由于函数在点 $X_0$ 处的泰勒展开可以近似 $X_0$ 邻域内的函数值，假设 $X_0$ 即为迭代 t 次后得到的 $X^{(t + 1)}$，则迭代前一轮的 $X^{(t)}$ 即为邻域内一点，可用二阶泰勒展开逼近，因此可得迭代关系：</p>\n<p>$<br>\\nabla f(X^{(t)}) \\approx \\nabla f(X^{(t + 1)}) + \\nabla^2 f(X^{(t + 1)}) (X^{(t)} - X^{(t + 1)})<br>$</p>\n<p>再使用 gradiant 和 Hessian 分别表示 $X$ 的一阶梯度和二阶梯度矩阵：$g^{(t)} = \\nabla f(X^{(t)})$，$H^{(t)} = \\nabla^2 f(X^{(t)})$，整理可得：</p>\n<p>$<br>g^{(t + 1)} - g^{(t)} \\approx H^{(t + 1)} (X^{(t + 1)} - X^{(t)})<br>$</p>\n<p>进一步，引入记号：$s^{(t)} = X^{(t + 1)} - X^{(t)}$ 表示 $X$ 的变化量，$y^{(t)} = g^{(t + 1)} - g^{(t)}$ 表示梯度变化量，则可得简洁迭代关系：</p>\n<p>$$<br>y^{(t)} \\approx H^{(t + 1)} s^{(t)}<br>$$</p>\n<p>由于牛顿法中 Hessian 矩阵的逆难以计算，因此在拟牛顿法中，令 $B$ 表示 $H$ 的近似，$D$ 表示 $H^{-1}$ 的近似，代入上式即可得到 <strong>拟牛顿法的条件&lt;</strong> 为：</p>\n<p>$$<br>y^{(t)} = B^{(t + 1)} s^{(t)}<br>$$</p>\n<p>或</p>\n<p>$$<br>s^{(t)} = D^{(t + 1)} y^{(t)}<br>$$</p>\n<p><strong>实际上，拟牛顿法的条件给出了 Hessian 矩阵的近似需要满足的条件。</strong></p>\n<h3 id=\"2-1-BFGS\"><a href=\"#2-1-BFGS\" class=\"headerlink\" title=\"2.1 BFGS\"></a>2.1 BFGS</h3><p>BFGS（Broyden, Fletcher, Glodfarb, Shanno）被认为是数值效果最好的拟牛顿法，且具有全局收敛性和超线性收敛速度。</p>\n<p>BFGS 算法采用迭代法逼近 Hessian 矩阵：$B^{(t + 1)} = B^{(t)} + \\Delta B^{(t)}$，初始值 $B^{(0)} = I$ 为单位矩阵，因此关键在于如何构造 $\\Delta B^{(t)}$。</p>\n<p>为保证矩阵 $B$ 的正定性，令 $\\Delta B^{(t)} = \\alpha u u^T + \\beta v v^T$，代入上述拟牛顿法条件可得：</p>\n<p>$<br>\\begin{aligned}<br>y^{(t)} &amp;= B^{(t + 1)} s^{(t)} = (B^{(t)} + \\Delta B^{(t)}) s^{(t)} = B^{(t)} s^{(t)} + \\Delta B^{(t)} s^{(t)}<br>\\\\<br>&amp;= B^{(t)} s^{(t)} + \\alpha u u^T s^{(t)} + \\beta v v^T s^{(t)}<br>\\\\<br>&amp;= B^{(t)} s^{(t)} + u (\\alpha u^T s^{(t)}) + v (\\beta v^T s^{(t)})<br>\\end{aligned}<br>$</p>\n<blockquote>\n<p>当 $u^T$ 或 $v^T$ 的维数与 $s^{(t)}$ 的维数一致（由于 $\\Delta B^{(t)}$ 是构造的，因此可以构造为相同维数）时，$u^T s^{(t)}$ 以及 $v^T s^{(t)}$ 均为一个标量数值（向量的转置 x 向量 = 数值）。</p>\n</blockquote>\n<p>令 $\\alpha u^T s^{(t)} = 1$，$\\beta v^T s^{(t)} = -1$，即 $\\alpha = \\dfrac {1} {u^T s^{(t)}}$，$\\beta = - \\dfrac {1} {v^T s^{(t)}}$，得到：</p>\n<p>$<br>u - v = y^{(t)} - B^{(t)} s^{(t)}<br>$</p>\n<p>不妨令 $u = y^{(t)}$，$v = B^{(t)} s^{(t)}$，代入 $\\alpha$ 和 $\\beta$ 的表达式得：</p>\n<p>$<br>\\alpha = \\dfrac {1} {u^T s^{(t)}} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}<br>$</p>\n<p>$<br>\\beta = - \\dfrac {1} {v^T s^{(t)}} = - \\dfrac {1} {(B^{(t)} s^{(t)})^T s^{(t)}} = - \\dfrac {1} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}<br>$</p>\n<p><strong>代入 $\\Delta B^{(t)}$ 的表达式得：</strong></p>\n<p>$$<br>\\begin{aligned}<br>\\Delta B^{(t)} &amp;= \\alpha u u^T + \\beta v v^T<br>\\\\<br>&amp;= \\dfrac {y^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} - \\dfrac {B^{(t)} s^{(t)} (B^{(t)} s^{(t)})^T} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}<br>\\end{aligned}<br>$$</p>\n<blockquote>\n<p>Sherman-Morrison 公式：若 $A$ 为非奇异方阵，$1 + v^T A^{-1} u \\ne 0$，则有：</p>\n</blockquote>\n<p>$<br>(A + uv^T)^{-1} = A^{-1} - \\dfrac {A^{-1} u v^T A^{-1}} {1 + v^T A^{-1}}<br>$</p>\n<p><strong>由于牛顿法迭代过程需要计算 Hessian 矩阵的逆矩阵，因此根据 Sherman-Morrison 公式可得：</strong></p>\n<p>$$<br>(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>$$</p>\n<p>综上，对于 $\\Delta B^{(t)}$ 和 $D^{(t + 1)}$，均可使用 $s^{(t)}$（$X$ 的变化量）和 $y^{(t)}$（函数梯度的变化量）表示，而初始化 $B^{(0)} = D^{(0)} = I$ 是一指的，$s^{(t)}$ 和 $y^{(t)}$ 在 $X$ 已知（优化求解的目的是寻找最优的 $X$，而 $X$ 本来就是已知的）时均是可计算的。</p>\n<p>整理得 BFGS 更新参数的流程如下：</p>\n<ol>\n<li><p>从 $t = 0$ 开始，初始化 $D^{(0)} = I$</p>\n</li>\n<li><p>计算移动方向：$d^{(t)} = D^{(t)} g^{(t)}$</p>\n<blockquote>\n<p>先用 $B^{(t)} = B^{(t - 1)} + \\Delta B^{(t - 1)}$ 迭代解出 $B^{(t)}$，再用 Sherman-Morrison 公式解出 $D^{(t)}$。</p>\n</blockquote>\n</li>\n<li><p>更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$</p>\n</li>\n<li><p>$s^{(t)} = d^{(t)}$</p>\n</li>\n<li><p>若 $||g^{(t + 1)}|| \\le \\varepsilon$，则迭代终止</p>\n</li>\n<li><p>计算：$y^{(t)} = g^{(t + 1)} - g^{(t)}$</p>\n</li>\n<li><p>$t = t + 1$，跳转第 2 步</p>\n</li>\n</ol>\n<h3 id=\"2-2-L-BFGS\"><a href=\"#2-2-L-BFGS\" class=\"headerlink\" title=\"2.2 L-BFGS\"></a>2.2 L-BFGS</h3><p>在 BFGS 中，每一轮迭代需要存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），但当 $X$ 维数很高时，矩阵的维度也会很高，需要耗费大量存储空间。</p>\n<p>L-BFGS（Limited memory BFGS）不直接存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），而是存储迭代计算过程中的 $s^{(t)}$ 和 $y^{(t)}$ 来计算，从而减少参数存储所需空间。</p>\n<p>在 BFGS 中，Hessian 矩阵的更新公式为：</p>\n<p>$<br>(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>$</p>\n<p>令 $\\rho^{(t)} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}$，$V^{(t)} = \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) = I - \\rho^{(t)} y^{(t)} (s^{(t)})^T$</p>\n<blockquote>\n<p>由于向量 $s^{(t)}$（X的变化量）和向量 $y^{(t)}$（梯度变化量）的维数相同（都与 $X$ 维度相等），因此 $s^{(t)} (y^{(t)})^T$ 和 $s^{(t)} (s^{(t)})^T$ 是矩阵，而 $(y^{(t)})^T s^{(t)}$ 是一个数值，因此 $\\rho^{(t)}$ 是一个常数。</p>\n</blockquote>\n<p>则有：</p>\n<p>$<br>\\begin{aligned}<br>(V^{(t)})^T &amp;= \\left( I - \\rho^{(t)} y^{(t)} (s^{(t)})^T \\right)^T<br>\\\\<br>&amp;= I - \\rho^{(t)} \\left( y^{(t)} (s^{(t)})^T \\right)^T<br>\\\\<br>&amp;= I - \\rho^{(t)} s^{(t)} (y^{(t)})^T<br>\\\\<br>&amp;= I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}}<br>\\end{aligned}<br>$</p>\n<p>因此原 Hessian 更新公式变为：</p>\n<p>$$<br>D^{(t + 1)} = (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>$$</p>\n<p>将上述迭代更新公式展开得：</p>\n<p>$<br>\\begin{aligned}<br>D^{(t + 1)} &amp;= (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\\\<br>&amp; \\Downarrow<br>\\\\<br>D^{(1)} &amp;= (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T<br>\\\\ \\\\<br>D^{(2)} &amp;= (V^{(1)})^T D^{(1)} V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\\\<br>&amp;= (V^{(1)})^T \\left( (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right) V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\\\<br>&amp;= (V^{(1)})^T (V^{(0)})^T D^{(0)} V^{(0)} V^{(1)} + (V^{(1)})^T \\rho^{(0)} s^{(0)} (s^{(0)})^T V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T<br>\\\\<br>&amp; \\ \\ \\vdots<br>\\\\<br>D^{(t + 1)} &amp;= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(0)})^T \\right] D^{(0)} \\left[ V^{(0)} V^{(1)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(1)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(1)} V^{(2)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(2)})^T \\right] \\left[ \\rho^{(1)} s^{(1)} (s^{(1)})^T \\right] \\left[ V^{(2)} V^{(3)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\ \\cdots \\cdots<br>\\\\<br>&amp; \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}<br>\\\\<br>&amp; \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\end{aligned}<br>$</p>\n<p>从上述迭代过程可知，计算 $D^{(t + 1)}$ 需要用到 $\\left \\{ s^{(k)} y^{(k)} \\right \\}^t_{k = 0}$，若存储空间有限，仅能存储 m 组 $\\left \\{ s^{(k)} y^{(k)} \\right \\}$，当 $t &gt; m$ 时，应当丢弃较早生成的 $\\left \\{ s^{(k)} y^{(k)} \\right \\}$。当然，由于丢弃了部分信息，此时计算的 $D^{(m + 1)}$ 是 $D^{(t + 1)}$ 的近似，也即 Hessian 矩阵的逆矩阵的进一步近似。</p>\n<p>当 $t &gt; m + 1$ 时，构造近似公式：</p>\n<p>$<br>\\begin{aligned}<br>D^{(t + 1)} &amp;= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 1)})^T \\right] D^{(0)} \\left[ V^{(t - m + 1)} V^{(1)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 2)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(t - m + 2)} V^{(2)} \\dots V^{(t)} \\right]<br>\\\\<br>&amp; \\ + \\ \\cdots \\cdots<br>\\\\<br>&amp; \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}<br>\\\\<br>&amp; \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T<br>\\end{aligned}<br>$</p>\n<p>$D^{(t)}$ 的迭代计算很繁琐，但计算 $D^{(t)}$ 的目的是为了得到搜索方向 $d^{(t)} = D^{(t)} g^{(t)}$，因此可以设计快速计算 $D^{(t)} g^{(t)}$ 的方法：</p>\n<p><img data-src=\"./double_circle_direction.png\" alt=\"双向循环快速求解搜索方向\" title=\"@ASSET\"></p>\n<p>算法中还有部分不太明白，暂时只放上图片，待研究透彻后改为 Python 代码形式。另有几篇关于该双向循环快速求解 $D^{(t)} g^{(t)}$ 算法的参考文章如下：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://blog.csdn.net/red_stone1/article/details/80821760\" title=\"@LINK\">机器学习中牛顿法凸优化的通俗解释</a></li>\n<li><a href=\"https://blog.csdn.net/itplus/article/details/21897715\" title=\"@LINK\">牛顿法与拟牛顿法学习笔记（五）L-BFGS 算法</a></li>\n<li><a href=\"https://blog.csdn.net/snaillup/article/details/53524415\" title=\"@LINK\">spark L-BFGS实现</a></li>\n<li><a href=\"https://github.com/scalanlp/breeze/blob/master/math/src/main/scala/breeze/optimize/LBFGS.scala\" title=\"@LINK\">LBFGS.scala</a></li>\n<li><a href=\"https://liuxiaofei.com.cn/blog/lbfgs方法推导/#lbfgs方法推导\" title=\"@LINK\">LBFGS方法推导</a></li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"3-Logistic优化求解算法\"><a href=\"#3-Logistic优化求解算法\" class=\"headerlink\" title=\"3. Logistic优化求解算法\"></a>3. Logistic优化求解算法</h2><p>Logistic 回归采用 Logistic 损失 / 交叉熵损失：</p>\n<p>$<br>L(y, \\mu (X)) = - y \\log (\\mu (X)) - (1 - y) \\log (1 - \\mu (X))<br>$</p>\n<p>其中 $y$ 为真值， $\\mu (X)$ 为预测值为 1 的概率。</p>\n<p>与其他机器学习一样，Logistic 回归的目标函数也包括两项：训练集上的损失和 + 正则项。</p>\n<p>$<br>J(W; \\lambda) = \\sum^N_{i = 1} L(y_i, \\mu (X_i; W)) + \\lambda R(W)<br>$</p>\n<blockquote>\n<p>由于 L1 正则在零点不可导，因此当正则项中含有 L1 正则时，不能直接使用基于梯度、Hessian 矩阵的优化求解算法，而通常使用坐标轴下降法求解，或也可使用次梯度法。</p>\n</blockquote>\n<p>在给定正则参数 $\\lambda$ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W, \\lambda)$，取得最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W, \\lambda)} {\\partial W} = 0$。</p>\n<p>与线性回归模型不同的是，Logistic 回归模型的参数无法用解析法求解，因此可使用迭代法逼近求解。</p>\n<p>其中一阶近似有与梯度相关的几个算法：</p>\n<ul>\n<li>梯度下降（Logistic 使用梯度下降法收敛速度较慢）</li>\n<li>随机梯度下降（SGD）</li>\n<li>随机平均梯度法（SAG）</li>\n<li>随机平均梯度法改进版（SAGA）</li>\n<li>共轭梯度</li>\n<li>坐标轴下降</li>\n</ul>\n<p>二阶近似有：</p>\n<ul>\n<li>牛顿法</li>\n<li>拟牛顿法（BFGS、L-BFGS）</li>\n</ul>\n<p>观察目标函数的损失和部分：</p>\n<p>$<br>J_1 (W) = \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)<br>$</p>\n<h3 id=\"3-1-梯度\"><a href=\"#3-1-梯度\" class=\"headerlink\" title=\"3.1 梯度\"></a>3.1 梯度</h3><p>最优化问题的求解离不开梯度的计算，由于目标函数中包含了 $\\mu$，即 Sigmoid 变换，记 $\\mu_i = \\mu (X_i; W) = \\sigma (W^T X_i)$，令 $z_i = W^T X_i$，根据复合函数的求导，$\\dfrac {\\partial \\mu_i} {\\partial W}$ 的求解如下：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {\\partial \\mu_i} {\\partial W} &amp;= \\dfrac {\\partial \\sigma (W^T X_i)} {\\partial W} = \\dfrac {\\partial \\sigma {z_i}} {\\partial W}<br>\\\\<br>&amp;= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}<br>\\end{aligned}<br>$</p>\n<p>其中 ① 复合函数外层 $\\sigma (z_i)$ 求导：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {d \\sigma (z_i)} {d z_i} &amp;= \\dfrac {d (\\dfrac {1} {1 + e^{- z_i}})} {d z_i}<br>\\\\<br>&amp;= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times \\dfrac {d (1 + e^{- z_i})} {d z_i}<br>\\\\<br>&amp;= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times (- e^{- z_i})<br>\\\\<br>&amp;= \\dfrac {1} {(1 + e^{- z_i})^2} \\times (e^{- z_i})<br>\\\\<br>&amp;= \\dfrac {1} {1 + e^{- z_i}} \\times \\dfrac {(1 + e^{- z_i}) - 1} {1 + e^{- z_i}}<br>\\\\<br>&amp;= \\sigma (z_i) \\times (1 - \\sigma (z_i))<br>\\end{aligned}<br>$</p>\n<p>② 复合函数内层 $z_i$ 求导：</p>\n<p>$<br>\\dfrac {\\partial z_i} {\\partial W} = \\dfrac {\\partial (W^T X_i)} {\\partial W} = X_i<br>$</p>\n<p>综合上述 2 式得：</p>\n<p>$<br>\\begin{aligned}<br>\\dfrac {\\partial \\mu_i} {\\partial W} &amp;= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}<br>\\\\<br>&amp;= \\sigma (z_i) \\times (1 - \\sigma (z_i)) \\times X_i<br>\\\\<br>&amp;= \\mu_i \\times (1 - \\mu_i) \\times X_i<br>\\end{aligned}<br>$</p>\n<p>回到目标函数梯度，将上式代入求导得：</p>\n<p>$<br>\\begin{aligned}<br>J_1 (W) &amp;= \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)<br>\\\\<br>&amp;= \\sum^N_{i = 1} \\left( - y_i \\log \\mu_i - (1 - y_i) \\log (1 - \\mu_i) \\right)<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left(y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right)<br>\\end{aligned}<br>$</p>\n<p>$<br>\\begin{aligned}<br>g_1 (W) &amp;= \\nabla J_1 (W) = \\dfrac {d J_1 (W)} {d W}<br>\\\\<br>&amp;= - d \\left( \\sum^N_{i = 1} \\left( y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right) \\right) / d W<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} \\times \\dfrac {\\partial \\mu_i} {\\partial W} + (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\times - \\dfrac {\\partial \\mu_i} {\\partial W} \\right)<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} - (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\right) \\times \\mu_i (1 - \\mu_i) X_i<br>\\\\<br>&amp;= - \\sum^N_{i = 1} \\left( y_i (1 - \\mu_i) - (1 - y_i) \\mu_i \\right) \\times X_i<br>\\\\<br>&amp;= - \\sum^N_{i = 1} (y_i - \\mu_i) \\times X_i<br>\\\\<br>&amp;= (\\mu - y) X<br>\\end{aligned}<br>$</p>\n<p><strong>整理可得 Logistic 回归损失和部分的梯度表达式：</strong></p>\n<p>$$<br>g_1 (W) = X^T (\\mu - y)<br>$$</p>\n<blockquote>\n<p>这里直接解出来的结果是 $(\\mu - y) X$，但表达式使用的是 $X^T (\\mu - y)$，对此我有些自己的理解方式如下。</p>\n</blockquote>\n<p>首先要提一下矩阵的形式。在机器学习中有一个很重要的工具包 <code>numpy</code>，这个工具包里其中两个很重要的类：<code>numpy.matrix</code> 和 <code>numpy.array</code>也即矩阵和向量，通常手动创建一个矩阵的时候可以用如下方式：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>A = np.matrix([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(A)</span><br><span class=\"line\">[[<span class=\"number\">1</span> <span class=\"number\">2</span>]</span><br><span class=\"line\"> [<span class=\"number\">3</span> <span class=\"number\">4</span>]]</span><br></pre></td></tr></table></figure>\n\n<p>这就可以视为一个 2 x 2 的矩阵：$\\left[ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{matrix} \\right]$，但是当我们如下创建一个向量时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>B = np.array([<span class=\"number\">1</span>, <span class=\"number\">2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(B)</span><br><span class=\"line\">[<span class=\"number\">1</span> <span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(B.shape)</span><br><span class=\"line\">(<span class=\"number\">2</span>,)</span><br></pre></td></tr></table></figure>\n\n<p><strong>可以看到，尽管输出的 B 的形式还是 <code>[1 2]</code>，但这是一个 2 行（也即 1 列）的向量（之所以没有标出 <code>(2, 1)</code> 是因为向量要么只有 1 行要么只有 1 列，防止与矩阵的 n x m 搞混了）。也就是说，默认情况下的向量是列向量，这也符合机器学习中的直觉，例如标签 y，预测值，或单个特征等都是列向量。</strong></p>\n<p><strong>回到原问题的梯度表达式中，假设训练数据共有 D 维特征 N 个样本，则 X 是 N x D 维的矩阵，$\\mu$ 和 y 均为 N 行的列向量，都知道矩阵的乘法 (A x B) 需要满足 A 的列数 = B 的行数时才有意义，而当作为矩阵运算 $(\\mu - y) X$ 时，$(\\mu - y)$ 列数为 1，此时无论 $X$ 是否转置，$(\\mu - y) X$ 都无意义，不能做乘法运算。因此 $\\sum^N_{i = 1} (\\mu_i - y_i) \\times X_i$ 转换为矩阵表达式时，将 $X$ 提到左乘并转置，不仅 $X^T$ 的列数恰好为 N，与 $\\mu$ 和 $y$ 的行数相等，可以做乘法，而且从矩阵的乘法运算规则上符合直观地计算过程（$X$ 转置后，每一列为一个样本，分别与每个 $(\\mu_i - y_i)$ 相乘）。</strong></p>\n<p><strong>因此，梯度的表达式为：$g_1 (W) = X^T (\\mu - y)$。</strong></p>\n<h3 id=\"3-2-Hessian矩阵\"><a href=\"#3-2-Hessian矩阵\" class=\"headerlink\" title=\"3.2 Hessian矩阵\"></a>3.2 Hessian矩阵</h3><p>Logistic 损失和部分的梯度为 $g_1 (W) = X^T (\\mu - y)$，由此求解 Hessian 矩阵：</p>\n<p>$<br>\\begin{aligned}<br>H_1 (W) &amp;= \\dfrac {\\partial g_1 (W)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} (\\mu_i - y_i) X_i \\right)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} X^T_i (\\mu_i - y_i) \\right)} {\\partial W}<br>\\\\<br>&amp;= \\sum^N_{i = 1} X^T_i \\dfrac {\\partial (\\mu_i)} {\\partial W}<br>\\\\<br>&amp;= \\sum^N_{i = 1} X^T_i \\mu_i (1 - \\mu_i) X_i<br>\\end{aligned}<br>$</p>\n<blockquote>\n<p>说明：$\\dfrac {\\partial (a^T y)} {\\partial y} = a^T$</p>\n</blockquote>\n<p><strong>令矩阵 $S \\triangleq \\mu_i (1 - \\mu_i)$，即 $S$ 为对角阵，对角元素为 $\\mu_i (1 - \\mu_i)$。可得 Hessian 矩阵表达式：</strong></p>\n<p>$$<br>H_1 (W) = X^T S X<br>$$</p>\n<h3 id=\"3-3-牛顿法求解Logistic损失函数和极小值：IRLS\"><a href=\"#3-3-牛顿法求解Logistic损失函数和极小值：IRLS\" class=\"headerlink\" title=\"3.3 牛顿法求解Logistic损失函数和极小值：IRLS\"></a>3.3 牛顿法求解Logistic损失函数和极小值：IRLS</h3><p>当解得梯度 $g_1 (W) = X^T (\\mu - y)$ 和 Hessian 矩阵 $H_1 (W) = X^T S X$ 后，即可代入牛顿迭代公式中：</p>\n<p>$<br>\\begin{aligned}<br>W^{(t + 1)} &amp;= W^{(t)} - H(W^{(t)})^{-1} g(W)<br>\\\\<br>&amp;= W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} (X^T S^{(t)} X) \\times W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T (\\mu - y) \\right)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T S^{(t)} {S^{(t)}}^{-1} (\\mu - y) \\right)<br>\\\\<br>&amp;= (X^T S^{(t)} X)^{-1} X^T S^{(t)} \\times \\left( X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y) \\right)<br>\\end{aligned}<br>$</p>\n<p><strong>令 $z^{(t)} \\triangleq X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y)$，则得到牛顿法迭代求 Logistic 损失函数和极小值的解：</strong></p>\n<p>$$<br>W^{(t + 1)} = (X^T S^{(t)} X)^{-1} X^T S^{(t)} z^{(t)}<br>$$</p>\n<p>对比线性回归 $X W = y$ 方程中最小二乘的解：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，给每个样本加权（每个样本的权重为 $S_i$）即可得加权最小二乘的解：</p>\n<p>$<br>\\hat{W}_{OLS_weight} = (X^T S X)^{-1} X^T y<br>$</p>\n<p>牛顿迭代法求得的 Logistic 损失函数和极小值的解 与 加权最小二乘的解形式类似，因此也称为 <strong>迭代加权最小二乘（Iteratively Reweighted Least Squares, IRLS）</strong>，其中每个样本的权重为 $S_i = \\mu_i (1 - \\mu_i)$。而 IRLS 又通过 共轭梯度（Conjugate Gradient）法 求解，因此 Scikit-Learn 中采用牛顿法求解的优化算法为 <code>&#39;newton-cg&#39;</code>。</p>\n<hr>\n<h2 id=\"4-Logistic的优化求解器Solver\"><a href=\"#4-Logistic的优化求解器Solver\" class=\"headerlink\" title=\"4. Logistic的优化求解器Solver\"></a>4. Logistic的优化求解器Solver</h2><p>Logistic 回归有多种优化求解方法。当使用 L2 正则时，可采用所有优化算法，而由于 L1 正则在零点处不可导，因此次不能使用需要计算梯度 / Hessian 矩阵的方法，此时可以类似 Lasso 求解，采用坐标轴下降法。</p>\n<p>Scikit-Learn 中的 Logistic 类已在：<a href=\"/post/machinelearning/ml-logistic/ml-logistic-introduction/ml-logistic-introduction/\" title=\"@LINK\">《ML入门——Logistic回归简介》</a> 文中介绍，此处展开参数 <code>solver</code> 的一些可选项：</p>\n<p>&#39;liblinear&#39;：<br>线性求解器，适用于小数据集，支持 L1 正则和 L2 正则。<br>内部使用了坐标轴下降法来迭代优化损失函数，如果模型的特征非常多，希望一些不重要的特征系数归零从而让模型系数稀疏的话，可以使用 L1 正则化。在多类 Logistic 回归任务中仅支持 OvR，不支持多项分布损失（MvM），但 MVM 相对精确。</p>\n<p>&#39;lbfgs&#39;：<br>拟牛顿法，适用于较大数据集，仅支持 L2 正则。<br>支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>&#39;newton-cg&#39;：<br>牛顿法，适用于较大数据集，仅支持 L2 正则。<br>每个大迭代中的加权最小二乘回归部分采用共轭梯度算法实现。支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>&#39;sag&#39;：<br>随机平均梯度下降，适用于很大（如大于 5 万）的数据集，仅支持 L2 正则。<br>梯度下降法的变种，支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>&#39;saga&#39;：<br>改进的随机平均梯度下降，适用于非常大的数据集，支持 L1 正则。<br>当数据量很大，且选择 L1 正则时，只能采用 &#39;saga&#39; 优化求解器。支持 OvR 和 MvM 两种多类 Logistic 回归。</p>\n<p>其中，&#39;sag&#39; 和 &#39;saga&#39; 只有在特征尺度大致相等时才能保证收敛，因此需要对数据做缩放（<code>class sklearn.preprocessing</code> 可以实现如：标准化、MinMaxScaler、MaxAbsScaler 等）。在实际任务中，大部分情况下数据预处理时都最好做标准化。实际上，加正则项本身也要求对每维特征做缩放。</p>\n<p>另外，对于大数据集的训练任务，可以使用 <code>SGDClassifier</code>，并使用 LogLoss 作为损失函数。</p>\n<blockquote>\n<p>若 <code>SGDClassifier</code> 使用 HingeLoss 作为损失函数，则为实现随机梯度下降的 SVM。在回归任务中还有 <code>SDGRegressor</code>。</p>\n</blockquote>\n","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-类别样本不均衡问题","url":"/post/machinelearning/ml-logistic/ml-logistic-unbalanced/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-类别样本不均衡问题\"><a href=\"#ML入门-类别样本不均衡问题\" class=\"headerlink\" title=\"ML入门-类别样本不均衡问题\"></a>ML入门-类别样本不均衡问题</h1>","categories":["MachineLearning","LogisticRegression"],"tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"]},{"title":"ML入门-模型性能评价指标","url":"/post/machinelearning/ml-model/ml-model-performance/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-模型性能评价指标\"><a href=\"#ML入门-模型性能评价指标\" class=\"headerlink\" title=\"ML入门-模型性能评价指标\"></a>ML入门-模型性能评价指标</h1><p>前言：一个机器学习模型训练好后，需要采用一些度量准则评价模型预测的效果。根据任务的种类可以分为回归模型评价指标和分类模型评价指标。</p>\n<hr>\n<h2 id=\"1-回归模型性能评价指标\"><a href=\"#1-回归模型性能评价指标\" class=\"headerlink\" title=\"1. 回归模型性能评价指标\"></a>1. 回归模型性能评价指标</h2><h3 id=\"1-1-常见的-6-种评价指标\"><a href=\"#1-1-常见的-6-种评价指标\" class=\"headerlink\" title=\"1.1 常见的 6 种评价指标\"></a>1.1 常见的 6 种评价指标</h3><p>（1）开放均方误差（Rooted Mean Squared Error, RMSE）：</p>\n<p>$<br>RMSE(y, \\hat{y}) = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i, \\hat{y_i})^2}<br>$</p>\n<p>开放的目的在于使得 RMSE 的返回值与 $y$ 的单位一致。</p>\n<p>（2）平均绝对值误差（Mean Absolute Error, MAE）：</p>\n<p>$<br>MAE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} |y_i - \\hat{y_i}|<br>$</p>\n<p>（3）绝对误差中值（Median Absolute Error, MedAE）：</p>\n<p>$<br>MedAE(y, \\hat{y}) = median(|y_1 - \\hat{y_1}|, \\cdots, |y_N - \\hat{y_N}|)<br>$</p>\n<p>相对于均值，中值对噪声点较不敏感。</p>\n<p>（4）平均平方 $\\log$ 误差（Mean Squared Logarithmic Error, MSLE）：</p>\n<p>$<br>MSLE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} \\left( \\log (1 + y_i) - \\log (1 + \\hat{y_i}) \\right)^2<br>$</p>\n<p>当 $y$ 呈指数增长时可以使用，如计数、一年的平均销量、价格等。$1 + y_i$ 与 $1 + \\hat{y_i}$ 的目的是为了确保 $\\log$ 计算有意义（当 $y_i / \\hat{y_i} = 0$ 时，$\\log 0$ 无意义）。</p>\n<p>（5）$R^2$ 分数（$R^2$ Score）：</p>\n<p>$<br>\\begin{aligned}<br>&amp; SS_{res}(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2<br>\\\\<br>&amp; SS_{tot}(y) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\bar{y})^2<br>\\\\<br>&amp; R^2(y, \\hat{y}) = 1 - \\dfrac {SS_{res}(y, \\hat{y})} {SS_{tot}(y)}<br>\\end{aligned}<br>$</p>\n<p>$R^2$ 分数既考虑了预测值与真实值之间的差异，又考虑了问题本身针织之间的差异，是 Scikit-Learn 线性回归模型的默认评价准则。当 $SS_{res} = 0$ 时，$R^2 = 1$ 为最佳分数，分数越低则模型性能越差，可能为负值。</p>\n<p>（6）已解释的访查分数（Explained variance socre）：</p>\n<p>$<br>explained_variance(y, \\hat{y}) = 1 - \\dfrac {Var(y - \\hat{y})} {Var \\{ y \\} }<br>$</p>\n<h3 id=\"1-2-Scikit-Learn中的评价指标\"><a href=\"#1-2-Scikit-Learn中的评价指标\" class=\"headerlink\" title=\"1.2 Scikit-Learn中的评价指标\"></a>1.2 Scikit-Learn中的评价指标</h3><p>Scikit-Learn 中有三种评价模型性能的方式，但基本都是通过上述 6 种计算方式实现的。</p>\n<p>（1）每个学习器 Estimator 自己的 <code>score</code> 方法，提供一个默认的评估方法（回归为 $R^2$ 分数）。</p>\n<p>（2）Metric：<code>sklearn.metrics</code> 模块实现了一些函数，用来评估预测误差。</p>\n<p><code>sklearn.metrics</code> 中的回归评价指标：</p>\n<p>① <code>metrics.explained_variance_score(y_true, y_pred)</code>：Explained variance regression score function<br>② <code>metrics.mean_absolute_error(y_true, y_pred)</code>：Mean-Absolute-Error regression loss<br>③ <code>metrics.mean_squared_error(y_true, y_pred[, ...])</code>：Mean-Squared-Error regression loss<br>④ <code>metrics.mean_squared_log_error(y_true, y_pred)</code>：Mean-Squared-Logarithmic-Error regression loss<br>⑤ <code>metrics.median_absolute_error(y_true, y_pred)</code>：Median-Absolute-Error regression loss<br>⑥ <code>metrics.r2_score(y_true, y_pred[, ...])</code>：$R^2$ (coefficient of determination) regression score function.</p>\n<p>（3）Scoring 参数：使用交叉验证评估模型的工具有 Scoring 参数，与 Metrics 一一对应。</p>\n<p>① <code>explained_variance</code>；metrics.explained_variance_score<br>② <code>neg_mean_absolute_error</code>：metrics.mean_absolute_error<br>③ <code>neg_mean_squared_error</code>：metrics.mean_squared_error<br>④ <code>neg_mean_squared_log_error</code>：metrics.mean_squared_log_error<br>⑤ <code>neg_median_absolute_error</code>：metrics.median_absolute_error<br>⑥ <code>r2</code>：metrics.r2_score</p>\n<p>Scoring 越高代表模型性能越好，其中 explained_variance 和 $R^2$ 本来即越高越好，因此 Scoring 可直接使用。第 ②、③、④、⑤ 个参数取“error”对应 误差 / 损失，因此对 error 取负数“neg_”。</p>\n<hr>\n<h2 id=\"2-分类模型性能评价指标\"><a href=\"#2-分类模型性能评价指标\" class=\"headerlink\" title=\"2. 分类模型性能评价指标\"></a>2. 分类模型性能评价指标</h2>","categories":["MachineLearning","Model"],"tags":["AI","MachineLearning","人工智能","机器学习","评价指标"]},{"title":"ML入门-交叉验证与模型选择","url":"/post/machinelearning/ml-model/ml-model-selection/","content":"<span id=\"more\"></span>\n\n<h1 id=\"ML入门-交叉验证与模型选择\"><a href=\"#ML入门-交叉验证与模型选择\" class=\"headerlink\" title=\"ML入门-交叉验证与模型选择\"></a>ML入门-交叉验证与模型选择</h1><h2 id=\"1-模型的交叉验证\"><a href=\"#1-模型的交叉验证\" class=\"headerlink\" title=\"1. 模型的交叉验证\"></a>1. 模型的交叉验证</h2><h3 id=\"1-1-划分校验集\"><a href=\"#1-1-划分校验集\" class=\"headerlink\" title=\"1.1 划分校验集\"></a>1.1 划分校验集</h3><p>模型的评估不能在训练集上进行，而应该在新的测试数据上检验其 推广能力 / 泛化能力。但在实际任务中，测试数据往往是需要用来预测的数据，其标签是未知的，因此可以选择从全体训练数据中分离出一部分作为校验数据，不参与模型的训练：</p>\n<p><img data-src=\"./check_data.png\" alt=\"校验数据\" title=\"@ASSET\"></p>\n<p>当训练样本足够多时，划分剩下的训练样本仍足以训练出较好的模型时，即可采用这个方式。Scikit-Learn 中提供了划分校验集的功能：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.train_test_split</span></span><br><span class=\"line\"></span><br><span class=\"line\">X_train, X_test, y_train, y_test = train_test_split(*arrays, **options)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X, y = np.arange(<span class=\"number\">10</span>).reshape((<span class=\"number\">5</span>, <span class=\"number\">2</span>)), <span class=\"built_in\">range</span>(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X</span><br><span class=\"line\">array([[<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">      [<span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">      [<span class=\"number\">6</span>, <span class=\"number\">7</span>],</span><br><span class=\"line\">      [<span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">list</span>(y)</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_train, X_test, y_train, y_test = train_test_split(</span><br><span class=\"line\">         X, y, test_size=<span class=\"number\">0.33</span>, random_state=<span class=\"number\">42</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_train</span><br><span class=\"line\">array([[<span class=\"number\">4</span>, <span class=\"number\">5</span>],</span><br><span class=\"line\">      [<span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">      [<span class=\"number\">6</span>, <span class=\"number\">7</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_train</span><br><span class=\"line\">[<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X_test</span><br><span class=\"line\">array([[<span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">      [<span class=\"number\">8</span>, <span class=\"number\">9</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y_test</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>train_test_split(y, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\">[[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>*arrays</code>: 需要划分的数据 (X, y)。sequence of indexables with same length / shape[0].</p>\n<p>Allowed inputs are lists, numpy arrays, scipy-sparse matrices or pandas dataframes.</p>\n</li>\n<li><p><code>test_size</code>: 校验集大小。float, int or None, optional (default=None)</p>\n<p>If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If train_size is also None, it will be set to 0.25.</p>\n</li>\n<li><p><code>train_size</code>: 训练集大小。float, int, or None, (default=None)</p>\n<p>If float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size.</p>\n</li>\n<li><p><code>random_state</code>: 随机种子。int, RandomState instance or None, optional (default=None)</p>\n<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.</p>\n</li>\n<li><p><code>shuffle</code>: 划分数据前是否洗牌。boolean, optional (default=True)</p>\n<p>Whether or not to shuffle the data before splitting. If shuffle=False then stratify must be None.</p>\n</li>\n<li><p><code>stratify</code>: 分层抽样。array-like or None (default=None)</p>\n<ul>\n<li><p>If not None, data is split in a stratified fashion, using this as the class labels.</p>\n</li>\n<li><p>分层抽样主要用在分类数据类别样本不均衡的时候，如正负样本比例为 1 : 9，假设划 20% 作为校验数据，则分别对正样本和负样本各自划分 20% 作为校验数据再合并。</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><code>train_test_split</code> 还能在数据集较大时，用来分隔出小部分数据进行 EDA。</p>\n</blockquote>\n<h3 id=\"1-2-交叉验证\"><a href=\"#1-2-交叉验证\" class=\"headerlink\" title=\"1.2 交叉验证\"></a>1.2 交叉验证</h3><p>当训练数据比较少，或模型训练需要更多数据时（训练样本越多越好），直接分离校验集就不太好了，这时可使用 K 折交叉验证。</p>\n<p>K 折交叉验证即：将全体训练样本等分为 K 份（若无法完全等分，多出来的部分都放进最后一份中），每次用 1 份数据作为校验集，余下 (K - 1) 份作为训练数据，重复 K 次：</p>\n<p><img data-src=\"./k_fold.png\" alt=\"K 折交叉验证\" title=\"@ASSET\"></p>\n<blockquote>\n<p>该方法计算代价很高，但不会浪费太多数据，当样本数据集较少时有优势，K 常取 [3, 5, 10]。</p>\n</blockquote>\n<p>Scikit-Learn 中实现了 K 折交叉验证 <code>KFold</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.KFold</span></span><br><span class=\"line\"></span><br><span class=\"line\">KFold(n_splits=<span class=\"number\">3</span>,</span><br><span class=\"line\">      shuffle=<span class=\"literal\">False</span>,</span><br><span class=\"line\">      random_state=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>n_splits</code>: 交叉验证的折数 K，默认为 3。</p>\n</li>\n<li><p><code>shuffle</code>: 是否在划分数据之前对全体数据进行洗牌（打乱顺序）。</p>\n</li>\n<li><p><code>random_state</code>: 由随机数产生器产生的随机种子。当参数 <code>shuffle == True</code> 时用到。</p>\n</li>\n</ul>\n<p>当数据是分类数据时（标签 y 为类别），为保证每折中各个类别样本比例一致，Scikit-Learn 实现了分层（Stratified）的 K 折交叉验证 <code>StratifiedKFold</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.StratifiedKFold</span></span><br><span class=\"line\"></span><br><span class=\"line\">StratifiedKFold(n_splits=<span class=\"number\">3</span>,</span><br><span class=\"line\">                shuffle=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                random_state=<span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> StratifiedKFold</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = np.array([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>], [<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = np.array([<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf = StratifiedKFold(n_splits=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf.get_n_splits(X, y)  <span class=\"comment\"># 得到划分结果</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>skf</span><br><span class=\"line\">StratifiedKFold(n_splits=<span class=\"number\">2</span>, random_state=<span class=\"literal\">None</span>, shuffle=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> train_index, test_index <span class=\"keyword\">in</span> skf.split(X, y):</span><br><span class=\"line\">    <span class=\"comment\"># split() 取出每折训练和校验数据的索引</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;TRAIN:&quot;</span>, train_index, <span class=\"string\">&quot;TEST:&quot;</span>, test_index)</span><br><span class=\"line\">        X_train, X_test = X[train_index], X[test_index]</span><br><span class=\"line\">        y_train, y_test = y[train_index], y[test_index]</span><br><span class=\"line\"></span><br><span class=\"line\">TRAIN: [<span class=\"number\">1</span> <span class=\"number\">3</span>] TEST: [<span class=\"number\">0</span> <span class=\"number\">2</span>]</span><br><span class=\"line\">TRAIN: [<span class=\"number\">0</span> <span class=\"number\">2</span>] TEST: [<span class=\"number\">1</span> <span class=\"number\">3</span>]</span><br></pre></td></tr></table></figure>\n\n<p><code>StratifiedKFold</code> 参数含义与 <code>KFold</code> 相同。</p>\n<p>假设有一训练数据集如下表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">样本索引</th>\n<th align=\"center\">$x_1$</th>\n<th align=\"center\">$x_2$</th>\n<th align=\"center\">y</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">3</td>\n<td align=\"center\">4</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>K 折交叉验证中，校验验证通常用于 模型选择 / 超参数调优（评价不同超参数对应模型的性能）。交叉验证的步骤流程如下图：</p>\n<p><img data-src=\"./k_fold_detail.png\" alt=\"K 折交叉验证流程\" title=\"@ASSET\"></p>\n<p>Scikit-Learn 中实现两个了采用 K 折交叉验证评估模型性能的函数：<code>cross_val_score</code> 和 <code>cross_validate</code>：</p>\n<h4 id=\"1-2-1-cross-val-score\"><a href=\"#1-2-1-cross-val-score\" class=\"headerlink\" title=\"1.2.1 cross_val_score\"></a>1.2.1 cross_val_score</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.cross_val_score</span></span><br><span class=\"line\"></span><br><span class=\"line\">cross_val_score(estimator,</span><br><span class=\"line\">                X,</span><br><span class=\"line\">                y=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                groups=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">                verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">                fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets, linear_model</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_val_score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>diabetes = datasets.load_diabetes()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = diabetes.data[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = diabetes.target[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lasso = linear_model.Lasso()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(cross_val_score(lasso, X, y, cv=<span class=\"number\">3</span>))</span><br><span class=\"line\">[<span class=\"number\">0.33150734</span> <span class=\"number\">0.08022311</span> <span class=\"number\">0.03531764</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>estimator</code>: 要训练的模型</p>\n</li>\n<li><p><code>X, y</code>: 全体训练数据</p>\n</li>\n<li><p><code>groups</code>: 数据的分组标识。</p>\n<p>通常假设数据是独立同分布（Independent Identical Distribution, IID），但在有些应用中如果数据生成过程依赖于样本的 groups，（如从多个患者收集医学数据，从每个患者身上采集多个样本。则每个样本的患者 ID 是其分组标识）。在这种情况下，想知道在一组特定的 groups 上训练的模型是否能很好地适用于未见过的 group 。因此，要确保验证数据的所有样本与对应的训练折中的数据没有相同的组。（Scikit-Learn 中有一整套与 groups 有关的校验验证实现）。</p>\n</li>\n<li><p><code>scoring</code>: 评价指标。</p>\n</li>\n<li><p><code>cv</code>: 交叉校验划分策略。可为整数（交叉验证的折数 K）、交叉验证生成器的对象、产生 train / test 划分的迭代器对象。默认为 <code>None</code>，采用3折交叉验证。输入类别数据时，自动采用分层抽样。</p>\n</li>\n<li><p><code>n_jobs</code>: 使用CPU的数目，-1 表示使用所有的CPU资源（与设置为 CPU 核的数目效果相同）。</p>\n</li>\n<li><p><code>verbose</code>: 日志冗长度。</p>\n<ul>\n<li>0：不输出训练过程</li>\n<li>1：偶尔输出</li>\n<li>$&gt; 1$：对每个子模型都输出</li>\n</ul>\n</li>\n<li><p><code>fit_params</code>: estimator 的 <code>fit()</code> 函数需要的参数。</p>\n</li>\n<li><p><code>pre_dispatch</code>: 控制并行计算中预派遣的任务数。</p>\n<p>根据设备条件（内存大小）设置。例如 12 折 CV 任务，且 <code>n_jobs = 3</code>。</p>\n<ol>\n<li>当该参数不设置时，程序一次性将所有并行任务派遣给 CPU，则 3 个 CPU 各获得 4 份 CV 训练数据集和 4 份 测试数据集，并存放在内存中，各个 CPU 则按顺序训练，此时内存占用最高，但由于提前一次性将所有数据分配完毕，开始训练后的等待时间最小。</li>\n<li>当设置 <code>pre_dispatch=&#39;1*n_jobs&#39;</code> 时，本例中即 <code>pre_despatch == 3</code>，则程序每次只为 3 个 CPU 各分配一份数据，分配后 CPU 立即开始训练，训练完成后再次分配，此时内存占用最低，但由于每次训练完后才分配数据，开始训练后的等待时间最长。</li>\n<li>当设置 <code>pre_dispatch=&#39;2*n_jobs&#39;</code> 时，本例中即 <code>pre_despatch == 6</code>，则 3 个 CPU 各获得两份 CV 训练数据（一份即时训练，另一份在队列中等待）并存储在内存中，当某个 CPU 训练完一份 CV 数据后，程序再分配下一份数据，直到所有数据均被分配完毕。通常这种设置的综合效果最佳。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-2-cross-validate\"><a href=\"#1-2-2-cross-validate\" class=\"headerlink\" title=\"1.2.2 cross_validate\"></a>1.2.2 cross_validate</h4><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.cross_validate</span></span><br><span class=\"line\"></span><br><span class=\"line\">cross_validate(estimator,</span><br><span class=\"line\">               X,</span><br><span class=\"line\">               y=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               groups=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">               verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">               fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">               pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>,</span><br><span class=\"line\">               return_train_score=<span class=\"string\">&#x27;warn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets, linear_model</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> cross_validate</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.metrics.scorer <span class=\"keyword\">import</span> make_scorer</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> confusion_matrix</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.svm <span class=\"keyword\">import</span> LinearSVC</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>diabetes = datasets.load_diabetes()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>X = diabetes.data[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = diabetes.target[:<span class=\"number\">150</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>lasso = linear_model.Lasso()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Single metric evaluation using cross_validate</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cv_results = cross_validate(lasso, X, y, cv=<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(cv_results.keys())</span><br><span class=\"line\">[<span class=\"string\">&#x27;fit_time&#x27;</span>, <span class=\"string\">&#x27;score_time&#x27;</span>, <span class=\"string\">&#x27;test_score&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># cross_validate 可以得到每折的训练和校验得分，此处仅查看校验得分。</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>cv_results[<span class=\"string\">&#x27;test_score&#x27;</span>]</span><br><span class=\"line\">array([<span class=\"number\">0.33150734</span>, <span class=\"number\">0.08022311</span>, <span class=\"number\">0.03531764</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Multiple metric evaluation using cross_validate</span></span><br><span class=\"line\"><span class=\"comment\"># (please refer the scoring parameter doc for more information)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>scores = cross_validate(lasso, X, y, cv=<span class=\"number\">3</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>                        scoring=(<span class=\"string\">&#x27;r2&#x27;</span>,</span><br><span class=\"line\"><span class=\"meta\">... </span>                                 <span class=\"string\">&#x27;neg_mean_squared_error&#x27;</span>),</span><br><span class=\"line\"><span class=\"meta\">... </span>                        return_train_score=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多种评价指标：&#x27;r2&#x27;, &#x27;neg_mean_squared_error&#x27;</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(scores[<span class=\"string\">&#x27;test_neg_mean_squared_error&#x27;</span>])</span><br><span class=\"line\">[-<span class=\"number\">3635.5</span>... -<span class=\"number\">3573.3</span>... -<span class=\"number\">6114.7</span>...]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(scores[<span class=\"string\">&#x27;train_r2&#x27;</span>])</span><br><span class=\"line\">[<span class=\"number\">0.28010158</span> <span class=\"number\">0.39088426</span> <span class=\"number\">0.22784852</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>return_train_score</code>: 是否包含训练得分。</p>\n<p>默认 &#39;warn&#39; 表示真，包含训练得分。计算训练得分可以通过训练得分和校验得分查看模型在过拟合状态还是欠拟合状态。但是训练得分较慢，且不计算也不影响模型 的最佳参数选取（最佳参数只看校验得分），后续版本可能将缺省值设为 <code>False</code>。</p>\n</li>\n<li><p>其他参数与 <code>cross_val_score</code> 相同。</p>\n</li>\n</ul>\n<p>使用 <code>cross_validate</code> 可以输出训练集和校验集上的分数，从而判断是否处于欠拟合或过拟合的状态。</p>\n<h3 id=\"1-3-特殊的交叉验证\"><a href=\"#1-3-特殊的交叉验证\" class=\"headerlink\" title=\"1.3 特殊的交叉验证\"></a>1.3 特殊的交叉验证</h3><h4 id=\"1-3-1-留一交叉验证\"><a href=\"#1-3-1-留一交叉验证\" class=\"headerlink\" title=\"1.3.1 留一交叉验证\"></a>1.3.1 留一交叉验证</h4><p>特别地，当交叉验证的折数与样本数相等时（$K = N$），因为每次仅留出一个样本做校验，因此称为留一交叉验证。由于折数更多，通常进行时间也更长，一般仅在样本数非常少的时候使用。</p>\n<p>但对于线性模型，可以采用广义交叉验证（Generalized Cross Validation, GCV）来近似留一交叉验证，极大降低交叉验证的计算量。Scikit-Learn 中实现了基于 GCV 的线性模型，如：<code>RidgeCV</code>, <code>LassoCV</code>, <code>LogisticRegressionCV</code> 等。其流程大致如下图：</p>\n<p><img data-src=\"./leave_one_cv.png\" alt=\"留一交叉验证\" title=\"@ASSET\"></p>\n<h4 id=\"1-3-2-自助法（Bootstrap）\"><a href=\"#1-3-2-自助法（Bootstrap）\" class=\"headerlink\" title=\"1.3.2 自助法（Bootstrap）\"></a>1.3.2 自助法（Bootstrap）</h4><p>交叉验证（包括留一交叉验证）均为无放回采样，一个实例仅能被选择一次。而 Bootstrap 是有放回采样，假设数据集中有 N 个样本，每次有放回地从数据集中抽取一个样本，共采样 N 次。一个 Bootstrap 样本有 N 个样本，其中很可能存在重复数据。由于每个样本被采样的概率为 $\\dfrac {1} {N}$，则不被采样的概率为 $1 - \\dfrac {1} {N}$，因此一个 Bootstrap 的 N 个样本中，某个样本点不被采样的概率为 $(1 - \\dfrac{1} {N})^N \\approx 0.368$，也即一个 Bootstrap 样本中只包含了全体训练集中约 $63.2 \\%$ 的数据（K 折交叉验证每次包含 $1 - \\dfrac {1} {K}$ 的训练数据），因此也称为“0.632 自助法”。</p>\n<h4 id=\"1-3-3-特殊的校验验证\"><a href=\"#1-3-3-特殊的校验验证\" class=\"headerlink\" title=\"1.3.3 特殊的校验验证\"></a>1.3.3 特殊的校验验证</h4><p>通常，训练数据假设是独立同分布的（Independent Identical Distribution, IID）。</p>\n<p>但在实际任务中，有时样本时使用与时间相关的过程生成的，也即样本间存在时序关系，样本与各自的时序强相关，例如股票的价格等，此时使用 time-series aware cross-validation scheme 更安全。</p>\n<p>同样，如果知道数据生成过程中具有分组结构（group structure），例如从不同 subjects、不同实验、不同测量设备收集的样本等，则使用 group-wise cross-validation 更安全。</p>\n<hr>\n<h2 id=\"2-超参数调优\"><a href=\"#2-超参数调优\" class=\"headerlink\" title=\"2. 超参数调优\"></a>2. 超参数调优</h2><p>Scikit-Learn 中实现了基于交叉验证的模型超参数调优方法 <code>GridSearchCV</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># class sklearn.model_selection.GridSearchCV</span></span><br><span class=\"line\"></span><br><span class=\"line\">GridSearchCV(estimator,</span><br><span class=\"line\">             param_grid,</span><br><span class=\"line\">             scoring=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             fit_params=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             n_jobs=<span class=\"number\">1</span>,</span><br><span class=\"line\">             iid=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             refit=<span class=\"literal\">True</span>,</span><br><span class=\"line\">             cv=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             verbose=<span class=\"number\">0</span>,</span><br><span class=\"line\">             pre_dispatch=<span class=\"string\">&#x27;2*n_jobs&#x27;</span>,</span><br><span class=\"line\">             error_score=<span class=\"string\">&#x27;raise&#x27;</span>,</span><br><span class=\"line\">             return_train_score=<span class=\"string\">&#x27;warn&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例程</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> svm, datasets</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> GridSearchCV</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>iris = datasets.load_iris()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>parameters = &#123;<span class=\"string\">&#x27;kernel&#x27;</span>:(<span class=\"string\">&#x27;linear&#x27;</span>, <span class=\"string\">&#x27;rbf&#x27;</span>), <span class=\"string\">&#x27;C&#x27;</span>:[<span class=\"number\">1</span>, <span class=\"number\">10</span>]&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>svc = svm.SVC(gamma=<span class=\"string\">&quot;scale&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>clf = GridSearchCV(svc, parameters, cv=<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fit 过程可能较慢，若有 M 个参数需搜索，采用 K 折交叉验证，则需训练 M x K 次。</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>clf.fit(iris.data, iris.target)</span><br><span class=\"line\">GridSearchCV(cv=<span class=\"number\">5</span>,</span><br><span class=\"line\">             error_score=...,</span><br><span class=\"line\">             estimator=SVC(C=<span class=\"number\">1.0</span>,</span><br><span class=\"line\">                           cache_size=...,</span><br><span class=\"line\">                           class_weight=...,</span><br><span class=\"line\">                           coef0=...,</span><br><span class=\"line\">                           decision_function_shape=<span class=\"string\">&#x27;ovr&#x27;</span>,</span><br><span class=\"line\">                           degree=...,</span><br><span class=\"line\">                           gamma=...,</span><br><span class=\"line\">                           kernel=<span class=\"string\">&#x27;rbf&#x27;</span>,</span><br><span class=\"line\">                           max_iter=-<span class=\"number\">1</span>,</span><br><span class=\"line\">                           probability=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                           random_state=<span class=\"literal\">None</span>,</span><br><span class=\"line\">                           shrinking=<span class=\"literal\">True</span>,</span><br><span class=\"line\">                           tol=...,</span><br><span class=\"line\">                           verbose=<span class=\"literal\">False</span>),</span><br><span class=\"line\">             iid=...,</span><br><span class=\"line\">             n_jobs=<span class=\"literal\">None</span>,</span><br><span class=\"line\">             param_grid=...,</span><br><span class=\"line\">             pre_dispatch=...,</span><br><span class=\"line\">             refit=...,</span><br><span class=\"line\">             return_train_score=...,</span><br><span class=\"line\">             scoring=...,</span><br><span class=\"line\">             verbose=...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出的结果都保存在字典 cv_results_ 中。</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳超参数：best_params_</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳得分：best_score_</span></span><br><span class=\"line\"><span class=\"comment\"># 最佳模型：best_estimator_，仅在设置 refit=true 时适用</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">sorted</span>(clf.cv_results_.keys())</span><br><span class=\"line\">[<span class=\"string\">&#x27;mean_fit_time&#x27;</span>, <span class=\"string\">&#x27;mean_score_time&#x27;</span>, <span class=\"string\">&#x27;mean_test_score&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;param_C&#x27;</span>, <span class=\"string\">&#x27;param_kernel&#x27;</span>, <span class=\"string\">&#x27;params&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;rank_test_score&#x27;</span>, <span class=\"string\">&#x27;split0_test_score&#x27;</span>,...</span><br><span class=\"line\"> <span class=\"string\">&#x27;split2_test_score&#x27;</span>, ...</span><br><span class=\"line\"> <span class=\"string\">&#x27;std_fit_time&#x27;</span>, <span class=\"string\">&#x27;std_score_time&#x27;</span>, <span class=\"string\">&#x27;std_test_score&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>param_grid</code>: 待评价参数（可以多个超参数一起调优：grid）。</p>\n</li>\n<li><p><code>X, y</code>: 全体训练数据。</p>\n</li>\n<li><p><code>iid</code>: 样本是否是独立同分布。</p>\n</li>\n<li><p><code>refit</code>: 评价指标。</p>\n<p>是否在找到最佳超参数后用全体训练数据再次训练模型参数。</p>\n</li>\n<li><p><code>error_score</code>: 训练失败的处理</p>\n</li>\n</ul>\n<p><strong>总结来说，K 折交叉验证可以检验超参数对应的模型的性能，配合网格搜索 <code>GridSearchCV</code> 可以遍历一段取值范围内的超参数 $\\lambda$ 并找到模型效果最好时的超参数 $\\lambda^{\\ast}$，再选定该超参数，使用全体训练数据再次训练模型，得到最佳模型参数 $W$，最终模型为 $f(X;W, \\lambda^{\\ast})$ 。</strong></p>\n","categories":["MachineLearning","Model"],"tags":["AI","MachineLearning","人工智能","机器学习","交叉验证"]}]